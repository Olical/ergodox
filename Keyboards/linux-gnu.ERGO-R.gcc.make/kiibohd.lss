
kiibohd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00010390  00002000  00002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .usbdescriptortable 00000160  1fff8000  1fff8000  00028000  2**2
                  ALLOC
  2 .dmabuffers   00000000  1fff8160  1fff8160  00019154  2**0
                  CONTENTS
  3 .usbbuffers   00000870  1fff8160  1fff8160  00028000  2**0
                  ALLOC
  4 .data         00000784  1fff89d0  00012390  000189d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00001cd8  1fff9154  00012b14  00019154  2**2
                  ALLOC
  6 .debug_info   00021903  00000000  00000000  00019154  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051cc  00000000  00000000  0003aa57  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000fe8  00000000  00000000  0003fc23  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000020a0  00000000  00000000  00040c0b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  00010dab  00000000  00000000  00042cab  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000ab32  00000000  00000000  00053a56  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00039a2d  00000000  00000000  0005e588  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000001d  00000000  00000000  00097fb5  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000033  00000000  00000000  00097fd2  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00002dbc  00000000  00000000  00098008  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000bb7a  00000000  00000000  0009adc4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00002000 <gVectors>:
    2000:	00 80 00 20 bd 21 00 00 f9 24 00 00 05 25 00 00     ... .!...$...%..
    2010:	39 25 00 00 79 25 00 00 b9 25 00 00 b1 24 00 00     9%..y%...%...$..
    2020:	b1 24 00 00 b1 24 00 00 b1 24 00 00 f1 24 00 00     .$...$...$...$..
    2030:	f1 24 00 00 b1 24 00 00 f1 24 00 00 75 24 00 00     .$...$...$..u$..
    2040:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2050:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2060:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2070:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2080:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2090:	f1 24 00 00 f1 24 00 00 e1 25 00 00 f1 24 00 00     .$...$...%...$..
    20a0:	cd 2d 00 00 d3 2d 00 00 f1 24 00 00 f1 24 00 00     .-...-...$...$..
    20b0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    20c0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    20d0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    20e0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    20f0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2100:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2110:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2120:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2130:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2140:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2150:	49 29 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     I)...$...$...$..
    2160:	f1 24 00 00 dd 94 00 00 f1 24 00 00 f1 24 00 00     .$.......$...$..
    2170:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2180:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    2190:	f1 24 00 00 b9 27 00 00 f1 24 00 00 f1 24 00 00     .$...'...$...$..
    21a0:	f1 24 00 00 f1 24 00 00 f1 24 00 00 f1 24 00 00     .$...$...$...$..
    21b0:	f1 24 00 00 f1 24 00 00 f1 24 00 00                 .$...$...$..

000021bc <ResetHandler>:

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    21bc:	b508      	push	{r3, lr}
	// Disable Watchdog
	while ( WDOG_TMROUTL < 2 ); // Must wait for WDOG timer if already running, before jumping
    21be:	4a44      	ldr	r2, [pc, #272]	; (22d0 <ResetHandler+0x114>)
    21c0:	8813      	ldrh	r3, [r2, #0]
    21c2:	2b01      	cmp	r3, #1
    21c4:	d9fc      	bls.n	21c0 <ResetHandler+0x4>
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    21c6:	4b43      	ldr	r3, [pc, #268]	; (22d4 <ResetHandler+0x118>)
    21c8:	f24c 5220 	movw	r2, #50464	; 0xc520
    21cc:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    21ce:	f64d 1228 	movw	r2, #55592	; 0xd928
    21d2:	801a      	strh	r2, [r3, #0]
	WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
    21d4:	4a40      	ldr	r2, [pc, #256]	; (22d8 <ResetHandler+0x11c>)
    21d6:	8813      	ldrh	r3, [r2, #0]
    21d8:	f023 0301 	bic.w	r3, r3, #1
    21dc:	041b      	lsls	r3, r3, #16
    21de:	0c1b      	lsrs	r3, r3, #16
    21e0:	8013      	strh	r3, [r2, #0]

	uint32_t *src = (uint32_t*)&_etext;
	uint32_t *dest = (uint32_t*)&_sdata;

	// Enable clocks to always-used peripherals
	SIM_SCGC5 = 0x00043F82; // Clocks active to all GPIO
    21e2:	4b3e      	ldr	r3, [pc, #248]	; (22dc <ResetHandler+0x120>)
    21e4:	4a3e      	ldr	r2, [pc, #248]	; (22e0 <ResetHandler+0x124>)
    21e6:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    21e8:	4a3e      	ldr	r2, [pc, #248]	; (22e4 <ResetHandler+0x128>)
    21ea:	605a      	str	r2, [r3, #4]
#if defined(_teensy_3_0_)
	SIM_SCGC6 |= SIM_SCGC6_RTC;
#elif defined(_kii_v2_)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
    21ec:	4a3e      	ldr	r2, [pc, #248]	; (22e8 <ResetHandler+0x12c>)
    21ee:	f04f 6110 	mov.w	r1, #150994944	; 0x9000000
    21f2:	6011      	str	r1, [r2, #0]
	SIM_SCGC6 |= SIM_SCGC6_RTC;
    21f4:	685a      	ldr	r2, [r3, #4]
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
	// Prepare RAM
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    21f6:	493d      	ldr	r1, [pc, #244]	; (22ec <ResetHandler+0x130>)
	SIM_SCGC6 |= SIM_SCGC6_RTC;
    21f8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
    21fc:	605a      	str	r2, [r3, #4]
	if ( PMC_REGSC & PMC_REGSC_ACKISO )
    21fe:	f503 3353 	add.w	r3, r3, #216064	; 0x34c00
    2202:	f203 33ca 	addw	r3, r3, #970	; 0x3ca
    2206:	781a      	ldrb	r2, [r3, #0]
    2208:	0710      	lsls	r0, r2, #28
		PMC_REGSC |= PMC_REGSC_ACKISO;
    220a:	bf42      	ittt	mi
    220c:	781a      	ldrbmi	r2, [r3, #0]
    220e:	f042 0208 	orrmi.w	r2, r2, #8
    2212:	701a      	strbmi	r2, [r3, #0]
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
    2214:	4b36      	ldr	r3, [pc, #216]	; (22f0 <ResetHandler+0x134>)
    2216:	222a      	movs	r2, #42	; 0x2a
    2218:	701a      	strb	r2, [r3, #0]
    221a:	4a36      	ldr	r2, [pc, #216]	; (22f4 <ResetHandler+0x138>)
    221c:	4b36      	ldr	r3, [pc, #216]	; (22f8 <ResetHandler+0x13c>)
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    221e:	428b      	cmp	r3, r1
    2220:	d34e      	bcc.n	22c0 <ResetHandler+0x104>
	dest = (uint32_t*)&_sbss;
    2222:	4b36      	ldr	r3, [pc, #216]	; (22fc <ResetHandler+0x140>)
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    2224:	4a36      	ldr	r2, [pc, #216]	; (2300 <ResetHandler+0x144>)
    2226:	2100      	movs	r1, #0
    2228:	4293      	cmp	r3, r2
    222a:	d34e      	bcc.n	22ca <ResetHandler+0x10e>
    222c:	4b35      	ldr	r3, [pc, #212]	; (2304 <ResetHandler+0x148>)
	// use vector table in flash
	SCB_VTOR = 0;
#endif

	// default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    222e:	4a36      	ldr	r2, [pc, #216]	; (2308 <ResetHandler+0x14c>)
	{
		NVIC_SET_PRIORITY( i, 128 );
    2230:	2180      	movs	r1, #128	; 0x80
    2232:	f803 1b01 	strb.w	r1, [r3], #1
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    2236:	4293      	cmp	r3, r2
    2238:	d1fb      	bne.n	2232 <ResetHandler+0x76>
	}

	// start in FEI mode
	// enable capacitors for crystal
	OSC0_CR = OSC_SC8P | OSC_SC2P;
    223a:	4b34      	ldr	r3, [pc, #208]	; (230c <ResetHandler+0x150>)
    223c:	220a      	movs	r2, #10
    223e:	701a      	strb	r2, [r3, #0]

	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0( 2 ) | MCG_C2_EREFS;
    2240:	f6a3 73ff 	subw	r3, r3, #4095	; 0xfff
    2244:	2224      	movs	r2, #36	; 0x24
    2246:	701a      	strb	r2, [r3, #0]

	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS( 2 ) | MCG_C1_FRDIV( 4 );
    2248:	22a0      	movs	r2, #160	; 0xa0
    224a:	f803 2c01 	strb.w	r2, [r3, #-1]

	// wait for crystal oscillator to begin
	while ( (MCG_S & MCG_S_OSCINIT0) == 0 );
    224e:	3305      	adds	r3, #5
    2250:	461a      	mov	r2, r3
    2252:	7819      	ldrb	r1, [r3, #0]
    2254:	0789      	lsls	r1, r1, #30
    2256:	d5fc      	bpl.n	2252 <ResetHandler+0x96>

	// wait for FLL to use oscillator
	while ( (MCG_S & MCG_S_IREFST) != 0 );
    2258:	7813      	ldrb	r3, [r2, #0]
    225a:	06d8      	lsls	r0, r3, #27
    225c:	d4fc      	bmi.n	2258 <ResetHandler+0x9c>

	// wait for MCGOUT to use oscillator
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 2 ) );
    225e:	7813      	ldrb	r3, [r2, #0]
    2260:	f003 030c 	and.w	r3, r3, #12
    2264:	2b08      	cmp	r3, #8
    2266:	d1fa      	bne.n	225e <ResetHandler+0xa2>

	// now we're in FBE mode
#if F_CPU == 72000000
	// config PLL input for 16 MHz Crystal / 8 = 2 MHz
	MCG_C5 = MCG_C5_PRDIV0( 7 );
    2268:	4b29      	ldr	r3, [pc, #164]	; (2310 <ResetHandler+0x154>)
    226a:	2207      	movs	r2, #7
    226c:	701a      	strb	r2, [r3, #0]
	MCG_C5 = MCG_C5_PRDIV0( 3 );
#endif

#if F_CPU == 72000000
	// config PLL for 72 MHz output (36 * 2 MHz Ext PLL)
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 12 );
    226e:	224c      	movs	r2, #76	; 0x4c
    2270:	705a      	strb	r2, [r3, #1]
	// config PLL for 96 MHz output
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 0 );
#endif

	// wait for PLL to start using xtal as its input
	while ( !(MCG_S & MCG_S_PLLST) );
    2272:	3302      	adds	r3, #2
    2274:	461a      	mov	r2, r3
    2276:	7819      	ldrb	r1, [r3, #0]
    2278:	0689      	lsls	r1, r1, #26
    227a:	d5fc      	bpl.n	2276 <ResetHandler+0xba>

	// wait for PLL to lock
	while ( !(MCG_S & MCG_S_LOCK0) );
    227c:	7813      	ldrb	r3, [r2, #0]
    227e:	065b      	lsls	r3, r3, #25
    2280:	d5fc      	bpl.n	227c <ResetHandler+0xc0>
#if F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#elif F_CPU == 72000000
	// config divisors: 72 MHz core, 36 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 2 );
    2282:	4b24      	ldr	r3, [pc, #144]	; (2314 <ResetHandler+0x158>)
    2284:	f04f 7281 	mov.w	r2, #16908288	; 0x1020000
    2288:	601a      	str	r2, [r3, #0]
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 3 ) | SIM_CLKDIV1_OUTDIV2( 3 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#else
#error "Error, F_CPU must be 96000000, 72000000, 48000000, or 24000000"
#endif
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS( 0 ) | MCG_C1_FRDIV( 4 );
    228a:	4b23      	ldr	r3, [pc, #140]	; (2318 <ResetHandler+0x15c>)
    228c:	2220      	movs	r2, #32
    228e:	701a      	strb	r2, [r3, #0]

	// wait for PLL clock to be used
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 3 ) );
    2290:	4a22      	ldr	r2, [pc, #136]	; (231c <ResetHandler+0x160>)
    2292:	7813      	ldrb	r3, [r2, #0]
    2294:	f003 030c 	and.w	r3, r3, #12
    2298:	2b0c      	cmp	r3, #12
    229a:	d1fa      	bne.n	2292 <ResetHandler+0xd6>

	// now we're in PEE mode
#if F_CPU == 72000000
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 2 ) | SIM_CLKDIV2_USBFRAC; // USB = 72 MHz PLL / 1.5
    229c:	4b20      	ldr	r3, [pc, #128]	; (2320 <ResetHandler+0x164>)
    229e:	2205      	movs	r2, #5
    22a0:	601a      	str	r2, [r3, #0]
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 1 ); // USB = 96 MHz PLL / 2
#endif

	// USB uses PLL clock, trace is CPU clock, CLKOUT=OSCERCLK0
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL( 6 );
    22a2:	4a20      	ldr	r2, [pc, #128]	; (2324 <ResetHandler+0x168>)
    22a4:	f843 2c44 	str.w	r2, [r3, #-68]

#endif

	// Initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
    22a8:	4b1f      	ldr	r3, [pc, #124]	; (2328 <ResetHandler+0x16c>)
    22aa:	4a20      	ldr	r2, [pc, #128]	; (232c <ResetHandler+0x170>)
    22ac:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    22ae:	2207      	movs	r2, #7
    22b0:	f843 2c04 	str.w	r2, [r3, #-4]

	// Enable IRQs
	__enable_irq();
    22b4:	b662      	cpsie	i

	// Intialize entropy for random numbers
	rand_initialize();
    22b6:	f000 fa19 	bl	26ec <rand_initialize>

	// Start main
	main();
    22ba:	f000 f8bd 	bl	2438 <main>
    22be:	e7fe      	b.n	22be <ResetHandler+0x102>
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    22c0:	f852 0f04 	ldr.w	r0, [r2, #4]!
    22c4:	f843 0b04 	str.w	r0, [r3], #4
    22c8:	e7a9      	b.n	221e <ResetHandler+0x62>
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    22ca:	f843 1b04 	str.w	r1, [r3], #4
    22ce:	e7ab      	b.n	2228 <ResetHandler+0x6c>
    22d0:	40052012 	.word	0x40052012
    22d4:	4005200e 	.word	0x4005200e
    22d8:	40052000 	.word	0x40052000
    22dc:	40048038 	.word	0x40048038
    22e0:	00043f82 	.word	0x00043f82
    22e4:	0b000001 	.word	0x0b000001
    22e8:	40048030 	.word	0x40048030
    22ec:	1fff9154 	.word	0x1fff9154
    22f0:	4007e000 	.word	0x4007e000
    22f4:	0001238c 	.word	0x0001238c
    22f8:	1fff89d0 	.word	0x1fff89d0
    22fc:	1fff9154 	.word	0x1fff9154
    2300:	1fffae2c 	.word	0x1fffae2c
    2304:	e000e400 	.word	0xe000e400
    2308:	e000e45f 	.word	0xe000e45f
    230c:	40065000 	.word	0x40065000
    2310:	40064004 	.word	0x40064004
    2314:	40048044 	.word	0x40048044
    2318:	40064000 	.word	0x40064000
    231c:	40064006 	.word	0x40064006
    2320:	40048048 	.word	0x40048048
    2324:	000510c0 	.word	0x000510c0
    2328:	e000e014 	.word	0xe000e014
    232c:	0001193f 	.word	0x0001193f
    2330:	00000000 	.word	0x00000000
    2334:	00000000 	.word	0x00000000
    2338:	00000000 	.word	0x00000000
    233c:	00000000 	.word	0x00000000
    2340:	00000000 	.word	0x00000000
    2344:	00000000 	.word	0x00000000
    2348:	00000000 	.word	0x00000000
    234c:	00000000 	.word	0x00000000
    2350:	00000000 	.word	0x00000000
    2354:	00000000 	.word	0x00000000
    2358:	00000000 	.word	0x00000000
    235c:	00000000 	.word	0x00000000
    2360:	00000000 	.word	0x00000000
    2364:	00000000 	.word	0x00000000
    2368:	00000000 	.word	0x00000000
    236c:	00000000 	.word	0x00000000
    2370:	00000000 	.word	0x00000000
    2374:	00000000 	.word	0x00000000
    2378:	00000000 	.word	0x00000000
    237c:	00000000 	.word	0x00000000
    2380:	00000000 	.word	0x00000000
    2384:	00000000 	.word	0x00000000
    2388:	00000000 	.word	0x00000000
    238c:	00000000 	.word	0x00000000
    2390:	00000000 	.word	0x00000000
    2394:	00000000 	.word	0x00000000
    2398:	00000000 	.word	0x00000000
    239c:	00000000 	.word	0x00000000
    23a0:	00000000 	.word	0x00000000
    23a4:	00000000 	.word	0x00000000
    23a8:	00000000 	.word	0x00000000
    23ac:	00000000 	.word	0x00000000
    23b0:	00000000 	.word	0x00000000
    23b4:	00000000 	.word	0x00000000
    23b8:	00000000 	.word	0x00000000
    23bc:	00000000 	.word	0x00000000
    23c0:	00000000 	.word	0x00000000
    23c4:	00000000 	.word	0x00000000
    23c8:	00000000 	.word	0x00000000
    23cc:	00000000 	.word	0x00000000
    23d0:	00000000 	.word	0x00000000
    23d4:	00000000 	.word	0x00000000
    23d8:	00000000 	.word	0x00000000
    23dc:	00000000 	.word	0x00000000
    23e0:	00000000 	.word	0x00000000
    23e4:	00000000 	.word	0x00000000
    23e8:	00000000 	.word	0x00000000
    23ec:	00000000 	.word	0x00000000
    23f0:	00000000 	.word	0x00000000
    23f4:	00000000 	.word	0x00000000
    23f8:	00000000 	.word	0x00000000
    23fc:	00000000 	.word	0x00000000

00002400 <main_periodic>:

// Run periodically at a consistent time rate
// Used to process events that need to be run at regular intervals
// And have negative effect being delayed or stretched too much
void main_periodic()
{
    2400:	b510      	push	{r4, lr}
	// Scan module periodic routines
	switch ( stage_tracker )
    2402:	4c0c      	ldr	r4, [pc, #48]	; (2434 <main_periodic+0x34>)
    2404:	7823      	ldrb	r3, [r4, #0]
    2406:	b2db      	uxtb	r3, r3
    2408:	2b01      	cmp	r3, #1
    240a:	d00a      	beq.n	2422 <main_periodic+0x22>
    240c:	d302      	bcc.n	2414 <main_periodic+0x14>
    240e:	2b02      	cmp	r3, #2
    2410:	d00b      	beq.n	242a <main_periodic+0x2a>
		// Send periodic USB results
		Output_periodic();
		stage_tracker = PeriodicStage_Scan;
		break;
	}
}
    2412:	bd10      	pop	{r4, pc}
		if ( Scan_periodic() )
    2414:	f002 ffa7 	bl	5366 <Scan_periodic>
    2418:	2800      	cmp	r0, #0
    241a:	d0fa      	beq.n	2412 <main_periodic+0x12>
			stage_tracker = PeriodicStage_Macro;
    241c:	2301      	movs	r3, #1
		stage_tracker = PeriodicStage_Scan;
    241e:	7023      	strb	r3, [r4, #0]
}
    2420:	e7f7      	b.n	2412 <main_periodic+0x12>
		Macro_periodic();
    2422:	f003 fd97 	bl	5f54 <Macro_periodic>
		stage_tracker = PeriodicStage_Output;
    2426:	2302      	movs	r3, #2
    2428:	e7f9      	b.n	241e <main_periodic+0x1e>
		Output_periodic();
    242a:	f006 fba6 	bl	8b7a <Output_periodic>
		stage_tracker = PeriodicStage_Scan;
    242e:	2300      	movs	r3, #0
    2430:	e7f5      	b.n	241e <main_periodic+0x1e>
    2432:	bf00      	nop
    2434:	1fff9154 	.word	0x1fff9154

00002438 <main>:

// ----- MCU-only Functions -----
#if !defined(_host_)

int main()
{
    2438:	b508      	push	{r3, lr}
#if defined(_avr_at_)
	CLKPR = 0x80;
	CLKPR = 0x00;
#endif
	// Setup Latency Measurements
	Latency_init();
    243a:	f008 feef 	bl	b21c <Latency_init>

	// Enable CLI
	CLI_init();
    243e:	f008 fc8d 	bl	ad5c <CLI_init>

	// Setup periodic timer function
	Periodic_function( &main_periodic );
    2442:	480a      	ldr	r0, [pc, #40]	; (246c <main+0x34>)
    2444:	f000 fa74 	bl	2930 <Periodic_function>

	// Setup Modules
	Output_setup();
    2448:	f006 fb8e 	bl	8b68 <Output_setup>
	Macro_setup();
    244c:	f003 fe34 	bl	60b8 <Macro_setup>
	Scan_setup();
    2450:	f002 ff6c 	bl	532c <Scan_setup>

	// Start scanning on first periodic loop
	stage_tracker = PeriodicStage_Scan;
    2454:	4b06      	ldr	r3, [pc, #24]	; (2470 <main+0x38>)
    2456:	2200      	movs	r2, #0
    2458:	701a      	strb	r2, [r3, #0]
		// Should not be used to run things that require consistent timing.
		// While counter-intuitive, things such as LED/Display modules should be run as poll
		// as they need to run as quickly as possible, in case there needs to be frame drops

		// Process CLI
		CLI_process();
    245a:	f008 fd65 	bl	af28 <CLI_process>

		// Scan module poll routines
		Scan_poll();
    245e:	f002 ff79 	bl	5354 <Scan_poll>

		// Macro module poll routines
		Macro_poll();
    2462:	f003 fd75 	bl	5f50 <Macro_poll>

		// Output module poll routines
		Output_poll();
    2466:	f006 fb86 	bl	8b76 <Output_poll>
    246a:	e7f6      	b.n	245a <main+0x22>
    246c:	00002401 	.word	0x00002401
    2470:	1fff9154 	.word	0x1fff9154

00002474 <systick_default_isr>:
	systick_millis_count++;
    2474:	4a0a      	ldr	r2, [pc, #40]	; (24a0 <systick_default_isr+0x2c>)
    2476:	6813      	ldr	r3, [r2, #0]
    2478:	3301      	adds	r3, #1
    247a:	6013      	str	r3, [r2, #0]
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    247c:	4a09      	ldr	r2, [pc, #36]	; (24a4 <systick_default_isr+0x30>)
    247e:	6813      	ldr	r3, [r2, #0]
    2480:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    2484:	6013      	str	r3, [r2, #0]
	ARM_DWT_CTRL &= ~ARM_DWT_CTRL_CYCCNTENA;
    2486:	4b08      	ldr	r3, [pc, #32]	; (24a8 <systick_default_isr+0x34>)
    2488:	681a      	ldr	r2, [r3, #0]
    248a:	f022 0201 	bic.w	r2, r2, #1
    248e:	601a      	str	r2, [r3, #0]
	ARM_DWT_CYCCNT = 0;
    2490:	4a06      	ldr	r2, [pc, #24]	; (24ac <systick_default_isr+0x38>)
    2492:	2100      	movs	r1, #0
    2494:	6011      	str	r1, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    2496:	681a      	ldr	r2, [r3, #0]
    2498:	f042 0201 	orr.w	r2, r2, #1
    249c:	601a      	str	r2, [r3, #0]
}
    249e:	4770      	bx	lr
    24a0:	1fff9158 	.word	0x1fff9158
    24a4:	e000edfc 	.word	0xe000edfc
    24a8:	e0001000 	.word	0xe0001000
    24ac:	e0001004 	.word	0xe0001004

000024b0 <fault_isr>:
{
    24b0:	b508      	push	{r3, lr}
	print("Fault!" NL );
    24b2:	480d      	ldr	r0, [pc, #52]	; (24e8 <fault_isr+0x38>)
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    24b4:	4d0d      	ldr	r5, [pc, #52]	; (24ec <fault_isr+0x3c>)
	print("Fault!" NL );
    24b6:	f008 ffa3 	bl	b400 <_print>
    24ba:	462c      	mov	r4, r5
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    24bc:	682b      	ldr	r3, [r5, #0]
    24be:	0358      	lsls	r0, r3, #13
    24c0:	d501      	bpl.n	24c6 <fault_isr+0x16>
    24c2:	f007 f80b 	bl	94dc <usb_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART0 )  uart0_status_isr();
    24c6:	6823      	ldr	r3, [r4, #0]
    24c8:	0559      	lsls	r1, r3, #21
    24ca:	d501      	bpl.n	24d0 <fault_isr+0x20>
    24cc:	f000 f810 	bl	24f0 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART1 )  uart1_status_isr();
    24d0:	6823      	ldr	r3, [r4, #0]
    24d2:	051a      	lsls	r2, r3, #20
    24d4:	d501      	bpl.n	24da <fault_isr+0x2a>
    24d6:	f000 f80b 	bl	24f0 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART2 )  uart2_status_isr();
    24da:	6823      	ldr	r3, [r4, #0]
    24dc:	04db      	lsls	r3, r3, #19
    24de:	d5ed      	bpl.n	24bc <fault_isr+0xc>
    24e0:	f000 f806 	bl	24f0 <unused_isr>
    24e4:	e7ea      	b.n	24bc <fault_isr+0xc>
    24e6:	bf00      	nop
    24e8:	0000c931 	.word	0x0000c931
    24ec:	40048034 	.word	0x40048034

000024f0 <unused_isr>:
{
    24f0:	b508      	push	{r3, lr}
	fault_isr();
    24f2:	f7ff ffdd 	bl	24b0 <fault_isr>
    24f6:	0000      	movs	r0, r0

000024f8 <nmi_default_isr>:
	print("NMI!" NL );
    24f8:	4801      	ldr	r0, [pc, #4]	; (2500 <nmi_default_isr+0x8>)
    24fa:	f008 bf81 	b.w	b400 <_print>
    24fe:	bf00      	nop
    2500:	0000b70e 	.word	0x0000b70e

00002504 <hard_fault_default_isr>:
{
    2504:	b508      	push	{r3, lr}
	print("Hard Fault! SCB_HFSR: ");
    2506:	4807      	ldr	r0, [pc, #28]	; (2524 <hard_fault_default_isr+0x20>)
    2508:	f008 ff7a 	bl	b400 <_print>
	printHex32( SCB_HFSR );
    250c:	4b06      	ldr	r3, [pc, #24]	; (2528 <hard_fault_default_isr+0x24>)
    250e:	2101      	movs	r1, #1
    2510:	6818      	ldr	r0, [r3, #0]
    2512:	f009 f855 	bl	b5c0 <printHex32_op>
	print( NL );
    2516:	4805      	ldr	r0, [pc, #20]	; (252c <hard_fault_default_isr+0x28>)
    2518:	f008 ff72 	bl	b400 <_print>
	SOFTWARE_RESET();
    251c:	4b04      	ldr	r3, [pc, #16]	; (2530 <hard_fault_default_isr+0x2c>)
    251e:	4a05      	ldr	r2, [pc, #20]	; (2534 <hard_fault_default_isr+0x30>)
    2520:	601a      	str	r2, [r3, #0]
}
    2522:	bd08      	pop	{r3, pc}
    2524:	0000b6ca 	.word	0x0000b6ca
    2528:	e000ed2c 	.word	0xe000ed2c
    252c:	00010d99 	.word	0x00010d99
    2530:	e000ed0c 	.word	0xe000ed0c
    2534:	05fa0004 	.word	0x05fa0004

00002538 <memmanage_fault_default_isr>:
{
    2538:	b508      	push	{r3, lr}
	print("Memory Manager Fault! SCB_CFSR: ");
    253a:	480a      	ldr	r0, [pc, #40]	; (2564 <memmanage_fault_default_isr+0x2c>)
    253c:	f008 ff60 	bl	b400 <_print>
	printHex32( SCB_CFSR );
    2540:	4b09      	ldr	r3, [pc, #36]	; (2568 <memmanage_fault_default_isr+0x30>)
    2542:	2101      	movs	r1, #1
    2544:	6818      	ldr	r0, [r3, #0]
    2546:	f009 f83b 	bl	b5c0 <printHex32_op>
	print(" SCB_MMAR: ");
    254a:	4808      	ldr	r0, [pc, #32]	; (256c <memmanage_fault_default_isr+0x34>)
    254c:	f008 ff58 	bl	b400 <_print>
	printHex32( SCB_MMAR );
    2550:	4b07      	ldr	r3, [pc, #28]	; (2570 <memmanage_fault_default_isr+0x38>)
    2552:	2101      	movs	r1, #1
    2554:	6818      	ldr	r0, [r3, #0]
    2556:	f009 f833 	bl	b5c0 <printHex32_op>
	print( NL );
    255a:	4806      	ldr	r0, [pc, #24]	; (2574 <memmanage_fault_default_isr+0x3c>)
}
    255c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print( NL );
    2560:	f008 bf4e 	b.w	b400 <_print>
    2564:	0000b6e1 	.word	0x0000b6e1
    2568:	e000ed28 	.word	0xe000ed28
    256c:	0000b702 	.word	0x0000b702
    2570:	e000ed34 	.word	0xe000ed34
    2574:	00010d99 	.word	0x00010d99

00002578 <bus_fault_default_isr>:
{
    2578:	b508      	push	{r3, lr}
	print("Bus Fault! SCB_CFSR: ");
    257a:	480a      	ldr	r0, [pc, #40]	; (25a4 <bus_fault_default_isr+0x2c>)
    257c:	f008 ff40 	bl	b400 <_print>
	printHex32( SCB_CFSR );
    2580:	4b09      	ldr	r3, [pc, #36]	; (25a8 <bus_fault_default_isr+0x30>)
    2582:	2101      	movs	r1, #1
    2584:	6818      	ldr	r0, [r3, #0]
    2586:	f009 f81b 	bl	b5c0 <printHex32_op>
	print(" SCB_BFAR: ");
    258a:	4808      	ldr	r0, [pc, #32]	; (25ac <bus_fault_default_isr+0x34>)
    258c:	f008 ff38 	bl	b400 <_print>
	printHex32( SCB_BFAR );
    2590:	4b07      	ldr	r3, [pc, #28]	; (25b0 <bus_fault_default_isr+0x38>)
    2592:	2101      	movs	r1, #1
    2594:	6818      	ldr	r0, [r3, #0]
    2596:	f009 f813 	bl	b5c0 <printHex32_op>
	print( NL );
    259a:	4806      	ldr	r0, [pc, #24]	; (25b4 <bus_fault_default_isr+0x3c>)
}
    259c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print( NL );
    25a0:	f008 bf2e 	b.w	b400 <_print>
    25a4:	0000b6a8 	.word	0x0000b6a8
    25a8:	e000ed28 	.word	0xe000ed28
    25ac:	0000b6be 	.word	0x0000b6be
    25b0:	e000ed38 	.word	0xe000ed38
    25b4:	00010d99 	.word	0x00010d99

000025b8 <usage_fault_default_isr>:
{
    25b8:	b508      	push	{r3, lr}
	print("Usage Fault! SCB_CFSR: ");
    25ba:	4806      	ldr	r0, [pc, #24]	; (25d4 <usage_fault_default_isr+0x1c>)
    25bc:	f008 ff20 	bl	b400 <_print>
	printHex32( SCB_CFSR );
    25c0:	4b05      	ldr	r3, [pc, #20]	; (25d8 <usage_fault_default_isr+0x20>)
    25c2:	2101      	movs	r1, #1
    25c4:	6818      	ldr	r0, [r3, #0]
    25c6:	f008 fffb 	bl	b5c0 <printHex32_op>
	print( NL );
    25ca:	4804      	ldr	r0, [pc, #16]	; (25dc <usage_fault_default_isr+0x24>)
}
    25cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print( NL );
    25d0:	f008 bf16 	b.w	b400 <_print>
    25d4:	0000b72b 	.word	0x0000b72b
    25d8:	e000ed28 	.word	0xe000ed28
    25dc:	00010d99 	.word	0x00010d99

000025e0 <watchdog_default_isr>:
{
    25e0:	b510      	push	{r4, lr}
	print("Watchdog timeout! ");
    25e2:	4810      	ldr	r0, [pc, #64]	; (2624 <watchdog_default_isr+0x44>)
	print( NL );
    25e4:	4c10      	ldr	r4, [pc, #64]	; (2628 <watchdog_default_isr+0x48>)
	print("Watchdog timeout! ");
    25e6:	f008 ff0b 	bl	b400 <_print>
	printHex( WDOG_TMROUTH );
    25ea:	4b10      	ldr	r3, [pc, #64]	; (262c <watchdog_default_isr+0x4c>)
    25ec:	2101      	movs	r1, #1
    25ee:	8818      	ldrh	r0, [r3, #0]
    25f0:	f008 ffae 	bl	b550 <printHex_op>
	print(" ");
    25f4:	480e      	ldr	r0, [pc, #56]	; (2630 <watchdog_default_isr+0x50>)
    25f6:	f008 ff03 	bl	b400 <_print>
	printHex( WDOG_TMROUTL );
    25fa:	4b0e      	ldr	r3, [pc, #56]	; (2634 <watchdog_default_isr+0x54>)
    25fc:	2101      	movs	r1, #1
    25fe:	8818      	ldrh	r0, [r3, #0]
    2600:	f008 ffa6 	bl	b550 <printHex_op>
	print( NL );
    2604:	4620      	mov	r0, r4
    2606:	f008 fefb 	bl	b400 <_print>
	print("Watchdog Reset Count: ");
    260a:	480b      	ldr	r0, [pc, #44]	; (2638 <watchdog_default_isr+0x58>)
    260c:	f008 fef8 	bl	b400 <_print>
	printHex( WDOG_RSTCNT );
    2610:	4b0a      	ldr	r3, [pc, #40]	; (263c <watchdog_default_isr+0x5c>)
    2612:	2101      	movs	r1, #1
    2614:	8818      	ldrh	r0, [r3, #0]
    2616:	f008 ff9b 	bl	b550 <printHex_op>
	print( NL );
    261a:	4620      	mov	r0, r4
}
    261c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    2620:	f008 beee 	b.w	b400 <_print>
    2624:	0000b743 	.word	0x0000b743
    2628:	00010d99 	.word	0x00010d99
    262c:	40052010 	.word	0x40052010
    2630:	00011f77 	.word	0x00011f77
    2634:	40052012 	.word	0x40052012
    2638:	0000b756 	.word	0x0000b756
    263c:	40052014 	.word	0x40052014

00002640 <memset>:
{
    2640:	4402      	add	r2, r0
	char *buf = addr;
    2642:	4603      	mov	r3, r0
	for (; len > 0; --len, ++buf)
    2644:	4293      	cmp	r3, r2
    2646:	d100      	bne.n	264a <memset+0xa>
}
    2648:	4770      	bx	lr
		*buf = val;
    264a:	f803 1b01 	strb.w	r1, [r3], #1
    264e:	e7f9      	b.n	2644 <memset+0x4>

00002650 <memcpy>:
{
    2650:	b510      	push	{r4, lr}
    2652:	3901      	subs	r1, #1
    2654:	4402      	add	r2, r0
	char *dstbuf = dst;
    2656:	4603      	mov	r3, r0
	for (; len > 0; --len, ++dstbuf, ++srcbuf)
    2658:	4293      	cmp	r3, r2
    265a:	d100      	bne.n	265e <memcpy+0xe>
}
    265c:	bd10      	pop	{r4, pc}
		*dstbuf = *srcbuf;
    265e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    2662:	f803 4b01 	strb.w	r4, [r3], #1
    2666:	e7f7      	b.n	2658 <memcpy+0x8>

00002668 <us_now>:
	uint32_t count;
	uint32_t current;
	uint32_t istatus;

	// Snapshot both the cycle count and ms counter
	__disable_irq();
    2668:	b672      	cpsid	i
	current = SYST_CVR;
    266a:	4b0c      	ldr	r3, [pc, #48]	; (269c <us_now+0x34>)
	count = systick_millis_count;
    266c:	4a0c      	ldr	r2, [pc, #48]	; (26a0 <us_now+0x38>)
	istatus = SCB_ICSR; // bit 26 indicates if systick exception pending
    266e:	490d      	ldr	r1, [pc, #52]	; (26a4 <us_now+0x3c>)
	current = SYST_CVR;
    2670:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    2672:	6812      	ldr	r2, [r2, #0]
	istatus = SCB_ICSR; // bit 26 indicates if systick exception pending
    2674:	6809      	ldr	r1, [r1, #0]
	__enable_irq();
    2676:	b662      	cpsie	i

	// Check for pending systick, and increment if one is it was
	if ( ( istatus & SCB_ICSR_PENDSTSET ) && current > ( ( F_CPU / 1000 ) - 50 ) )
    2678:	0149      	lsls	r1, r1, #5
    267a:	d503      	bpl.n	2684 <us_now+0x1c>
    267c:	490a      	ldr	r1, [pc, #40]	; (26a8 <us_now+0x40>)
    267e:	428b      	cmp	r3, r1
	{
		count++;
    2680:	bf88      	it	hi
    2682:	3201      	addhi	r2, #1
	}

	// Determine cycles since systick (approx.)
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    2684:	f5c3 338c 	rsb	r3, r3, #71680	; 0x11800

	// Add ms and cycles (since systick), converted as us
	return count * 1000 + current / ( F_CPU / 1000000 );
    2688:	2048      	movs	r0, #72	; 0x48
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    268a:	f203 133f 	addw	r3, r3, #319	; 0x13f
	return count * 1000 + current / ( F_CPU / 1000000 );
    268e:	fbb3 f3f0 	udiv	r3, r3, r0
#else
#warning "us_now not implemented"
	return 0;
#endif
}
    2692:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    2696:	fb00 3002 	mla	r0, r0, r2, r3
    269a:	4770      	bx	lr
    269c:	e000e018 	.word	0xe000e018
    26a0:	1fff9158 	.word	0x1fff9158
    26a4:	e000ed04 	.word	0xe000ed04
    26a8:	0001190e 	.word	0x0001190e

000026ac <yield>:

// - Misc Functions -

void yield()
{
}
    26ac:	4770      	bx	lr

000026ae <delay_us>:
{
    26ae:	b538      	push	{r3, r4, r5, lr}
    26b0:	4604      	mov	r4, r0
	uint32_t start = us_now();
    26b2:	f7ff ffd9 	bl	2668 <us_now>
    26b6:	4605      	mov	r5, r0
	while ( us_now() - start <= us )
    26b8:	f7ff ffd6 	bl	2668 <us_now>
    26bc:	1b40      	subs	r0, r0, r5
    26be:	42a0      	cmp	r0, r4
    26c0:	d900      	bls.n	26c4 <delay_us+0x16>
}
    26c2:	bd38      	pop	{r3, r4, r5, pc}
		yield();
    26c4:	f7ff fff2 	bl	26ac <yield>
    26c8:	e7f6      	b.n	26b8 <delay_us+0xa>
    26ca:	0000      	movs	r0, r0

000026cc <delay_ms>:
{
    26cc:	b570      	push	{r4, r5, r6, lr}
    26ce:	4604      	mov	r4, r0
	uint32_t start = us_now();
    26d0:	f7ff ffca 	bl	2668 <us_now>
	return systick_millis_count; // single aligned 32 bit is atomic;
    26d4:	4e04      	ldr	r6, [pc, #16]	; (26e8 <delay_ms+0x1c>)
	uint32_t start = us_now();
    26d6:	4605      	mov	r5, r0
	return systick_millis_count; // single aligned 32 bit is atomic;
    26d8:	6833      	ldr	r3, [r6, #0]
	while ( ms_now() - start <= ms )
    26da:	1b5b      	subs	r3, r3, r5
    26dc:	42a3      	cmp	r3, r4
    26de:	d900      	bls.n	26e2 <delay_ms+0x16>
}
    26e0:	bd70      	pop	{r4, r5, r6, pc}
		yield();
    26e2:	f7ff ffe3 	bl	26ac <yield>
    26e6:	e7f7      	b.n	26d8 <delay_ms+0xc>
    26e8:	1fff9158 	.word	0x1fff9158

000026ec <rand_initialize>:
// the buffer that holds the raw Timer 1 values that are used to create the entropy pool.  It then
// Initializes the Watch Dog Timer (WDT) to perform an interrupt every 2048 clock cycles, (about
// 16 ms) which is as fast as it can be set.
void rand_initialize()
{
	gWDT_buffer_position = 0;
    26ec:	4a0e      	ldr	r2, [pc, #56]	; (2728 <rand_initialize+0x3c>)
    26ee:	2300      	movs	r3, #0
    26f0:	7013      	strb	r3, [r2, #0]
	gWDT_pool_start = 0;
    26f2:	4a0e      	ldr	r2, [pc, #56]	; (272c <rand_initialize+0x40>)
    26f4:	7013      	strb	r3, [r2, #0]
	gWDT_pool_end = 0;
    26f6:	4a0e      	ldr	r2, [pc, #56]	; (2730 <rand_initialize+0x44>)
    26f8:	7013      	strb	r3, [r2, #0]
	gWDT_pool_count = 0;
    26fa:	4a0e      	ldr	r2, [pc, #56]	; (2734 <rand_initialize+0x48>)
    26fc:	7013      	strb	r3, [r2, #0]

	SIM_SCGC5 |= SIM_SCGC5_LPTIMER;
    26fe:	4a0e      	ldr	r2, [pc, #56]	; (2738 <rand_initialize+0x4c>)
    2700:	6813      	ldr	r3, [r2, #0]
    2702:	f043 0301 	orr.w	r3, r3, #1
    2706:	6013      	str	r3, [r2, #0]
	LPTMR0_CSR = 0b10000100;
    2708:	4b0c      	ldr	r3, [pc, #48]	; (273c <rand_initialize+0x50>)
    270a:	2284      	movs	r2, #132	; 0x84
    270c:	601a      	str	r2, [r3, #0]
	LPTMR0_PSR = 0b00000101; // PCS=01 : 1 kHz clock
    270e:	4a0c      	ldr	r2, [pc, #48]	; (2740 <rand_initialize+0x54>)
    2710:	2105      	movs	r1, #5
    2712:	6011      	str	r1, [r2, #0]
	LPTMR0_CMR = 0x0006;     // smaller number = faster random numbers...
    2714:	2106      	movs	r1, #6
    2716:	6051      	str	r1, [r2, #4]
	LPTMR0_CSR = 0b01000101;
    2718:	2245      	movs	r2, #69	; 0x45
    271a:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_LPTMR );
    271c:	4b09      	ldr	r3, [pc, #36]	; (2744 <rand_initialize+0x58>)
    271e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    2722:	601a      	str	r2, [r3, #0]
}
    2724:	4770      	bx	lr
    2726:	bf00      	nop
    2728:	1fff9b4c 	.word	0x1fff9b4c
    272c:	1fff9b6e 	.word	0x1fff9b6e
    2730:	1fff9b6f 	.word	0x1fff9b6f
    2734:	1fff9b6d 	.word	0x1fff9b6d
    2738:	40048038 	.word	0x40048038
    273c:	40040000 	.word	0x40040000
    2740:	40040004 	.word	0x40040004
    2744:	e000e108 	.word	0xe000e108

00002748 <rand_value32>:
// otherwise.  To ensure a proper random return the available() function
// should be called first to ensure that entropy exists.
//
// The pool is implemented as an 8 value circular buffer
uint32_t rand_value32()
{
    2748:	b510      	push	{r4, lr}
	uint32_t retVal = 0;
	uint8_t waiting;
	while ( gWDT_pool_count < 1 )
    274a:	4915      	ldr	r1, [pc, #84]	; (27a0 <rand_value32+0x58>)
    274c:	780b      	ldrb	r3, [r1, #0]
    274e:	2b00      	cmp	r3, #0
    2750:	d0fc      	beq.n	274c <rand_value32+0x4>

// returns 0 if interrupts enabled, 1 if disabled
static __inline__ uint32_t __get_primask()
{
	uint32_t primask = 0;
	__asm__ volatile ("MRS %[result], PRIMASK\n\t":[result]"=r"(primask)::);
    2752:	f3ef 8210 	mrs	r2, PRIMASK
	return 1;
}

static __inline__ uint32_t __iCliRetVal()
{
	__asm__ volatile ("CPSID i\n\t""dmb\n\t""dsb\n\t""isb\n\t");
    2756:	b672      	cpsid	i
    2758:	f3bf 8f5f 	dmb	sy
    275c:	f3bf 8f4f 	dsb	sy
    2760:	f3bf 8f6f 	isb	sy
		waiting += 1;
	}

	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
	{
		retVal = gWDT_entropy_pool[gWDT_pool_start];
    2764:	4c0f      	ldr	r4, [pc, #60]	; (27a4 <rand_value32+0x5c>)
    2766:	4810      	ldr	r0, [pc, #64]	; (27a8 <rand_value32+0x60>)
    2768:	7823      	ldrb	r3, [r4, #0]
    276a:	b2db      	uxtb	r3, r3
    276c:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
		gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2770:	7823      	ldrb	r3, [r4, #0]
    2772:	3301      	adds	r3, #1
    2774:	f003 0307 	and.w	r3, r3, #7
    2778:	7023      	strb	r3, [r4, #0]
		--gWDT_pool_count;
    277a:	780b      	ldrb	r3, [r1, #0]
    277c:	3b01      	subs	r3, #1
    277e:	b2db      	uxtb	r3, r3
    2780:	700b      	strb	r3, [r1, #0]
	__asm__ volatile ("MSR PRIMASK, %[value]\n\t""dmb\n\t""dsb\n\t""isb\n\t"::[value]"r"(setval):);
    2782:	f382 8810 	msr	PRIMASK, r2
    2786:	f3bf 8f5f 	dmb	sy
    278a:	f3bf 8f4f 	dsb	sy
    278e:	f3bf 8f6f 	isb	sy
	(void)__s;
}

static __inline__ void __iRestore( const  uint32_t *__s )
{
	__set_primask(*__s); __asm__ volatile ("dmb\n\t""dsb\n\t""isb\n\t");
    2792:	f3bf 8f5f 	dmb	sy
    2796:	f3bf 8f4f 	dsb	sy
    279a:	f3bf 8f6f 	isb	sy
	}

	return retVal;
}
    279e:	bd10      	pop	{r4, pc}
    27a0:	1fff9b6d 	.word	0x1fff9b6d
    27a4:	1fff9b6e 	.word	0x1fff9b6e
    27a8:	1fff9b2c 	.word	0x1fff9b2c

000027ac <rand_available>:

// This function returns a unsigned char (8-bit) with the number of unsigned long values
// in the entropy pool
uint8_t rand_available()
{
	return gWDT_pool_count;
    27ac:	4b01      	ldr	r3, [pc, #4]	; (27b4 <rand_available+0x8>)
    27ae:	7818      	ldrb	r0, [r3, #0]
}
    27b0:	4770      	bx	lr
    27b2:	bf00      	nop
    27b4:	1fff9b6d 	.word	0x1fff9b6d

000027b8 <lptmr_isr>:

// ----- Interrupts -----

void lptmr_isr()
{
	LPTMR0_CSR = 0b10000100;
    27b8:	4b3e      	ldr	r3, [pc, #248]	; (28b4 <lptmr_isr+0xfc>)
    27ba:	2284      	movs	r2, #132	; 0x84
{
    27bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	LPTMR0_CSR = 0b10000100;
    27be:	601a      	str	r2, [r3, #0]
	LPTMR0_CSR = 0b01000101;
    27c0:	2245      	movs	r2, #69	; 0x45
    27c2:	601a      	str	r2, [r3, #0]
	gWDT_buffer[gWDT_buffer_position] = val;
    27c4:	4c3c      	ldr	r4, [pc, #240]	; (28b8 <lptmr_isr+0x100>)
	isr_hardware_neutral(SYST_CVR);
    27c6:	4b3d      	ldr	r3, [pc, #244]	; (28bc <lptmr_isr+0x104>)
	gWDT_buffer[gWDT_buffer_position] = val;
    27c8:	4f3d      	ldr	r7, [pc, #244]	; (28c0 <lptmr_isr+0x108>)
	isr_hardware_neutral(SYST_CVR);
    27ca:	681a      	ldr	r2, [r3, #0]
	gWDT_buffer[gWDT_buffer_position] = val;
    27cc:	7823      	ldrb	r3, [r4, #0]
	isr_hardware_neutral(SYST_CVR);
    27ce:	54fa      	strb	r2, [r7, r3]
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    27d0:	3301      	adds	r3, #1
    27d2:	b2db      	uxtb	r3, r3
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    27d4:	2b1f      	cmp	r3, #31
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    27d6:	7023      	strb	r3, [r4, #0]
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    27d8:	d96b      	bls.n	28b2 <lptmr_isr+0xfa>
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    27da:	483a      	ldr	r0, [pc, #232]	; (28c4 <lptmr_isr+0x10c>)
    27dc:	493a      	ldr	r1, [pc, #232]	; (28c8 <lptmr_isr+0x110>)
    27de:	7803      	ldrb	r3, [r0, #0]
    27e0:	780a      	ldrb	r2, [r1, #0]
    27e2:	4413      	add	r3, r2
    27e4:	4a39      	ldr	r2, [pc, #228]	; (28cc <lptmr_isr+0x114>)
    27e6:	f003 0307 	and.w	r3, r3, #7
    27ea:	7013      	strb	r3, [r2, #0]
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    27ec:	4b38      	ldr	r3, [pc, #224]	; (28d0 <lptmr_isr+0x118>)
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    27ee:	2500      	movs	r5, #0
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    27f0:	7816      	ldrb	r6, [r2, #0]
    27f2:	f817 c005 	ldrb.w	ip, [r7, r5]
    27f6:	b2f6      	uxtb	r6, r6
    27f8:	3501      	adds	r5, #1
    27fa:	f853 e026 	ldr.w	lr, [r3, r6, lsl #2]
    27fe:	44f4      	add	ip, lr
    2800:	f843 c026 	str.w	ip, [r3, r6, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    2804:	7816      	ldrb	r6, [r2, #0]
    2806:	b2f6      	uxtb	r6, r6
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    2808:	2d20      	cmp	r5, #32
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    280a:	f853 e026 	ldr.w	lr, [r3, r6, lsl #2]
    280e:	7816      	ldrb	r6, [r2, #0]
    2810:	b2f6      	uxtb	r6, r6
    2812:	f853 c026 	ldr.w	ip, [r3, r6, lsl #2]
    2816:	eb0c 2c8e 	add.w	ip, ip, lr, lsl #10
    281a:	f843 c026 	str.w	ip, [r3, r6, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 6);
    281e:	7816      	ldrb	r6, [r2, #0]
    2820:	b2f6      	uxtb	r6, r6
    2822:	f853 e026 	ldr.w	lr, [r3, r6, lsl #2]
    2826:	7816      	ldrb	r6, [r2, #0]
    2828:	b2f6      	uxtb	r6, r6
    282a:	f853 c026 	ldr.w	ip, [r3, r6, lsl #2]
    282e:	ea8c 1c9e 	eor.w	ip, ip, lr, lsr #6
    2832:	f843 c026 	str.w	ip, [r3, r6, lsl #2]
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    2836:	d1db      	bne.n	27f0 <lptmr_isr+0x38>
    2838:	4e26      	ldr	r6, [pc, #152]	; (28d4 <lptmr_isr+0x11c>)
    283a:	7035      	strb	r5, [r6, #0]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 3);
    283c:	7815      	ldrb	r5, [r2, #0]
    283e:	b2ed      	uxtb	r5, r5
    2840:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    2844:	7815      	ldrb	r5, [r2, #0]
    2846:	b2ed      	uxtb	r5, r5
    2848:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    284c:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
    2850:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 11);
    2854:	7815      	ldrb	r5, [r2, #0]
    2856:	b2ed      	uxtb	r5, r5
    2858:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    285c:	7815      	ldrb	r5, [r2, #0]
    285e:	b2ed      	uxtb	r5, r5
    2860:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    2864:	ea86 26d7 	eor.w	r6, r6, r7, lsr #11
    2868:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 15);
    286c:	7815      	ldrb	r5, [r2, #0]
    286e:	b2ed      	uxtb	r5, r5
    2870:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    2874:	7815      	ldrb	r5, [r2, #0]
    2876:	b2ed      	uxtb	r5, r5
    2878:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    287c:	eb06 36c7 	add.w	r6, r6, r7, lsl #15
    2880:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] = gWDT_entropy_pool[gWDT_pool_end];
    2884:	7815      	ldrb	r5, [r2, #0]
    2886:	7812      	ldrb	r2, [r2, #0]
    2888:	b2ed      	uxtb	r5, r5
    288a:	b2d2      	uxtb	r2, r2
    288c:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
    2890:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
		gWDT_buffer_position = 0;
    2894:	2300      	movs	r3, #0
    2896:	7023      	strb	r3, [r4, #0]
		if (gWDT_pool_count == WDT_POOL_SIZE)
    2898:	780b      	ldrb	r3, [r1, #0]
    289a:	2b08      	cmp	r3, #8
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    289c:	bf0b      	itete	eq
    289e:	7803      	ldrbeq	r3, [r0, #0]
			++gWDT_pool_count;
    28a0:	780b      	ldrbne	r3, [r1, #0]
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    28a2:	3301      	addeq	r3, #1
			++gWDT_pool_count;
    28a4:	3301      	addne	r3, #1
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    28a6:	bf0b      	itete	eq
    28a8:	f003 0307 	andeq.w	r3, r3, #7
			++gWDT_pool_count;
    28ac:	b2db      	uxtbne	r3, r3
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    28ae:	7003      	strbeq	r3, [r0, #0]
			++gWDT_pool_count;
    28b0:	700b      	strbne	r3, [r1, #0]
}
    28b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28b4:	40040000 	.word	0x40040000
    28b8:	1fff9b4c 	.word	0x1fff9b4c
    28bc:	e000e018 	.word	0xe000e018
    28c0:	1fff9b4d 	.word	0x1fff9b4d
    28c4:	1fff9b6e 	.word	0x1fff9b6e
    28c8:	1fff9b6d 	.word	0x1fff9b6d
    28cc:	1fff9b6f 	.word	0x1fff9b6f
    28d0:	1fff9b2c 	.word	0x1fff9b2c
    28d4:	1fff9b70 	.word	0x1fff9b70

000028d8 <Periodic_init>:
#if defined(_kinetis_k_)
// Must set function pointer first!!
void Periodic_init( uint32_t cycles )
{
	// Setup PIT (Programmable Interrupt Timer)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    28d8:	4a0b      	ldr	r2, [pc, #44]	; (2908 <Periodic_init+0x30>)
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    28da:	490c      	ldr	r1, [pc, #48]	; (290c <Periodic_init+0x34>)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    28dc:	6813      	ldr	r3, [r2, #0]
    28de:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    28e2:	6013      	str	r3, [r2, #0]
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
    28e4:	4b0a      	ldr	r3, [pc, #40]	; (2910 <Periodic_init+0x38>)
    28e6:	2200      	movs	r2, #0
    28e8:	601a      	str	r2, [r3, #0]
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    28ea:	600a      	str	r2, [r1, #0]

	// Timer Count-down value
	// Number of cycles to count from CPU clock before calling interrupt
	PIT_LDVAL0 = cycles;
    28ec:	4a09      	ldr	r2, [pc, #36]	; (2914 <Periodic_init+0x3c>)
    28ee:	6010      	str	r0, [r2, #0]

	// Enable Timer, Enable interrupt
	PIT_TCTRL0 = PIT_TCTRL_TIE | PIT_TCTRL_TEN;
    28f0:	2203      	movs	r2, #3
    28f2:	601a      	str	r2, [r3, #0]

	// Enable PIT Ch0 interrupt
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    28f4:	f103 4320 	add.w	r3, r3, #2684354560	; 0xa0000000
    28f8:	f5a3 3324 	sub.w	r3, r3, #167936	; 0x29000
    28fc:	2210      	movs	r2, #16
    28fe:	601a      	str	r2, [r3, #0]

	// Set PIT0 interrupt to a low priority
	NVIC_SET_PRIORITY( IRQ_PIT_CH0, 200 );
    2900:	22c8      	movs	r2, #200	; 0xc8
    2902:	f883 233c 	strb.w	r2, [r3, #828]	; 0x33c
}
    2906:	4770      	bx	lr
    2908:	4004803c 	.word	0x4004803c
    290c:	40037000 	.word	0x40037000
    2910:	40037108 	.word	0x40037108
    2914:	40037100 	.word	0x40037100

00002918 <Periodic_enable>:

void Periodic_enable()
{
	// Used to re-enable IRQ
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    2918:	4b01      	ldr	r3, [pc, #4]	; (2920 <Periodic_enable+0x8>)
    291a:	2210      	movs	r2, #16
    291c:	601a      	str	r2, [r3, #0]
}
    291e:	4770      	bx	lr
    2920:	e000e108 	.word	0xe000e108

00002924 <Periodic_disable>:

void Periodic_disable()
{
	// Used to disable IRQ
	NVIC_DISABLE_IRQ( IRQ_PIT_CH0 );
    2924:	4b01      	ldr	r3, [pc, #4]	; (292c <Periodic_disable+0x8>)
    2926:	2210      	movs	r2, #16
    2928:	601a      	str	r2, [r3, #0]
}
    292a:	4770      	bx	lr
    292c:	e000e188 	.word	0xe000e188

00002930 <Periodic_function>:

void Periodic_function( void *func )
{
	// Set function pointer
	periodic_func = func;
    2930:	4b01      	ldr	r3, [pc, #4]	; (2938 <Periodic_function+0x8>)
    2932:	6018      	str	r0, [r3, #0]
}
    2934:	4770      	bx	lr
    2936:	bf00      	nop
    2938:	1fff915c 	.word	0x1fff915c

0000293c <Periodic_cycles>:

uint32_t Periodic_cycles()
{
	return PIT_LDVAL0;
    293c:	4b01      	ldr	r3, [pc, #4]	; (2944 <Periodic_cycles+0x8>)
    293e:	6818      	ldr	r0, [r3, #0]
}
    2940:	4770      	bx	lr
    2942:	bf00      	nop
    2944:	40037100 	.word	0x40037100

00002948 <pit0_isr>:

void pit0_isr()
{
    2948:	b508      	push	{r3, lr}
	// Call specified function
	(*periodic_func)();
    294a:	4b03      	ldr	r3, [pc, #12]	; (2958 <pit0_isr+0x10>)
    294c:	681b      	ldr	r3, [r3, #0]
    294e:	4798      	blx	r3

	// Clear the interrupt
	PIT_TFLG0 = PIT_TFLG_TIF;
    2950:	4b02      	ldr	r3, [pc, #8]	; (295c <pit0_isr+0x14>)
    2952:	2201      	movs	r2, #1
    2954:	601a      	str	r2, [r3, #0]
}
    2956:	bd08      	pop	{r3, pc}
    2958:	1fff915c 	.word	0x1fff915c
    295c:	4003710c 	.word	0x4003710c

00002960 <Time_now>:

// Get current time
Time Time_now()
{
#if defined(_kinetis_)
	Time time = {
    2960:	4a03      	ldr	r2, [pc, #12]	; (2970 <Time_now+0x10>)
    2962:	6811      	ldr	r1, [r2, #0]
		.ms    = systick_millis_count,
		.ticks = ARM_DWT_CYCCNT,
    2964:	4a03      	ldr	r2, [pc, #12]	; (2974 <Time_now+0x14>)
    2966:	6812      	ldr	r2, [r2, #0]
#else
	// No time facilities...
	Time time = Time_init();
#endif

	return time;
    2968:	e9c0 1200 	strd	r1, r2, [r0]
}
    296c:	4770      	bx	lr
    296e:	bf00      	nop
    2970:	1fff9158 	.word	0x1fff9158
    2974:	e0001004 	.word	0xe0001004

00002978 <Time_ms>:

#if !defined(_host_)
inline
#endif
uint32_t Time_ms( Time time )
{
    2978:	b082      	sub	sp, #8
    297a:	ab02      	add	r3, sp, #8
    297c:	e903 0003 	stmdb	r3, {r0, r1}
	return time.ms;
}
    2980:	9800      	ldr	r0, [sp, #0]
    2982:	b002      	add	sp, #8
    2984:	4770      	bx	lr
    2986:	0000      	movs	r0, r0

00002988 <Time_us>:

#if !defined(_host_)
inline
#endif
uint32_t Time_us( Time time )
{
    2988:	b082      	sub	sp, #8
    298a:	ab02      	add	r3, sp, #8
    298c:	e903 0003 	stmdb	r3, {r0, r1}
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000) )
    2990:	4a07      	ldr	r2, [pc, #28]	; (29b0 <Time_us+0x28>)
    2992:	9b00      	ldr	r3, [sp, #0]
    2994:	4293      	cmp	r3, r2
	{
		return 0xFFFFFFFF;
	}

	uint32_t us = ( time.ms + time.ticks * Time_maxTicks ) * 1000;
    2996:	bf9f      	itttt	ls
    2998:	9801      	ldrls	r0, [sp, #4]
    299a:	4a06      	ldrls	r2, [pc, #24]	; (29b4 <Time_us+0x2c>)
    299c:	fb02 3300 	mlals	r3, r2, r0, r3
    29a0:	f44f 707a 	movls.w	r0, #1000	; 0x3e8
    29a4:	bf94      	ite	ls
    29a6:	4358      	mulls	r0, r3
		return 0xFFFFFFFF;
    29a8:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
	return us;
}
    29ac:	b002      	add	sp, #8
    29ae:	4770      	bx	lr
    29b0:	00418936 	.word	0x00418936
    29b4:	00011940 	.word	0x00011940

000029b8 <Time_ns>:

#if !defined(_host_)
inline
#endif
uint32_t Time_ns( Time time )
{
    29b8:	b082      	sub	sp, #8
    29ba:	ab02      	add	r3, sp, #8
    29bc:	e903 0003 	stmdb	r3, {r0, r1}
    29c0:	9b00      	ldr	r3, [sp, #0]
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000000) )
    29c2:	f241 02c5 	movw	r2, #4293	; 0x10c5
    29c6:	4293      	cmp	r3, r2
	{
		return 0xFFFFFFFF;
	}

	uint32_t ns = ( time.ms + time.ticks * Time_maxTicks ) * 1000000;
    29c8:	bf9f      	itttt	ls
    29ca:	9801      	ldrls	r0, [sp, #4]
    29cc:	4a04      	ldrls	r2, [pc, #16]	; (29e0 <Time_ns+0x28>)
    29ce:	fb02 3300 	mlals	r3, r2, r0, r3
    29d2:	4804      	ldrls	r0, [pc, #16]	; (29e4 <Time_ns+0x2c>)
		return 0xFFFFFFFF;
    29d4:	bf8c      	ite	hi
    29d6:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
	uint32_t ns = ( time.ms + time.ticks * Time_maxTicks ) * 1000000;
    29da:	4358      	mulls	r0, r3
	return ns;
}
    29dc:	b002      	add	sp, #8
    29de:	4770      	bx	lr
    29e0:	00011940 	.word	0x00011940
    29e4:	000f4240 	.word	0x000f4240

000029e8 <Time_duration_rollover>:
// Time since the given time
// If the given time value is lower, then assume a single register wrap
// This is around 49 days (plenty of time for most tasks)

Time Time_duration_rollover( Time since )
{
    29e8:	b082      	sub	sp, #8
    29ea:	ab02      	add	r3, sp, #8
    29ec:	e903 0006 	stmdb	r3, {r1, r2}
	Time time = {
    29f0:	4b09      	ldr	r3, [pc, #36]	; (2a18 <Time_duration_rollover+0x30>)
    29f2:	9a00      	ldr	r2, [sp, #0]
    29f4:	6819      	ldr	r1, [r3, #0]
		.ticks = ARM_DWT_CYCCNT,
    29f6:	4b09      	ldr	r3, [pc, #36]	; (2a1c <Time_duration_rollover+0x34>)
	Time now = Time_now();
	Time duration;

	// Check if ms have done a rollover
	if ( now.ms < since.ms )
    29f8:	4291      	cmp	r1, r2
		.ticks = ARM_DWT_CYCCNT,
    29fa:	681b      	ldr	r3, [r3, #0]
	{
		duration.ms = now.ms + ( 0xFFFFFFFF - since.ms );
    29fc:	bf38      	it	cc
    29fe:	f101 31ff 	addcc.w	r1, r1, #4294967295	; 0xffffffff
	}
	// Standard case
	else
	{
		duration.ms = now.ms - since.ms;
    2a02:	1a8a      	subs	r2, r1, r2
	}

	// Ticks do not rollover, they are computed from the last increment of ms
	// Depending on the set clock speed, the maximum number of ticks per ms may vary
	duration.ticks = now.ticks + ( Time_maxTicks - since.ticks );
    2a04:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
    2a08:	9901      	ldr	r1, [sp, #4]
    2a0a:	f503 73a0 	add.w	r3, r3, #320	; 0x140
    2a0e:	1a5b      	subs	r3, r3, r1

	return duration;
    2a10:	e9c0 2300 	strd	r2, r3, [r0]
}
    2a14:	b002      	add	sp, #8
    2a16:	4770      	bx	lr
    2a18:	1fff9158 	.word	0x1fff9158
    2a1c:	e0001004 	.word	0xe0001004

00002a20 <Time_duration>:

Time Time_duration( Time since )
{
    2a20:	b513      	push	{r0, r1, r4, lr}
    2a22:	466b      	mov	r3, sp
    2a24:	e883 0006 	stmia.w	r3, {r1, r2}
	return Time_duration_rollover( since );
    2a28:	e893 0006 	ldmia.w	r3, {r1, r2}
    2a2c:	f7ff ffdc 	bl	29e8 <Time_duration_rollover>
}
    2a30:	b002      	add	sp, #8
    2a32:	bd10      	pop	{r4, pc}

00002a34 <Time_duration_ms>:
	Time duration = Time_duration_rollover( since );
	return Time_seconds( duration );
}

uint32_t Time_duration_ms( Time since )
{
    2a34:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2a36:	466b      	mov	r3, sp
    2a38:	e883 0003 	stmia.w	r3, {r0, r1}
	Time duration = Time_duration_rollover( since );
    2a3c:	a802      	add	r0, sp, #8
    2a3e:	e893 0006 	ldmia.w	r3, {r1, r2}
    2a42:	f7ff ffd1 	bl	29e8 <Time_duration_rollover>
	return Time_ms( duration );
}
    2a46:	9802      	ldr	r0, [sp, #8]
    2a48:	b005      	add	sp, #20
    2a4a:	f85d fb04 	ldr.w	pc, [sp], #4

00002a4e <Time_duration_us>:

uint32_t Time_duration_us( Time since )
{
    2a4e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2a50:	466b      	mov	r3, sp
    2a52:	e883 0003 	stmia.w	r3, {r0, r1}
	Time duration = Time_duration_rollover( since );
    2a56:	ac02      	add	r4, sp, #8
    2a58:	e893 0006 	ldmia.w	r3, {r1, r2}
    2a5c:	4620      	mov	r0, r4
    2a5e:	f7ff ffc3 	bl	29e8 <Time_duration_rollover>
	return Time_us( duration );
    2a62:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    2a66:	b004      	add	sp, #16
    2a68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return Time_us( duration );
    2a6c:	f7ff bf8c 	b.w	2988 <Time_us>

00002a70 <Time_duration_ns>:

uint32_t Time_duration_ns( Time since )
{
    2a70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2a72:	466b      	mov	r3, sp
    2a74:	e883 0003 	stmia.w	r3, {r0, r1}
	Time duration = Time_duration_rollover( since );
    2a78:	ac02      	add	r4, sp, #8
    2a7a:	e893 0006 	ldmia.w	r3, {r1, r2}
    2a7e:	4620      	mov	r0, r4
    2a80:	f7ff ffb2 	bl	29e8 <Time_duration_rollover>
	return Time_ns( duration );
    2a84:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    2a88:	b004      	add	sp, #16
    2a8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return Time_ns( duration );
    2a8e:	f7ff bf93 	b.w	29b8 <Time_ns>
    2a92:	0000      	movs	r0, r0

00002a94 <Time_duration_ticks>:

// Number of ticks since
uint32_t Time_duration_ticks( Time since )
{
    2a94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2a96:	466b      	mov	r3, sp
    2a98:	e883 0003 	stmia.w	r3, {r0, r1}
	Time duration = Time_duration_rollover( since );
    2a9c:	a802      	add	r0, sp, #8
    2a9e:	e893 0006 	ldmia.w	r3, {r1, r2}
    2aa2:	f7ff ffa1 	bl	29e8 <Time_duration_rollover>
    2aa6:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
	if ( time.ms >= Time_maxTicks_ms )
    2aaa:	f64e 1203 	movw	r2, #59651	; 0xe903
    2aae:	4290      	cmp	r0, r2
	ticks += time.ticks;
    2ab0:	bf96      	itet	ls
    2ab2:	4a04      	ldrls	r2, [pc, #16]	; (2ac4 <Time_duration_ticks+0x30>)
		return 0xFFFFFFFF;
    2ab4:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
	ticks += time.ticks;
    2ab8:	fb02 3000 	mlals	r0, r2, r0, r3
	return Time_ticks( duration );
}
    2abc:	b005      	add	sp, #20
    2abe:	f85d fb04 	ldr.w	pc, [sp], #4
    2ac2:	bf00      	nop
    2ac4:	00011940 	.word	0x00011940

00002ac8 <i2c_setup>:

		switch ( ch )
		{
		case 0:
			// Enable I2C internal clock
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    2ac8:	490f      	ldr	r1, [pc, #60]	; (2b08 <i2c_setup+0x40>)
		volatile uint8_t *I2C_F   = (uint8_t*)(&I2C0_F) + i2c_offset[ch];
    2aca:	4b10      	ldr	r3, [pc, #64]	; (2b0c <i2c_setup+0x44>)
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    2acc:	680a      	ldr	r2, [r1, #0]
		volatile uint8_t *I2C_F   = (uint8_t*)(&I2C0_F) + i2c_offset[ch];
    2ace:	681b      	ldr	r3, [r3, #0]
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    2ad0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2ad4:	600a      	str	r2, [r1, #0]

			// External pull-up resistor
			PORTB_PCR0 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    2ad6:	490e      	ldr	r1, [pc, #56]	; (2b10 <i2c_setup+0x48>)
    2ad8:	f44f 7219 	mov.w	r2, #612	; 0x264
    2adc:	600a      	str	r2, [r1, #0]
			PORTB_PCR1 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    2ade:	604a      	str	r2, [r1, #4]
		*I2C_FLT = 0x04;
#elif ISSI_Chip_31FL3731_define == 1 && defined(_kii_v2_)
		// 0x84 -> 36 MHz / (4 * 28) = 321.428 kBaud
		// 0x80 => mul(4)
		// 0x04 => ICR(28)
		*I2C_F = 0x84;
    2ae0:	4a0c      	ldr	r2, [pc, #48]	; (2b14 <i2c_setup+0x4c>)
    2ae2:	2184      	movs	r1, #132	; 0x84
    2ae4:	5499      	strb	r1, [r3, r2]
		*I2C_FLT = 0x03;
    2ae6:	3205      	adds	r2, #5
    2ae8:	2103      	movs	r1, #3
    2aea:	5499      	strb	r1, [r3, r2]
		// 0x40 => mul(2)
		// 0x00 => ICR(20)
		*I2C_F = 0x40;
		*I2C_FLT = 0x02;
#endif
		*I2C_C1 = I2C_C1_IICEN;
    2aec:	3a04      	subs	r2, #4
    2aee:	2180      	movs	r1, #128	; 0x80
    2af0:	5499      	strb	r1, [r3, r2]
		*I2C_C2 = I2C_C2_HDRS; // High drive select
    2af2:	3203      	adds	r2, #3
    2af4:	2120      	movs	r1, #32
    2af6:	5499      	strb	r1, [r3, r2]

		switch ( ch )
		{
		case 0:
			// Enable I2C Interrupt
			NVIC_ENABLE_IRQ( IRQ_I2C0 );
    2af8:	4b07      	ldr	r3, [pc, #28]	; (2b18 <i2c_setup+0x50>)
    2afa:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    2afe:	601a      	str	r2, [r3, #0]

			// Set priority below USB, but not too low to maintain performance
			NVIC_SET_PRIORITY( IRQ_PIT_CH0, 150 );
    2b00:	2296      	movs	r2, #150	; 0x96
    2b02:	f883 2344 	strb.w	r2, [r3, #836]	; 0x344
			NVIC_SET_PRIORITY( IRQ_PIT_CH1, 150 );
			break;
#endif
		}
	}
}
    2b06:	4770      	bx	lr
    2b08:	40048034 	.word	0x40048034
    2b0c:	1fff89d4 	.word	0x1fff89d4
    2b10:	4004a000 	.word	0x4004a000
    2b14:	40066001 	.word	0x40066001
    2b18:	e000e100 	.word	0xe000e100

00002b1c <i2c_reset>:
{
	// Cleanup after an I2C error
	for ( uint8_t ch = 0; ch < ISSI_I2C_Buses_define; ch++ )
	{
		volatile I2C_Channel *channel = &( i2c_channels[ch] );
		channel->status = I2C_AVAILABLE;
    2b1c:	4b02      	ldr	r3, [pc, #8]	; (2b28 <i2c_reset+0xc>)
    2b1e:	2200      	movs	r2, #0
    2b20:	755a      	strb	r2, [r3, #21]
	}

	i2c_setup();
    2b22:	f7ff bfd1 	b.w	2ac8 <i2c_setup>
    2b26:	bf00      	nop
    2b28:	1fff9b74 	.word	0x1fff9b74

00002b2c <i2c_busy>:
}

uint8_t i2c_busy( uint8_t ch )
{
	volatile I2C_Channel *channel = &( i2c_channels[ch] );
	if ( channel->status == I2C_BUSY )
    2b2c:	4a04      	ldr	r2, [pc, #16]	; (2b40 <i2c_busy+0x14>)
    2b2e:	2318      	movs	r3, #24
    2b30:	fb03 2000 	mla	r0, r3, r0, r2
    2b34:	7d40      	ldrb	r0, [r0, #21]
	{
		return 1;
	}

	return 0;
}
    2b36:	1e43      	subs	r3, r0, #1
    2b38:	4258      	negs	r0, r3
    2b3a:	4158      	adcs	r0, r3
    2b3c:	4770      	bx	lr
    2b3e:	bf00      	nop
    2b40:	1fff9b74 	.word	0x1fff9b74

00002b44 <i2c_send_sequence>:
	uint16_t *sequence,
	uint32_t sequence_length,
	uint8_t *received_data,
	void ( *callback_fn )( void* ),
	void *user_data
) {
    2b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint8_t *I2C_D   = (uint8_t*)(&I2C0_D) + i2c_offset[ch];

	int32_t result = 0;
	uint8_t status;

	if ( channel->status == I2C_BUSY )
    2b46:	f8df c094 	ldr.w	ip, [pc, #148]	; 2bdc <i2c_send_sequence+0x98>
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    2b4a:	4c20      	ldr	r4, [pc, #128]	; (2bcc <i2c_send_sequence+0x88>)
    2b4c:	4f20      	ldr	r7, [pc, #128]	; (2bd0 <i2c_send_sequence+0x8c>)
    2b4e:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
	volatile uint8_t *I2C_S   = (uint8_t*)(&I2C0_S) + i2c_offset[ch];
    2b52:	f8df e08c 	ldr.w	lr, [pc, #140]	; 2be0 <i2c_send_sequence+0x9c>
	if ( channel->status == I2C_BUSY )
    2b56:	2618      	movs	r6, #24
    2b58:	4346      	muls	r6, r0
    2b5a:	eb0c 0506 	add.w	r5, ip, r6
    2b5e:	7d68      	ldrb	r0, [r5, #21]
    2b60:	2801      	cmp	r0, #1
    2b62:	d027      	beq.n	2bb4 <i2c_send_sequence+0x70>
		print(" ");
	}
	print(NL);
	*/

	channel->sequence = sequence;
    2b64:	f84c 1006 	str.w	r1, [ip, r6]
	channel->sequence_end = sequence + sequence_length;
    2b68:	eb01 0142 	add.w	r1, r1, r2, lsl #1
    2b6c:	6069      	str	r1, [r5, #4]
	channel->received_data = received_data;
    2b6e:	60ab      	str	r3, [r5, #8]
	channel->status = I2C_BUSY;
    2b70:	2301      	movs	r3, #1
    2b72:	756b      	strb	r3, [r5, #21]
	channel->txrx = I2C_WRITING;
    2b74:	2300      	movs	r3, #0
    2b76:	75ab      	strb	r3, [r5, #22]
	channel->callback_fn = callback_fn;
    2b78:	9b06      	ldr	r3, [sp, #24]
    2b7a:	60eb      	str	r3, [r5, #12]
	channel->user_data = user_data;
    2b7c:	9b07      	ldr	r3, [sp, #28]
    2b7e:	612b      	str	r3, [r5, #16]

	// reads_ahead does not need to be initialized

	// Acknowledge the interrupt request, just in case
	*I2C_S |= I2C_S_IICIF;
    2b80:	f814 300e 	ldrb.w	r3, [r4, lr]
    2b84:	f043 0302 	orr.w	r3, r3, #2
    2b88:	f804 300e 	strb.w	r3, [r4, lr]
	*I2C_C1 = ( I2C_C1_IICEN | I2C_C1_IICIE );
    2b8c:	23c0      	movs	r3, #192	; 0xc0
    2b8e:	55e3      	strb	r3, [r4, r7]

	// Generate a start condition and prepare for transmitting.
	*I2C_C1 |= ( I2C_C1_MST | I2C_C1_TX );
    2b90:	5de3      	ldrb	r3, [r4, r7]
    2b92:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    2b96:	55e3      	strb	r3, [r4, r7]

	status = *I2C_S;
    2b98:	f814 000e 	ldrb.w	r0, [r4, lr]
	if ( status & I2C_S_ARBL )
    2b9c:	f010 0010 	ands.w	r0, r0, #16
    2ba0:	d00b      	beq.n	2bba <i2c_send_sequence+0x76>
	{
		warn_print("Arbitration lost");
    2ba2:	480c      	ldr	r0, [pc, #48]	; (2bd4 <i2c_send_sequence+0x90>)
    2ba4:	f008 fc2c 	bl	b400 <_print>

	// Everything is OK.
	return result;

i2c_send_sequence_cleanup:
	*I2C_C1 &= ~( I2C_C1_IICIE | I2C_C1_MST | I2C_C1_TX );
    2ba8:	5de3      	ldrb	r3, [r4, r7]
    2baa:	f003 038f 	and.w	r3, r3, #143	; 0x8f
    2bae:	55e3      	strb	r3, [r4, r7]
	channel->status = I2C_ERROR;
    2bb0:	2302      	movs	r3, #2
    2bb2:	756b      	strb	r3, [r5, #21]
		return -1;
    2bb4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2bb8:	e007      	b.n	2bca <i2c_send_sequence+0x86>
	*I2C_D = *channel->sequence++;
    2bba:	f85c 3006 	ldr.w	r3, [ip, r6]
    2bbe:	1c9a      	adds	r2, r3, #2
    2bc0:	f84c 2006 	str.w	r2, [ip, r6]
    2bc4:	781a      	ldrb	r2, [r3, #0]
    2bc6:	4b04      	ldr	r3, [pc, #16]	; (2bd8 <i2c_send_sequence+0x94>)
    2bc8:	54e2      	strb	r2, [r4, r3]
	return result;
}
    2bca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2bcc:	1fff89d4 	.word	0x1fff89d4
    2bd0:	40066002 	.word	0x40066002
    2bd4:	0000b7ca 	.word	0x0000b7ca
    2bd8:	40066004 	.word	0x40066004
    2bdc:	1fff9b74 	.word	0x1fff9b74
    2be0:	40066003 	.word	0x40066003

00002be4 <i2c_isr>:


void i2c_isr( uint8_t ch )
{
    2be4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	volatile I2C_Channel* channel = &i2c_channels[ch];

	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    2be8:	4b70      	ldr	r3, [pc, #448]	; (2dac <i2c_isr+0x1c8>)
	volatile uint8_t *I2C_S   = (uint8_t*)(&I2C0_S) + i2c_offset[ch];
    2bea:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 2dc8 <i2c_isr+0x1e4>
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    2bee:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    2bf2:	4e6f      	ldr	r6, [pc, #444]	; (2db0 <i2c_isr+0x1cc>)
    2bf4:	4d6f      	ldr	r5, [pc, #444]	; (2db4 <i2c_isr+0x1d0>)
{
    2bf6:	4607      	mov	r7, r0
	volatile uint8_t *I2C_D   = (uint8_t*)(&I2C0_D) + i2c_offset[ch];

	uint16_t element;
	uint8_t status;

	status = *I2C_S;
    2bf8:	f814 0008 	ldrb.w	r0, [r4, r8]

	// Acknowledge the interrupt request
	*I2C_S |= I2C_S_IICIF;
    2bfc:	f814 3008 	ldrb.w	r3, [r4, r8]
	status = *I2C_S;
    2c00:	b2c0      	uxtb	r0, r0
	*I2C_S |= I2C_S_IICIF;
    2c02:	f043 0302 	orr.w	r3, r3, #2

	// Arbitration problem
	if ( status & I2C_S_ARBL )
    2c06:	f010 0f10 	tst.w	r0, #16
	*I2C_S |= I2C_S_IICIF;
    2c0a:	f804 3008 	strb.w	r3, [r4, r8]
	if ( status & I2C_S_ARBL )
    2c0e:	d019      	beq.n	2c44 <i2c_isr+0x60>
	{
		warn_msg("Arbitration error. Bus: ");
    2c10:	4869      	ldr	r0, [pc, #420]	; (2db8 <i2c_isr+0x1d4>)
    2c12:	f008 fbf5 	bl	b400 <_print>
		printHex( ch );
    2c16:	2101      	movs	r1, #1
    2c18:	4638      	mov	r0, r7
    2c1a:	f008 fc99 	bl	b550 <printHex_op>
		print(NL);
    2c1e:	4867      	ldr	r0, [pc, #412]	; (2dbc <i2c_isr+0x1d8>)
    2c20:	f008 fbee 	bl	b400 <_print>

		*I2C_S |= I2C_S_ARBL;
    2c24:	f814 3008 	ldrb.w	r3, [r4, r8]
    2c28:	f043 0310 	orr.w	r3, r3, #16
    2c2c:	f804 3008 	strb.w	r3, [r4, r8]
	}
	return;

i2c_isr_error:
	// Generate STOP and disable further interrupts.
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE );
    2c30:	5da3      	ldrb	r3, [r4, r6]
	channel->status = I2C_ERROR;
    2c32:	2018      	movs	r0, #24
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE );
    2c34:	f003 039f 	and.w	r3, r3, #159	; 0x9f
	channel->status = I2C_ERROR;
    2c38:	fb00 5007 	mla	r0, r0, r7, r5
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE );
    2c3c:	55a3      	strb	r3, [r4, r6]
	channel->status = I2C_ERROR;
    2c3e:	2302      	movs	r3, #2
    2c40:	7543      	strb	r3, [r0, #21]
	return;
    2c42:	e044      	b.n	2cce <i2c_isr+0xea>
	if ( channel->txrx == I2C_READING )
    2c44:	2218      	movs	r2, #24
    2c46:	437a      	muls	r2, r7
    2c48:	18ab      	adds	r3, r5, r2
	volatile uint8_t *I2C_D   = (uint8_t*)(&I2C0_D) + i2c_offset[ch];
    2c4a:	495d      	ldr	r1, [pc, #372]	; (2dc0 <i2c_isr+0x1dc>)
	if ( channel->txrx == I2C_READING )
    2c4c:	f893 c016 	ldrb.w	ip, [r3, #22]
    2c50:	f1bc 0f01 	cmp.w	ip, #1
    2c54:	d142      	bne.n	2cdc <i2c_isr+0xf8>
		switch( channel->reads_ahead )
    2c56:	7d18      	ldrb	r0, [r3, #20]
    2c58:	f000 0cff 	and.w	ip, r0, #255	; 0xff
    2c5c:	b140      	cbz	r0, 2c70 <i2c_isr+0x8c>
    2c5e:	f1bc 0f01 	cmp.w	ip, #1
    2c62:	d036      	beq.n	2cd2 <i2c_isr+0xee>
			*channel->received_data++ = *I2C_D;
    2c64:	689a      	ldr	r2, [r3, #8]
    2c66:	1c50      	adds	r0, r2, #1
    2c68:	6098      	str	r0, [r3, #8]
    2c6a:	5c63      	ldrb	r3, [r4, r1]
    2c6c:	7013      	strb	r3, [r2, #0]
			break;
    2c6e:	e022      	b.n	2cb6 <i2c_isr+0xd2>
			*I2C_C1 |= I2C_C1_TX;
    2c70:	5da0      	ldrb	r0, [r4, r6]
    2c72:	f040 0010 	orr.w	r0, r0, #16
    2c76:	55a0      	strb	r0, [r4, r6]
			*channel->received_data++ = *I2C_D;
    2c78:	6898      	ldr	r0, [r3, #8]
    2c7a:	f100 0e01 	add.w	lr, r0, #1
    2c7e:	f8c3 e008 	str.w	lr, [r3, #8]
    2c82:	f814 e001 	ldrb.w	lr, [r4, r1]
    2c86:	f880 e000 	strb.w	lr, [r0]
			if ( ( channel->sequence < channel->sequence_end ) && ( *channel->sequence == I2C_RESTART ) )
    2c8a:	f855 e002 	ldr.w	lr, [r5, r2]
    2c8e:	6858      	ldr	r0, [r3, #4]
    2c90:	4586      	cmp	lr, r0
    2c92:	d276      	bcs.n	2d82 <i2c_isr+0x19e>
    2c94:	58a8      	ldr	r0, [r5, r2]
    2c96:	8800      	ldrh	r0, [r0, #0]
    2c98:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    2c9c:	d171      	bne.n	2d82 <i2c_isr+0x19e>
				*I2C_C1 |= I2C_C1_RSTA;
    2c9e:	5da0      	ldrb	r0, [r4, r6]
    2ca0:	f040 0004 	orr.w	r0, r0, #4
    2ca4:	55a0      	strb	r0, [r4, r6]
				channel->txrx = I2C_WRITING;
    2ca6:	f883 c016 	strb.w	ip, [r3, #22]
				channel->sequence++;
    2caa:	58ab      	ldr	r3, [r5, r2]
    2cac:	3302      	adds	r3, #2
    2cae:	50ab      	str	r3, [r5, r2]
				element = *channel->sequence;
    2cb0:	58ab      	ldr	r3, [r5, r2]
				*I2C_D = element;
    2cb2:	781b      	ldrb	r3, [r3, #0]
    2cb4:	5463      	strb	r3, [r4, r1]
		channel->reads_ahead--;
    2cb6:	2218      	movs	r2, #24
    2cb8:	fb02 5207 	mla	r2, r2, r7, r5
    2cbc:	7d13      	ldrb	r3, [r2, #20]
    2cbe:	3b01      	subs	r3, #1
    2cc0:	b2db      	uxtb	r3, r3
    2cc2:	7513      	strb	r3, [r2, #20]
	channel->sequence++;
    2cc4:	2018      	movs	r0, #24
    2cc6:	4378      	muls	r0, r7
    2cc8:	582b      	ldr	r3, [r5, r0]
    2cca:	3302      	adds	r3, #2
    2ccc:	502b      	str	r3, [r5, r0]
}
    2cce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			*I2C_C1 |= I2C_C1_TXAK;
    2cd2:	5da2      	ldrb	r2, [r4, r6]
    2cd4:	f042 0208 	orr.w	r2, r2, #8
    2cd8:	55a2      	strb	r2, [r4, r6]
    2cda:	e7c3      	b.n	2c64 <i2c_isr+0x80>
		if ( channel->sequence == channel->sequence_end )
    2cdc:	f855 e002 	ldr.w	lr, [r5, r2]
    2ce0:	f8d3 c004 	ldr.w	ip, [r3, #4]
    2ce4:	45e6      	cmp	lr, ip
    2ce6:	d04c      	beq.n	2d82 <i2c_isr+0x19e>
		if ( status & I2C_S_RXAK )
    2ce8:	07c0      	lsls	r0, r0, #31
    2cea:	d503      	bpl.n	2cf4 <i2c_isr+0x110>
			warn_print("NACK Received");
    2cec:	4835      	ldr	r0, [pc, #212]	; (2dc4 <i2c_isr+0x1e0>)
    2cee:	f008 fb87 	bl	b400 <_print>
			goto i2c_isr_error;
    2cf2:	e79d      	b.n	2c30 <i2c_isr+0x4c>
		element = *channel->sequence;
    2cf4:	58a8      	ldr	r0, [r5, r2]
    2cf6:	8800      	ldrh	r0, [r0, #0]
		if ( element == I2C_RESTART )
    2cf8:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    2cfc:	d10a      	bne.n	2d14 <i2c_isr+0x130>
			*I2C_C1 |= I2C_C1_RSTA | I2C_C1_TX;
    2cfe:	5da3      	ldrb	r3, [r4, r6]
    2d00:	f043 0314 	orr.w	r3, r3, #20
    2d04:	55a3      	strb	r3, [r4, r6]
			channel->sequence++;
    2d06:	58ab      	ldr	r3, [r5, r2]
    2d08:	3302      	adds	r3, #2
    2d0a:	50ab      	str	r3, [r5, r2]
			element = *channel->sequence;
    2d0c:	58ab      	ldr	r3, [r5, r2]
			*I2C_D = element;
    2d0e:	781b      	ldrb	r3, [r3, #0]
    2d10:	5463      	strb	r3, [r4, r1]
    2d12:	e7d7      	b.n	2cc4 <i2c_isr+0xe0>
			if ( element == I2C_READ ) {
    2d14:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    2d18:	d130      	bne.n	2d7c <i2c_isr+0x198>
				channel->txrx = I2C_READING;
    2d1a:	2201      	movs	r2, #1
    2d1c:	759a      	strb	r2, [r3, #22]
					channel->reads_ahead++;
    2d1e:	751a      	strb	r2, [r3, #20]
					(  ( channel->sequence + channel->reads_ahead ) < channel->sequence_end ) &&
    2d20:	681a      	ldr	r2, [r3, #0]
    2d22:	f893 c014 	ldrb.w	ip, [r3, #20]
    2d26:	6858      	ldr	r0, [r3, #4]
    2d28:	eb02 024c 	add.w	r2, r2, ip, lsl #1
				while (
    2d2c:	4290      	cmp	r0, r2
    2d2e:	d906      	bls.n	2d3e <i2c_isr+0x15a>
					( *( channel->sequence + channel->reads_ahead ) == I2C_READ )
    2d30:	681a      	ldr	r2, [r3, #0]
    2d32:	7d18      	ldrb	r0, [r3, #20]
					(  ( channel->sequence + channel->reads_ahead ) < channel->sequence_end ) &&
    2d34:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
    2d38:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    2d3c:	d01a      	beq.n	2d74 <i2c_isr+0x190>
				*I2C_C1 &= ~I2C_C1_TX;
    2d3e:	5da3      	ldrb	r3, [r4, r6]
    2d40:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    2d44:	55a3      	strb	r3, [r4, r6]
				if ( channel->reads_ahead == 1 )
    2d46:	2318      	movs	r3, #24
    2d48:	fb03 5307 	mla	r3, r3, r7, r5
    2d4c:	7d1b      	ldrb	r3, [r3, #20]
    2d4e:	2b01      	cmp	r3, #1
					*I2C_C1 |= I2C_C1_TXAK;
    2d50:	5da3      	ldrb	r3, [r4, r6]
    2d52:	bf0c      	ite	eq
    2d54:	f043 0308 	orreq.w	r3, r3, #8
					*I2C_C1 &= ~( I2C_C1_TXAK );
    2d58:	f003 03f7 	andne.w	r3, r3, #247	; 0xf7
    2d5c:	55a3      	strb	r3, [r4, r6]
				*channel->received_data = *I2C_D;
    2d5e:	2318      	movs	r3, #24
    2d60:	fb03 5307 	mla	r3, r3, r7, r5
    2d64:	689a      	ldr	r2, [r3, #8]
    2d66:	5c61      	ldrb	r1, [r4, r1]
    2d68:	7011      	strb	r1, [r2, #0]
				channel->reads_ahead--;
    2d6a:	7d1a      	ldrb	r2, [r3, #20]
    2d6c:	3a01      	subs	r2, #1
    2d6e:	b2d2      	uxtb	r2, r2
    2d70:	751a      	strb	r2, [r3, #20]
    2d72:	e7a7      	b.n	2cc4 <i2c_isr+0xe0>
					channel->reads_ahead++;
    2d74:	7d1a      	ldrb	r2, [r3, #20]
    2d76:	3201      	adds	r2, #1
    2d78:	b2d2      	uxtb	r2, r2
    2d7a:	e7d0      	b.n	2d1e <i2c_isr+0x13a>
				*I2C_D = element;
    2d7c:	b2c0      	uxtb	r0, r0
    2d7e:	5460      	strb	r0, [r4, r1]
    2d80:	e7a0      	b.n	2cc4 <i2c_isr+0xe0>
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE | I2C_C1_TXAK );
    2d82:	5da3      	ldrb	r3, [r4, r6]
	channel->status = I2C_AVAILABLE;
    2d84:	2018      	movs	r0, #24
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE | I2C_C1_TXAK );
    2d86:	f003 0397 	and.w	r3, r3, #151	; 0x97
	channel->status = I2C_AVAILABLE;
    2d8a:	fb00 5507 	mla	r5, r0, r7, r5
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE | I2C_C1_TXAK );
    2d8e:	55a3      	strb	r3, [r4, r6]
	channel->status = I2C_AVAILABLE;
    2d90:	2300      	movs	r3, #0
    2d92:	756b      	strb	r3, [r5, #21]
	if ( channel->callback_fn )
    2d94:	68eb      	ldr	r3, [r5, #12]
    2d96:	2b00      	cmp	r3, #0
    2d98:	d099      	beq.n	2cce <i2c_isr+0xea>
		delay_us(10);
    2d9a:	200a      	movs	r0, #10
    2d9c:	f7ff fc87 	bl	26ae <delay_us>
		( *channel->callback_fn )( channel->user_data );
    2da0:	68eb      	ldr	r3, [r5, #12]
    2da2:	6928      	ldr	r0, [r5, #16]
}
    2da4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		( *channel->callback_fn )( channel->user_data );
    2da8:	4718      	bx	r3
    2daa:	bf00      	nop
    2dac:	1fff89d4 	.word	0x1fff89d4
    2db0:	40066002 	.word	0x40066002
    2db4:	1fff9b74 	.word	0x1fff9b74
    2db8:	0000b777 	.word	0x0000b777
    2dbc:	00010d99 	.word	0x00010d99
    2dc0:	40066004 	.word	0x40066004
    2dc4:	0000b7a5 	.word	0x0000b7a5
    2dc8:	40066003 	.word	0x40066003

00002dcc <i2c0_isr>:

void i2c0_isr()
{
	i2c_isr( 0 );
    2dcc:	2000      	movs	r0, #0
    2dce:	f7ff bf09 	b.w	2be4 <i2c_isr>

00002dd2 <i2c1_isr>:
}

void i2c1_isr()
{
	i2c_isr( 1 );
    2dd2:	2001      	movs	r0, #1
    2dd4:	f7ff bf06 	b.w	2be4 <i2c_isr>

00002dd8 <cliFunc_ledToggle>:
	printInt32( LED_framerate );
	print("ms");
}

void cliFunc_ledToggle( char* args )
{
    2dd8:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    2dda:	4806      	ldr	r0, [pc, #24]	; (2df4 <cliFunc_ledToggle+0x1c>)
    2ddc:	f008 fb10 	bl	b400 <_print>
	info_msg("LEDs Toggle");
    2de0:	4805      	ldr	r0, [pc, #20]	; (2df8 <cliFunc_ledToggle+0x20>)
    2de2:	f008 fb0d 	bl	b400 <_print>
	LED_enable = !LED_enable;
    2de6:	4a05      	ldr	r2, [pc, #20]	; (2dfc <cliFunc_ledToggle+0x24>)
    2de8:	7813      	ldrb	r3, [r2, #0]
    2dea:	fab3 f383 	clz	r3, r3
    2dee:	095b      	lsrs	r3, r3, #5
    2df0:	7013      	strb	r3, [r2, #0]
}
    2df2:	bd08      	pop	{r3, pc}
    2df4:	00010d99 	.word	0x00010d99
    2df8:	0000b8fa 	.word	0x0000b8fa
    2dfc:	1fff9cc4 	.word	0x1fff9cc4

00002e00 <cliFunc_ledCheck>:
	print( NL ); // No \r\n by default after the command is entered
    2e00:	4801      	ldr	r0, [pc, #4]	; (2e08 <cliFunc_ledCheck+0x8>)
    2e02:	f008 bafd 	b.w	b400 <_print>
    2e06:	bf00      	nop
    2e08:	00010d99 	.word	0x00010d99

00002e0c <cliFunc_ledSet>:

void cliFunc_ledSet( char* args )
{
    2e0c:	b513      	push	{r0, r1, r4, lr}
    2e0e:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    2e10:	480c      	ldr	r0, [pc, #48]	; (2e44 <cliFunc_ledSet+0x38>)
    2e12:	f008 faf5 	bl	b400 <_print>

	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2e16:	aa02      	add	r2, sp, #8

	// Process speed argument if given
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e18:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    2e1a:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e1e:	4669      	mov	r1, sp
    2e20:	f007 fee6 	bl	abf0 <CLI_argumentIsolation>

	// Reset brightness
	if ( *arg1Ptr == '\0' )
    2e24:	9800      	ldr	r0, [sp, #0]
    2e26:	4c08      	ldr	r4, [pc, #32]	; (2e48 <cliFunc_ledSet+0x3c>)
    2e28:	7803      	ldrb	r3, [r0, #0]
    2e2a:	b933      	cbnz	r3, 2e3a <cliFunc_ledSet+0x2e>
	{
		LED_brightness = ISSI_Global_Brightness_define;
    2e2c:	23ff      	movs	r3, #255	; 0xff
    2e2e:	7023      	strb	r3, [r4, #0]
	else
	{
		LED_brightness = numToInt( arg1Ptr );
	}

	info_msg("LED Brightness Set");
    2e30:	4806      	ldr	r0, [pc, #24]	; (2e4c <cliFunc_ledSet+0x40>)
    2e32:	f008 fae5 	bl	b400 <_print>
#elif ISSI_Chip_31FL3731_define == 1
		// XXX (HaaTa) - This is emulated, see LED_scan and LED_linkedSend for implementation
#endif
	}
#endif
}
    2e36:	b002      	add	sp, #8
    2e38:	bd10      	pop	{r4, pc}
		LED_brightness = numToInt( arg1Ptr );
    2e3a:	f008 fbf4 	bl	b626 <numToInt>
    2e3e:	7020      	strb	r0, [r4, #0]
    2e40:	e7f6      	b.n	2e30 <cliFunc_ledSet+0x24>
    2e42:	bf00      	nop
    2e44:	00010d99 	.word	0x00010d99
    2e48:	1fff9cb8 	.word	0x1fff9cb8
    2e4c:	0000b8d5 	.word	0x0000b8d5

00002e50 <LED_linkedSend>:
{
    2e50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if ( LED_chipSend >= ISSI_Chips_define )
    2e52:	4c11      	ldr	r4, [pc, #68]	; (2e98 <LED_linkedSend+0x48>)
    2e54:	4b11      	ldr	r3, [pc, #68]	; (2e9c <LED_linkedSend+0x4c>)
    2e56:	7822      	ldrb	r2, [r4, #0]
    2e58:	b11a      	cbz	r2, 2e62 <LED_linkedSend+0x12>
		Pixel_FrameState = FrameState_Update;
    2e5a:	2202      	movs	r2, #2
    2e5c:	701a      	strb	r2, [r3, #0]
}
    2e5e:	b003      	add	sp, #12
    2e60:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Pixel_FrameState = FrameState_Sending;
    2e62:	2201      	movs	r2, #1
		(uint16_t*)&LED_pageBuffer_brightness[ LED_chipSend ],
    2e64:	4d0e      	ldr	r5, [pc, #56]	; (2ea0 <LED_linkedSend+0x50>)
	while ( i2c_send_sequence(
    2e66:	4f0f      	ldr	r7, [pc, #60]	; (2ea4 <LED_linkedSend+0x54>)
	Pixel_FrameState = FrameState_Sending;
    2e68:	701a      	strb	r2, [r3, #0]
		(uint16_t*)&LED_pageBuffer_brightness[ LED_chipSend ],
    2e6a:	f44f 7692 	mov.w	r6, #292	; 0x124
    2e6e:	7821      	ldrb	r1, [r4, #0]
	while ( i2c_send_sequence(
    2e70:	2300      	movs	r3, #0
    2e72:	e9cd 7300 	strd	r7, r3, [sp]
    2e76:	2292      	movs	r2, #146	; 0x92
    2e78:	fb06 5101 	mla	r1, r6, r1, r5
    2e7c:	4618      	mov	r0, r3
    2e7e:	f7ff fe61 	bl	2b44 <i2c_send_sequence>
    2e82:	3001      	adds	r0, #1
    2e84:	d003      	beq.n	2e8e <LED_linkedSend+0x3e>
	LED_chipSend++;
    2e86:	7823      	ldrb	r3, [r4, #0]
    2e88:	3301      	adds	r3, #1
    2e8a:	7023      	strb	r3, [r4, #0]
    2e8c:	e7e7      	b.n	2e5e <LED_linkedSend+0xe>
		delay_us( delay_tm );
    2e8e:	2032      	movs	r0, #50	; 0x32
    2e90:	f7ff fc0d 	bl	26ae <delay_us>
    2e94:	e7eb      	b.n	2e6e <LED_linkedSend+0x1e>
    2e96:	bf00      	nop
    2e98:	1fff9b90 	.word	0x1fff9b90
    2e9c:	1fffa765 	.word	0x1fffa765
    2ea0:	1fff9b94 	.word	0x1fff9b94
    2ea4:	00002e51 	.word	0x00002e51

00002ea8 <cliFunc_ledFPS>:
{
    2ea8:	b513      	push	{r0, r1, r4, lr}
    2eaa:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    2eac:	4816      	ldr	r0, [pc, #88]	; (2f08 <cliFunc_ledFPS+0x60>)
    2eae:	f008 faa7 	bl	b400 <_print>
	char* arg2Ptr = args;
    2eb2:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2eb4:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    2eb6:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2eba:	4669      	mov	r1, sp
    2ebc:	f007 fe98 	bl	abf0 <CLI_argumentIsolation>
	if ( *arg1Ptr == '\0' )
    2ec0:	9800      	ldr	r0, [sp, #0]
    2ec2:	7803      	ldrb	r3, [r0, #0]
    2ec4:	b953      	cbnz	r3, 2edc <cliFunc_ledFPS+0x34>
		info_msg("FPS Toggle");
    2ec6:	4811      	ldr	r0, [pc, #68]	; (2f0c <cliFunc_ledFPS+0x64>)
    2ec8:	f008 fa9a 	bl	b400 <_print>
		LED_displayFPS = !LED_displayFPS;
    2ecc:	4a10      	ldr	r2, [pc, #64]	; (2f10 <cliFunc_ledFPS+0x68>)
    2ece:	7813      	ldrb	r3, [r2, #0]
    2ed0:	fab3 f383 	clz	r3, r3
    2ed4:	095b      	lsrs	r3, r3, #5
    2ed6:	7013      	strb	r3, [r2, #0]
}
    2ed8:	b002      	add	sp, #8
    2eda:	bd10      	pop	{r4, pc}
	switch ( *arg1Ptr )
    2edc:	2b52      	cmp	r3, #82	; 0x52
    2ede:	4c0d      	ldr	r4, [pc, #52]	; (2f14 <cliFunc_ledFPS+0x6c>)
    2ee0:	d001      	beq.n	2ee6 <cliFunc_ledFPS+0x3e>
    2ee2:	2b72      	cmp	r3, #114	; 0x72
    2ee4:	d10b      	bne.n	2efe <cliFunc_ledFPS+0x56>
		LED_framerate = ISSI_FrameRate_ms_define;
    2ee6:	2364      	movs	r3, #100	; 0x64
    2ee8:	6023      	str	r3, [r4, #0]
	info_msg("Setting framerate to: ");
    2eea:	480b      	ldr	r0, [pc, #44]	; (2f18 <cliFunc_ledFPS+0x70>)
    2eec:	f008 fa88 	bl	b400 <_print>
	printInt32( LED_framerate );
    2ef0:	6820      	ldr	r0, [r4, #0]
    2ef2:	f008 faf4 	bl	b4de <printInt32>
	print("ms");
    2ef6:	4809      	ldr	r0, [pc, #36]	; (2f1c <cliFunc_ledFPS+0x74>)
    2ef8:	f008 fa82 	bl	b400 <_print>
    2efc:	e7ec      	b.n	2ed8 <cliFunc_ledFPS+0x30>
		LED_framerate = numToInt( arg1Ptr );
    2efe:	f008 fb92 	bl	b626 <numToInt>
    2f02:	6020      	str	r0, [r4, #0]
		break;
    2f04:	e7f1      	b.n	2eea <cliFunc_ledFPS+0x42>
    2f06:	bf00      	nop
    2f08:	00010d99 	.word	0x00010d99
    2f0c:	0000b88c 	.word	0x0000b88c
    2f10:	1fff9b92 	.word	0x1fff9b92
    2f14:	1fff9b8c 	.word	0x1fff9b8c
    2f18:	0000b8a9 	.word	0x0000b8a9
    2f1c:	0000b8d2 	.word	0x0000b8d2

00002f20 <LED_setupPage>:
{
    2f20:	b530      	push	{r4, r5, lr}
    2f22:	b085      	sub	sp, #20
	uint16_t pageSetup[] = { addr, 0xFD, page };
    2f24:	23fd      	movs	r3, #253	; 0xfd
{
    2f26:	4604      	mov	r4, r0
	uint16_t pageSetup[] = { addr, 0xFD, page };
    2f28:	f8ad 1008 	strh.w	r1, [sp, #8]
    2f2c:	f8ad 300a 	strh.w	r3, [sp, #10]
    2f30:	f8ad 200c 	strh.w	r2, [sp, #12]
	while ( i2c_send( bus, pageSetup, sizeof( pageSetup ) / 2 ) == -1 )
    2f34:	2500      	movs	r5, #0
    2f36:	e9cd 5500 	strd	r5, r5, [sp]
    2f3a:	2300      	movs	r3, #0
    2f3c:	2203      	movs	r2, #3
    2f3e:	a902      	add	r1, sp, #8
    2f40:	4620      	mov	r0, r4
    2f42:	f7ff fdff 	bl	2b44 <i2c_send_sequence>
    2f46:	3001      	adds	r0, #1
    2f48:	d005      	beq.n	2f56 <LED_setupPage+0x36>
	while ( i2c_busy( bus ) )
    2f4a:	4620      	mov	r0, r4
    2f4c:	f7ff fdee 	bl	2b2c <i2c_busy>
    2f50:	b928      	cbnz	r0, 2f5e <LED_setupPage+0x3e>
}
    2f52:	b005      	add	sp, #20
    2f54:	bd30      	pop	{r4, r5, pc}
		delay_us( ISSI_SendDelay );
    2f56:	2032      	movs	r0, #50	; 0x32
    2f58:	f7ff fba9 	bl	26ae <delay_us>
    2f5c:	e7eb      	b.n	2f36 <LED_setupPage+0x16>
		delay_us( ISSI_SendDelay );
    2f5e:	2032      	movs	r0, #50	; 0x32
    2f60:	f7ff fba5 	bl	26ae <delay_us>
    2f64:	e7f1      	b.n	2f4a <LED_setupPage+0x2a>

00002f66 <LED_zeroPages>:
{
    2f66:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2f6a:	b0df      	sub	sp, #380	; 0x17c
    2f6c:	4688      	mov	r8, r1
    2f6e:	4614      	mov	r4, r2
    2f70:	4606      	mov	r6, r0
	uint16_t clearPage[2 + ISSI_PageLength] = { 0 };
    2f72:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    2f76:	2100      	movs	r1, #0
    2f78:	a803      	add	r0, sp, #12
{
    2f7a:	f89d 9198 	ldrb.w	r9, [sp, #408]	; 0x198
    2f7e:	461f      	mov	r7, r3
	uint16_t clearPage[2 + ISSI_PageLength] = { 0 };
    2f80:	f7ff fb5e 	bl	2640 <memset>
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    2f84:	f89d 519c 	ldrb.w	r5, [sp, #412]	; 0x19c
	clearPage[0] = addr;
    2f88:	f8ad 800c 	strh.w	r8, [sp, #12]
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    2f8c:	3502      	adds	r5, #2
	clearPage[1] = startReg;
    2f8e:	f8ad 900e 	strh.w	r9, [sp, #14]
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    2f92:	4427      	add	r7, r4
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    2f94:	eba5 0509 	sub.w	r5, r5, r9
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    2f98:	42bc      	cmp	r4, r7
    2f9a:	db06      	blt.n	2faa <LED_zeroPages+0x44>
	while ( i2c_busy( bus ) )
    2f9c:	4630      	mov	r0, r6
    2f9e:	f7ff fdc5 	bl	2b2c <i2c_busy>
    2fa2:	b9d0      	cbnz	r0, 2fda <LED_zeroPages+0x74>
}
    2fa4:	b05f      	add	sp, #380	; 0x17c
    2fa6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LED_setupPage( bus, addr, page );
    2faa:	4622      	mov	r2, r4
    2fac:	4641      	mov	r1, r8
    2fae:	4630      	mov	r0, r6
    2fb0:	f7ff ffb6 	bl	2f20 <LED_setupPage>
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    2fb4:	f04f 0900 	mov.w	r9, #0
    2fb8:	e9cd 9900 	strd	r9, r9, [sp]
    2fbc:	2300      	movs	r3, #0
    2fbe:	462a      	mov	r2, r5
    2fc0:	a903      	add	r1, sp, #12
    2fc2:	4630      	mov	r0, r6
    2fc4:	f7ff fdbe 	bl	2b44 <i2c_send_sequence>
    2fc8:	3001      	adds	r0, #1
    2fca:	d002      	beq.n	2fd2 <LED_zeroPages+0x6c>
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    2fcc:	3401      	adds	r4, #1
    2fce:	b2e4      	uxtb	r4, r4
    2fd0:	e7e2      	b.n	2f98 <LED_zeroPages+0x32>
			delay_us( ISSI_SendDelay );
    2fd2:	2032      	movs	r0, #50	; 0x32
    2fd4:	f7ff fb6b 	bl	26ae <delay_us>
    2fd8:	e7ee      	b.n	2fb8 <LED_zeroPages+0x52>
		delay_us( ISSI_SendDelay );
    2fda:	2032      	movs	r0, #50	; 0x32
    2fdc:	f7ff fb67 	bl	26ae <delay_us>
    2fe0:	e7dc      	b.n	2f9c <LED_zeroPages+0x36>

00002fe2 <LED_zeroControlPages>:
{
    2fe2:	b507      	push	{r0, r1, r2, lr}
		LED_zeroPages( bus, addr, ISSI_ConfigPage, 1, 0x00, ISSI_ConfigPageLength ); // Control Registers
    2fe4:	230c      	movs	r3, #12
    2fe6:	2000      	movs	r0, #0
    2fe8:	e9cd 0300 	strd	r0, r3, [sp]
    2fec:	220b      	movs	r2, #11
    2fee:	2301      	movs	r3, #1
    2ff0:	21e8      	movs	r1, #232	; 0xe8
    2ff2:	f7ff ffb8 	bl	2f66 <LED_zeroPages>
}
    2ff6:	b003      	add	sp, #12
    2ff8:	f85d fb04 	ldr.w	pc, [sp], #4

00002ffc <LED_sendPage>:
{
    2ffc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2ffe:	4616      	mov	r6, r2
	LED_setupPage( bus, addr, page );
    3000:	f89d 2020 	ldrb.w	r2, [sp, #32]
{
    3004:	4605      	mov	r5, r0
    3006:	461f      	mov	r7, r3
	LED_setupPage( bus, addr, page );
    3008:	f7ff ff8a 	bl	2f20 <LED_setupPage>
	while ( i2c_send( bus, buffer, len ) == -1 )
    300c:	2400      	movs	r4, #0
    300e:	e9cd 4400 	strd	r4, r4, [sp]
    3012:	2300      	movs	r3, #0
    3014:	463a      	mov	r2, r7
    3016:	4631      	mov	r1, r6
    3018:	4628      	mov	r0, r5
    301a:	f7ff fd93 	bl	2b44 <i2c_send_sequence>
    301e:	3001      	adds	r0, #1
    3020:	d001      	beq.n	3026 <LED_sendPage+0x2a>
}
    3022:	b003      	add	sp, #12
    3024:	bdf0      	pop	{r4, r5, r6, r7, pc}
		delay_us( ISSI_SendDelay );
    3026:	2032      	movs	r0, #50	; 0x32
    3028:	f7ff fb41 	bl	26ae <delay_us>
    302c:	e7ef      	b.n	300e <LED_sendPage+0x12>

0000302e <LED_writeReg>:
{
    302e:	b530      	push	{r4, r5, lr}
    3030:	b085      	sub	sp, #20
    3032:	4604      	mov	r4, r0
	uint16_t writeData[] = { addr, reg, val };
    3034:	f8ad 200a 	strh.w	r2, [sp, #10]
	LED_setupPage( bus, addr, page );
    3038:	f89d 2020 	ldrb.w	r2, [sp, #32]
	uint16_t writeData[] = { addr, reg, val };
    303c:	f8ad 1008 	strh.w	r1, [sp, #8]
    3040:	f8ad 300c 	strh.w	r3, [sp, #12]
	LED_setupPage( bus, addr, page );
    3044:	f7ff ff6c 	bl	2f20 <LED_setupPage>
	while ( i2c_send( bus, writeData, sizeof( writeData ) / 2 ) == -1 )
    3048:	2500      	movs	r5, #0
    304a:	e9cd 5500 	strd	r5, r5, [sp]
    304e:	2300      	movs	r3, #0
    3050:	2203      	movs	r2, #3
    3052:	a902      	add	r1, sp, #8
    3054:	4620      	mov	r0, r4
    3056:	f7ff fd75 	bl	2b44 <i2c_send_sequence>
    305a:	3001      	adds	r0, #1
    305c:	d005      	beq.n	306a <LED_writeReg+0x3c>
	while ( i2c_busy( bus ) )
    305e:	4620      	mov	r0, r4
    3060:	f7ff fd64 	bl	2b2c <i2c_busy>
    3064:	b928      	cbnz	r0, 3072 <LED_writeReg+0x44>
}
    3066:	b005      	add	sp, #20
    3068:	bd30      	pop	{r4, r5, pc}
		delay_us( ISSI_SendDelay );
    306a:	2032      	movs	r0, #50	; 0x32
    306c:	f7ff fb1f 	bl	26ae <delay_us>
    3070:	e7eb      	b.n	304a <LED_writeReg+0x1c>
		delay_us( ISSI_SendDelay );
    3072:	2032      	movs	r0, #50	; 0x32
    3074:	f7ff fb1b 	bl	26ae <delay_us>
    3078:	e7f1      	b.n	305e <LED_writeReg+0x30>
    307a:	0000      	movs	r0, r0

0000307c <LED_reset>:
{
    307c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	LED_displayFPS = 0;
    307e:	4b15      	ldr	r3, [pc, #84]	; (30d4 <LED_reset+0x58>)
	Pixel_FrameState = FrameState_Sending;
    3080:	4d15      	ldr	r5, [pc, #84]	; (30d8 <LED_reset+0x5c>)
	LED_displayFPS = 0;
    3082:	2400      	movs	r4, #0
    3084:	701c      	strb	r4, [r3, #0]
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    3086:	23b4      	movs	r3, #180	; 0xb4
	Pixel_FrameState = FrameState_Sending;
    3088:	2601      	movs	r6, #1
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    308a:	e9cd 4300 	strd	r4, r3, [sp]
    308e:	4622      	mov	r2, r4
    3090:	4620      	mov	r0, r4
    3092:	2308      	movs	r3, #8
    3094:	21e8      	movs	r1, #232	; 0xe8
		LED_writeReg( bus, addr, 0x00, 0x00, ISSI_ConfigPage );
    3096:	270b      	movs	r7, #11
	Pixel_FrameState = FrameState_Sending;
    3098:	702e      	strb	r6, [r5, #0]
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    309a:	f7ff ff64 	bl	2f66 <LED_zeroPages>
		LED_sendPage(
    309e:	4620      	mov	r0, r4
    30a0:	9400      	str	r4, [sp, #0]
    30a2:	2314      	movs	r3, #20
    30a4:	4a0d      	ldr	r2, [pc, #52]	; (30dc <LED_reset+0x60>)
    30a6:	21e8      	movs	r1, #232	; 0xe8
    30a8:	f7ff ffa8 	bl	2ffc <LED_sendPage>
		LED_writeReg( bus, addr, 0x00, 0x00, ISSI_ConfigPage );
    30ac:	4623      	mov	r3, r4
    30ae:	4622      	mov	r2, r4
    30b0:	4620      	mov	r0, r4
    30b2:	9700      	str	r7, [sp, #0]
    30b4:	21e8      	movs	r1, #232	; 0xe8
    30b6:	f7ff ffba 	bl	302e <LED_writeReg>
		LED_writeReg( bus, addr, 0x0A, 0x01, ISSI_ConfigPage );
    30ba:	4633      	mov	r3, r6
    30bc:	9700      	str	r7, [sp, #0]
    30be:	220a      	movs	r2, #10
    30c0:	21e8      	movs	r1, #232	; 0xe8
    30c2:	4620      	mov	r0, r4
    30c4:	f7ff ffb3 	bl	302e <LED_writeReg>
	Pixel_FrameState = FrameState_Update;
    30c8:	2302      	movs	r3, #2
    30ca:	702b      	strb	r3, [r5, #0]
	LED_pause = 0;
    30cc:	4b04      	ldr	r3, [pc, #16]	; (30e0 <LED_reset+0x64>)
    30ce:	701c      	strb	r4, [r3, #0]
}
    30d0:	b003      	add	sp, #12
    30d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30d4:	1fff9b92 	.word	0x1fff9b92
    30d8:	1fffa765 	.word	0x1fffa765
    30dc:	0000b816 	.word	0x0000b816
    30e0:	1fff9b91 	.word	0x1fff9b91

000030e4 <cliFunc_ledReset>:
{
    30e4:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    30e6:	480f      	ldr	r0, [pc, #60]	; (3124 <cliFunc_ledReset+0x40>)
    30e8:	f008 f98a 	bl	b400 <_print>
	GPIOC_PSOR |= (1<<5);
    30ec:	4a0e      	ldr	r2, [pc, #56]	; (3128 <cliFunc_ledReset+0x44>)
    30ee:	6813      	ldr	r3, [r2, #0]
    30f0:	f043 0320 	orr.w	r3, r3, #32
	delay_us(50);
    30f4:	2032      	movs	r0, #50	; 0x32
	GPIOC_PSOR |= (1<<5);
    30f6:	6013      	str	r3, [r2, #0]
	delay_us(50);
    30f8:	f7ff fad9 	bl	26ae <delay_us>
	GPIOC_PCOR |= (1<<5);
    30fc:	4a0b      	ldr	r2, [pc, #44]	; (312c <cliFunc_ledReset+0x48>)
    30fe:	6813      	ldr	r3, [r2, #0]
    3100:	f043 0320 	orr.w	r3, r3, #32
    3104:	6013      	str	r3, [r2, #0]
	i2c_reset();
    3106:	f7ff fd09 	bl	2b1c <i2c_reset>
	LED_zeroControlPages();
    310a:	f7ff ff6a 	bl	2fe2 <LED_zeroControlPages>
		memset( (void*)LED_pageBuffer[ buf ].buffer, 0, LED_BufferLength * 2 );
    310e:	f44f 7290 	mov.w	r2, #288	; 0x120
    3112:	2100      	movs	r1, #0
    3114:	4806      	ldr	r0, [pc, #24]	; (3130 <cliFunc_ledReset+0x4c>)
    3116:	f7ff fa93 	bl	2640 <memset>
}
    311a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LED_reset();
    311e:	f7ff bfad 	b.w	307c <LED_reset>
    3122:	bf00      	nop
    3124:	00010d99 	.word	0x00010d99
    3128:	400ff084 	.word	0x400ff084
    312c:	400ff088 	.word	0x400ff088
    3130:	1fffa8ae 	.word	0x1fffa8ae

00003134 <LED_setup>:
{
    3134:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    3136:	4920      	ldr	r1, [pc, #128]	; (31b8 <LED_setup+0x84>)
    3138:	4820      	ldr	r0, [pc, #128]	; (31bc <LED_setup+0x88>)
	LED_timePrev = Time_now();
    313a:	4d21      	ldr	r5, [pc, #132]	; (31c0 <LED_setup+0x8c>)
    313c:	466c      	mov	r4, sp
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    313e:	f007 fdf1 	bl	ad24 <CLI_registerDictionary>
	LED_timePrev = Time_now();
    3142:	4620      	mov	r0, r4
    3144:	f7ff fc0c 	bl	2960 <Time_now>
	LED_framerate = ISSI_FrameRate_ms_define;
    3148:	4b1e      	ldr	r3, [pc, #120]	; (31c4 <LED_setup+0x90>)
	LED_timePrev = Time_now();
    314a:	e894 0003 	ldmia.w	r4, {r0, r1}
	LED_framerate = ISSI_FrameRate_ms_define;
    314e:	2264      	movs	r2, #100	; 0x64
    3150:	601a      	str	r2, [r3, #0]
	LED_brightness = ISSI_Global_Brightness_define;
    3152:	4b1d      	ldr	r3, [pc, #116]	; (31c8 <LED_setup+0x94>)
	LED_enable = ISSI_Enable_define;
    3154:	4c1d      	ldr	r4, [pc, #116]	; (31cc <LED_setup+0x98>)
	LED_brightness = ISSI_Global_Brightness_define;
    3156:	22ff      	movs	r2, #255	; 0xff
	LED_timePrev = Time_now();
    3158:	e885 0003 	stmia.w	r5, {r0, r1}
	LED_brightness = ISSI_Global_Brightness_define;
    315c:	701a      	strb	r2, [r3, #0]
	i2c_setup();
    315e:	f7ff fcb3 	bl	2ac8 <i2c_setup>
	LED_pageBuffer[0].i2c_addr = LED_MapCh1_Addr_define;
    3162:	4b1b      	ldr	r3, [pc, #108]	; (31d0 <LED_setup+0x9c>)
    3164:	21e8      	movs	r1, #232	; 0xe8
	LED_pageBuffer[0].reg_addr = ISSI_LEDPwmRegStart;
    3166:	2224      	movs	r2, #36	; 0x24
    3168:	805a      	strh	r2, [r3, #2]
	LED_pageBuffer[0].i2c_addr = LED_MapCh1_Addr_define;
    316a:	8019      	strh	r1, [r3, #0]
	LED_pageBuffer_brightness[0].i2c_addr = LED_MapCh1_Addr_define;
    316c:	4b19      	ldr	r3, [pc, #100]	; (31d4 <LED_setup+0xa0>)
    316e:	8019      	strh	r1, [r3, #0]
	LED_pageBuffer_brightness[0].reg_addr = ISSI_LEDPwmRegStart;
    3170:	805a      	strh	r2, [r3, #2]
	GPIOB_PDDR |= (1<<16);
    3172:	4a19      	ldr	r2, [pc, #100]	; (31d8 <LED_setup+0xa4>)
	LED_enable = ISSI_Enable_define;
    3174:	2301      	movs	r3, #1
    3176:	7023      	strb	r3, [r4, #0]
	GPIOB_PDDR |= (1<<16);
    3178:	6813      	ldr	r3, [r2, #0]
    317a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    317e:	6013      	str	r3, [r2, #0]
	PORTB_PCR16 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    3180:	4b16      	ldr	r3, [pc, #88]	; (31dc <LED_setup+0xa8>)
    3182:	f44f 72a2 	mov.w	r2, #324	; 0x144
    3186:	601a      	str	r2, [r3, #0]
	GPIOB_PCOR |= (1<<16);
    3188:	4a15      	ldr	r2, [pc, #84]	; (31e0 <LED_setup+0xac>)
    318a:	6813      	ldr	r3, [r2, #0]
    318c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    3190:	6013      	str	r3, [r2, #0]
	LED_zeroControlPages();
    3192:	f7ff ff26 	bl	2fe2 <LED_zeroControlPages>
	if ( LED_enable )
    3196:	7823      	ldrb	r3, [r4, #0]
    3198:	b123      	cbz	r3, 31a4 <LED_setup+0x70>
		GPIOB_PSOR |= (1<<16);
    319a:	4a12      	ldr	r2, [pc, #72]	; (31e4 <LED_setup+0xb0>)
    319c:	6813      	ldr	r3, [r2, #0]
    319e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    31a2:	6013      	str	r3, [r2, #0]
	LED_reset();
    31a4:	f7ff ff6a 	bl	307c <LED_reset>
	ledLatencyResource = Latency_add_resource("ISSILed", LatencyOption_Ticks);
    31a8:	2100      	movs	r1, #0
    31aa:	480f      	ldr	r0, [pc, #60]	; (31e8 <LED_setup+0xb4>)
    31ac:	f008 f84c 	bl	b248 <Latency_add_resource>
    31b0:	4b0e      	ldr	r3, [pc, #56]	; (31ec <LED_setup+0xb8>)
    31b2:	7018      	strb	r0, [r3, #0]
}
    31b4:	b003      	add	sp, #12
    31b6:	bd30      	pop	{r4, r5, pc}
    31b8:	0000b960 	.word	0x0000b960
    31bc:	0000b918 	.word	0x0000b918
    31c0:	1fff9cbc 	.word	0x1fff9cbc
    31c4:	1fff9b8c 	.word	0x1fff9b8c
    31c8:	1fff9cb8 	.word	0x1fff9cb8
    31cc:	1fff9cc4 	.word	0x1fff9cc4
    31d0:	1fffa8aa 	.word	0x1fffa8aa
    31d4:	1fff9b94 	.word	0x1fff9b94
    31d8:	400ff054 	.word	0x400ff054
    31dc:	4004a040 	.word	0x4004a040
    31e0:	400ff048 	.word	0x400ff048
    31e4:	400ff044 	.word	0x400ff044
    31e8:	0000b884 	.word	0x0000b884
    31ec:	1fff9164 	.word	0x1fff9164

000031f0 <LED_scan>:
{
    31f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	Latency_start_time( ledLatencyResource );
    31f4:	4d4b      	ldr	r5, [pc, #300]	; (3324 <LED_scan+0x134>)
	if ( LED_currentEvent )
    31f6:	4c4c      	ldr	r4, [pc, #304]	; (3328 <LED_scan+0x138>)
	Latency_start_time( ledLatencyResource );
    31f8:	7828      	ldrb	r0, [r5, #0]
{
    31fa:	b086      	sub	sp, #24
	Latency_start_time( ledLatencyResource );
    31fc:	f008 f874 	bl	b2e8 <Latency_start_time>
	if ( LED_currentEvent )
    3200:	6822      	ldr	r2, [r4, #0]
    3202:	b16a      	cbz	r2, 3220 <LED_scan+0x30>
		if ( LED_currentEvent < 150 )
    3204:	2a95      	cmp	r2, #149	; 0x95
    3206:	4b49      	ldr	r3, [pc, #292]	; (332c <LED_scan+0x13c>)
			LED_enable = 0;
    3208:	bf95      	itete	ls
    320a:	2200      	movls	r2, #0
			LED_enable = 1;
    320c:	2201      	movhi	r2, #1
			Pixel_setAnimationControl( AnimationControl_WipePause );
    320e:	2005      	movls	r0, #5
			Pixel_setAnimationControl( AnimationControl_Forward );
    3210:	2000      	movhi	r0, #0
			LED_enable = 0;
    3212:	bf94      	ite	ls
    3214:	701a      	strbls	r2, [r3, #0]
			LED_enable = 1;
    3216:	701a      	strbhi	r2, [r3, #0]
			Pixel_setAnimationControl( AnimationControl_Forward );
    3218:	f004 fe0e 	bl	7e38 <Pixel_setAnimationControl>
		LED_currentEvent = 0;
    321c:	2300      	movs	r3, #0
    321e:	6023      	str	r3, [r4, #0]
	if ( LED_pause )
    3220:	4b43      	ldr	r3, [pc, #268]	; (3330 <LED_scan+0x140>)
    3222:	781b      	ldrb	r3, [r3, #0]
    3224:	2b00      	cmp	r3, #0
    3226:	d16d      	bne.n	3304 <LED_scan+0x114>
	if ( LED_enable )
    3228:	4b40      	ldr	r3, [pc, #256]	; (332c <LED_scan+0x13c>)
    322a:	781b      	ldrb	r3, [r3, #0]
    322c:	2b00      	cmp	r3, #0
    322e:	d064      	beq.n	32fa <LED_scan+0x10a>
		GPIOB_PSOR |= (1<<16);
    3230:	4a40      	ldr	r2, [pc, #256]	; (3334 <LED_scan+0x144>)
    3232:	6813      	ldr	r3, [r2, #0]
    3234:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    3238:	6013      	str	r3, [r2, #0]
	if ( Pixel_FrameState == FrameState_Sending )
    323a:	4b3f      	ldr	r3, [pc, #252]	; (3338 <LED_scan+0x148>)
	if ( Pixel_FrameState != FrameState_Ready )
    323c:	781b      	ldrb	r3, [r3, #0]
    323e:	2b00      	cmp	r3, #0
    3240:	d160      	bne.n	3304 <LED_scan+0x114>
	Time duration = Time_duration( LED_timePrev );
    3242:	4c3e      	ldr	r4, [pc, #248]	; (333c <LED_scan+0x14c>)
	if ( duration.ms < LED_framerate )
    3244:	4e3e      	ldr	r6, [pc, #248]	; (3340 <LED_scan+0x150>)
	Time duration = Time_duration( LED_timePrev );
    3246:	af04      	add	r7, sp, #16
    3248:	e894 0006 	ldmia.w	r4, {r1, r2}
    324c:	4638      	mov	r0, r7
    324e:	f7ff fbe7 	bl	2a20 <Time_duration>
    3252:	f8dd 8010 	ldr.w	r8, [sp, #16]
	if ( duration.ms < LED_framerate )
    3256:	6833      	ldr	r3, [r6, #0]
    3258:	4598      	cmp	r8, r3
    325a:	d353      	bcc.n	3304 <LED_scan+0x114>
	if ( LED_displayFPS )
    325c:	4b39      	ldr	r3, [pc, #228]	; (3344 <LED_scan+0x154>)
    325e:	781b      	ldrb	r3, [r3, #0]
    3260:	b1eb      	cbz	r3, 329e <LED_scan+0xae>
		dbug_msg("1frame/");
    3262:	4839      	ldr	r0, [pc, #228]	; (3348 <LED_scan+0x158>)
    3264:	f008 f8cc 	bl	b400 <_print>
		printInt32( Time_ms( duration ) );
    3268:	e897 0003 	ldmia.w	r7, {r0, r1}
    326c:	f7ff fb84 	bl	2978 <Time_ms>
    3270:	f008 f935 	bl	b4de <printInt32>
		print("ms + ");
    3274:	4835      	ldr	r0, [pc, #212]	; (334c <LED_scan+0x15c>)
    3276:	f008 f8c3 	bl	b400 <_print>
		printInt32( duration.ticks );
    327a:	9805      	ldr	r0, [sp, #20]
    327c:	f008 f92f 	bl	b4de <printInt32>
		print(" ticks");
    3280:	4833      	ldr	r0, [pc, #204]	; (3350 <LED_scan+0x160>)
    3282:	f008 f8bd 	bl	b400 <_print>
		if ( duration.ms > LED_framerate )
    3286:	6833      	ldr	r3, [r6, #0]
    3288:	4598      	cmp	r8, r3
    328a:	d905      	bls.n	3298 <LED_scan+0xa8>
			print(" - Could not meet framerate: ");
    328c:	4831      	ldr	r0, [pc, #196]	; (3354 <LED_scan+0x164>)
    328e:	f008 f8b7 	bl	b400 <_print>
			printInt32( LED_framerate );
    3292:	6830      	ldr	r0, [r6, #0]
    3294:	f008 f923 	bl	b4de <printInt32>
		print( NL );
    3298:	482f      	ldr	r0, [pc, #188]	; (3358 <LED_scan+0x168>)
    329a:	f008 f8b1 	bl	b400 <_print>
	uint8_t inverse_brightness = 0xFF - LED_brightness;
    329e:	4b2f      	ldr	r3, [pc, #188]	; (335c <LED_scan+0x16c>)
    32a0:	4e2f      	ldr	r6, [pc, #188]	; (3360 <LED_scan+0x170>)
    32a2:	7819      	ldrb	r1, [r3, #0]
    32a4:	4f2f      	ldr	r7, [pc, #188]	; (3364 <LED_scan+0x174>)
    32a6:	43c9      	mvns	r1, r1
    32a8:	b2c9      	uxtb	r1, r1
    32aa:	2000      	movs	r0, #0
			if ( LED_pageBuffer[ chip ].buffer[ ch ] == 0 )
    32ac:	f836 3f02 	ldrh.w	r3, [r6, #2]!
    32b0:	0042      	lsls	r2, r0, #1
    32b2:	bb6b      	cbnz	r3, 3310 <LED_scan+0x120>
			LED_pageBuffer_brightness[ chip ].buffer[ ch ] =
    32b4:	443a      	add	r2, r7
    32b6:	3001      	adds	r0, #1
		for ( uint8_t ch = 0; ch < LED_BufferLength; ch++ )
    32b8:	2890      	cmp	r0, #144	; 0x90
			LED_pageBuffer_brightness[ chip ].buffer[ ch ] =
    32ba:	8093      	strh	r3, [r2, #4]
		for ( uint8_t ch = 0; ch < LED_BufferLength; ch++ )
    32bc:	d1f6      	bne.n	32ac <LED_scan+0xbc>
	LED_timePrev = Time_now();
    32be:	ae02      	add	r6, sp, #8
    32c0:	4630      	mov	r0, r6
    32c2:	f7ff fb4d 	bl	2960 <Time_now>
    32c6:	e896 0003 	ldmia.w	r6, {r0, r1}
		LED_setupPage(
    32ca:	2200      	movs	r2, #0
	LED_timePrev = Time_now();
    32cc:	e884 0003 	stmia.w	r4, {r0, r1}
		LED_setupPage(
    32d0:	21e8      	movs	r1, #232	; 0xe8
    32d2:	4610      	mov	r0, r2
    32d4:	f7ff fe24 	bl	2f20 <LED_setupPage>
		while ( i2c_send( bus, (uint16_t*)&LED_ledEnableMask[ ch ], sizeof( LED_EnableBuffer ) / 2 ) == -1 )
    32d8:	4e23      	ldr	r6, [pc, #140]	; (3368 <LED_scan+0x178>)
    32da:	2400      	movs	r4, #0
    32dc:	2300      	movs	r3, #0
    32de:	e9cd 4400 	strd	r4, r4, [sp]
    32e2:	2214      	movs	r2, #20
    32e4:	4631      	mov	r1, r6
    32e6:	4618      	mov	r0, r3
    32e8:	f7ff fc2c 	bl	2b44 <i2c_send_sequence>
    32ec:	3001      	adds	r0, #1
    32ee:	d014      	beq.n	331a <LED_scan+0x12a>
	LED_chipSend = 0; // Start with chip 0
    32f0:	4b1e      	ldr	r3, [pc, #120]	; (336c <LED_scan+0x17c>)
    32f2:	701c      	strb	r4, [r3, #0]
	LED_linkedSend();
    32f4:	f7ff fdac 	bl	2e50 <LED_linkedSend>
    32f8:	e004      	b.n	3304 <LED_scan+0x114>
		GPIOB_PCOR |= (1<<16);
    32fa:	4a1d      	ldr	r2, [pc, #116]	; (3370 <LED_scan+0x180>)
    32fc:	6813      	ldr	r3, [r2, #0]
    32fe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    3302:	6013      	str	r3, [r2, #0]
	Latency_end_time( ledLatencyResource );
    3304:	7828      	ldrb	r0, [r5, #0]
}
    3306:	b006      	add	sp, #24
    3308:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	Latency_end_time( ledLatencyResource );
    330c:	f007 bffe 	b.w	b30c <Latency_end_time>
				LED_pageBuffer[ chip ].buffer[ ch ] - inverse_brightness < 0
    3310:	1a5b      	subs	r3, r3, r1
				: LED_pageBuffer[ chip ].buffer[ ch ] - inverse_brightness;
    3312:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
			LED_pageBuffer_brightness[ chip ].buffer[ ch ] =
    3316:	b29b      	uxth	r3, r3
    3318:	e7cc      	b.n	32b4 <LED_scan+0xc4>
			delay_us( ISSI_SendDelay );
    331a:	2032      	movs	r0, #50	; 0x32
    331c:	f7ff f9c7 	bl	26ae <delay_us>
    3320:	e7dc      	b.n	32dc <LED_scan+0xec>
    3322:	bf00      	nop
    3324:	1fff9164 	.word	0x1fff9164
    3328:	1fff9160 	.word	0x1fff9160
    332c:	1fff9cc4 	.word	0x1fff9cc4
    3330:	1fff9b91 	.word	0x1fff9b91
    3334:	400ff044 	.word	0x400ff044
    3338:	1fffa765 	.word	0x1fffa765
    333c:	1fff9cbc 	.word	0x1fff9cbc
    3340:	1fff9b8c 	.word	0x1fff9b8c
    3344:	1fff9b92 	.word	0x1fff9b92
    3348:	0000b83e 	.word	0x0000b83e
    334c:	0000b859 	.word	0x0000b859
    3350:	0000b85f 	.word	0x0000b85f
    3354:	0000b866 	.word	0x0000b866
    3358:	00010d99 	.word	0x00010d99
    335c:	1fff9cb8 	.word	0x1fff9cb8
    3360:	1fffa8ac 	.word	0x1fffa8ac
    3364:	1fff9b94 	.word	0x1fff9b94
    3368:	0000b816 	.word	0x0000b816
    336c:	1fff9b90 	.word	0x1fff9b90
    3370:	400ff048 	.word	0x400ff048

00003374 <LED_currentChange>:
	LED_currentEvent = current;
    3374:	4b01      	ldr	r3, [pc, #4]	; (337c <LED_currentChange+0x8>)
    3376:	6018      	str	r0, [r3, #0]
}
    3378:	4770      	bx	lr
    337a:	bf00      	nop
    337c:	1fff9160 	.word	0x1fff9160

00003380 <LED_control>:
	switch ( control )
    3380:	2805      	cmp	r0, #5
    3382:	d80d      	bhi.n	33a0 <LED_control+0x20>
    3384:	e8df f000 	tbb	[pc, r0]
    3388:	20190d03 	.word	0x20190d03
    338c:	2623      	.short	0x2623
		LED_enable = 1;
    338e:	4b14      	ldr	r3, [pc, #80]	; (33e0 <LED_control+0x60>)
    3390:	2201      	movs	r2, #1
    3392:	701a      	strb	r2, [r3, #0]
		if ( LED_brightness - arg < 0 )
    3394:	4a13      	ldr	r2, [pc, #76]	; (33e4 <LED_control+0x64>)
    3396:	7813      	ldrb	r3, [r2, #0]
    3398:	1a5b      	subs	r3, r3, r1
    339a:	d500      	bpl.n	339e <LED_control+0x1e>
			LED_brightness = 0;
    339c:	2300      	movs	r3, #0
		LED_enable = !LED_enable;
    339e:	7013      	strb	r3, [r2, #0]
}
    33a0:	4770      	bx	lr
		LED_enable = 1;
    33a2:	4b0f      	ldr	r3, [pc, #60]	; (33e0 <LED_control+0x60>)
    33a4:	2201      	movs	r2, #1
    33a6:	701a      	strb	r2, [r3, #0]
		if ( LED_brightness + arg > 0xFF )
    33a8:	4a0e      	ldr	r2, [pc, #56]	; (33e4 <LED_control+0x64>)
    33aa:	7813      	ldrb	r3, [r2, #0]
    33ac:	4419      	add	r1, r3
    33ae:	29ff      	cmp	r1, #255	; 0xff
    33b0:	dd01      	ble.n	33b6 <LED_control+0x36>
			LED_brightness = 0xFF;
    33b2:	23ff      	movs	r3, #255	; 0xff
    33b4:	e7f3      	b.n	339e <LED_control+0x1e>
			LED_brightness += arg;
    33b6:	7011      	strb	r1, [r2, #0]
    33b8:	4770      	bx	lr
		LED_enable = 1;
    33ba:	4b09      	ldr	r3, [pc, #36]	; (33e0 <LED_control+0x60>)
    33bc:	2201      	movs	r2, #1
    33be:	701a      	strb	r2, [r3, #0]
		LED_brightness = ISSI_Global_Brightness_define;
    33c0:	4b08      	ldr	r3, [pc, #32]	; (33e4 <LED_control+0x64>)
    33c2:	22ff      	movs	r2, #255	; 0xff
		LED_enable = 1;
    33c4:	701a      	strb	r2, [r3, #0]
		return;
    33c6:	4770      	bx	lr
		LED_enable = 0;
    33c8:	4b05      	ldr	r3, [pc, #20]	; (33e0 <LED_control+0x60>)
    33ca:	2200      	movs	r2, #0
    33cc:	e7fa      	b.n	33c4 <LED_control+0x44>
		LED_enable = 1;
    33ce:	4b04      	ldr	r3, [pc, #16]	; (33e0 <LED_control+0x60>)
    33d0:	2201      	movs	r2, #1
    33d2:	e7f7      	b.n	33c4 <LED_control+0x44>
		LED_enable = !LED_enable;
    33d4:	4a02      	ldr	r2, [pc, #8]	; (33e0 <LED_control+0x60>)
    33d6:	7813      	ldrb	r3, [r2, #0]
    33d8:	fab3 f383 	clz	r3, r3
    33dc:	095b      	lsrs	r3, r3, #5
    33de:	e7de      	b.n	339e <LED_control+0x1e>
    33e0:	1fff9cc4 	.word	0x1fff9cc4
    33e4:	1fff9cb8 	.word	0x1fff9cb8

000033e8 <LED_control_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    33e8:	2aff      	cmp	r2, #255	; 0xff
{
    33ea:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if ( stateType == 0xFF && state == 0xFF )
    33ec:	d107      	bne.n	33fe <LED_control_capability+0x16>
    33ee:	29ff      	cmp	r1, #255	; 0xff
    33f0:	d105      	bne.n	33fe <LED_control_capability+0x16>
		print("LED_control_capability(mode,amount)");
    33f2:	4810      	ldr	r0, [pc, #64]	; (3434 <LED_control_capability+0x4c>)
}
    33f4:	b003      	add	sp, #12
    33f6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("LED_control_capability(mode,amount)");
    33fa:	f008 b801 	b.w	b400 <_print>
	if ( state != 0x01 )
    33fe:	2901      	cmp	r1, #1
    3400:	d115      	bne.n	342e <LED_control_capability+0x46>
	uint8_t addr = Connect_id + 1;
    3402:	480d      	ldr	r0, [pc, #52]	; (3438 <LED_control_capability+0x50>)
	LedControl control = (LedControl)args[0];
    3404:	781c      	ldrb	r4, [r3, #0]
	uint8_t arg = (uint8_t)args[1];
    3406:	785d      	ldrb	r5, [r3, #1]
	uint8_t addr = Connect_id + 1;
    3408:	7800      	ldrb	r0, [r0, #0]
	Connect_send_RemoteCapability(
    340a:	9301      	str	r3, [sp, #4]
    340c:	4b0b      	ldr	r3, [pc, #44]	; (343c <LED_control_capability+0x54>)
	uint8_t addr = Connect_id + 1;
    340e:	3001      	adds	r0, #1
	Connect_send_RemoteCapability(
    3410:	7d1b      	ldrb	r3, [r3, #20]
    3412:	9300      	str	r3, [sp, #0]
    3414:	b2c0      	uxtb	r0, r0
    3416:	4613      	mov	r3, r2
    3418:	460a      	mov	r2, r1
    341a:	2102      	movs	r1, #2
    341c:	f001 fbec 	bl	4bf8 <Connect_send_RemoteCapability>
	LED_control( control, arg );
    3420:	4629      	mov	r1, r5
    3422:	4620      	mov	r0, r4
}
    3424:	b003      	add	sp, #12
    3426:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LED_control( control, arg );
    342a:	f7ff bfa9 	b.w	3380 <LED_control>
}
    342e:	b003      	add	sp, #12
    3430:	bd30      	pop	{r4, r5, pc}
    3432:	bf00      	nop
    3434:	0000b7f2 	.word	0x0000b7f2
    3438:	1fff89fc 	.word	0x1fff89fc
    343c:	0000cff0 	.word	0x0000cff0

00003440 <cliFunc_matrixState>:
	info_msg("Matrix Debug Mode: ");
	printInt8( matrixDebugMode );
}

void cliFunc_matrixState( char* args )
{
    3440:	b513      	push	{r0, r1, r4, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3442:	aa01      	add	r2, sp, #4
    3444:	4669      	mov	r1, sp
    3446:	f007 fbd3 	bl	abf0 <CLI_argumentIsolation>

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    344a:	4c06      	ldr	r4, [pc, #24]	; (3464 <cliFunc_matrixState+0x24>)

	if ( arg1Ptr[0] != '\0' )
    344c:	9800      	ldr	r0, [sp, #0]
	matrixDebugStateCounter = 1;
    344e:	2301      	movs	r3, #1
    3450:	8023      	strh	r3, [r4, #0]
	if ( arg1Ptr[0] != '\0' )
    3452:	7803      	ldrb	r3, [r0, #0]
    3454:	b11b      	cbz	r3, 345e <cliFunc_matrixState+0x1e>
	{
		matrixDebugStateCounter = (uint16_t)numToInt( arg1Ptr );
    3456:	f008 f8e6 	bl	b626 <numToInt>
    345a:	b280      	uxth	r0, r0
    345c:	8020      	strh	r0, [r4, #0]
	}
}
    345e:	b002      	add	sp, #8
    3460:	bd10      	pop	{r4, pc}
    3462:	bf00      	nop
    3464:	1fff92d4 	.word	0x1fff92d4

00003468 <cliFunc_debounce>:
{
    3468:	b513      	push	{r0, r1, r4, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    346a:	aa01      	add	r2, sp, #4
    346c:	4669      	mov	r1, sp
    346e:	f007 fbbf 	bl	abf0 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    3472:	9800      	ldr	r0, [sp, #0]
    3474:	4c0a      	ldr	r4, [pc, #40]	; (34a0 <cliFunc_debounce+0x38>)
    3476:	7803      	ldrb	r3, [r0, #0]
    3478:	b11b      	cbz	r3, 3482 <cliFunc_debounce+0x1a>
		debounceExpiryTime = (uint8_t)numToInt( arg1Ptr );
    347a:	f008 f8d4 	bl	b626 <numToInt>
    347e:	b2c0      	uxtb	r0, r0
    3480:	7020      	strb	r0, [r4, #0]
	print( NL );
    3482:	4808      	ldr	r0, [pc, #32]	; (34a4 <cliFunc_debounce+0x3c>)
    3484:	f007 ffbc 	bl	b400 <_print>
	info_msg("Debounce Timer: ");
    3488:	4807      	ldr	r0, [pc, #28]	; (34a8 <cliFunc_debounce+0x40>)
    348a:	f007 ffb9 	bl	b400 <_print>
	printInt8( debounceExpiryTime );
    348e:	7820      	ldrb	r0, [r4, #0]
    3490:	f007 ffe8 	bl	b464 <printInt8>
	print("ms");
    3494:	4805      	ldr	r0, [pc, #20]	; (34ac <cliFunc_debounce+0x44>)
    3496:	f007 ffb3 	bl	b400 <_print>
}
    349a:	b002      	add	sp, #8
    349c:	bd10      	pop	{r4, pc}
    349e:	bf00      	nop
    34a0:	1fff92d0 	.word	0x1fff92d0
    34a4:	00010d99 	.word	0x00010d99
    34a8:	0000bb3c 	.word	0x0000bb3c
    34ac:	0000b8d2 	.word	0x0000b8d2

000034b0 <cliFunc_matrixInfo>:
{
    34b0:	b510      	push	{r4, lr}
	print( NL );
    34b2:	4c0f      	ldr	r4, [pc, #60]	; (34f0 <cliFunc_matrixInfo+0x40>)
    34b4:	4620      	mov	r0, r4
    34b6:	f007 ffa3 	bl	b400 <_print>
	info_msg("Columns:  ");
    34ba:	480e      	ldr	r0, [pc, #56]	; (34f4 <cliFunc_matrixInfo+0x44>)
    34bc:	f007 ffa0 	bl	b400 <_print>
	printInt8( Matrix_colsNum );
    34c0:	2009      	movs	r0, #9
    34c2:	f007 ffcf 	bl	b464 <printInt8>
	print( NL );
    34c6:	4620      	mov	r0, r4
    34c8:	f007 ff9a 	bl	b400 <_print>
	info_msg("Rows:     ");
    34cc:	480a      	ldr	r0, [pc, #40]	; (34f8 <cliFunc_matrixInfo+0x48>)
    34ce:	f007 ff97 	bl	b400 <_print>
	printInt8( Matrix_rowsNum );
    34d2:	2005      	movs	r0, #5
    34d4:	f007 ffc6 	bl	b464 <printInt8>
	print( NL );
    34d8:	4620      	mov	r0, r4
    34da:	f007 ff91 	bl	b400 <_print>
	info_msg("Max Keys: ");
    34de:	4807      	ldr	r0, [pc, #28]	; (34fc <cliFunc_matrixInfo+0x4c>)
    34e0:	f007 ff8e 	bl	b400 <_print>
	printInt8( Matrix_maxKeys );
    34e4:	202d      	movs	r0, #45	; 0x2d
}
    34e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( Matrix_maxKeys );
    34ea:	f007 bfbb 	b.w	b464 <printInt8>
    34ee:	bf00      	nop
    34f0:	00010d99 	.word	0x00010d99
    34f4:	0000bb85 	.word	0x0000bb85
    34f8:	0000bba2 	.word	0x0000bba2
    34fc:	0000bbbf 	.word	0x0000bbbf

00003500 <cliFunc_matrixDebug>:
{
    3500:	b507      	push	{r0, r1, r2, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3502:	aa01      	add	r2, sp, #4
    3504:	4669      	mov	r1, sp
    3506:	f007 fb73 	bl	abf0 <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    350a:	9b00      	ldr	r3, [sp, #0]
    350c:	781b      	ldrb	r3, [r3, #0]
    350e:	2b32      	cmp	r3, #50	; 0x32
    3510:	d012      	beq.n	3538 <cliFunc_matrixDebug+0x38>
    3512:	d805      	bhi.n	3520 <cliFunc_matrixDebug+0x20>
    3514:	b31b      	cbz	r3, 355e <cliFunc_matrixDebug+0x5e>
    3516:	2b31      	cmp	r3, #49	; 0x31
    3518:	d021      	beq.n	355e <cliFunc_matrixDebug+0x5e>
}
    351a:	b003      	add	sp, #12
    351c:	f85d fb04 	ldr.w	pc, [sp], #4
	switch ( arg1Ptr[0] )
    3520:	2b54      	cmp	r3, #84	; 0x54
    3522:	d009      	beq.n	3538 <cliFunc_matrixDebug+0x38>
    3524:	2b74      	cmp	r3, #116	; 0x74
    3526:	d007      	beq.n	3538 <cliFunc_matrixDebug+0x38>
    3528:	2b33      	cmp	r3, #51	; 0x33
    352a:	d1f6      	bne.n	351a <cliFunc_matrixDebug+0x1a>
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    352c:	4b10      	ldr	r3, [pc, #64]	; (3570 <cliFunc_matrixDebug+0x70>)
    352e:	781a      	ldrb	r2, [r3, #0]
    3530:	2a03      	cmp	r2, #3
    3532:	bf18      	it	ne
    3534:	2203      	movne	r2, #3
    3536:	e004      	b.n	3542 <cliFunc_matrixDebug+0x42>
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
    3538:	4b0d      	ldr	r3, [pc, #52]	; (3570 <cliFunc_matrixDebug+0x70>)
    353a:	781a      	ldrb	r2, [r3, #0]
    353c:	2a02      	cmp	r2, #2
    353e:	bf18      	it	ne
    3540:	2202      	movne	r2, #2
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    3542:	bf08      	it	eq
    3544:	2200      	moveq	r2, #0
    3546:	701a      	strb	r2, [r3, #0]
	print( NL );
    3548:	480a      	ldr	r0, [pc, #40]	; (3574 <cliFunc_matrixDebug+0x74>)
    354a:	f007 ff59 	bl	b400 <_print>
	info_msg("Matrix Debug Mode: ");
    354e:	480a      	ldr	r0, [pc, #40]	; (3578 <cliFunc_matrixDebug+0x78>)
    3550:	f007 ff56 	bl	b400 <_print>
	printInt8( matrixDebugMode );
    3554:	4b06      	ldr	r3, [pc, #24]	; (3570 <cliFunc_matrixDebug+0x70>)
    3556:	7818      	ldrb	r0, [r3, #0]
    3558:	f007 ff84 	bl	b464 <printInt8>
    355c:	e7dd      	b.n	351a <cliFunc_matrixDebug+0x1a>
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    355e:	4a04      	ldr	r2, [pc, #16]	; (3570 <cliFunc_matrixDebug+0x70>)
    3560:	7813      	ldrb	r3, [r2, #0]
    3562:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    3566:	bf18      	it	ne
    3568:	2301      	movne	r3, #1
    356a:	7013      	strb	r3, [r2, #0]
		break;
    356c:	e7ec      	b.n	3548 <cliFunc_matrixDebug+0x48>
    356e:	bf00      	nop
    3570:	1fff92d2 	.word	0x1fff92d2
    3574:	00010d99 	.word	0x00010d99
    3578:	0000bb5f 	.word	0x0000bb5f

0000357c <cliFunc_strobeDelay>:

void cliFunc_strobeDelay( char* args )
{
    357c:	b513      	push	{r0, r1, r4, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    357e:	aa01      	add	r2, sp, #4
    3580:	4669      	mov	r1, sp
    3582:	f007 fb35 	bl	abf0 <CLI_argumentIsolation>

	if ( arg1Ptr[0] != '\0' )
    3586:	9800      	ldr	r0, [sp, #0]
    3588:	4c0a      	ldr	r4, [pc, #40]	; (35b4 <cliFunc_strobeDelay+0x38>)
    358a:	7803      	ldrb	r3, [r0, #0]
    358c:	b11b      	cbz	r3, 3596 <cliFunc_strobeDelay+0x1a>
	{
		strobeDelayTime = (uint8_t)numToInt( arg1Ptr );
    358e:	f008 f84a 	bl	b626 <numToInt>
    3592:	b2c0      	uxtb	r0, r0
    3594:	7020      	strb	r0, [r4, #0]
	}

	print( NL );
    3596:	4808      	ldr	r0, [pc, #32]	; (35b8 <cliFunc_strobeDelay+0x3c>)
    3598:	f007 ff32 	bl	b400 <_print>
	info_msg("Strobe Delay: ");
    359c:	4807      	ldr	r0, [pc, #28]	; (35bc <cliFunc_strobeDelay+0x40>)
    359e:	f007 ff2f 	bl	b400 <_print>
	printInt8( strobeDelayTime );
    35a2:	7820      	ldrb	r0, [r4, #0]
    35a4:	f007 ff5e 	bl	b464 <printInt8>
	print("us");
    35a8:	4805      	ldr	r0, [pc, #20]	; (35c0 <cliFunc_strobeDelay+0x44>)
    35aa:	f007 ff29 	bl	b400 <_print>
}
    35ae:	b002      	add	sp, #8
    35b0:	bd10      	pop	{r4, pc}
    35b2:	bf00      	nop
    35b4:	1fff92d7 	.word	0x1fff92d7
    35b8:	00010d99 	.word	0x00010d99
    35bc:	0000bbdc 	.word	0x0000bbdc
    35c0:	0000cc9c 	.word	0x0000cc9c

000035c4 <Matrix_pin>:
{
    35c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    35c6:	b2c3      	uxtb	r3, r0
    35c8:	f8ad 0004 	strh.w	r0, [sp, #4]
    35cc:	f3c0 2007 	ubfx	r0, r0, #8, #8
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
    35d0:	019a      	lsls	r2, r3, #6
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;
    35d2:	eb00 2383 	add.w	r3, r0, r3, lsl #10
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    35d6:	009b      	lsls	r3, r3, #2
    35d8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
    35dc:	4c24      	ldr	r4, [pc, #144]	; (3670 <Matrix_pin+0xac>)
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    35de:	f503 2392 	add.w	r3, r3, #299008	; 0x49000
	switch ( type )
    35e2:	2904      	cmp	r1, #4
    35e4:	d80b      	bhi.n	35fe <Matrix_pin+0x3a>
    35e6:	e8df f001 	tbb	[pc, r1]
    35ea:	0c03      	.short	0x0c03
    35ec:	200e      	.short	0x200e
    35ee:	2b          	.byte	0x2b
    35ef:	00          	.byte	0x00
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
    35f0:	4920      	ldr	r1, [pc, #128]	; (3674 <Matrix_pin+0xb0>)
		*GPIO_PCOR |= (1 << gpio.pin);
    35f2:	5854      	ldr	r4, [r2, r1]
    35f4:	2301      	movs	r3, #1
    35f6:	fa03 f000 	lsl.w	r0, r3, r0
    35fa:	4320      	orrs	r0, r4
    35fc:	5050      	str	r0, [r2, r1]
	return 0;
    35fe:	2000      	movs	r0, #0
			break;
    3600:	e01c      	b.n	363c <Matrix_pin+0x78>
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
    3602:	491d      	ldr	r1, [pc, #116]	; (3678 <Matrix_pin+0xb4>)
    3604:	e7f5      	b.n	35f2 <Matrix_pin+0x2e>
		*GPIO_PDDR |= (1 << gpio.pin);
    3606:	5915      	ldr	r5, [r2, r4]
    3608:	2101      	movs	r1, #1
    360a:	fa01 f000 	lsl.w	r0, r1, r0
    360e:	4328      	orrs	r0, r5
    3610:	5110      	str	r0, [r2, r4]
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    3612:	f44f 72a2 	mov.w	r2, #324	; 0x144
    3616:	601a      	str	r2, [r3, #0]
		switch ( Matrix_type )
    3618:	4a18      	ldr	r2, [pc, #96]	; (367c <Matrix_pin+0xb8>)
    361a:	7812      	ldrb	r2, [r2, #0]
    361c:	2a02      	cmp	r2, #2
    361e:	d1ee      	bne.n	35fe <Matrix_pin+0x3a>
			*PORT_PCR |= PORT_PCR_ODE;
    3620:	681a      	ldr	r2, [r3, #0]
    3622:	f042 0220 	orr.w	r2, r2, #32
			*PORT_PCR |= PORT_PCR_PE;
    3626:	601a      	str	r2, [r3, #0]
    3628:	e7e9      	b.n	35fe <Matrix_pin+0x3a>
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
    362a:	4b15      	ldr	r3, [pc, #84]	; (3680 <Matrix_pin+0xbc>)
		return *GPIO_PDIR & (1 << gpio.pin) ? 1 : 0;
    362c:	58d2      	ldr	r2, [r2, r3]
    362e:	2301      	movs	r3, #1
    3630:	fa03 f000 	lsl.w	r0, r3, r0
    3634:	4210      	tst	r0, r2
    3636:	bf14      	ite	ne
    3638:	4618      	movne	r0, r3
    363a:	2000      	moveq	r0, #0
}
    363c:	b003      	add	sp, #12
    363e:	bd30      	pop	{r4, r5, pc}
		*GPIO_PDDR &= ~(1 << gpio.pin);
    3640:	5911      	ldr	r1, [r2, r4]
    3642:	2501      	movs	r5, #1
    3644:	fa05 f000 	lsl.w	r0, r5, r0
    3648:	ea21 0000 	bic.w	r0, r1, r0
    364c:	5110      	str	r0, [r2, r4]
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    364e:	f44f 7288 	mov.w	r2, #272	; 0x110
    3652:	601a      	str	r2, [r3, #0]
		switch ( Matrix_type )
    3654:	4a09      	ldr	r2, [pc, #36]	; (367c <Matrix_pin+0xb8>)
    3656:	7810      	ldrb	r0, [r2, #0]
    3658:	b128      	cbz	r0, 3666 <Matrix_pin+0xa2>
    365a:	42a8      	cmp	r0, r5
    365c:	d1cf      	bne.n	35fe <Matrix_pin+0x3a>
			*PORT_PCR |= PORT_PCR_PE;
    365e:	681a      	ldr	r2, [r3, #0]
    3660:	f042 0202 	orr.w	r2, r2, #2
    3664:	e7df      	b.n	3626 <Matrix_pin+0x62>
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
    3666:	681a      	ldr	r2, [r3, #0]
    3668:	f042 0203 	orr.w	r2, r2, #3
    366c:	601a      	str	r2, [r3, #0]
			break;
    366e:	e7e5      	b.n	363c <Matrix_pin+0x78>
    3670:	400ff014 	.word	0x400ff014
    3674:	400ff004 	.word	0x400ff004
    3678:	400ff008 	.word	0x400ff008
    367c:	1fff89f8 	.word	0x1fff89f8
    3680:	400ff010 	.word	0x400ff010

00003684 <Matrix_setup>:
{
    3684:	b538      	push	{r3, r4, r5, lr}
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    3686:	4921      	ldr	r1, [pc, #132]	; (370c <Matrix_setup+0x88>)
    3688:	4821      	ldr	r0, [pc, #132]	; (3710 <Matrix_setup+0x8c>)
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
    368a:	4d22      	ldr	r5, [pc, #136]	; (3714 <Matrix_setup+0x90>)
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    368c:	f007 fb4a 	bl	ad24 <CLI_registerDictionary>
    3690:	2400      	movs	r4, #0
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
    3692:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    3696:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    369a:	7850      	ldrb	r0, [r2, #1]
    369c:	2102      	movs	r1, #2
    369e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    36a2:	3401      	adds	r4, #1
    36a4:	f7ff ff8e 	bl	35c4 <Matrix_pin>
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
    36a8:	2c09      	cmp	r4, #9
    36aa:	d1f2      	bne.n	3692 <Matrix_setup+0xe>
		Matrix_pin( Matrix_rows[ pin ], Type_SenseSetup );
    36ac:	4d1a      	ldr	r5, [pc, #104]	; (3718 <Matrix_setup+0x94>)
    36ae:	2400      	movs	r4, #0
    36b0:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    36b4:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    36b8:	7850      	ldrb	r0, [r2, #1]
    36ba:	2104      	movs	r1, #4
    36bc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    36c0:	3401      	adds	r4, #1
    36c2:	f7ff ff7f 	bl	35c4 <Matrix_pin>
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
    36c6:	2c05      	cmp	r4, #5
    36c8:	d1f2      	bne.n	36b0 <Matrix_setup+0x2c>
    36ca:	2200      	movs	r2, #0
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    36cc:	4813      	ldr	r0, [pc, #76]	; (371c <Matrix_setup+0x98>)
    36ce:	4613      	mov	r3, r2
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    36d0:	24ff      	movs	r4, #255	; 0xff
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    36d2:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
    36d6:	708b      	strb	r3, [r1, #2]
		Matrix_scanArray[ item ].curState         = KeyState_Off;
    36d8:	70cb      	strb	r3, [r1, #3]
		Matrix_scanArray[ item ].activeCount      = 0;
    36da:	f800 3032 	strb.w	r3, [r0, r2, lsl #3]
    36de:	3201      	adds	r2, #1
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    36e0:	2a2d      	cmp	r2, #45	; 0x2d
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    36e2:	704c      	strb	r4, [r1, #1]
		Matrix_scanArray[ item ].prevDecisionTime = 0;
    36e4:	604b      	str	r3, [r1, #4]
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    36e6:	d1f4      	bne.n	36d2 <Matrix_setup+0x4e>
	matrixCurrentStrobe = 0;
    36e8:	4a0d      	ldr	r2, [pc, #52]	; (3720 <Matrix_setup+0x9c>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    36ea:	480e      	ldr	r0, [pc, #56]	; (3724 <Matrix_setup+0xa0>)
	matrixCurrentStrobe = 0;
    36ec:	7013      	strb	r3, [r2, #0]
	matrixDebugMode = 0;
    36ee:	4a0e      	ldr	r2, [pc, #56]	; (3728 <Matrix_setup+0xa4>)
    36f0:	7013      	strb	r3, [r2, #0]
	matrixDebugStateCounter = 0;
    36f2:	4a0e      	ldr	r2, [pc, #56]	; (372c <Matrix_setup+0xa8>)
    36f4:	8013      	strh	r3, [r2, #0]
	debounceExpiryTime = MinDebounceTime_define;
    36f6:	4a0e      	ldr	r2, [pc, #56]	; (3730 <Matrix_setup+0xac>)
    36f8:	2105      	movs	r1, #5
    36fa:	7011      	strb	r1, [r2, #0]
	strobeDelayTime = StrobeDelay_define;
    36fc:	4a0d      	ldr	r2, [pc, #52]	; (3734 <Matrix_setup+0xb0>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    36fe:	2100      	movs	r1, #0
	strobeDelayTime = StrobeDelay_define;
    3700:	7013      	strb	r3, [r2, #0]
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    3702:	f007 fda1 	bl	b248 <Latency_add_resource>
    3706:	4b0c      	ldr	r3, [pc, #48]	; (3738 <Matrix_setup+0xb4>)
    3708:	7018      	strb	r0, [r3, #0]
}
    370a:	bd38      	pop	{r3, r4, r5, pc}
    370c:	0000bc80 	.word	0x0000bc80
    3710:	0000bc38 	.word	0x0000bc38
    3714:	1fff89dc 	.word	0x1fff89dc
    3718:	1fff89ee 	.word	0x1fff89ee
    371c:	1fff9168 	.word	0x1fff9168
    3720:	1fff92d1 	.word	0x1fff92d1
    3724:	0000ba95 	.word	0x0000ba95
    3728:	1fff92d2 	.word	0x1fff92d2
    372c:	1fff92d4 	.word	0x1fff92d4
    3730:	1fff92d0 	.word	0x1fff92d0
    3734:	1fff92d7 	.word	0x1fff92d7
    3738:	1fff92d6 	.word	0x1fff92d6

0000373c <Matrix_keyPositionDebug>:
	switch ( pos )
    373c:	2803      	cmp	r0, #3
    373e:	d80c      	bhi.n	375a <Matrix_keyPositionDebug+0x1e>
    3740:	e8df f000 	tbb	[pc, r0]
    3744:	09070502 	.word	0x09070502
		print("\033[1mO\033[0m");
    3748:	4805      	ldr	r0, [pc, #20]	; (3760 <Matrix_keyPositionDebug+0x24>)
		print("\033[1;31mI\033[0m");
    374a:	f007 be59 	b.w	b400 <_print>
		print("\033[1;33mP\033[0m");
    374e:	4805      	ldr	r0, [pc, #20]	; (3764 <Matrix_keyPositionDebug+0x28>)
    3750:	e7fb      	b.n	374a <Matrix_keyPositionDebug+0xe>
		print("\033[1;32mH\033[0m");
    3752:	4805      	ldr	r0, [pc, #20]	; (3768 <Matrix_keyPositionDebug+0x2c>)
    3754:	e7f9      	b.n	374a <Matrix_keyPositionDebug+0xe>
		print("\033[1;35mR\033[0m");
    3756:	4805      	ldr	r0, [pc, #20]	; (376c <Matrix_keyPositionDebug+0x30>)
    3758:	e7f7      	b.n	374a <Matrix_keyPositionDebug+0xe>
		print("\033[1;31mI\033[0m");
    375a:	4805      	ldr	r0, [pc, #20]	; (3770 <Matrix_keyPositionDebug+0x34>)
    375c:	e7f5      	b.n	374a <Matrix_keyPositionDebug+0xe>
    375e:	bf00      	nop
    3760:	0000ba57 	.word	0x0000ba57
    3764:	0000ba61 	.word	0x0000ba61
    3768:	0000ba6e 	.word	0x0000ba6e
    376c:	0000ba7b 	.word	0x0000ba7b
    3770:	0000ba88 	.word	0x0000ba88

00003774 <Matrix_single_scan>:
{
    3774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	Latency_start_time( matrixLatencyResource );
    3778:	4ead      	ldr	r6, [pc, #692]	; (3a30 <Matrix_single_scan+0x2bc>)
	uint8_t strobe = matrixCurrentStrobe;
    377a:	4dae      	ldr	r5, [pc, #696]	; (3a34 <Matrix_single_scan+0x2c0>)
	Latency_start_time( matrixLatencyResource );
    377c:	7830      	ldrb	r0, [r6, #0]
	Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );
    377e:	4cae      	ldr	r4, [pc, #696]	; (3a38 <Matrix_single_scan+0x2c4>)
{
    3780:	b087      	sub	sp, #28
	Latency_start_time( matrixLatencyResource );
    3782:	f007 fdb1 	bl	b2e8 <Latency_start_time>
	uint32_t currentTime = systick_millis_count;
    3786:	4bad      	ldr	r3, [pc, #692]	; (3a3c <Matrix_single_scan+0x2c8>)
    3788:	681b      	ldr	r3, [r3, #0]
	uint8_t strobe = matrixCurrentStrobe;
    378a:	782f      	ldrb	r7, [r5, #0]
	uint32_t currentTime = systick_millis_count;
    378c:	9301      	str	r3, [sp, #4]
	uint8_t strobe = matrixCurrentStrobe;
    378e:	b2ff      	uxtb	r7, r7
	Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );
    3790:	007a      	lsls	r2, r7, #1
    3792:	f814 3017 	ldrb.w	r3, [r4, r7, lsl #1]
    3796:	9203      	str	r2, [sp, #12]
    3798:	18a2      	adds	r2, r4, r2
    379a:	2100      	movs	r1, #0
    379c:	7850      	ldrb	r0, [r2, #1]
    379e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    37a2:	f7ff ff0f 	bl	35c4 <Matrix_pin>
	if ( strobeDelayTime > 0 )
    37a6:	4ba6      	ldr	r3, [pc, #664]	; (3a40 <Matrix_single_scan+0x2cc>)
    37a8:	9604      	str	r6, [sp, #16]
    37aa:	781a      	ldrb	r2, [r3, #0]
    37ac:	9402      	str	r4, [sp, #8]
    37ae:	46a8      	mov	r8, r5
    37b0:	b112      	cbz	r2, 37b8 <Matrix_single_scan+0x44>
		delay_us( strobeDelayTime );
    37b2:	7818      	ldrb	r0, [r3, #0]
    37b4:	f7fe ff7b 	bl	26ae <delay_us>
    37b8:	b2bb      	uxth	r3, r7
    37ba:	4ca2      	ldr	r4, [pc, #648]	; (3a44 <Matrix_single_scan+0x2d0>)
    37bc:	9300      	str	r3, [sp, #0]
    37be:	1c5d      	adds	r5, r3, #1
{
    37c0:	2600      	movs	r6, #0
		if ( key_disp > MaxScanCode_KLL )
    37c2:	2d5a      	cmp	r5, #90	; 0x5a
		uint16_t key = Matrix_colsNum * sense + strobe;
    37c4:	fa1f fb86 	uxth.w	fp, r6
		if ( key_disp > MaxScanCode_KLL )
    37c8:	d87b      	bhi.n	38c2 <Matrix_single_scan+0x14e>
    37ca:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
    37ce:	eb03 0a07 	add.w	sl, r3, r7
		if ( Matrix_pin( Matrix_rows[ sense ], Type_Sense ) )
    37d2:	4b9d      	ldr	r3, [pc, #628]	; (3a48 <Matrix_single_scan+0x2d4>)
    37d4:	eb03 0146 	add.w	r1, r3, r6, lsl #1
    37d8:	f813 2016 	ldrb.w	r2, [r3, r6, lsl #1]
    37dc:	7848      	ldrb	r0, [r1, #1]
    37de:	2103      	movs	r1, #3
    37e0:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    37e4:	f7ff feee 	bl	35c4 <Matrix_pin>
    37e8:	b300      	cbz	r0, 382c <Matrix_single_scan+0xb8>
			if ( state->activeCount < DebounceDivThreshold ) state->activeCount += 1;
    37ea:	f814 203a 	ldrb.w	r2, [r4, sl, lsl #3]
    37ee:	2aff      	cmp	r2, #255	; 0xff
    37f0:	bf1f      	itttt	ne
    37f2:	f814 203a 	ldrbne.w	r2, [r4, sl, lsl #3]
    37f6:	3201      	addne	r2, #1
    37f8:	b2d2      	uxtbne	r2, r2
    37fa:	f804 203a 	strbne.w	r2, [r4, sl, lsl #3]
			state->inactiveCount >>= 1;
    37fe:	eb04 01ca 	add.w	r1, r4, sl, lsl #3
    3802:	784a      	ldrb	r2, [r1, #1]
    3804:	0852      	lsrs	r2, r2, #1
    3806:	704a      	strb	r2, [r1, #1]
		state->prevState = state->curState;
    3808:	ea4f 02ca 	mov.w	r2, sl, lsl #3
    380c:	18a1      	adds	r1, r4, r2
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    380e:	9b01      	ldr	r3, [sp, #4]
		state->prevState = state->curState;
    3810:	78c8      	ldrb	r0, [r1, #3]
    3812:	b2c0      	uxtb	r0, r0
    3814:	7088      	strb	r0, [r1, #2]
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    3816:	6848      	ldr	r0, [r1, #4]
		switch ( state->prevState )
    3818:	7889      	ldrb	r1, [r1, #2]
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    381a:	eba3 0900 	sub.w	r9, r3, r0
		switch ( state->prevState )
    381e:	2903      	cmp	r1, #3
    3820:	f200 80d6 	bhi.w	39d0 <Matrix_single_scan+0x25c>
    3824:	e8df f001 	tbb	[pc, r1]
    3828:	c51111c5 	.word	0xc51111c5
			if ( state->inactiveCount < DebounceDivThreshold ) state->inactiveCount += 1;
    382c:	eb04 01ca 	add.w	r1, r4, sl, lsl #3
    3830:	784a      	ldrb	r2, [r1, #1]
    3832:	2aff      	cmp	r2, #255	; 0xff
    3834:	bf1f      	itttt	ne
    3836:	784a      	ldrbne	r2, [r1, #1]
    3838:	3201      	addne	r2, #1
    383a:	b2d2      	uxtbne	r2, r2
    383c:	704a      	strbne	r2, [r1, #1]
			state->activeCount >>= 1;
    383e:	f814 203a 	ldrb.w	r2, [r4, sl, lsl #3]
    3842:	0852      	lsrs	r2, r2, #1
    3844:	f804 203a 	strb.w	r2, [r4, sl, lsl #3]
    3848:	e7de      	b.n	3808 <Matrix_single_scan+0x94>
			if ( state->activeCount > state->inactiveCount )
    384a:	4422      	add	r2, r4
    384c:	f814 003a 	ldrb.w	r0, [r4, sl, lsl #3]
    3850:	7851      	ldrb	r1, [r2, #1]
    3852:	4288      	cmp	r0, r1
    3854:	d92e      	bls.n	38b4 <Matrix_single_scan+0x140>
				state->curState = KeyState_Hold;
    3856:	2102      	movs	r1, #2
				state->curState = KeyState_Press;
    3858:	70d1      	strb	r1, [r2, #3]
		state->prevDecisionTime = currentTime;
    385a:	eb04 0bca 	add.w	fp, r4, sl, lsl #3
    385e:	9b01      	ldr	r3, [sp, #4]
    3860:	f8cb 3004 	str.w	r3, [fp, #4]
		Macro_keyState( key_disp, state->curState );
    3864:	f89b 1003 	ldrb.w	r1, [fp, #3]
    3868:	4628      	mov	r0, r5
    386a:	f002 faad 	bl	5dc8 <Macro_keyState>
		if ( matrixDebugMode && state->curState != state->prevState )
    386e:	4a77      	ldr	r2, [pc, #476]	; (3a4c <Matrix_single_scan+0x2d8>)
    3870:	7811      	ldrb	r1, [r2, #0]
    3872:	b331      	cbz	r1, 38c2 <Matrix_single_scan+0x14e>
    3874:	f89b 0003 	ldrb.w	r0, [fp, #3]
    3878:	f89b 1002 	ldrb.w	r1, [fp, #2]
    387c:	4288      	cmp	r0, r1
    387e:	d020      	beq.n	38c2 <Matrix_single_scan+0x14e>
			if ( matrixDebugMode == 1 && state->curState == KeyState_Press )
    3880:	7812      	ldrb	r2, [r2, #0]
    3882:	2a01      	cmp	r2, #1
    3884:	f040 80c7 	bne.w	3a16 <Matrix_single_scan+0x2a2>
    3888:	f89b b003 	ldrb.w	fp, [fp, #3]
    388c:	fa5f fb8b 	uxtb.w	fp, fp
    3890:	f1bb 0f01 	cmp.w	fp, #1
    3894:	f040 80bf 	bne.w	3a16 <Matrix_single_scan+0x2a2>
				printInt16( key_disp );
    3898:	4628      	mov	r0, r5
    389a:	f007 fe01 	bl	b4a0 <printInt16>
				print(":");
    389e:	486c      	ldr	r0, [pc, #432]	; (3a50 <Matrix_single_scan+0x2dc>)
    38a0:	f007 fdae 	bl	b400 <_print>
				printHex( key_disp );
    38a4:	4659      	mov	r1, fp
    38a6:	4628      	mov	r0, r5
    38a8:	f007 fe52 	bl	b550 <printHex_op>
				print(" ");
    38ac:	4869      	ldr	r0, [pc, #420]	; (3a54 <Matrix_single_scan+0x2e0>)
				print( NL );
    38ae:	f007 fda7 	bl	b400 <_print>
    38b2:	e006      	b.n	38c2 <Matrix_single_scan+0x14e>
				if ( lastTransition < debounceExpiryTime )
    38b4:	4968      	ldr	r1, [pc, #416]	; (3a58 <Matrix_single_scan+0x2e4>)
    38b6:	7809      	ldrb	r1, [r1, #0]
    38b8:	4549      	cmp	r1, r9
    38ba:	d978      	bls.n	39ae <Matrix_single_scan+0x23a>
					state->curState = state->prevState;
    38bc:	7893      	ldrb	r3, [r2, #2]
    38be:	b2db      	uxtb	r3, r3
    38c0:	70d3      	strb	r3, [r2, #3]
    38c2:	3601      	adds	r6, #1
    38c4:	3509      	adds	r5, #9
	for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    38c6:	2e05      	cmp	r6, #5
    38c8:	b2ad      	uxth	r5, r5
    38ca:	f47f af7a 	bne.w	37c2 <Matrix_single_scan+0x4e>
	Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOff );
    38ce:	9b02      	ldr	r3, [sp, #8]
    38d0:	f813 2017 	ldrb.w	r2, [r3, r7, lsl #1]
    38d4:	e9dd 1302 	ldrd	r1, r3, [sp, #8]
    38d8:	440b      	add	r3, r1
    38da:	2101      	movs	r1, #1
    38dc:	7858      	ldrb	r0, [r3, #1]
    38de:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    38e2:	f7ff fe6f 	bl	35c4 <Matrix_pin>
	Latency_end_time( matrixLatencyResource );
    38e6:	9b04      	ldr	r3, [sp, #16]
    38e8:	7818      	ldrb	r0, [r3, #0]
    38ea:	f007 fd0f 	bl	b30c <Latency_end_time>
	if ( matrixDebugStateCounter > 0 )
    38ee:	4a5b      	ldr	r2, [pc, #364]	; (3a5c <Matrix_single_scan+0x2e8>)
    38f0:	8813      	ldrh	r3, [r2, #0]
    38f2:	b29b      	uxth	r3, r3
    38f4:	2b00      	cmp	r3, #0
    38f6:	d04b      	beq.n	3990 <Matrix_single_scan+0x21c>
		matrixDebugStateCounter--;
    38f8:	8813      	ldrh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    38fa:	4859      	ldr	r0, [pc, #356]	; (3a60 <Matrix_single_scan+0x2ec>)
				print( NL );
    38fc:	4f59      	ldr	r7, [pc, #356]	; (3a64 <Matrix_single_scan+0x2f0>)
			print("\033[1m");
    38fe:	4e5a      	ldr	r6, [pc, #360]	; (3a68 <Matrix_single_scan+0x2f4>)
			print(" 0x");
    3900:	4d5a      	ldr	r5, [pc, #360]	; (3a6c <Matrix_single_scan+0x2f8>)
		matrixDebugStateCounter--;
    3902:	3b01      	subs	r3, #1
    3904:	b29b      	uxth	r3, r3
    3906:	8013      	strh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    3908:	f007 fd7a 	bl	b400 <_print>
    390c:	2400      	movs	r4, #0
			if ( key % 5 == 0 )
    390e:	b2e2      	uxtb	r2, r4
    3910:	2305      	movs	r3, #5
    3912:	fbb2 f3f3 	udiv	r3, r2, r3
    3916:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    391a:	1ad3      	subs	r3, r2, r3
    391c:	f013 0fff 	tst.w	r3, #255	; 0xff
    3920:	d102      	bne.n	3928 <Matrix_single_scan+0x1b4>
				print( NL );
    3922:	4638      	mov	r0, r7
    3924:	f007 fd6c 	bl	b400 <_print>
			print("\033[1m");
    3928:	4630      	mov	r0, r6
			printInt16( key + 1 );
    392a:	f104 0a01 	add.w	sl, r4, #1
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    392e:	f8df b114 	ldr.w	fp, [pc, #276]	; 3a44 <Matrix_single_scan+0x2d0>
			print("\033[1m");
    3932:	f007 fd65 	bl	b400 <_print>
			printInt16( key + 1 );
    3936:	fa1f f08a 	uxth.w	r0, sl
    393a:	f007 fdb1 	bl	b4a0 <printInt16>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    393e:	eb0b 09c4 	add.w	r9, fp, r4, lsl #3
			print("\033[0m");
    3942:	484b      	ldr	r0, [pc, #300]	; (3a70 <Matrix_single_scan+0x2fc>)
    3944:	f007 fd5c 	bl	b400 <_print>
			print(":");
    3948:	4841      	ldr	r0, [pc, #260]	; (3a50 <Matrix_single_scan+0x2dc>)
    394a:	f007 fd59 	bl	b400 <_print>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    394e:	f899 0002 	ldrb.w	r0, [r9, #2]
    3952:	f7ff fef3 	bl	373c <Matrix_keyPositionDebug>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    3956:	f899 0003 	ldrb.w	r0, [r9, #3]
    395a:	f7ff feef 	bl	373c <Matrix_keyPositionDebug>
			print(" 0x");
    395e:	4628      	mov	r0, r5
    3960:	f007 fd4e 	bl	b400 <_print>
			printHex_op( Matrix_scanArray[ key ].activeCount, 2 );
    3964:	f81b 0034 	ldrb.w	r0, [fp, r4, lsl #3]
    3968:	2102      	movs	r1, #2
    396a:	f007 fdf1 	bl	b550 <printHex_op>
			print(" 0x");
    396e:	4628      	mov	r0, r5
    3970:	f007 fd46 	bl	b400 <_print>
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 2 );
    3974:	f899 0001 	ldrb.w	r0, [r9, #1]
    3978:	2102      	movs	r1, #2
    397a:	f007 fde9 	bl	b550 <printHex_op>
    397e:	4654      	mov	r4, sl
			print(" ");
    3980:	4834      	ldr	r0, [pc, #208]	; (3a54 <Matrix_single_scan+0x2e0>)
    3982:	f007 fd3d 	bl	b400 <_print>
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
    3986:	2c2d      	cmp	r4, #45	; 0x2d
    3988:	d1c1      	bne.n	390e <Matrix_single_scan+0x19a>
		print( NL );
    398a:	4836      	ldr	r0, [pc, #216]	; (3a64 <Matrix_single_scan+0x2f0>)
    398c:	f007 fd38 	bl	b400 <_print>
	if ( ++matrixCurrentStrobe >= Matrix_colsNum )
    3990:	f898 3000 	ldrb.w	r3, [r8]
    3994:	3301      	adds	r3, #1
    3996:	b2db      	uxtb	r3, r3
    3998:	2000      	movs	r0, #0
    399a:	2b08      	cmp	r3, #8
    399c:	f888 3000 	strb.w	r3, [r8]
		matrixCurrentStrobe = 0;
    39a0:	bf84      	itt	hi
    39a2:	f888 0000 	strbhi.w	r0, [r8]
		return 1;
    39a6:	2001      	movhi	r0, #1
}
    39a8:	b007      	add	sp, #28
    39aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				state->curState = KeyState_Release;
    39ae:	2103      	movs	r1, #3
    39b0:	e752      	b.n	3858 <Matrix_single_scan+0xe4>
			if ( state->activeCount > state->inactiveCount )
    39b2:	4422      	add	r2, r4
    39b4:	f814 003a 	ldrb.w	r0, [r4, sl, lsl #3]
    39b8:	7851      	ldrb	r1, [r2, #1]
    39ba:	4288      	cmp	r0, r1
    39bc:	d906      	bls.n	39cc <Matrix_single_scan+0x258>
				if ( lastTransition < debounceExpiryTime )
    39be:	4926      	ldr	r1, [pc, #152]	; (3a58 <Matrix_single_scan+0x2e4>)
    39c0:	7809      	ldrb	r1, [r1, #0]
    39c2:	4549      	cmp	r1, r9
    39c4:	f63f af7a 	bhi.w	38bc <Matrix_single_scan+0x148>
				state->curState = KeyState_Press;
    39c8:	2101      	movs	r1, #1
    39ca:	e745      	b.n	3858 <Matrix_single_scan+0xe4>
				state->curState = KeyState_Off;
    39cc:	2100      	movs	r1, #0
    39ce:	e743      	b.n	3858 <Matrix_single_scan+0xe4>
			erro_msg("Matrix scan bug!! Report me! - ");
    39d0:	4828      	ldr	r0, [pc, #160]	; (3a74 <Matrix_single_scan+0x300>)
    39d2:	9205      	str	r2, [sp, #20]
    39d4:	f007 fd14 	bl	b400 <_print>
			printHex( state->prevState );
    39d8:	9a05      	ldr	r2, [sp, #20]
    39da:	4422      	add	r2, r4
    39dc:	2101      	movs	r1, #1
    39de:	7890      	ldrb	r0, [r2, #2]
    39e0:	f007 fdb6 	bl	b550 <printHex_op>
			print(" Col: ");
    39e4:	4824      	ldr	r0, [pc, #144]	; (3a78 <Matrix_single_scan+0x304>)
    39e6:	f007 fd0b 	bl	b400 <_print>
			printHex( strobe );
    39ea:	2101      	movs	r1, #1
    39ec:	9800      	ldr	r0, [sp, #0]
    39ee:	f007 fdaf 	bl	b550 <printHex_op>
			print(" Row: ");
    39f2:	4822      	ldr	r0, [pc, #136]	; (3a7c <Matrix_single_scan+0x308>)
    39f4:	f007 fd04 	bl	b400 <_print>
			printHex( sense );
    39f8:	2101      	movs	r1, #1
    39fa:	4658      	mov	r0, fp
    39fc:	f007 fda8 	bl	b550 <printHex_op>
			print(" Key: ");
    3a00:	481f      	ldr	r0, [pc, #124]	; (3a80 <Matrix_single_scan+0x30c>)
    3a02:	f007 fcfd 	bl	b400 <_print>
			printHex( key_disp );
    3a06:	4628      	mov	r0, r5
    3a08:	2101      	movs	r1, #1
    3a0a:	f007 fda1 	bl	b550 <printHex_op>
			print( NL );
    3a0e:	4815      	ldr	r0, [pc, #84]	; (3a64 <Matrix_single_scan+0x2f0>)
    3a10:	f007 fcf6 	bl	b400 <_print>
			break;
    3a14:	e721      	b.n	385a <Matrix_single_scan+0xe6>
			else if ( matrixDebugMode == 2 )
    3a16:	4a0d      	ldr	r2, [pc, #52]	; (3a4c <Matrix_single_scan+0x2d8>)
    3a18:	7811      	ldrb	r1, [r2, #0]
    3a1a:	2902      	cmp	r1, #2
    3a1c:	d132      	bne.n	3a84 <Matrix_single_scan+0x310>
				printInt16( key_disp );
    3a1e:	4628      	mov	r0, r5
    3a20:	f007 fd3e 	bl	b4a0 <printInt16>
				Matrix_keyPositionDebug( state->curState );
    3a24:	eb04 03ca 	add.w	r3, r4, sl, lsl #3
    3a28:	78d8      	ldrb	r0, [r3, #3]
    3a2a:	f7ff fe87 	bl	373c <Matrix_keyPositionDebug>
    3a2e:	e73d      	b.n	38ac <Matrix_single_scan+0x138>
    3a30:	1fff92d6 	.word	0x1fff92d6
    3a34:	1fff92d1 	.word	0x1fff92d1
    3a38:	1fff89dc 	.word	0x1fff89dc
    3a3c:	1fff9158 	.word	0x1fff9158
    3a40:	1fff92d7 	.word	0x1fff92d7
    3a44:	1fff9168 	.word	0x1fff9168
    3a48:	1fff89ee 	.word	0x1fff89ee
    3a4c:	1fff92d2 	.word	0x1fff92d2
    3a50:	0000f857 	.word	0x0000f857
    3a54:	00011f77 	.word	0x00011f77
    3a58:	1fff92d0 	.word	0x1fff92d0
    3a5c:	1fff92d4 	.word	0x1fff92d4
    3a60:	0000baf6 	.word	0x0000baf6
    3a64:	00010d99 	.word	0x00010d99
    3a68:	0000baed 	.word	0x0000baed
    3a6c:	0000baf2 	.word	0x0000baf2
    3a70:	0000de76 	.word	0x0000de76
    3a74:	0000baa3 	.word	0x0000baa3
    3a78:	0000bad8 	.word	0x0000bad8
    3a7c:	0000badf 	.word	0x0000badf
    3a80:	0000bae6 	.word	0x0000bae6
			else if ( matrixDebugMode == 3 )
    3a84:	7812      	ldrb	r2, [r2, #0]
    3a86:	2a03      	cmp	r2, #3
    3a88:	f47f af1b 	bne.w	38c2 <Matrix_single_scan+0x14e>
				print("\033[1m");
    3a8c:	4816      	ldr	r0, [pc, #88]	; (3ae8 <Matrix_single_scan+0x374>)
    3a8e:	f007 fcb7 	bl	b400 <_print>
				printInt16( key_disp );
    3a92:	4628      	mov	r0, r5
    3a94:	f007 fd04 	bl	b4a0 <printInt16>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    3a98:	eb04 0bca 	add.w	fp, r4, sl, lsl #3
				print("\033[0m");
    3a9c:	4813      	ldr	r0, [pc, #76]	; (3aec <Matrix_single_scan+0x378>)
    3a9e:	f007 fcaf 	bl	b400 <_print>
				print(":");
    3aa2:	4813      	ldr	r0, [pc, #76]	; (3af0 <Matrix_single_scan+0x37c>)
    3aa4:	f007 fcac 	bl	b400 <_print>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    3aa8:	f89b 0002 	ldrb.w	r0, [fp, #2]
    3aac:	f7ff fe46 	bl	373c <Matrix_keyPositionDebug>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    3ab0:	f89b 0003 	ldrb.w	r0, [fp, #3]
    3ab4:	f7ff fe42 	bl	373c <Matrix_keyPositionDebug>
				print(" 0x");
    3ab8:	480e      	ldr	r0, [pc, #56]	; (3af4 <Matrix_single_scan+0x380>)
    3aba:	f007 fca1 	bl	b400 <_print>
				printHex_op( state->activeCount, 2 );
    3abe:	2102      	movs	r1, #2
    3ac0:	f814 003a 	ldrb.w	r0, [r4, sl, lsl #3]
    3ac4:	f007 fd44 	bl	b550 <printHex_op>
				print(" 0x");
    3ac8:	480a      	ldr	r0, [pc, #40]	; (3af4 <Matrix_single_scan+0x380>)
    3aca:	f007 fc99 	bl	b400 <_print>
				printHex_op( state->inactiveCount, 2 );
    3ace:	2102      	movs	r1, #2
    3ad0:	f89b 0001 	ldrb.w	r0, [fp, #1]
    3ad4:	f007 fd3c 	bl	b550 <printHex_op>
				print(" ");
    3ad8:	4807      	ldr	r0, [pc, #28]	; (3af8 <Matrix_single_scan+0x384>)
    3ada:	f007 fc91 	bl	b400 <_print>
				printInt32( lastTransition );
    3ade:	4648      	mov	r0, r9
    3ae0:	f007 fcfd 	bl	b4de <printInt32>
				print( NL );
    3ae4:	4805      	ldr	r0, [pc, #20]	; (3afc <Matrix_single_scan+0x388>)
    3ae6:	e6e2      	b.n	38ae <Matrix_single_scan+0x13a>
    3ae8:	0000baed 	.word	0x0000baed
    3aec:	0000de76 	.word	0x0000de76
    3af0:	0000f857 	.word	0x0000f857
    3af4:	0000baf2 	.word	0x0000baf2
    3af8:	00011f77 	.word	0x00011f77
    3afc:	00010d99 	.word	0x00010d99

00003b00 <Matrix_start>:
	Periodic_init( PeriodicCycles_define );
    3b00:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    3b04:	f7fe bee8 	b.w	28d8 <Periodic_init>

00003b08 <Matrix_currentChange>:
}
    3b08:	4770      	bx	lr
    3b0a:	0000      	movs	r0, r0

00003b0c <cliFunc_lcdColor>:
    }

}

void cliFunc_lcdColor( char* args )
{
    3b0c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    3b0e:	ad04      	add	r5, sp, #16
    3b10:	2400      	movs	r4, #0
    3b12:	f845 0d0c 	str.w	r0, [r5, #-12]!
		// Give up if not enough args given
		if ( *arg1Ptr == '\0' )
			return;

		// Convert argument to integer
		rgb[ color ] = numToInt( arg1Ptr );
    3b16:	ae02      	add	r6, sp, #8
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3b18:	9801      	ldr	r0, [sp, #4]
    3b1a:	462a      	mov	r2, r5
    3b1c:	4669      	mov	r1, sp
    3b1e:	f007 f867 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    3b22:	9800      	ldr	r0, [sp, #0]
    3b24:	7803      	ldrb	r3, [r0, #0]
    3b26:	b183      	cbz	r3, 3b4a <cliFunc_lcdColor+0x3e>
		rgb[ color ] = numToInt( arg1Ptr );
    3b28:	f007 fd7d 	bl	b626 <numToInt>
    3b2c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
    3b30:	3401      	adds	r4, #1
	for ( uint8_t color = 0; color < 3; color++ )
    3b32:	2c03      	cmp	r4, #3
    3b34:	d1f0      	bne.n	3b18 <cliFunc_lcdColor+0xc>
	}

	// Set PWM channels
	FTM0_C0V = rgb[0];
    3b36:	4b06      	ldr	r3, [pc, #24]	; (3b50 <cliFunc_lcdColor+0x44>)
    3b38:	f8bd 2008 	ldrh.w	r2, [sp, #8]
    3b3c:	601a      	str	r2, [r3, #0]
	FTM0_C1V = rgb[1];
    3b3e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    3b42:	609a      	str	r2, [r3, #8]
	FTM0_C2V = rgb[2];
    3b44:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    3b48:	611a      	str	r2, [r3, #16]
}
    3b4a:	b004      	add	sp, #16
    3b4c:	bd70      	pop	{r4, r5, r6, pc}
    3b4e:	bf00      	nop
    3b50:	40038010 	.word	0x40038010

00003b54 <SPI_setup>:
	SIM_SCGC6 |= SIM_SCGC6_SPI0;
    3b54:	4a0a      	ldr	r2, [pc, #40]	; (3b80 <SPI_setup+0x2c>)
    3b56:	6813      	ldr	r3, [r2, #0]
    3b58:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    3b5c:	6013      	str	r3, [r2, #0]
	PORTC_PCR6 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    3b5e:	f502 523f 	add.w	r2, r2, #12224	; 0x2fc0
    3b62:	321c      	adds	r2, #28
    3b64:	f44f 7310 	mov.w	r3, #576	; 0x240
    3b68:	6013      	str	r3, [r2, #0]
	PORTC_PCR5 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    3b6a:	f842 3c04 	str.w	r3, [r2, #-4]
	PORTC_PCR4 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    3b6e:	f842 3c08 	str.w	r3, [r2, #-8]
	SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(1);
    3b72:	4b04      	ldr	r3, [pc, #16]	; (3b84 <SPI_setup+0x30>)
    3b74:	4a04      	ldr	r2, [pc, #16]	; (3b88 <SPI_setup+0x34>)
    3b76:	601a      	str	r2, [r3, #0]
	SPI0_CTAR0 = SPI_CTAR_FMSZ(7)
    3b78:	4a04      	ldr	r2, [pc, #16]	; (3b8c <SPI_setup+0x38>)
    3b7a:	60da      	str	r2, [r3, #12]
}
    3b7c:	4770      	bx	lr
    3b7e:	bf00      	nop
    3b80:	4004803c 	.word	0x4004803c
    3b84:	4002c000 	.word	0x4002c000
    3b88:	80010000 	.word	0x80010000
    3b8c:	38007777 	.word	0x38007777

00003b90 <SPI_write>:
{
    3b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3b92:	1e44      	subs	r4, r0, #1
		while ( !( SPI0_SR & SPI_SR_TFFF ) )
    3b94:	4d0c      	ldr	r5, [pc, #48]	; (3bc8 <SPI_write+0x38>)
		SPI0_PUSHR = ( buffer[ byte ] & 0xff ) | SPI_PUSHR_PCS(1);
    3b96:	4f0d      	ldr	r7, [pc, #52]	; (3bcc <SPI_write+0x3c>)
    3b98:	1866      	adds	r6, r4, r1
	for ( uint8_t byte = 0; byte < len; byte++ )
    3b9a:	42b4      	cmp	r4, r6
    3b9c:	d103      	bne.n	3ba6 <SPI_write+0x16>
}
    3b9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			delay_us(10);
    3ba0:	200a      	movs	r0, #10
    3ba2:	f7fe fd84 	bl	26ae <delay_us>
		while ( !( SPI0_SR & SPI_SR_TFFF ) )
    3ba6:	682b      	ldr	r3, [r5, #0]
    3ba8:	019b      	lsls	r3, r3, #6
    3baa:	d5f9      	bpl.n	3ba0 <SPI_write+0x10>
		SPI0_PUSHR = ( buffer[ byte ] & 0xff ) | SPI_PUSHR_PCS(1);
    3bac:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    3bb0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    3bb4:	603b      	str	r3, [r7, #0]
		while ( !( SPI0_SR & SPI_SR_TCF ) );
    3bb6:	682b      	ldr	r3, [r5, #0]
    3bb8:	2b00      	cmp	r3, #0
    3bba:	dafc      	bge.n	3bb6 <SPI_write+0x26>
		SPI0_SR |= SPI_SR_TCF;
    3bbc:	682b      	ldr	r3, [r5, #0]
    3bbe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    3bc2:	602b      	str	r3, [r5, #0]
    3bc4:	e7e9      	b.n	3b9a <SPI_write+0xa>
    3bc6:	bf00      	nop
    3bc8:	4002c02c 	.word	0x4002c02c
    3bcc:	4002c034 	.word	0x4002c034

00003bd0 <LCD_writeControlReg>:
{
    3bd0:	b513      	push	{r0, r1, r4, lr}
	while ( SPI0_TxFIFO_CNT != 0 );
    3bd2:	4b10      	ldr	r3, [pc, #64]	; (3c14 <LCD_writeControlReg+0x44>)
{
    3bd4:	f88d 0007 	strb.w	r0, [sp, #7]
    3bd8:	461c      	mov	r4, r3
	while ( SPI0_TxFIFO_CNT != 0 );
    3bda:	681a      	ldr	r2, [r3, #0]
    3bdc:	f412 4f70 	tst.w	r2, #61440	; 0xf000
    3be0:	d1fb      	bne.n	3bda <LCD_writeControlReg+0xa>
	GPIOC_PCOR |= (1<<7);
    3be2:	4a0d      	ldr	r2, [pc, #52]	; (3c18 <LCD_writeControlReg+0x48>)
    3be4:	6813      	ldr	r3, [r2, #0]
    3be6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3bea:	6013      	str	r3, [r2, #0]
	SPI_write( &byte, 1 );
    3bec:	2101      	movs	r1, #1
    3bee:	f10d 0007 	add.w	r0, sp, #7
    3bf2:	f7ff ffcd 	bl	3b90 <SPI_write>
	while ( SPI0_TxFIFO_CNT != 0 );
    3bf6:	6823      	ldr	r3, [r4, #0]
    3bf8:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    3bfc:	d1fb      	bne.n	3bf6 <LCD_writeControlReg+0x26>
	delay_us(10); // XXX Adjust if SPI speed changes
    3bfe:	200a      	movs	r0, #10
    3c00:	f7fe fd55 	bl	26ae <delay_us>
	GPIOC_PSOR |= (1<<7);
    3c04:	4a05      	ldr	r2, [pc, #20]	; (3c1c <LCD_writeControlReg+0x4c>)
    3c06:	6813      	ldr	r3, [r2, #0]
    3c08:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3c0c:	6013      	str	r3, [r2, #0]
}
    3c0e:	b002      	add	sp, #8
    3c10:	bd10      	pop	{r4, pc}
    3c12:	bf00      	nop
    3c14:	4002c02c 	.word	0x4002c02c
    3c18:	400ff088 	.word	0x400ff088
    3c1c:	400ff084 	.word	0x400ff084

00003c20 <cliFunc_lcdDisp>:

void cliFunc_lcdDisp( char* args )
{
    3c20:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    3c22:	ac04      	add	r4, sp, #16

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3c24:	a902      	add	r1, sp, #8
	char* arg2Ptr = args;
    3c26:	f844 0d04 	str.w	r0, [r4, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3c2a:	4622      	mov	r2, r4
    3c2c:	f006 ffe0 	bl	abf0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    3c30:	9802      	ldr	r0, [sp, #8]
    3c32:	7803      	ldrb	r3, [r0, #0]
    3c34:	b373      	cbz	r3, 3c94 <cliFunc_lcdDisp+0x74>
		return;
	uint8_t page = numToInt( arg1Ptr );
    3c36:	f007 fcf6 	bl	b626 <numToInt>

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3c3a:	4622      	mov	r2, r4
	uint8_t page = numToInt( arg1Ptr );
    3c3c:	4605      	mov	r5, r0
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3c3e:	a902      	add	r1, sp, #8
    3c40:	9803      	ldr	r0, [sp, #12]
    3c42:	f006 ffd5 	bl	abf0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    3c46:	9802      	ldr	r0, [sp, #8]
    3c48:	7803      	ldrb	r3, [r0, #0]
    3c4a:	b31b      	cbz	r3, 3c94 <cliFunc_lcdDisp+0x74>
		return;
	uint8_t address = numToInt( arg1Ptr );
    3c4c:	f007 fceb 	bl	b626 <numToInt>
    3c50:	b2c6      	uxtb	r6, r0

	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3c52:	f005 000f 	and.w	r0, r5, #15
    3c56:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
    3c5a:	f7ff ffb9 	bl	3bd0 <LCD_writeControlReg>

	// Set starting address
	LCD_writeControlReg( 0x10 | ( ( 0xF0 & address ) >> 4 ) );
    3c5e:	0930      	lsrs	r0, r6, #4
    3c60:	f040 0010 	orr.w	r0, r0, #16
    3c64:	f7ff ffb4 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 | ( 0x0F & address ));
    3c68:	f006 000f 	and.w	r0, r6, #15
    3c6c:	f7ff ffb0 	bl	3bd0 <LCD_writeControlReg>

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3c70:	9803      	ldr	r0, [sp, #12]
    3c72:	4622      	mov	r2, r4
    3c74:	a902      	add	r1, sp, #8
    3c76:	f006 ffbb 	bl	abf0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    3c7a:	9802      	ldr	r0, [sp, #8]
    3c7c:	7803      	ldrb	r3, [r0, #0]
    3c7e:	b14b      	cbz	r3, 3c94 <cliFunc_lcdDisp+0x74>
			break;

		uint8_t value = numToInt( arg1Ptr ); 
    3c80:	f007 fcd1 	bl	b626 <numToInt>
		// Write buffer to SPI
		SPI_write( &value, 1 );
    3c84:	2101      	movs	r1, #1
		uint8_t value = numToInt( arg1Ptr ); 
    3c86:	f88d 0007 	strb.w	r0, [sp, #7]
		SPI_write( &value, 1 );
    3c8a:	f10d 0007 	add.w	r0, sp, #7
    3c8e:	f7ff ff7f 	bl	3b90 <SPI_write>
	{
    3c92:	e7ed      	b.n	3c70 <cliFunc_lcdDisp+0x50>
	}
}
    3c94:	b004      	add	sp, #16
    3c96:	bd70      	pop	{r4, r5, r6, pc}

00003c98 <LCD_writeDataReg>:
{
    3c98:	b513      	push	{r0, r1, r4, lr}
	while ( SPI0_TxFIFO_CNT != 0 );
    3c9a:	4b0d      	ldr	r3, [pc, #52]	; (3cd0 <LCD_writeDataReg+0x38>)
{
    3c9c:	f88d 0007 	strb.w	r0, [sp, #7]
    3ca0:	461c      	mov	r4, r3
	while ( SPI0_TxFIFO_CNT != 0 );
    3ca2:	681a      	ldr	r2, [r3, #0]
    3ca4:	f412 4f70 	tst.w	r2, #61440	; 0xf000
    3ca8:	d1fb      	bne.n	3ca2 <LCD_writeDataReg+0xa>
        GPIOC_PSOR |= (1<<7);
    3caa:	4a0a      	ldr	r2, [pc, #40]	; (3cd4 <LCD_writeDataReg+0x3c>)
    3cac:	6813      	ldr	r3, [r2, #0]
    3cae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3cb2:	6013      	str	r3, [r2, #0]
	SPI_write( &byte, 1 );
    3cb4:	2101      	movs	r1, #1
    3cb6:	f10d 0007 	add.w	r0, sp, #7
    3cba:	f7ff ff69 	bl	3b90 <SPI_write>
	while ( SPI0_TxFIFO_CNT != 0 );
    3cbe:	6823      	ldr	r3, [r4, #0]
    3cc0:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    3cc4:	d1fb      	bne.n	3cbe <LCD_writeDataReg+0x26>
	delay_us(10); // XXX Adjust if SPI speed changes
    3cc6:	200a      	movs	r0, #10
    3cc8:	f7fe fcf1 	bl	26ae <delay_us>
}
    3ccc:	b002      	add	sp, #8
    3cce:	bd10      	pop	{r4, pc}
    3cd0:	4002c02c 	.word	0x4002c02c
    3cd4:	400ff084 	.word	0x400ff084

00003cd8 <cliFunc_lcdCmd>:
{
    3cd8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	char* arg2Ptr = args;
    3cda:	ac02      	add	r4, sp, #8
    3cdc:	f844 0d04 	str.w	r0, [r4, #-4]!
	print( NL ); // No \r\n by default after the command is entered
    3ce0:	481a      	ldr	r0, [pc, #104]	; (3d4c <cliFunc_lcdCmd+0x74>)
    3ce2:	f007 fb8d 	bl	b400 <_print>
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3ce6:	9801      	ldr	r0, [sp, #4]
    3ce8:	4622      	mov	r2, r4
    3cea:	4669      	mov	r1, sp
    3cec:	f006 ff80 	bl	abf0 <CLI_argumentIsolation>
	if ( *arg1Ptr == '\0' )
    3cf0:	9800      	ldr	r0, [sp, #0]
    3cf2:	7803      	ldrb	r3, [r0, #0]
    3cf4:	b93b      	cbnz	r3, 3d06 <cliFunc_lcdCmd+0x2e>
		print("No args provided.");
    3cf6:	4816      	ldr	r0, [pc, #88]	; (3d50 <cliFunc_lcdCmd+0x78>)
    3cf8:	f007 fb82 	bl	b400 <_print>
		print( NL );
    3cfc:	4813      	ldr	r0, [pc, #76]	; (3d4c <cliFunc_lcdCmd+0x74>)
    3cfe:	f007 fb7f 	bl	b400 <_print>
}
    3d02:	b003      	add	sp, #12
    3d04:	bd30      	pop	{r4, r5, pc}
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    3d06:	f007 fc8e 	bl	b626 <numToInt>
	if ( *arg2Ptr == '\0' )
    3d0a:	9b01      	ldr	r3, [sp, #4]
    3d0c:	781b      	ldrb	r3, [r3, #0]
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    3d0e:	b2c4      	uxtb	r4, r0
    3d10:	b2a5      	uxth	r5, r4
	if ( *arg2Ptr == '\0' )
    3d12:	b96b      	cbnz	r3, 3d30 <cliFunc_lcdCmd+0x58>
        info_msg("Sending- ");
    3d14:	480f      	ldr	r0, [pc, #60]	; (3d54 <cliFunc_lcdCmd+0x7c>)
    3d16:	f007 fb73 	bl	b400 <_print>
		printHex( cmd );
    3d1a:	2101      	movs	r1, #1
    3d1c:	4628      	mov	r0, r5
    3d1e:	f007 fc17 	bl	b550 <printHex_op>
		print( NL );
    3d22:	480a      	ldr	r0, [pc, #40]	; (3d4c <cliFunc_lcdCmd+0x74>)
    3d24:	f007 fb6c 	bl	b400 <_print>
		LCD_writeControlReg( cmd );
    3d28:	4620      	mov	r0, r4
    3d2a:	f7ff ff51 	bl	3bd0 <LCD_writeControlReg>
		return;
    3d2e:	e7e8      	b.n	3d02 <cliFunc_lcdCmd+0x2a>
		info_msg("Sending WITH A0 FLAG SET- ");
    3d30:	4809      	ldr	r0, [pc, #36]	; (3d58 <cliFunc_lcdCmd+0x80>)
    3d32:	f007 fb65 	bl	b400 <_print>
		printHex( cmd );
    3d36:	2101      	movs	r1, #1
    3d38:	4628      	mov	r0, r5
    3d3a:	f007 fc09 	bl	b550 <printHex_op>
		print( NL );
    3d3e:	4803      	ldr	r0, [pc, #12]	; (3d4c <cliFunc_lcdCmd+0x74>)
    3d40:	f007 fb5e 	bl	b400 <_print>
		LCD_writeDataReg( cmd );
    3d44:	4620      	mov	r0, r4
    3d46:	f7ff ffa7 	bl	3c98 <LCD_writeDataReg>
		return;
    3d4a:	e7da      	b.n	3d02 <cliFunc_lcdCmd+0x2a>
    3d4c:	00010d99 	.word	0x00010d99
    3d50:	0000c5f2 	.word	0x0000c5f2
    3d54:	0000c604 	.word	0x0000c604
    3d58:	0000c620 	.word	0x0000c620

00003d5c <LCD_writeDisplayReg>:
{
    3d5c:	b538      	push	{r3, r4, r5, lr}
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3d5e:	f000 000f 	and.w	r0, r0, #15
    3d62:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
{
    3d66:	460c      	mov	r4, r1
    3d68:	4615      	mov	r5, r2
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3d6a:	f7ff ff31 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    3d6e:	2040      	movs	r0, #64	; 0x40
    3d70:	f7ff ff2e 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    3d74:	2010      	movs	r0, #16
    3d76:	f7ff ff2b 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    3d7a:	2000      	movs	r0, #0
    3d7c:	f7ff ff28 	bl	3bd0 <LCD_writeControlReg>
	SPI_write( buffer, len );
    3d80:	4629      	mov	r1, r5
    3d82:	4620      	mov	r0, r4
}
    3d84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SPI_write( buffer, len );
    3d88:	f7ff bf02 	b.w	3b90 <SPI_write>

00003d8c <cliFunc_lcdTest>:
{
    3d8c:	b510      	push	{r4, lr}
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    3d8e:	4c0c      	ldr	r4, [pc, #48]	; (3dc0 <cliFunc_lcdTest+0x34>)
    3d90:	2280      	movs	r2, #128	; 0x80
    3d92:	4621      	mov	r1, r4
    3d94:	2000      	movs	r0, #0
    3d96:	f7ff ffe1 	bl	3d5c <LCD_writeDisplayReg>
    3d9a:	2280      	movs	r2, #128	; 0x80
    3d9c:	18a1      	adds	r1, r4, r2
    3d9e:	2001      	movs	r0, #1
    3da0:	f7ff ffdc 	bl	3d5c <LCD_writeDisplayReg>
    3da4:	f504 7180 	add.w	r1, r4, #256	; 0x100
    3da8:	2280      	movs	r2, #128	; 0x80
    3daa:	2002      	movs	r0, #2
    3dac:	f7ff ffd6 	bl	3d5c <LCD_writeDisplayReg>
    3db0:	f504 71c0 	add.w	r1, r4, #384	; 0x180
    3db4:	2280      	movs	r2, #128	; 0x80
    3db6:	2003      	movs	r0, #3
}
    3db8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    3dbc:	f7ff bfce 	b.w	3d5c <LCD_writeDisplayReg>
    3dc0:	0000c3f2 	.word	0x0000c3f2

00003dc4 <LCD_clearPage>:
{
    3dc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3dc6:	f000 000f 	and.w	r0, r0, #15
    3dca:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
    3dce:	f7ff feff 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    3dd2:	2040      	movs	r0, #64	; 0x40
    3dd4:	f7ff fefc 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    3dd8:	2010      	movs	r0, #16
    3dda:	f7ff fef9 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    3dde:	2000      	movs	r0, #0
    3de0:	f7ff fef6 	bl	3bd0 <LCD_writeControlReg>
	for ( uint8_t page_reg = 0; page_reg < LCD_PAGE_LEN; page_reg++ )
    3de4:	2481      	movs	r4, #129	; 0x81
		uint8_t byte = 0;
    3de6:	2500      	movs	r5, #0
	for ( uint8_t page_reg = 0; page_reg < LCD_PAGE_LEN; page_reg++ )
    3de8:	3c01      	subs	r4, #1
    3dea:	d106      	bne.n	3dfa <LCD_clearPage+0x36>
	while ( SPI0_TxFIFO_CNT != 0 );
    3dec:	4a07      	ldr	r2, [pc, #28]	; (3e0c <LCD_clearPage+0x48>)
    3dee:	6813      	ldr	r3, [r2, #0]
    3df0:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    3df4:	d1fb      	bne.n	3dee <LCD_clearPage+0x2a>
}
    3df6:	b003      	add	sp, #12
    3df8:	bd30      	pop	{r4, r5, pc}
		SPI_write( &byte, 1 );
    3dfa:	2101      	movs	r1, #1
    3dfc:	f10d 0007 	add.w	r0, sp, #7
		uint8_t byte = 0;
    3e00:	f88d 5007 	strb.w	r5, [sp, #7]
		SPI_write( &byte, 1 );
    3e04:	f7ff fec4 	bl	3b90 <SPI_write>
    3e08:	e7ee      	b.n	3de8 <LCD_clearPage+0x24>
    3e0a:	bf00      	nop
    3e0c:	4002c02c 	.word	0x4002c02c

00003e10 <LCD_clear>:
{
    3e10:	b510      	push	{r4, lr}
    3e12:	2400      	movs	r4, #0
		LCD_clearPage( page );
    3e14:	b2e0      	uxtb	r0, r4
    3e16:	3401      	adds	r4, #1
    3e18:	f7ff ffd4 	bl	3dc4 <LCD_clearPage>
	for ( uint8_t page = 0; page < LCD_TOTAL_PAGES; page++ )
    3e1c:	2c09      	cmp	r4, #9
    3e1e:	d1f9      	bne.n	3e14 <LCD_clear+0x4>
	LCD_writeControlReg( 0xB0 );
    3e20:	20b0      	movs	r0, #176	; 0xb0
    3e22:	f7ff fed5 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    3e26:	2040      	movs	r0, #64	; 0x40
    3e28:	f7ff fed2 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    3e2c:	2010      	movs	r0, #16
    3e2e:	f7ff fecf 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    3e32:	2000      	movs	r0, #0
}
    3e34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LCD_writeControlReg( 0x00 );
    3e38:	f7ff beca 	b.w	3bd0 <LCD_writeControlReg>

00003e3c <LCD_initialize>:
{
    3e3c:	b508      	push	{r3, lr}
	LCD_writeControlReg( 0xA0 );
    3e3e:	20a0      	movs	r0, #160	; 0xa0
    3e40:	f7ff fec6 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0xAE );
    3e44:	20ae      	movs	r0, #174	; 0xae
    3e46:	f7ff fec3 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0xC0 );
    3e4a:	20c0      	movs	r0, #192	; 0xc0
    3e4c:	f7ff fec0 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0xA2 );
    3e50:	20a2      	movs	r0, #162	; 0xa2
    3e52:	f7ff febd 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x2F );
    3e56:	202f      	movs	r0, #47	; 0x2f
    3e58:	f7ff feba 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x26 );
    3e5c:	2026      	movs	r0, #38	; 0x26
    3e5e:	f7ff feb7 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0xE2 );
    3e62:	20e2      	movs	r0, #226	; 0xe2
    3e64:	f7ff feb4 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x81 );
    3e68:	2081      	movs	r0, #129	; 0x81
    3e6a:	f7ff feb1 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    3e6e:	2000      	movs	r0, #0
    3e70:	f7ff feae 	bl	3bd0 <LCD_writeControlReg>
	LCD_writeControlReg( 0xAF );
    3e74:	20af      	movs	r0, #175	; 0xaf
    3e76:	f7ff feab 	bl	3bd0 <LCD_writeControlReg>
}
    3e7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LCD_clear();
    3e7e:	f7ff bfc7 	b.w	3e10 <LCD_clear>

00003e82 <cliFunc_lcdInit>:
	LCD_initialize();
    3e82:	f7ff bfdb 	b.w	3e3c <LCD_initialize>
    3e86:	0000      	movs	r0, r0

00003e88 <LCD_setup>:
{
    3e88:	b510      	push	{r4, lr}
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    3e8a:	4936      	ldr	r1, [pc, #216]	; (3f64 <LCD_setup+0xdc>)
    3e8c:	4836      	ldr	r0, [pc, #216]	; (3f68 <LCD_setup+0xe0>)
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    3e8e:	4c37      	ldr	r4, [pc, #220]	; (3f6c <LCD_setup+0xe4>)
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    3e90:	f006 ff48 	bl	ad24 <CLI_registerDictionary>
	SPI_setup();
    3e94:	f7ff fe5e 	bl	3b54 <SPI_setup>
	GPIOC_PDDR |= (1<<7);
    3e98:	4a35      	ldr	r2, [pc, #212]	; (3f70 <LCD_setup+0xe8>)
    3e9a:	6813      	ldr	r3, [r2, #0]
    3e9c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3ea0:	6013      	str	r3, [r2, #0]
	PORTC_PCR7 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    3ea2:	4b34      	ldr	r3, [pc, #208]	; (3f74 <LCD_setup+0xec>)
    3ea4:	f44f 70a2 	mov.w	r0, #324	; 0x144
    3ea8:	6018      	str	r0, [r3, #0]
	GPIOC_PSOR |= (1<<7);
    3eaa:	f503 2334 	add.w	r3, r3, #737280	; 0xb4000
    3eae:	3368      	adds	r3, #104	; 0x68
    3eb0:	6819      	ldr	r1, [r3, #0]
    3eb2:	f041 0180 	orr.w	r1, r1, #128	; 0x80
    3eb6:	6019      	str	r1, [r3, #0]
	GPIOC_PDDR |= (1<<8);
    3eb8:	6811      	ldr	r1, [r2, #0]
    3eba:	f441 7180 	orr.w	r1, r1, #256	; 0x100
    3ebe:	6011      	str	r1, [r2, #0]
	PORTC_PCR8 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    3ec0:	f5a2 2234 	sub.w	r2, r2, #737280	; 0xb4000
    3ec4:	3a74      	subs	r2, #116	; 0x74
    3ec6:	6010      	str	r0, [r2, #0]
	GPIOC_PSOR |= (1<<8);
    3ec8:	681a      	ldr	r2, [r3, #0]
    3eca:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    3ece:	601a      	str	r2, [r3, #0]
	LCD_initialize();
    3ed0:	f7ff ffb4 	bl	3e3c <LCD_initialize>
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    3ed4:	2280      	movs	r2, #128	; 0x80
    3ed6:	4621      	mov	r1, r4
    3ed8:	2000      	movs	r0, #0
    3eda:	f7ff ff3f 	bl	3d5c <LCD_writeDisplayReg>
    3ede:	2280      	movs	r2, #128	; 0x80
    3ee0:	18a1      	adds	r1, r4, r2
    3ee2:	2001      	movs	r0, #1
    3ee4:	f7ff ff3a 	bl	3d5c <LCD_writeDisplayReg>
    3ee8:	2280      	movs	r2, #128	; 0x80
    3eea:	f504 7180 	add.w	r1, r4, #256	; 0x100
    3eee:	2002      	movs	r0, #2
    3ef0:	f7ff ff34 	bl	3d5c <LCD_writeDisplayReg>
    3ef4:	2280      	movs	r2, #128	; 0x80
    3ef6:	f504 71c0 	add.w	r1, r4, #384	; 0x180
    3efa:	2003      	movs	r0, #3
    3efc:	f7ff ff2e 	bl	3d5c <LCD_writeDisplayReg>
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    3f00:	4a1d      	ldr	r2, [pc, #116]	; (3f78 <LCD_setup+0xf0>)
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3f02:	481e      	ldr	r0, [pc, #120]	; (3f7c <LCD_setup+0xf4>)
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    3f04:	6813      	ldr	r3, [r2, #0]
    3f06:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    3f0a:	6013      	str	r3, [r2, #0]
	FTM0_CNT = 0; // Reset counter
    3f0c:	4b1c      	ldr	r3, [pc, #112]	; (3f80 <LCD_setup+0xf8>)
    3f0e:	2100      	movs	r1, #0
	FTM0_MOD = 0xFFFF;
    3f10:	f64f 72ff 	movw	r2, #65535	; 0xffff
	FTM0_CNT = 0; // Reset counter
    3f14:	6019      	str	r1, [r3, #0]
	FTM0_MOD = 0xFFFF;
    3f16:	605a      	str	r2, [r3, #4]
	FTM0_C0SC = 0x24; // MSnB:MSnA = 10, ELSnB:ELSnA = 01
    3f18:	4a1a      	ldr	r2, [pc, #104]	; (3f84 <LCD_setup+0xfc>)
    3f1a:	2324      	movs	r3, #36	; 0x24
    3f1c:	6013      	str	r3, [r2, #0]
	FTM0_C1SC = 0x24;
    3f1e:	6093      	str	r3, [r2, #8]
	FTM0_C2SC = 0x24;
    3f20:	6113      	str	r3, [r2, #16]
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS( STLcdBacklightPrescalar_define );
    3f22:	4b19      	ldr	r3, [pc, #100]	; (3f88 <LCD_setup+0x100>)
    3f24:	2208      	movs	r2, #8
    3f26:	601a      	str	r2, [r3, #0]
	FTM0_C0V = STLcdBacklightRed_define;
    3f28:	f640 72ff 	movw	r2, #4095	; 0xfff
    3f2c:	611a      	str	r2, [r3, #16]
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3f2e:	f240 4344 	movw	r3, #1092	; 0x444
    3f32:	6003      	str	r3, [r0, #0]
	FTM0_C1V = STLcdBacklightGreen_define;
    3f34:	f5a0 3097 	sub.w	r0, r0, #77312	; 0x12e00
    3f38:	f5a0 70f6 	sub.w	r0, r0, #492	; 0x1ec
    3f3c:	6002      	str	r2, [r0, #0]
	PORTC_PCR2 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3f3e:	f500 3097 	add.w	r0, r0, #77312	; 0x12e00
    3f42:	f500 70f8 	add.w	r0, r0, #496	; 0x1f0
    3f46:	6003      	str	r3, [r0, #0]
	FTM0_C2V = STLcdBacklightBlue_define;
    3f48:	f5a0 3097 	sub.w	r0, r0, #77312	; 0x12e00
    3f4c:	f5a0 70f4 	sub.w	r0, r0, #488	; 0x1e8
    3f50:	6002      	str	r2, [r0, #0]
	PORTC_PCR3 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3f52:	4a0e      	ldr	r2, [pc, #56]	; (3f8c <LCD_setup+0x104>)
	stlcdLatencyResource = Latency_add_resource("STLcd", LatencyOption_Ticks);
    3f54:	480e      	ldr	r0, [pc, #56]	; (3f90 <LCD_setup+0x108>)
	PORTC_PCR3 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3f56:	6013      	str	r3, [r2, #0]
	stlcdLatencyResource = Latency_add_resource("STLcd", LatencyOption_Ticks);
    3f58:	f007 f976 	bl	b248 <Latency_add_resource>
    3f5c:	4b0d      	ldr	r3, [pc, #52]	; (3f94 <LCD_setup+0x10c>)
    3f5e:	7018      	strb	r0, [r3, #0]
}
    3f60:	bd10      	pop	{r4, pc}
    3f62:	bf00      	nop
    3f64:	0000c698 	.word	0x0000c698
    3f68:	0000c650 	.word	0x0000c650
    3f6c:	0000c3f2 	.word	0x0000c3f2
    3f70:	400ff094 	.word	0x400ff094
    3f74:	4004b01c 	.word	0x4004b01c
    3f78:	4004803c 	.word	0x4004803c
    3f7c:	4004b004 	.word	0x4004b004
    3f80:	40038004 	.word	0x40038004
    3f84:	4003800c 	.word	0x4003800c
    3f88:	40038000 	.word	0x40038000
    3f8c:	4004b00c 	.word	0x4004b00c
    3f90:	0000c3ec 	.word	0x0000c3ec
    3f94:	1fff92e2 	.word	0x1fff92e2

00003f98 <LCD_scan>:
{
    3f98:	b538      	push	{r3, r4, r5, lr}
	Latency_start_time( stlcdLatencyResource );
    3f9a:	4c19      	ldr	r4, [pc, #100]	; (4000 <LCD_scan+0x68>)
    3f9c:	7820      	ldrb	r0, [r4, #0]
    3f9e:	f007 f9a3 	bl	b2e8 <Latency_start_time>
	uint16_t is_capslock = USBKeys_LEDs & 2;
    3fa2:	4b18      	ldr	r3, [pc, #96]	; (4004 <LCD_scan+0x6c>)
    3fa4:	781b      	ldrb	r3, [r3, #0]
	if ( is_capslock && !was_capslock )
    3fa6:	f013 0202 	ands.w	r2, r3, #2
    3faa:	4b17      	ldr	r3, [pc, #92]	; (4008 <LCD_scan+0x70>)
    3fac:	d017      	beq.n	3fde <LCD_scan+0x46>
    3fae:	781d      	ldrb	r5, [r3, #0]
    3fb0:	4816      	ldr	r0, [pc, #88]	; (400c <LCD_scan+0x74>)
    3fb2:	4917      	ldr	r1, [pc, #92]	; (4010 <LCD_scan+0x78>)
    3fb4:	4a17      	ldr	r2, [pc, #92]	; (4014 <LCD_scan+0x7c>)
    3fb6:	b945      	cbnz	r5, 3fca <LCD_scan+0x32>
		was_capslock = 1;
    3fb8:	2501      	movs	r5, #1
    3fba:	701d      	strb	r5, [r3, #0]
		hold_color[0] = FTM0_C0V;
    3fbc:	4b16      	ldr	r3, [pc, #88]	; (4018 <LCD_scan+0x80>)
    3fbe:	6805      	ldr	r5, [r0, #0]
    3fc0:	801d      	strh	r5, [r3, #0]
		hold_color[1] = FTM0_C1V;
    3fc2:	680d      	ldr	r5, [r1, #0]
    3fc4:	805d      	strh	r5, [r3, #2]
		hold_color[2] = FTM0_C2V;
    3fc6:	6815      	ldr	r5, [r2, #0]
    3fc8:	809d      	strh	r5, [r3, #4]
		FTM0_C0V = 0x8303;
    3fca:	f248 3303 	movw	r3, #33539	; 0x8303
    3fce:	6003      	str	r3, [r0, #0]
		FTM0_C1V = 0x1394;
    3fd0:	f241 3394 	movw	r3, #5012	; 0x1394
    3fd4:	600b      	str	r3, [r1, #0]
		FTM0_C2V = 0xb9f9;
    3fd6:	f64b 13f9 	movw	r3, #47609	; 0xb9f9
    3fda:	6013      	str	r3, [r2, #0]
    3fdc:	e00b      	b.n	3ff6 <LCD_scan+0x5e>
	else if ( !is_capslock && was_capslock )
    3fde:	7819      	ldrb	r1, [r3, #0]
    3fe0:	b149      	cbz	r1, 3ff6 <LCD_scan+0x5e>
		was_capslock = 0;
    3fe2:	701a      	strb	r2, [r3, #0]
		FTM0_C0V = hold_color[0];
    3fe4:	4b0c      	ldr	r3, [pc, #48]	; (4018 <LCD_scan+0x80>)
    3fe6:	4a09      	ldr	r2, [pc, #36]	; (400c <LCD_scan+0x74>)
    3fe8:	8819      	ldrh	r1, [r3, #0]
    3fea:	6011      	str	r1, [r2, #0]
		FTM0_C1V = hold_color[1];
    3fec:	8859      	ldrh	r1, [r3, #2]
    3fee:	6091      	str	r1, [r2, #8]
		FTM0_C2V = hold_color[2];
    3ff0:	889a      	ldrh	r2, [r3, #4]
    3ff2:	4b08      	ldr	r3, [pc, #32]	; (4014 <LCD_scan+0x7c>)
    3ff4:	601a      	str	r2, [r3, #0]
	Latency_end_time( stlcdLatencyResource );
    3ff6:	7820      	ldrb	r0, [r4, #0]
    3ff8:	f007 f988 	bl	b30c <Latency_end_time>
}
    3ffc:	2000      	movs	r0, #0
    3ffe:	bd38      	pop	{r3, r4, r5, pc}
    4000:	1fff92e2 	.word	0x1fff92e2
    4004:	1fff93ec 	.word	0x1fff93ec
    4008:	1fff92e3 	.word	0x1fff92e3
    400c:	40038010 	.word	0x40038010
    4010:	40038018 	.word	0x40038018
    4014:	40038020 	.word	0x40038020
    4018:	1fff92dc 	.word	0x1fff92dc

0000401c <LCD_currentChange>:
}
    401c:	4770      	bx	lr
    401e:	0000      	movs	r0, r0

00004020 <LCD_layerStackExact_capability>:
{
    4020:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if ( stateType == 0xFF && state == 0xFF )
    4024:	2aff      	cmp	r2, #255	; 0xff
{
    4026:	f2ad 5d44 	subw	sp, sp, #1348	; 0x544
    402a:	461d      	mov	r5, r3
	if ( stateType == 0xFF && state == 0xFF )
    402c:	d108      	bne.n	4040 <LCD_layerStackExact_capability+0x20>
    402e:	29ff      	cmp	r1, #255	; 0xff
    4030:	d106      	bne.n	4040 <LCD_layerStackExact_capability+0x20>
		print("LCD_layerStackExact_capability(num,layer1,layer2,layer3,layer4)");
    4032:	4842      	ldr	r0, [pc, #264]	; (413c <LCD_layerStackExact_capability+0x11c>)
    4034:	f007 f9e4 	bl	b400 <_print>
}
    4038:	f20d 5d44 	addw	sp, sp, #1348	; 0x544
    403c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	const uint8_t numbers[10][128] = {
    4040:	f44f 62a0 	mov.w	r2, #1280	; 0x500
    4044:	493e      	ldr	r1, [pc, #248]	; (4140 <LCD_layerStackExact_capability+0x120>)
    4046:	a810      	add	r0, sp, #64	; 0x40
    4048:	f7fe fb02 	bl	2650 <memcpy>
	const uint16_t colors[10][3] = {
    404c:	4b3d      	ldr	r3, [pc, #244]	; (4144 <LCD_layerStackExact_capability+0x124>)
    404e:	ae01      	add	r6, sp, #4
    4050:	4632      	mov	r2, r6
    4052:	f103 0738 	add.w	r7, r3, #56	; 0x38
    4056:	6818      	ldr	r0, [r3, #0]
    4058:	6859      	ldr	r1, [r3, #4]
    405a:	4614      	mov	r4, r2
    405c:	c403      	stmia	r4!, {r0, r1}
    405e:	3308      	adds	r3, #8
    4060:	42bb      	cmp	r3, r7
    4062:	4622      	mov	r2, r4
    4064:	d1f7      	bne.n	4056 <LCD_layerStackExact_capability+0x36>
    4066:	6818      	ldr	r0, [r3, #0]
    4068:	6020      	str	r0, [r4, #0]
	if ( stack_args->numArgs > 0 )
    406a:	7828      	ldrb	r0, [r5, #0]
    406c:	4c36      	ldr	r4, [pc, #216]	; (4148 <LCD_layerStackExact_capability+0x128>)
    406e:	4937      	ldr	r1, [pc, #220]	; (414c <LCD_layerStackExact_capability+0x12c>)
    4070:	4a37      	ldr	r2, [pc, #220]	; (4150 <LCD_layerStackExact_capability+0x130>)
    4072:	2800      	cmp	r0, #0
    4074:	d049      	beq.n	410a <LCD_layerStackExact_capability+0xea>
		FTM0_C0V = colors[ layerIndex ][0];
    4076:	8868      	ldrh	r0, [r5, #2]
    4078:	2306      	movs	r3, #6
    407a:	4343      	muls	r3, r0
    407c:	18f0      	adds	r0, r6, r3
    407e:	5af3      	ldrh	r3, [r6, r3]
    4080:	6023      	str	r3, [r4, #0]
		FTM0_C1V = colors[ layerIndex ][1];
    4082:	8843      	ldrh	r3, [r0, #2]
    4084:	600b      	str	r3, [r1, #0]
		FTM0_C2V = colors[ layerIndex ][2];
    4086:	2400      	movs	r4, #0
    4088:	8883      	ldrh	r3, [r0, #4]
    408a:	6013      	str	r3, [r2, #0]
			LCD_writeControlReg( 0x00 );
    408c:	4627      	mov	r7, r4
			LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    408e:	f064 004f 	orn	r0, r4, #79	; 0x4f
    4092:	b2c0      	uxtb	r0, r0
    4094:	f7ff fd9c 	bl	3bd0 <LCD_writeControlReg>
			LCD_writeControlReg( 0x10 );
    4098:	2010      	movs	r0, #16
    409a:	f7ff fd99 	bl	3bd0 <LCD_writeControlReg>
			LCD_writeControlReg( 0x00 );
    409e:	2000      	movs	r0, #0
    40a0:	f7ff fd96 	bl	3bd0 <LCD_writeControlReg>
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    40a4:	ea4f 1944 	mov.w	r9, r4, lsl #5
    40a8:	f105 0802 	add.w	r8, r5, #2
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
    40ac:	2600      	movs	r6, #0
    40ae:	782a      	ldrb	r2, [r5, #0]
    40b0:	b2b3      	uxth	r3, r6
    40b2:	429a      	cmp	r2, r3
    40b4:	d80e      	bhi.n	40d4 <LCD_layerStackExact_capability+0xb4>
			uint8_t data = 0;
    40b6:	f88d 7003 	strb.w	r7, [sp, #3]
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
    40ba:	f04f 0800 	mov.w	r8, #0
    40be:	782b      	ldrb	r3, [r5, #0]
    40c0:	fa5f f288 	uxtb.w	r2, r8
    40c4:	f1c3 0304 	rsb	r3, r3, #4
    40c8:	429a      	cmp	r2, r3
    40ca:	db11      	blt.n	40f0 <LCD_layerStackExact_capability+0xd0>
    40cc:	3401      	adds	r4, #1
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    40ce:	2c04      	cmp	r4, #4
    40d0:	d1dd      	bne.n	408e <LCD_layerStackExact_capability+0x6e>
    40d2:	e7b1      	b.n	4038 <LCD_layerStackExact_capability+0x18>
				layerIndex = stack_args->layers[ layer ];
    40d4:	f838 0b02 	ldrh.w	r0, [r8], #2
					layerIndex = 0;
    40d8:	280a      	cmp	r0, #10
    40da:	bf28      	it	cs
    40dc:	2000      	movcs	r0, #0
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    40de:	ab10      	add	r3, sp, #64	; 0x40
    40e0:	eb09 10c0 	add.w	r0, r9, r0, lsl #7
    40e4:	2120      	movs	r1, #32
    40e6:	4418      	add	r0, r3
    40e8:	f7ff fd52 	bl	3b90 <SPI_write>
    40ec:	3601      	adds	r6, #1
    40ee:	e7de      	b.n	40ae <LCD_layerStackExact_capability+0x8e>
    40f0:	2620      	movs	r6, #32
					SPI_write( &data, 1 );
    40f2:	2101      	movs	r1, #1
    40f4:	f10d 0003 	add.w	r0, sp, #3
    40f8:	3e01      	subs	r6, #1
    40fa:	f7ff fd49 	bl	3b90 <SPI_write>
				for ( uint8_t byte = 0; byte < 32; byte++ )
    40fe:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
    4102:	d1f6      	bne.n	40f2 <LCD_layerStackExact_capability+0xd2>
    4104:	f108 0801 	add.w	r8, r8, #1
    4108:	e7d9      	b.n	40be <LCD_layerStackExact_capability+0x9e>
		FTM0_C0V = STLcdBacklightRed_define;
    410a:	f640 73ff 	movw	r3, #4095	; 0xfff
    410e:	6023      	str	r3, [r4, #0]
		FTM0_C1V = STLcdBacklightGreen_define;
    4110:	600b      	str	r3, [r1, #0]
		FTM0_C2V = STLcdBacklightBlue_define;
    4112:	6013      	str	r3, [r2, #0]
			LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4114:	490f      	ldr	r1, [pc, #60]	; (4154 <LCD_layerStackExact_capability+0x134>)
    4116:	2280      	movs	r2, #128	; 0x80
    4118:	f7ff fe20 	bl	3d5c <LCD_writeDisplayReg>
    411c:	2280      	movs	r2, #128	; 0x80
    411e:	490e      	ldr	r1, [pc, #56]	; (4158 <LCD_layerStackExact_capability+0x138>)
    4120:	2001      	movs	r0, #1
    4122:	f7ff fe1b 	bl	3d5c <LCD_writeDisplayReg>
    4126:	2280      	movs	r2, #128	; 0x80
    4128:	490c      	ldr	r1, [pc, #48]	; (415c <LCD_layerStackExact_capability+0x13c>)
    412a:	2002      	movs	r0, #2
    412c:	f7ff fe16 	bl	3d5c <LCD_writeDisplayReg>
    4130:	2280      	movs	r2, #128	; 0x80
    4132:	490b      	ldr	r1, [pc, #44]	; (4160 <LCD_layerStackExact_capability+0x140>)
    4134:	2003      	movs	r0, #3
    4136:	f7ff fe11 	bl	3d5c <LCD_writeDisplayReg>
    413a:	e77d      	b.n	4038 <LCD_layerStackExact_capability+0x18>
    413c:	0000c390 	.word	0x0000c390
    4140:	0000be54 	.word	0x0000be54
    4144:	0000c354 	.word	0x0000c354
    4148:	40038010 	.word	0x40038010
    414c:	40038018 	.word	0x40038018
    4150:	40038020 	.word	0x40038020
    4154:	0000c3f2 	.word	0x0000c3f2
    4158:	0000c472 	.word	0x0000c472
    415c:	0000c4f2 	.word	0x0000c4f2
    4160:	0000c572 	.word	0x0000c572

00004164 <LCD_layerStack_capability>:
{
    4164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ( stateType == 0xFF && state == 0xFF )
    4168:	2aff      	cmp	r2, #255	; 0xff
{
    416a:	b086      	sub	sp, #24
    416c:	4680      	mov	r8, r0
    416e:	460e      	mov	r6, r1
    4170:	4617      	mov	r7, r2
	if ( stateType == 0xFF && state == 0xFF )
    4172:	d107      	bne.n	4184 <LCD_layerStack_capability+0x20>
    4174:	29ff      	cmp	r1, #255	; 0xff
    4176:	d105      	bne.n	4184 <LCD_layerStack_capability+0x20>
		print("LCD_layerStack_capability()");
    4178:	4821      	ldr	r0, [pc, #132]	; (4200 <LCD_layerStack_capability+0x9c>)
    417a:	f007 f941 	bl	b400 <_print>
}
    417e:	b006      	add	sp, #24
    4180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ( macroLayerIndexStackSize == LCD_layerStack_prevSize
    4184:	4d1f      	ldr	r5, [pc, #124]	; (4204 <LCD_layerStack_capability+0xa0>)
    4186:	4c20      	ldr	r4, [pc, #128]	; (4208 <LCD_layerStack_capability+0xa4>)
    4188:	882a      	ldrh	r2, [r5, #0]
    418a:	1e53      	subs	r3, r2, #1
    418c:	f834 0013 	ldrh.w	r0, [r4, r3, lsl #1]
    4190:	4b1e      	ldr	r3, [pc, #120]	; (420c <LCD_layerStack_capability+0xa8>)
    4192:	8819      	ldrh	r1, [r3, #0]
    4194:	4291      	cmp	r1, r2
    4196:	491e      	ldr	r1, [pc, #120]	; (4210 <LCD_layerStack_capability+0xac>)
    4198:	d103      	bne.n	41a2 <LCD_layerStack_capability+0x3e>
		&& macroLayerIndexStack[macroLayerIndexStackSize - 1] == LCD_layerStack_prevTop )
    419a:	f8b1 c000 	ldrh.w	ip, [r1]
    419e:	4584      	cmp	ip, r0
    41a0:	d0ed      	beq.n	417e <LCD_layerStack_capability+0x1a>
	LCD_layerStack_prevSize = macroLayerIndexStackSize;
    41a2:	801a      	strh	r2, [r3, #0]
	LCD_layerStack_prevTop  = macroLayerIndexStack[macroLayerIndexStackSize - 1];
    41a4:	8008      	strh	r0, [r1, #0]
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );
    41a6:	2208      	movs	r2, #8
    41a8:	2100      	movs	r1, #0
    41aa:	f10d 000e 	add.w	r0, sp, #14
    41ae:	f7fe fa47 	bl	2640 <memset>
	stack_args.numArgs = macroLayerIndexStackSize;
    41b2:	882a      	ldrh	r2, [r5, #0]
    41b4:	f88d 200c 	strb.w	r2, [sp, #12]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    41b8:	2301      	movs	r3, #1
    41ba:	429a      	cmp	r2, r3
    41bc:	d214      	bcs.n	41e8 <LCD_layerStack_capability+0x84>
	if ( Connect_master )
    41be:	4b15      	ldr	r3, [pc, #84]	; (4214 <LCD_layerStack_capability+0xb0>)
    41c0:	781b      	ldrb	r3, [r3, #0]
    41c2:	ac03      	add	r4, sp, #12
    41c4:	b14b      	cbz	r3, 41da <LCD_layerStack_capability+0x76>
		Connect_send_RemoteCapability(
    41c6:	4b14      	ldr	r3, [pc, #80]	; (4218 <LCD_layerStack_capability+0xb4>)
    41c8:	9401      	str	r4, [sp, #4]
    41ca:	791b      	ldrb	r3, [r3, #4]
    41cc:	9300      	str	r3, [sp, #0]
    41ce:	4632      	mov	r2, r6
    41d0:	463b      	mov	r3, r7
    41d2:	2100      	movs	r1, #0
    41d4:	20ff      	movs	r0, #255	; 0xff
    41d6:	f000 fd0f 	bl	4bf8 <Connect_send_RemoteCapability>
	LCD_layerStackExact_capability( trigger, state, stateType, (uint8_t*)&stack_args );
    41da:	4623      	mov	r3, r4
    41dc:	463a      	mov	r2, r7
    41de:	4631      	mov	r1, r6
    41e0:	4640      	mov	r0, r8
    41e2:	f7ff ff1d 	bl	4020 <LCD_layerStackExact_capability>
    41e6:	e7ca      	b.n	417e <LCD_layerStack_capability+0x1a>
		stack_args.layers[ layer - 1 ] = macroLayerIndexStack[ macroLayerIndexStackSize - layer ];
    41e8:	1ad0      	subs	r0, r2, r3
    41ea:	a906      	add	r1, sp, #24
    41ec:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    41f0:	f834 0010 	ldrh.w	r0, [r4, r0, lsl #1]
    41f4:	f821 0c0c 	strh.w	r0, [r1, #-12]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    41f8:	3301      	adds	r3, #1
    41fa:	b29b      	uxth	r3, r3
    41fc:	e7dd      	b.n	41ba <LCD_layerStack_capability+0x56>
    41fe:	bf00      	nop
    4200:	0000c3d0 	.word	0x0000c3d0
    4204:	1fff930e 	.word	0x1fff930e
    4208:	1fff9308 	.word	0x1fff9308
    420c:	1fff92d8 	.word	0x1fff92d8
    4210:	1fff92da 	.word	0x1fff92da
    4214:	1fff9300 	.word	0x1fff9300
    4218:	0000cff0 	.word	0x0000cff0

0000421c <Connect_receive_Animation>:
	// Check whether the scan codes have finished sending
	return *pending_bytes == 0 ? 1 : 0;
}

uint8_t Connect_receive_Animation( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    421c:	b508      	push	{r3, lr}
	dbug_print("Animation");
    421e:	4802      	ldr	r0, [pc, #8]	; (4228 <Connect_receive_Animation+0xc>)
    4220:	f007 f8ee 	bl	b400 <_print>
	return 1;
}
    4224:	2001      	movs	r0, #1
    4226:	bd08      	pop	{r3, pc}
    4228:	0000c8d4 	.word	0x0000c8d4

0000422c <cliFunc_connectDbg>:
		break;
	}
}

void cliFunc_connectDbg( char* args )
{
    422c:	b508      	push	{r3, lr}
	print( NL );
    422e:	4806      	ldr	r0, [pc, #24]	; (4248 <cliFunc_connectDbg+0x1c>)
    4230:	f007 f8e6 	bl	b400 <_print>
	info_msg("Connect Debug Mode Toggle");
    4234:	4805      	ldr	r0, [pc, #20]	; (424c <cliFunc_connectDbg+0x20>)
    4236:	f007 f8e3 	bl	b400 <_print>
	Connect_debug = !Connect_debug;
    423a:	4a05      	ldr	r2, [pc, #20]	; (4250 <cliFunc_connectDbg+0x24>)
    423c:	7813      	ldrb	r3, [r2, #0]
    423e:	fab3 f383 	clz	r3, r3
    4242:	095b      	lsrs	r3, r3, #5
    4244:	7013      	strb	r3, [r2, #0]
}
    4246:	bd08      	pop	{r3, pc}
    4248:	00010d99 	.word	0x00010d99
    424c:	0000cb62 	.word	0x0000cb62
    4250:	1fff92fa 	.word	0x1fff92fa

00004254 <Connect_receive_CableCheck>:
{
    4254:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ( *pending_bytes == 0xFFFF )
    4256:	880b      	ldrh	r3, [r1, #0]
{
    4258:	4616      	mov	r6, r2
	if ( *pending_bytes == 0xFFFF )
    425a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    425e:	4293      	cmp	r3, r2
{
    4260:	4605      	mov	r5, r0
    4262:	460c      	mov	r4, r1
	if ( *pending_bytes == 0xFFFF )
    4264:	d135      	bne.n	42d2 <Connect_receive_CableCheck+0x7e>
		*pending_bytes = byte;
    4266:	b287      	uxth	r7, r0
		if ( Connect_debug )
    4268:	4b38      	ldr	r3, [pc, #224]	; (434c <Connect_receive_CableCheck+0xf8>)
		*pending_bytes = byte;
    426a:	800f      	strh	r7, [r1, #0]
		if ( Connect_debug )
    426c:	781b      	ldrb	r3, [r3, #0]
    426e:	b183      	cbz	r3, 4292 <Connect_receive_CableCheck+0x3e>
			dbug_msg("PENDING SET -> ");
    4270:	4837      	ldr	r0, [pc, #220]	; (4350 <Connect_receive_CableCheck+0xfc>)
    4272:	f007 f8c5 	bl	b400 <_print>
			printHex( byte );
    4276:	2101      	movs	r1, #1
    4278:	4638      	mov	r0, r7
    427a:	f007 f969 	bl	b550 <printHex_op>
			print(" ");
    427e:	4835      	ldr	r0, [pc, #212]	; (4354 <Connect_receive_CableCheck+0x100>)
    4280:	f007 f8be 	bl	b400 <_print>
			printHex( *pending_bytes );
    4284:	8820      	ldrh	r0, [r4, #0]
    4286:	2101      	movs	r1, #1
    4288:	f007 f962 	bl	b550 <printHex_op>
			print( NL );
    428c:	4832      	ldr	r0, [pc, #200]	; (4358 <Connect_receive_CableCheck+0x104>)
    428e:	f007 f8b7 	bl	b400 <_print>
	if ( *pending_bytes == 0 )
    4292:	8823      	ldrh	r3, [r4, #0]
    4294:	b923      	cbnz	r3, 42a0 <Connect_receive_CableCheck+0x4c>
    4296:	2301      	movs	r3, #1
		if ( uart_num == UART_Slave )
    4298:	2e00      	cmp	r6, #0
    429a:	d155      	bne.n	4348 <Connect_receive_CableCheck+0xf4>
			Connect_cableOkSlave = 1;
    429c:	4a2f      	ldr	r2, [pc, #188]	; (435c <Connect_receive_CableCheck+0x108>)
			Connect_cableOkMaster = 1;
    429e:	7013      	strb	r3, [r2, #0]
	if ( Connect_debug )
    42a0:	4b2a      	ldr	r3, [pc, #168]	; (434c <Connect_receive_CableCheck+0xf8>)
    42a2:	781b      	ldrb	r3, [r3, #0]
    42a4:	b183      	cbz	r3, 42c8 <Connect_receive_CableCheck+0x74>
		dbug_msg("CABLECHECK RECEIVE - ");
    42a6:	482e      	ldr	r0, [pc, #184]	; (4360 <Connect_receive_CableCheck+0x10c>)
    42a8:	f007 f8aa 	bl	b400 <_print>
		printHex( byte );
    42ac:	2101      	movs	r1, #1
    42ae:	4628      	mov	r0, r5
    42b0:	f007 f94e 	bl	b550 <printHex_op>
		print(" ");
    42b4:	4827      	ldr	r0, [pc, #156]	; (4354 <Connect_receive_CableCheck+0x100>)
    42b6:	f007 f8a3 	bl	b400 <_print>
		printHex( *pending_bytes );
    42ba:	8820      	ldrh	r0, [r4, #0]
    42bc:	2101      	movs	r1, #1
    42be:	f007 f947 	bl	b550 <printHex_op>
		print( NL );
    42c2:	4825      	ldr	r0, [pc, #148]	; (4358 <Connect_receive_CableCheck+0x104>)
    42c4:	f007 f89c 	bl	b400 <_print>
	return *pending_bytes == 0 ? 1 : 0;
    42c8:	8820      	ldrh	r0, [r4, #0]
    42ca:	fab0 f080 	clz	r0, r0
    42ce:	0940      	lsrs	r0, r0, #5
    42d0:	e018      	b.n	4304 <Connect_receive_CableCheck+0xb0>
		(*pending_bytes)--;
    42d2:	3b01      	subs	r3, #1
		if ( byte != 0xD2 )
    42d4:	28d2      	cmp	r0, #210	; 0xd2
		(*pending_bytes)--;
    42d6:	800b      	strh	r3, [r1, #0]
		if ( byte != 0xD2 )
    42d8:	d024      	beq.n	4324 <Connect_receive_CableCheck+0xd0>
			warn_print("Cable Fault!");
    42da:	4822      	ldr	r0, [pc, #136]	; (4364 <Connect_receive_CableCheck+0x110>)
    42dc:	f007 f890 	bl	b400 <_print>
			if ( uart_num == UART_Slave )
    42e0:	b98e      	cbnz	r6, 4306 <Connect_receive_CableCheck+0xb2>
				Connect_cableFaultsSlave++;
    42e2:	4a21      	ldr	r2, [pc, #132]	; (4368 <Connect_receive_CableCheck+0x114>)
				print(" Slave ");
    42e4:	4821      	ldr	r0, [pc, #132]	; (436c <Connect_receive_CableCheck+0x118>)
				Connect_cableFaultsSlave++;
    42e6:	6813      	ldr	r3, [r2, #0]
    42e8:	3301      	adds	r3, #1
    42ea:	6013      	str	r3, [r2, #0]
				Connect_cableOkSlave = 0;
    42ec:	4b1b      	ldr	r3, [pc, #108]	; (435c <Connect_receive_CableCheck+0x108>)
    42ee:	701e      	strb	r6, [r3, #0]
				print(" Master ");
    42f0:	f007 f886 	bl	b400 <_print>
			printHex( byte );
    42f4:	2101      	movs	r1, #1
    42f6:	4628      	mov	r0, r5
    42f8:	f007 f92a 	bl	b550 <printHex_op>
			print( NL );
    42fc:	4816      	ldr	r0, [pc, #88]	; (4358 <Connect_receive_CableCheck+0x104>)
    42fe:	f007 f87f 	bl	b400 <_print>
			return 1;
    4302:	2001      	movs	r0, #1
}
    4304:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if ( Connect_id != 0 )
    4306:	4b1a      	ldr	r3, [pc, #104]	; (4370 <Connect_receive_CableCheck+0x11c>)
    4308:	781b      	ldrb	r3, [r3, #0]
    430a:	b113      	cbz	r3, 4312 <Connect_receive_CableCheck+0xbe>
					Output_update_external_current( 100 );
    430c:	2064      	movs	r0, #100	; 0x64
    430e:	f004 fbf3 	bl	8af8 <Output_update_external_current>
				Connect_cableFaultsMaster++;
    4312:	4a18      	ldr	r2, [pc, #96]	; (4374 <Connect_receive_CableCheck+0x120>)
				print(" Master ");
    4314:	4818      	ldr	r0, [pc, #96]	; (4378 <Connect_receive_CableCheck+0x124>)
				Connect_cableFaultsMaster++;
    4316:	6813      	ldr	r3, [r2, #0]
    4318:	3301      	adds	r3, #1
    431a:	6013      	str	r3, [r2, #0]
				Connect_cableOkMaster = 0;
    431c:	4b17      	ldr	r3, [pc, #92]	; (437c <Connect_receive_CableCheck+0x128>)
    431e:	2200      	movs	r2, #0
    4320:	701a      	strb	r2, [r3, #0]
    4322:	e7e5      	b.n	42f0 <Connect_receive_CableCheck+0x9c>
			if ( uart_num == UART_Slave )
    4324:	b926      	cbnz	r6, 4330 <Connect_receive_CableCheck+0xdc>
				Connect_cableChecksSlave++;
    4326:	4a16      	ldr	r2, [pc, #88]	; (4380 <Connect_receive_CableCheck+0x12c>)
				Connect_cableChecksMaster++;
    4328:	6813      	ldr	r3, [r2, #0]
    432a:	3301      	adds	r3, #1
    432c:	6013      	str	r3, [r2, #0]
    432e:	e7b0      	b.n	4292 <Connect_receive_CableCheck+0x3e>
				if ( Connect_id != 255 && Connect_id != 0 )
    4330:	4b0f      	ldr	r3, [pc, #60]	; (4370 <Connect_receive_CableCheck+0x11c>)
    4332:	781b      	ldrb	r3, [r3, #0]
    4334:	3b01      	subs	r3, #1
    4336:	b2db      	uxtb	r3, r3
    4338:	2bfd      	cmp	r3, #253	; 0xfd
    433a:	d803      	bhi.n	4344 <Connect_receive_CableCheck+0xf0>
					Output_update_external_current( 500 );
    433c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    4340:	f004 fbda 	bl	8af8 <Output_update_external_current>
				Connect_cableChecksMaster++;
    4344:	4a0f      	ldr	r2, [pc, #60]	; (4384 <Connect_receive_CableCheck+0x130>)
    4346:	e7ef      	b.n	4328 <Connect_receive_CableCheck+0xd4>
			Connect_cableOkMaster = 1;
    4348:	4a0c      	ldr	r2, [pc, #48]	; (437c <Connect_receive_CableCheck+0x128>)
    434a:	e7a8      	b.n	429e <Connect_receive_CableCheck+0x4a>
    434c:	1fff92fa 	.word	0x1fff92fa
    4350:	0000c8f3 	.word	0x0000c8f3
    4354:	00011f77 	.word	0x00011f77
    4358:	00010d99 	.word	0x00010d99
    435c:	1fff92f9 	.word	0x1fff92f9
    4360:	0000c94b 	.word	0x0000c94b
    4364:	0000c916 	.word	0x0000c916
    4368:	1fff92f4 	.word	0x1fff92f4
    436c:	0000c93a 	.word	0x0000c93a
    4370:	1fff89fc 	.word	0x1fff89fc
    4374:	1fff92f0 	.word	0x1fff92f0
    4378:	0000c942 	.word	0x0000c942
    437c:	1fff92f8 	.word	0x1fff92f8
    4380:	1fff92ec 	.word	0x1fff92ec
    4384:	1fff92e8 	.word	0x1fff92e8

00004388 <cliFunc_connectLst>:

	Connect_send_Idle( count );
}

void cliFunc_connectLst( char* args )
{
    4388:	b5f0      	push	{r4, r5, r6, r7, lr}
	const char *Command_strs[] = {
    438a:	4d12      	ldr	r5, [pc, #72]	; (43d4 <cliFunc_connectLst+0x4c>)

	print( NL );
	info_msg("List of UARTConnect commands");
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
	{
		print( NL );
    438c:	4f12      	ldr	r7, [pc, #72]	; (43d8 <cliFunc_connectLst+0x50>)
		printInt8( cmd );
		print(" - ");
    438e:	4e13      	ldr	r6, [pc, #76]	; (43dc <cliFunc_connectLst+0x54>)
	const char *Command_strs[] = {
    4390:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    4392:	b08b      	sub	sp, #44	; 0x2c
	const char *Command_strs[] = {
    4394:	ac01      	add	r4, sp, #4
    4396:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4398:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    439a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    439c:	682b      	ldr	r3, [r5, #0]
	print( NL );
    439e:	480e      	ldr	r0, [pc, #56]	; (43d8 <cliFunc_connectLst+0x50>)
	const char *Command_strs[] = {
    43a0:	6023      	str	r3, [r4, #0]
	print( NL );
    43a2:	f007 f82d 	bl	b400 <_print>
	info_msg("List of UARTConnect commands");
    43a6:	480e      	ldr	r0, [pc, #56]	; (43e0 <cliFunc_connectLst+0x58>)
    43a8:	f007 f82a 	bl	b400 <_print>
    43ac:	2400      	movs	r4, #0
    43ae:	ad01      	add	r5, sp, #4
		print( NL );
    43b0:	4638      	mov	r0, r7
    43b2:	f007 f825 	bl	b400 <_print>
		printInt8( cmd );
    43b6:	b2e0      	uxtb	r0, r4
    43b8:	f007 f854 	bl	b464 <printInt8>
		print(" - ");
    43bc:	4630      	mov	r0, r6
    43be:	f007 f81f 	bl	b400 <_print>
		dPrint( (char*)Command_strs[ cmd ] );
    43c2:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    43c6:	3401      	adds	r4, #1
    43c8:	f004 fbe1 	bl	8b8e <Output_putstr>
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
    43cc:	2c09      	cmp	r4, #9
    43ce:	d1ef      	bne.n	43b0 <cliFunc_connectLst+0x28>
	}
}
    43d0:	b00b      	add	sp, #44	; 0x2c
    43d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    43d4:	0000c7e8 	.word	0x0000c7e8
    43d8:	00010d99 	.word	0x00010d99
    43dc:	0000bad4 	.word	0x0000bad4
    43e0:	0000cbb6 	.word	0x0000cbb6

000043e4 <cliFunc_connectSts>:
	// Reset node id
	Connect_id = 0xFF;
}

void cliFunc_connectSts( char* args )
{
    43e4:	b538      	push	{r3, r4, r5, lr}
	print( NL );
    43e6:	4839      	ldr	r0, [pc, #228]	; (44cc <cliFunc_connectSts+0xe8>)
	print( NL "\tFaults:\t");
	printHex32( Connect_cableFaultsMaster );
	print("/");
	printHex32( Connect_cableChecksMaster );
	print( NL "\tRx:\t");
	printHex( uart_rx_status[UART_Master].status );
    43e8:	4d39      	ldr	r5, [pc, #228]	; (44d0 <cliFunc_connectSts+0xec>)
	print( NL "\tTx:\t");
	printHex( uart_tx_status[UART_Master].status );
    43ea:	4c3a      	ldr	r4, [pc, #232]	; (44d4 <cliFunc_connectSts+0xf0>)
	print( NL );
    43ec:	f007 f808 	bl	b400 <_print>
	info_msg("UARTConnect Status");
    43f0:	4839      	ldr	r0, [pc, #228]	; (44d8 <cliFunc_connectSts+0xf4>)
    43f2:	f007 f805 	bl	b400 <_print>
	print( NL "Device Type:\t" );
    43f6:	4839      	ldr	r0, [pc, #228]	; (44dc <cliFunc_connectSts+0xf8>)
    43f8:	f007 f802 	bl	b400 <_print>
	print( Connect_master ? "Master" : "Slave" );
    43fc:	4b38      	ldr	r3, [pc, #224]	; (44e0 <cliFunc_connectSts+0xfc>)
    43fe:	4a39      	ldr	r2, [pc, #228]	; (44e4 <cliFunc_connectSts+0x100>)
    4400:	7818      	ldrb	r0, [r3, #0]
    4402:	4b39      	ldr	r3, [pc, #228]	; (44e8 <cliFunc_connectSts+0x104>)
    4404:	2800      	cmp	r0, #0
    4406:	bf14      	ite	ne
    4408:	4610      	movne	r0, r2
    440a:	4618      	moveq	r0, r3
    440c:	f006 fff8 	bl	b400 <_print>
	print( NL "Device Id:\t" );
    4410:	4836      	ldr	r0, [pc, #216]	; (44ec <cliFunc_connectSts+0x108>)
    4412:	f006 fff5 	bl	b400 <_print>
	printHex( Connect_id );
    4416:	4b36      	ldr	r3, [pc, #216]	; (44f0 <cliFunc_connectSts+0x10c>)
    4418:	2101      	movs	r1, #1
    441a:	7818      	ldrb	r0, [r3, #0]
    441c:	f007 f898 	bl	b550 <printHex_op>
	print( NL "Max Id:\t" );
    4420:	4834      	ldr	r0, [pc, #208]	; (44f4 <cliFunc_connectSts+0x110>)
    4422:	f006 ffed 	bl	b400 <_print>
	printHex( Connect_maxId );
    4426:	4b34      	ldr	r3, [pc, #208]	; (44f8 <cliFunc_connectSts+0x114>)
    4428:	2101      	movs	r1, #1
    442a:	7818      	ldrb	r0, [r3, #0]
    442c:	f007 f890 	bl	b550 <printHex_op>
	print( NL "Master <=" NL "\tStatus:\t");
    4430:	4832      	ldr	r0, [pc, #200]	; (44fc <cliFunc_connectSts+0x118>)
    4432:	f006 ffe5 	bl	b400 <_print>
	printHex( Connect_cableOkMaster );
    4436:	4b32      	ldr	r3, [pc, #200]	; (4500 <cliFunc_connectSts+0x11c>)
    4438:	2101      	movs	r1, #1
    443a:	7818      	ldrb	r0, [r3, #0]
    443c:	f007 f888 	bl	b550 <printHex_op>
	print( NL "\tFaults:\t");
    4440:	4830      	ldr	r0, [pc, #192]	; (4504 <cliFunc_connectSts+0x120>)
    4442:	f006 ffdd 	bl	b400 <_print>
	printHex32( Connect_cableFaultsMaster );
    4446:	4b30      	ldr	r3, [pc, #192]	; (4508 <cliFunc_connectSts+0x124>)
    4448:	2101      	movs	r1, #1
    444a:	6818      	ldr	r0, [r3, #0]
    444c:	f007 f8b8 	bl	b5c0 <printHex32_op>
	print("/");
    4450:	482e      	ldr	r0, [pc, #184]	; (450c <cliFunc_connectSts+0x128>)
    4452:	f006 ffd5 	bl	b400 <_print>
	printHex32( Connect_cableChecksMaster );
    4456:	4b2e      	ldr	r3, [pc, #184]	; (4510 <cliFunc_connectSts+0x12c>)
    4458:	2101      	movs	r1, #1
    445a:	6818      	ldr	r0, [r3, #0]
    445c:	f007 f8b0 	bl	b5c0 <printHex32_op>
	print( NL "\tRx:\t");
    4460:	482c      	ldr	r0, [pc, #176]	; (4514 <cliFunc_connectSts+0x130>)
    4462:	f006 ffcd 	bl	b400 <_print>
	printHex( uart_rx_status[UART_Master].status );
    4466:	7928      	ldrb	r0, [r5, #4]
    4468:	2101      	movs	r1, #1
    446a:	f007 f871 	bl	b550 <printHex_op>
	print( NL "\tTx:\t");
    446e:	482a      	ldr	r0, [pc, #168]	; (4518 <cliFunc_connectSts+0x134>)
    4470:	f006 ffc6 	bl	b400 <_print>
	printHex( uart_tx_status[UART_Master].status );
    4474:	2101      	movs	r1, #1
    4476:	78a0      	ldrb	r0, [r4, #2]
    4478:	f007 f86a 	bl	b550 <printHex_op>
	print( NL "Slave <=" NL "\tStatus:\t");
    447c:	4827      	ldr	r0, [pc, #156]	; (451c <cliFunc_connectSts+0x138>)
    447e:	f006 ffbf 	bl	b400 <_print>
	printHex( Connect_cableOkSlave );
    4482:	4b27      	ldr	r3, [pc, #156]	; (4520 <cliFunc_connectSts+0x13c>)
    4484:	2101      	movs	r1, #1
    4486:	7818      	ldrb	r0, [r3, #0]
    4488:	f007 f862 	bl	b550 <printHex_op>
	print( NL "\tFaults:\t");
    448c:	481d      	ldr	r0, [pc, #116]	; (4504 <cliFunc_connectSts+0x120>)
    448e:	f006 ffb7 	bl	b400 <_print>
	printHex32( Connect_cableFaultsSlave );
    4492:	4b24      	ldr	r3, [pc, #144]	; (4524 <cliFunc_connectSts+0x140>)
    4494:	2101      	movs	r1, #1
    4496:	6818      	ldr	r0, [r3, #0]
    4498:	f007 f892 	bl	b5c0 <printHex32_op>
	print("/");
    449c:	481b      	ldr	r0, [pc, #108]	; (450c <cliFunc_connectSts+0x128>)
    449e:	f006 ffaf 	bl	b400 <_print>
	printHex32( Connect_cableChecksSlave );
    44a2:	4b21      	ldr	r3, [pc, #132]	; (4528 <cliFunc_connectSts+0x144>)
    44a4:	2101      	movs	r1, #1
    44a6:	6818      	ldr	r0, [r3, #0]
    44a8:	f007 f88a 	bl	b5c0 <printHex32_op>
	print( NL "\tRx:\t");
    44ac:	4819      	ldr	r0, [pc, #100]	; (4514 <cliFunc_connectSts+0x130>)
    44ae:	f006 ffa7 	bl	b400 <_print>
	printHex( uart_rx_status[UART_Slave].status );
    44b2:	7828      	ldrb	r0, [r5, #0]
    44b4:	2101      	movs	r1, #1
    44b6:	f007 f84b 	bl	b550 <printHex_op>
	print( NL "\tTx:\t");
    44ba:	4817      	ldr	r0, [pc, #92]	; (4518 <cliFunc_connectSts+0x134>)
    44bc:	f006 ffa0 	bl	b400 <_print>
	printHex( uart_tx_status[UART_Slave].status );
    44c0:	7820      	ldrb	r0, [r4, #0]
    44c2:	2101      	movs	r1, #1
}
    44c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	printHex( uart_tx_status[UART_Slave].status );
    44c8:	f007 b842 	b.w	b550 <printHex_op>
    44cc:	00010d99 	.word	0x00010d99
    44d0:	1fff9df0 	.word	0x1fff9df0
    44d4:	1fff9dd2 	.word	0x1fff9dd2
    44d8:	0000cc7a 	.word	0x0000cc7a
    44dc:	0000cc9f 	.word	0x0000cc9f
    44e0:	1fff9300 	.word	0x1fff9300
    44e4:	0000cc6d 	.word	0x0000cc6d
    44e8:	0000cc74 	.word	0x0000cc74
    44ec:	0000ccaf 	.word	0x0000ccaf
    44f0:	1fff89fc 	.word	0x1fff89fc
    44f4:	0000ccbd 	.word	0x0000ccbd
    44f8:	1fff9301 	.word	0x1fff9301
    44fc:	0000ccc8 	.word	0x0000ccc8
    4500:	1fff92f8 	.word	0x1fff92f8
    4504:	0000ccdf 	.word	0x0000ccdf
    4508:	1fff92f0 	.word	0x1fff92f0
    450c:	0000b857 	.word	0x0000b857
    4510:	1fff92e8 	.word	0x1fff92e8
    4514:	0000cceb 	.word	0x0000cceb
    4518:	0000ccf3 	.word	0x0000ccf3
    451c:	0000ccfb 	.word	0x0000ccfb
    4520:	1fff92f9 	.word	0x1fff92f9
    4524:	1fff92f4 	.word	0x1fff92f4
    4528:	1fff92ec 	.word	0x1fff92ec

0000452c <cliFunc_connectMst>:
{
    452c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    452e:	aa01      	add	r2, sp, #4
    4530:	4669      	mov	r1, sp
    4532:	f006 fb5d 	bl	abf0 <CLI_argumentIsolation>
	print( NL );
    4536:	4813      	ldr	r0, [pc, #76]	; (4584 <cliFunc_connectMst+0x58>)
    4538:	4d13      	ldr	r5, [pc, #76]	; (4588 <cliFunc_connectMst+0x5c>)
    453a:	4c14      	ldr	r4, [pc, #80]	; (458c <cliFunc_connectMst+0x60>)
    453c:	f006 ff60 	bl	b400 <_print>
	Connect_override = 1;
    4540:	4b13      	ldr	r3, [pc, #76]	; (4590 <cliFunc_connectMst+0x64>)
    4542:	2201      	movs	r2, #1
    4544:	701a      	strb	r2, [r3, #0]
	switch ( arg1Ptr[0] )
    4546:	9a00      	ldr	r2, [sp, #0]
    4548:	7812      	ldrb	r2, [r2, #0]
    454a:	2a53      	cmp	r2, #83	; 0x53
    454c:	d00d      	beq.n	456a <cliFunc_connectMst+0x3e>
    454e:	d808      	bhi.n	4562 <cliFunc_connectMst+0x36>
    4550:	2a44      	cmp	r2, #68	; 0x44
    4552:	d013      	beq.n	457c <cliFunc_connectMst+0x50>
		info_msg("Setting device as master.");
    4554:	480f      	ldr	r0, [pc, #60]	; (4594 <cliFunc_connectMst+0x68>)
    4556:	f006 ff53 	bl	b400 <_print>
		Connect_master = 1;
    455a:	2301      	movs	r3, #1
    455c:	702b      	strb	r3, [r5, #0]
		Connect_id = 0;
    455e:	2300      	movs	r3, #0
    4560:	e009      	b.n	4576 <cliFunc_connectMst+0x4a>
	switch ( arg1Ptr[0] )
    4562:	2a64      	cmp	r2, #100	; 0x64
    4564:	d00a      	beq.n	457c <cliFunc_connectMst+0x50>
    4566:	2a73      	cmp	r2, #115	; 0x73
    4568:	d1f4      	bne.n	4554 <cliFunc_connectMst+0x28>
		info_msg("Setting device as slave.");
    456a:	480b      	ldr	r0, [pc, #44]	; (4598 <cliFunc_connectMst+0x6c>)
    456c:	f006 ff48 	bl	b400 <_print>
		Connect_master = 0;
    4570:	2300      	movs	r3, #0
    4572:	702b      	strb	r3, [r5, #0]
		Connect_id = 0xFF;
    4574:	23ff      	movs	r3, #255	; 0xff
		Connect_id = 0;
    4576:	7023      	strb	r3, [r4, #0]
}
    4578:	b003      	add	sp, #12
    457a:	bd30      	pop	{r4, r5, pc}
		Connect_override = 0;
    457c:	2200      	movs	r2, #0
    457e:	701a      	strb	r2, [r3, #0]
    4580:	e7f3      	b.n	456a <cliFunc_connectMst+0x3e>
    4582:	bf00      	nop
    4584:	00010d99 	.word	0x00010d99
    4588:	1fff9300 	.word	0x1fff9300
    458c:	1fff89fc 	.word	0x1fff89fc
    4590:	1fff9302 	.word	0x1fff9302
    4594:	0000cc10 	.word	0x0000cc10
    4598:	0000cbe5 	.word	0x0000cbe5

0000459c <Connect_addBytes.part.1>:
void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    459c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    45a0:	4f28      	ldr	r7, [pc, #160]	; (4644 <Connect_addBytes.part.1+0xa8>)
    45a2:	2483      	movs	r4, #131	; 0x83
void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    45a4:	4605      	mov	r5, r0
    45a6:	4688      	mov	r8, r1
    45a8:	4616      	mov	r6, r2
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    45aa:	fb04 7402 	mla	r4, r4, r2, r7
    45ae:	78a3      	ldrb	r3, [r4, #2]
    45b0:	4443      	add	r3, r8
    45b2:	2b80      	cmp	r3, #128	; 0x80
    45b4:	dc08      	bgt.n	45c8 <Connect_addBytes.part.1+0x2c>
		uart_tx_buf[ uart ].buffer[ uart_tx_buf[ uart ].tail++ ] = buffer[ c ];
    45b6:	f04f 0983 	mov.w	r9, #131	; 0x83
    45ba:	44a8      	add	r8, r5
    45bc:	fb09 7406 	mla	r4, r9, r6, r7
	for ( uint8_t c = 0; c < count; c++ )
    45c0:	45a8      	cmp	r8, r5
    45c2:	d10e      	bne.n	45e2 <Connect_addBytes.part.1+0x46>
}
    45c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		warn_msg("Too much data to send on UART");
    45c8:	481f      	ldr	r0, [pc, #124]	; (4648 <Connect_addBytes.part.1+0xac>)
    45ca:	f006 ff19 	bl	b400 <_print>
		printInt8( uart );
    45ce:	4630      	mov	r0, r6
    45d0:	f006 ff48 	bl	b464 <printInt8>
		print( ", waiting..." NL );
    45d4:	481d      	ldr	r0, [pc, #116]	; (464c <Connect_addBytes.part.1+0xb0>)
    45d6:	f006 ff13 	bl	b400 <_print>
		delay_ms( 1 );
    45da:	2001      	movs	r0, #1
    45dc:	f7fe f876 	bl	26cc <delay_ms>
    45e0:	e7e5      	b.n	45ae <Connect_addBytes.part.1+0x12>
		if ( Connect_debug )
    45e2:	4b1b      	ldr	r3, [pc, #108]	; (4650 <Connect_addBytes.part.1+0xb4>)
    45e4:	781b      	ldrb	r3, [r3, #0]
    45e6:	b163      	cbz	r3, 4602 <Connect_addBytes.part.1+0x66>
			printHex( buffer[ c ] );
    45e8:	2101      	movs	r1, #1
    45ea:	7828      	ldrb	r0, [r5, #0]
    45ec:	f006 ffb0 	bl	b550 <printHex_op>
			print(" +");
    45f0:	4818      	ldr	r0, [pc, #96]	; (4654 <Connect_addBytes.part.1+0xb8>)
    45f2:	f006 ff05 	bl	b400 <_print>
			printInt8( uart );
    45f6:	4630      	mov	r0, r6
    45f8:	f006 ff34 	bl	b464 <printInt8>
			print( NL );
    45fc:	4816      	ldr	r0, [pc, #88]	; (4658 <Connect_addBytes.part.1+0xbc>)
    45fe:	f006 feff 	bl	b400 <_print>
		uart_tx_buf[ uart ].buffer[ uart_tx_buf[ uart ].tail++ ] = buffer[ c ];
    4602:	7862      	ldrb	r2, [r4, #1]
    4604:	1c53      	adds	r3, r2, #1
    4606:	b2db      	uxtb	r3, r3
    4608:	7063      	strb	r3, [r4, #1]
    460a:	4422      	add	r2, r4
    460c:	f815 1b01 	ldrb.w	r1, [r5], #1
    4610:	70d1      	strb	r1, [r2, #3]
		uart_tx_buf[ uart ].items++;
    4612:	78a2      	ldrb	r2, [r4, #2]
		if ( uart_tx_buf[ uart ].tail >= UART_Buffer_Size )
    4614:	061b      	lsls	r3, r3, #24
		uart_tx_buf[ uart ].items++;
    4616:	f102 0201 	add.w	r2, r2, #1
			uart_tx_buf[ uart ].tail = 0;
    461a:	bf48      	it	mi
    461c:	2300      	movmi	r3, #0
		uart_tx_buf[ uart ].items++;
    461e:	70a2      	strb	r2, [r4, #2]
		if ( uart_tx_buf[ uart ].head == uart_tx_buf[ uart ].tail )
    4620:	fb09 f206 	mul.w	r2, r9, r6
			uart_tx_buf[ uart ].tail = 0;
    4624:	bf48      	it	mi
    4626:	7063      	strbmi	r3, [r4, #1]
		if ( uart_tx_buf[ uart ].head == uart_tx_buf[ uart ].tail )
    4628:	18bb      	adds	r3, r7, r2
    462a:	5cb9      	ldrb	r1, [r7, r2]
    462c:	785b      	ldrb	r3, [r3, #1]
    462e:	428b      	cmp	r3, r1
			uart_tx_buf[ uart ].head++;
    4630:	bf04      	itt	eq
    4632:	3301      	addeq	r3, #1
    4634:	54bb      	strbeq	r3, [r7, r2]
		if ( uart_tx_buf[ uart ].head >= UART_Buffer_Size )
    4636:	f994 3000 	ldrsb.w	r3, [r4]
    463a:	2b00      	cmp	r3, #0
			uart_tx_buf[ uart ].head = 0;
    463c:	bfbc      	itt	lt
    463e:	2300      	movlt	r3, #0
    4640:	7023      	strblt	r3, [r4, #0]
    4642:	e7bd      	b.n	45c0 <Connect_addBytes.part.1+0x24>
    4644:	1fff9cc6 	.word	0x1fff9cc6
    4648:	0000c817 	.word	0x0000c817
    464c:	0000c84a 	.word	0x0000c84a
    4650:	1fff92fa 	.word	0x1fff92fa
    4654:	0000c859 	.word	0x0000c859
    4658:	00010d99 	.word	0x00010d99

0000465c <Connect_receive_ScanCode>:
{
    465c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if ( uart_num == UART_Master )
    465e:	2a01      	cmp	r2, #1
{
    4660:	460d      	mov	r5, r1
    4662:	f88d 0007 	strb.w	r0, [sp, #7]
	if ( uart_num == UART_Master )
    4666:	d102      	bne.n	466e <Connect_receive_ScanCode+0x12>
		erro_print("Invalid ScanCode direction...");
    4668:	484f      	ldr	r0, [pc, #316]	; (47a8 <Connect_receive_ScanCode+0x14c>)
    466a:	f006 fec9 	bl	b400 <_print>
    466e:	882a      	ldrh	r2, [r5, #0]
	if ( Connect_master ) switch ( (*pending_bytes)-- )
    4670:	494e      	ldr	r1, [pc, #312]	; (47ac <Connect_receive_ScanCode+0x150>)
    4672:	1e53      	subs	r3, r2, #1
    4674:	7809      	ldrb	r1, [r1, #0]
    4676:	b29b      	uxth	r3, r3
    4678:	f64f 70fe 	movw	r0, #65534	; 0xfffe
    467c:	802b      	strh	r3, [r5, #0]
    467e:	2900      	cmp	r1, #0
    4680:	d055      	beq.n	472e <Connect_receive_ScanCode+0xd2>
    4682:	4282      	cmp	r2, r0
    4684:	f89d 3007 	ldrb.w	r3, [sp, #7]
    4688:	d00b      	beq.n	46a2 <Connect_receive_ScanCode+0x46>
    468a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    468e:	428a      	cmp	r2, r1
    4690:	d10e      	bne.n	46b0 <Connect_receive_ScanCode+0x54>
		Connect_receive_ScanCodeDeviceId = byte;
    4692:	4a47      	ldr	r2, [pc, #284]	; (47b0 <Connect_receive_ScanCode+0x154>)
    4694:	7013      	strb	r3, [r2, #0]
	return *pending_bytes == 0 ? 1 : 0;
    4696:	8828      	ldrh	r0, [r5, #0]
}
    4698:	fab0 f080 	clz	r0, r0
    469c:	0940      	lsrs	r0, r0, #5
    469e:	b004      	add	sp, #16
    46a0:	bd70      	pop	{r4, r5, r6, pc}
		*pending_bytes = byte * sizeof( TriggerGuide );
    46a2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    46a6:	802b      	strh	r3, [r5, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    46a8:	4b42      	ldr	r3, [pc, #264]	; (47b4 <Connect_receive_ScanCode+0x158>)
    46aa:	2200      	movs	r2, #0
    46ac:	701a      	strb	r2, [r3, #0]
		break;
    46ae:	e7f2      	b.n	4696 <Connect_receive_ScanCode+0x3a>
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    46b0:	4940      	ldr	r1, [pc, #256]	; (47b4 <Connect_receive_ScanCode+0x158>)
    46b2:	4c41      	ldr	r4, [pc, #260]	; (47b8 <Connect_receive_ScanCode+0x15c>)
    46b4:	7808      	ldrb	r0, [r1, #0]
    46b6:	1c42      	adds	r2, r0, #1
    46b8:	b2d2      	uxtb	r2, r2
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    46ba:	2a02      	cmp	r2, #2
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    46bc:	700a      	strb	r2, [r1, #0]
    46be:	5503      	strb	r3, [r0, r4]
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    46c0:	d9e9      	bls.n	4696 <Connect_receive_ScanCode+0x3a>
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    46c2:	4e3b      	ldr	r6, [pc, #236]	; (47b0 <Connect_receive_ScanCode+0x154>)
    46c4:	7832      	ldrb	r2, [r6, #0]
			Connect_receive_ScanCodeBufferPos = 0;
    46c6:	2300      	movs	r3, #0
    46c8:	700b      	strb	r3, [r1, #0]
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    46ca:	b18a      	cbz	r2, 46f0 <Connect_receive_ScanCode+0x94>
				if ( Connect_receive_ScanCodeDeviceId >= InterconnectNodeMax )
    46cc:	2a02      	cmp	r2, #2
    46ce:	d90a      	bls.n	46e6 <Connect_receive_ScanCode+0x8a>
					warn_msg("Not enough interconnect layout nodes configured: ");
    46d0:	483a      	ldr	r0, [pc, #232]	; (47bc <Connect_receive_ScanCode+0x160>)
    46d2:	f006 fe95 	bl	b400 <_print>
					printHex( Connect_receive_ScanCodeDeviceId );
    46d6:	7830      	ldrb	r0, [r6, #0]
    46d8:	2101      	movs	r1, #1
    46da:	f006 ff39 	bl	b550 <printHex_op>
					print( NL );
    46de:	4838      	ldr	r0, [pc, #224]	; (47c0 <Connect_receive_ScanCode+0x164>)
    46e0:	f006 fe8e 	bl	b400 <_print>
					break;
    46e4:	e7d7      	b.n	4696 <Connect_receive_ScanCode+0x3a>
				Connect_receive_ScanCodeBuffer.scanCode = Connect_receive_ScanCodeBuffer.scanCode + InterconnectOffsetList[ Connect_receive_ScanCodeDeviceId ];
    46e6:	4937      	ldr	r1, [pc, #220]	; (47c4 <Connect_receive_ScanCode+0x168>)
    46e8:	78a3      	ldrb	r3, [r4, #2]
    46ea:	5c8a      	ldrb	r2, [r1, r2]
    46ec:	4413      	add	r3, r2
    46ee:	70a3      	strb	r3, [r4, #2]
			if ( Connect_debug )
    46f0:	4b35      	ldr	r3, [pc, #212]	; (47c8 <Connect_receive_ScanCode+0x16c>)
    46f2:	781b      	ldrb	r3, [r3, #0]
    46f4:	b1bb      	cbz	r3, 4726 <Connect_receive_ScanCode+0xca>
				dbug_msg("");
    46f6:	4835      	ldr	r0, [pc, #212]	; (47cc <Connect_receive_ScanCode+0x170>)
    46f8:	f006 fe82 	bl	b400 <_print>
				printHex( Connect_receive_ScanCodeBuffer.type );
    46fc:	2101      	movs	r1, #1
    46fe:	7820      	ldrb	r0, [r4, #0]
    4700:	f006 ff26 	bl	b550 <printHex_op>
				print(" ");
    4704:	4832      	ldr	r0, [pc, #200]	; (47d0 <Connect_receive_ScanCode+0x174>)
    4706:	f006 fe7b 	bl	b400 <_print>
				printHex( Connect_receive_ScanCodeBuffer.state );
    470a:	2101      	movs	r1, #1
    470c:	7860      	ldrb	r0, [r4, #1]
    470e:	f006 ff1f 	bl	b550 <printHex_op>
				print(" ");
    4712:	482f      	ldr	r0, [pc, #188]	; (47d0 <Connect_receive_ScanCode+0x174>)
    4714:	f006 fe74 	bl	b400 <_print>
				printHex( Connect_receive_ScanCodeBuffer.scanCode );
    4718:	78a0      	ldrb	r0, [r4, #2]
    471a:	2101      	movs	r1, #1
    471c:	f006 ff18 	bl	b550 <printHex_op>
				print( NL );
    4720:	4827      	ldr	r0, [pc, #156]	; (47c0 <Connect_receive_ScanCode+0x164>)
    4722:	f006 fe6d 	bl	b400 <_print>
			Macro_pressReleaseAdd( &Connect_receive_ScanCodeBuffer );
    4726:	4824      	ldr	r0, [pc, #144]	; (47b8 <Connect_receive_ScanCode+0x15c>)
    4728:	f001 faf0 	bl	5d0c <Macro_pressReleaseAdd>
    472c:	e7b3      	b.n	4696 <Connect_receive_ScanCode+0x3a>
	else switch ( (*pending_bytes)-- )
    472e:	4282      	cmp	r2, r0
    4730:	d01f      	beq.n	4772 <Connect_receive_ScanCode+0x116>
    4732:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4736:	429a      	cmp	r2, r3
    4738:	d126      	bne.n	4788 <Connect_receive_ScanCode+0x12c>
		Connect_receive_ScanCodeDeviceId = byte;
    473a:	4b1d      	ldr	r3, [pc, #116]	; (47b0 <Connect_receive_ScanCode+0x154>)
    473c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    4740:	701a      	strb	r2, [r3, #0]
		uart_lockTx( UART_Master );
    4742:	4b24      	ldr	r3, [pc, #144]	; (47d4 <Connect_receive_ScanCode+0x178>)
    4744:	78d9      	ldrb	r1, [r3, #3]
    4746:	2900      	cmp	r1, #0
    4748:	d1fd      	bne.n	4746 <Connect_receive_ScanCode+0xea>
    474a:	2101      	movs	r1, #1
    474c:	70d9      	strb	r1, [r3, #3]
    474e:	7899      	ldrb	r1, [r3, #2]
    4750:	2904      	cmp	r1, #4
    4752:	d1fd      	bne.n	4750 <Connect_receive_ScanCode+0xf4>
    4754:	2000      	movs	r0, #0
    4756:	7098      	strb	r0, [r3, #2]
		uint8_t header[] = { 0x16, 0x01, ScanCode, byte };
    4758:	f44f 738b 	mov.w	r3, #278	; 0x116
    475c:	f88d 200f 	strb.w	r2, [sp, #15]
    4760:	f8ad 300c 	strh.w	r3, [sp, #12]
    4764:	f88d 100e 	strb.w	r1, [sp, #14]
    4768:	2201      	movs	r2, #1
    476a:	a803      	add	r0, sp, #12
    476c:	f7ff ff16 	bl	459c <Connect_addBytes.part.1>
    4770:	e791      	b.n	4696 <Connect_receive_ScanCode+0x3a>
		*pending_bytes = byte * sizeof( TriggerGuide );
    4772:	a804      	add	r0, sp, #16
    4774:	2201      	movs	r2, #1
    4776:	f810 3d09 	ldrb.w	r3, [r0, #-9]!
    477a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    477e:	802b      	strh	r3, [r5, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    4780:	4b0c      	ldr	r3, [pc, #48]	; (47b4 <Connect_receive_ScanCode+0x158>)
    4782:	7019      	strb	r1, [r3, #0]
    4784:	4611      	mov	r1, r2
    4786:	e7f1      	b.n	476c <Connect_receive_ScanCode+0x110>
    4788:	2201      	movs	r2, #1
    478a:	4611      	mov	r1, r2
    478c:	f10d 0007 	add.w	r0, sp, #7
    4790:	f7ff ff04 	bl	459c <Connect_addBytes.part.1>
		if ( *pending_bytes == 0 )
    4794:	882a      	ldrh	r2, [r5, #0]
    4796:	2a00      	cmp	r2, #0
    4798:	f47f af7d 	bne.w	4696 <Connect_receive_ScanCode+0x3a>
			uart_unlockTx( UART_Master );
    479c:	4b0d      	ldr	r3, [pc, #52]	; (47d4 <Connect_receive_ScanCode+0x178>)
    479e:	2104      	movs	r1, #4
    47a0:	7099      	strb	r1, [r3, #2]
    47a2:	70da      	strb	r2, [r3, #3]
    47a4:	e777      	b.n	4696 <Connect_receive_ScanCode+0x3a>
    47a6:	bf00      	nop
    47a8:	0000ca64 	.word	0x0000ca64
    47ac:	1fff9300 	.word	0x1fff9300
    47b0:	1fff9def 	.word	0x1fff9def
    47b4:	1fff9eff 	.word	0x1fff9eff
    47b8:	1fff9efc 	.word	0x1fff9efc
    47bc:	0000ca99 	.word	0x0000ca99
    47c0:	00010d99 	.word	0x00010d99
    47c4:	0000d098 	.word	0x0000d098
    47c8:	1fff92fa 	.word	0x1fff92fa
    47cc:	0000cae0 	.word	0x0000cae0
    47d0:	00011f77 	.word	0x00011f77
    47d4:	1fff9dd2 	.word	0x1fff9dd2

000047d8 <Connect_addBytes>:
	if ( count > UART_Buffer_Size )
    47d8:	2980      	cmp	r1, #128	; 0x80
    47da:	d902      	bls.n	47e2 <Connect_addBytes+0xa>
		erro_msg("Too big of a command to fit into the buffer...");
    47dc:	4804      	ldr	r0, [pc, #16]	; (47f0 <Connect_addBytes+0x18>)
		erro_print("Invalid UART to send from...");
    47de:	f006 be0f 	b.w	b400 <_print>
	if ( uart >= UART_Num_Interfaces )
    47e2:	2a01      	cmp	r2, #1
    47e4:	d801      	bhi.n	47ea <Connect_addBytes+0x12>
    47e6:	f7ff bed9 	b.w	459c <Connect_addBytes.part.1>
		erro_print("Invalid UART to send from...");
    47ea:	4802      	ldr	r0, [pc, #8]	; (47f4 <Connect_addBytes+0x1c>)
    47ec:	e7f7      	b.n	47de <Connect_addBytes+0x6>
    47ee:	bf00      	nop
    47f0:	0000c85c 	.word	0x0000c85c
    47f4:	0000c8a0 	.word	0x0000c8a0

000047f8 <Connect_receive_RemoteCapability>:
	switch ( (*pending_bytes)-- )
    47f8:	880b      	ldrh	r3, [r1, #0]
{
    47fa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    47fc:	4616      	mov	r6, r2
	switch ( (*pending_bytes)-- )
    47fe:	1e5a      	subs	r2, r3, #1
    4800:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
    4804:	b292      	uxth	r2, r2
    4806:	3bfb      	subs	r3, #251	; 0xfb
{
    4808:	460f      	mov	r7, r1
	switch ( (*pending_bytes)-- )
    480a:	800a      	strh	r2, [r1, #0]
    480c:	4c38      	ldr	r4, [pc, #224]	; (48f0 <Connect_receive_RemoteCapability+0xf8>)
    480e:	2b04      	cmp	r3, #4
    4810:	d814      	bhi.n	483c <Connect_receive_RemoteCapability+0x44>
    4812:	e8df f003 	tbb	[pc, r3]
    4816:	0e10      	.short	0x0e10
    4818:	0a0c      	.short	0x0a0c
    481a:	03          	.byte	0x03
    481b:	00          	.byte	0x00
		Connect_receive_RemoteCapabilityBuffer.id = byte;
    481c:	7060      	strb	r0, [r4, #1]
	return *pending_bytes == 0 ? 1 : 0;
    481e:	8838      	ldrh	r0, [r7, #0]
}
    4820:	fab0 f080 	clz	r0, r0
    4824:	0940      	lsrs	r0, r0, #5
    4826:	b003      	add	sp, #12
    4828:	bdf0      	pop	{r4, r5, r6, r7, pc}
		Connect_receive_RemoteCapabilityBuffer.capabilityIndex = byte;
    482a:	70a0      	strb	r0, [r4, #2]
		break;
    482c:	e7f7      	b.n	481e <Connect_receive_RemoteCapability+0x26>
		Connect_receive_RemoteCapabilityBuffer.state = byte;
    482e:	70e0      	strb	r0, [r4, #3]
		break;
    4830:	e7f5      	b.n	481e <Connect_receive_RemoteCapability+0x26>
		Connect_receive_RemoteCapabilityBuffer.stateType = byte;
    4832:	7120      	strb	r0, [r4, #4]
		break;
    4834:	e7f3      	b.n	481e <Connect_receive_RemoteCapability+0x26>
		Connect_receive_RemoteCapabilityBuffer.numArgs = byte;
    4836:	7160      	strb	r0, [r4, #5]
		*pending_bytes = byte;
    4838:	8038      	strh	r0, [r7, #0]
		break;
    483a:	e7f0      	b.n	481e <Connect_receive_RemoteCapability+0x26>
			Connect_receive_RemoteCapabilityBuffer.numArgs - *pending_bytes + 1
    483c:	7963      	ldrb	r3, [r4, #5]
    483e:	1a9b      	subs	r3, r3, r2
		] = byte;
    4840:	4a2c      	ldr	r2, [pc, #176]	; (48f4 <Connect_receive_RemoteCapability+0xfc>)
    4842:	441a      	add	r2, r3
    4844:	7050      	strb	r0, [r2, #1]
		if ( *pending_bytes == 0 )
    4846:	883b      	ldrh	r3, [r7, #0]
    4848:	2b00      	cmp	r3, #0
    484a:	d1e8      	bne.n	481e <Connect_receive_RemoteCapability+0x26>
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
    484c:	7863      	ldrb	r3, [r4, #1]
    484e:	2bff      	cmp	r3, #255	; 0xff
    4850:	d003      	beq.n	485a <Connect_receive_RemoteCapability+0x62>
				|| Connect_receive_RemoteCapabilityBuffer.id == Connect_id )
    4852:	4a29      	ldr	r2, [pc, #164]	; (48f8 <Connect_receive_RemoteCapability+0x100>)
    4854:	7812      	ldrb	r2, [r2, #0]
    4856:	429a      	cmp	r2, r3
    4858:	d108      	bne.n	486c <Connect_receive_RemoteCapability+0x74>
							Connect_receive_RemoteCapabilityBuffer.capabilityIndex
    485a:	78a2      	ldrb	r2, [r4, #2]
				capability(
    485c:	4b27      	ldr	r3, [pc, #156]	; (48fc <Connect_receive_RemoteCapability+0x104>)
    485e:	78e1      	ldrb	r1, [r4, #3]
    4860:	f853 5032 	ldr.w	r5, [r3, r2, lsl #3]
    4864:	4b26      	ldr	r3, [pc, #152]	; (4900 <Connect_receive_RemoteCapability+0x108>)
    4866:	7922      	ldrb	r2, [r4, #4]
    4868:	2000      	movs	r0, #0
    486a:	47a8      	blx	r5
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
    486c:	7863      	ldrb	r3, [r4, #1]
    486e:	2bff      	cmp	r3, #255	; 0xff
    4870:	d003      	beq.n	487a <Connect_receive_RemoteCapability+0x82>
				|| Connect_receive_RemoteCapabilityBuffer.id != Connect_id )
    4872:	4a21      	ldr	r2, [pc, #132]	; (48f8 <Connect_receive_RemoteCapability+0x100>)
    4874:	7812      	ldrb	r2, [r2, #0]
    4876:	429a      	cmp	r2, r3
    4878:	d0d1      	beq.n	481e <Connect_receive_RemoteCapability+0x26>
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    487a:	f116 36ff 	adds.w	r6, r6, #4294967295	; 0xffffffff
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    487e:	f04f 0306 	mov.w	r3, #6
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    4882:	bf18      	it	ne
    4884:	2601      	movne	r6, #1
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    4886:	7023      	strb	r3, [r4, #0]
    4888:	4d1e      	ldr	r5, [pc, #120]	; (4904 <Connect_receive_RemoteCapability+0x10c>)
				switch ( uart_direction )
    488a:	b316      	cbz	r6, 48d2 <Connect_receive_RemoteCapability+0xda>
				case UART_Master: uart_lockTx( UART_Master ); break;
    488c:	78eb      	ldrb	r3, [r5, #3]
    488e:	2b00      	cmp	r3, #0
    4890:	d1fd      	bne.n	488e <Connect_receive_RemoteCapability+0x96>
    4892:	2301      	movs	r3, #1
    4894:	70eb      	strb	r3, [r5, #3]
    4896:	78ab      	ldrb	r3, [r5, #2]
    4898:	2b04      	cmp	r3, #4
    489a:	d1fd      	bne.n	4898 <Connect_receive_RemoteCapability+0xa0>
    489c:	2300      	movs	r3, #0
    489e:	70ab      	strb	r3, [r5, #2]
				uint8_t header[] = { 0x16, 0x01 };
    48a0:	4b19      	ldr	r3, [pc, #100]	; (4908 <Connect_receive_RemoteCapability+0x110>)
				Connect_addBytes( header, sizeof( header ), uart_direction );
    48a2:	4632      	mov	r2, r6
				uint8_t header[] = { 0x16, 0x01 };
    48a4:	881b      	ldrh	r3, [r3, #0]
    48a6:	f8ad 3004 	strh.w	r3, [sp, #4]
				Connect_addBytes( header, sizeof( header ), uart_direction );
    48aa:	2102      	movs	r1, #2
    48ac:	a801      	add	r0, sp, #4
    48ae:	f7ff ff93 	bl	47d8 <Connect_addBytes>
				Connect_addBytes( (uint8_t*)&Connect_receive_RemoteCapabilityBuffer, sizeof( RemoteCapabilityCommand ), uart_direction );
    48b2:	4632      	mov	r2, r6
    48b4:	2106      	movs	r1, #6
    48b6:	480e      	ldr	r0, [pc, #56]	; (48f0 <Connect_receive_RemoteCapability+0xf8>)
    48b8:	f7ff ff8e 	bl	47d8 <Connect_addBytes>
				Connect_addBytes( Connect_receive_RemoteCapabilityArgs, Connect_receive_RemoteCapabilityBuffer.numArgs, uart_direction );
    48bc:	4632      	mov	r2, r6
    48be:	7961      	ldrb	r1, [r4, #5]
    48c0:	480c      	ldr	r0, [pc, #48]	; (48f4 <Connect_receive_RemoteCapability+0xfc>)
    48c2:	f7ff ff89 	bl	47d8 <Connect_addBytes>
    48c6:	2300      	movs	r3, #0
    48c8:	2204      	movs	r2, #4
				switch ( uart_direction )
    48ca:	b16e      	cbz	r6, 48e8 <Connect_receive_RemoteCapability+0xf0>
				case UART_Master: uart_unlockTx( UART_Master ); break;
    48cc:	70aa      	strb	r2, [r5, #2]
    48ce:	70eb      	strb	r3, [r5, #3]
    48d0:	e7a5      	b.n	481e <Connect_receive_RemoteCapability+0x26>
				case UART_Slave:  uart_lockTx( UART_Slave );  break;
    48d2:	786b      	ldrb	r3, [r5, #1]
    48d4:	2b00      	cmp	r3, #0
    48d6:	d1fd      	bne.n	48d4 <Connect_receive_RemoteCapability+0xdc>
    48d8:	2301      	movs	r3, #1
    48da:	706b      	strb	r3, [r5, #1]
    48dc:	782b      	ldrb	r3, [r5, #0]
    48de:	2b04      	cmp	r3, #4
    48e0:	d1fd      	bne.n	48de <Connect_receive_RemoteCapability+0xe6>
    48e2:	2300      	movs	r3, #0
    48e4:	702b      	strb	r3, [r5, #0]
    48e6:	e7db      	b.n	48a0 <Connect_receive_RemoteCapability+0xa8>
				case UART_Slave:  uart_unlockTx( UART_Slave );  break;
    48e8:	702a      	strb	r2, [r5, #0]
    48ea:	706b      	strb	r3, [r5, #1]
    48ec:	e797      	b.n	481e <Connect_receive_RemoteCapability+0x26>
    48ee:	bf00      	nop
    48f0:	1fff9dcc 	.word	0x1fff9dcc
    48f4:	1fff9dd6 	.word	0x1fff9dd6
    48f8:	1fff89fc 	.word	0x1fff89fc
    48fc:	0000cff0 	.word	0x0000cff0
    4900:	1fff9dd8 	.word	0x1fff9dd8
    4904:	1fff9dd2 	.word	0x1fff9dd2
    4908:	0000c80c 	.word	0x0000c80c

0000490c <Connect_send_CableCheck>:
{
    490c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uart_lockBothTx( UART_Master, UART_Slave );
    490e:	4c20      	ldr	r4, [pc, #128]	; (4990 <Connect_send_CableCheck+0x84>)
    4910:	78e2      	ldrb	r2, [r4, #3]
    4912:	7863      	ldrb	r3, [r4, #1]
{
    4914:	4607      	mov	r7, r0
	uart_lockBothTx( UART_Master, UART_Slave );
    4916:	2a00      	cmp	r2, #0
    4918:	d1fd      	bne.n	4916 <Connect_send_CableCheck+0xa>
    491a:	2b00      	cmp	r3, #0
    491c:	d1fd      	bne.n	491a <Connect_send_CableCheck+0xe>
    491e:	2301      	movs	r3, #1
    4920:	70e3      	strb	r3, [r4, #3]
    4922:	7063      	strb	r3, [r4, #1]
    4924:	7826      	ldrb	r6, [r4, #0]
    4926:	78a3      	ldrb	r3, [r4, #2]
    4928:	2b04      	cmp	r3, #4
    492a:	d1fd      	bne.n	4928 <Connect_send_CableCheck+0x1c>
    492c:	2e04      	cmp	r6, #4
    492e:	d1fd      	bne.n	492c <Connect_send_CableCheck+0x20>
    4930:	2500      	movs	r5, #0
	uint8_t header[] = { 0x16, 0x01, CableCheck, patternLen };
    4932:	f44f 738b 	mov.w	r3, #278	; 0x116
    4936:	4631      	mov	r1, r6
    4938:	2201      	movs	r2, #1
    493a:	a801      	add	r0, sp, #4
    493c:	f8ad 3004 	strh.w	r3, [sp, #4]
	uart_lockBothTx( UART_Master, UART_Slave );
    4940:	70a5      	strb	r5, [r4, #2]
    4942:	7025      	strb	r5, [r4, #0]
	uint8_t header[] = { 0x16, 0x01, CableCheck, patternLen };
    4944:	f88d 5006 	strb.w	r5, [sp, #6]
    4948:	f88d 7007 	strb.w	r7, [sp, #7]
    494c:	f7ff fe26 	bl	459c <Connect_addBytes.part.1>
    4950:	4631      	mov	r1, r6
    4952:	462a      	mov	r2, r5
    4954:	a801      	add	r0, sp, #4
	uint8_t value = 0xD2;
    4956:	ae02      	add	r6, sp, #8
    4958:	f7ff fe20 	bl	459c <Connect_addBytes.part.1>
    495c:	23d2      	movs	r3, #210	; 0xd2
    495e:	f806 3d05 	strb.w	r3, [r6, #-5]!
	for ( uint8_t c = 0; c < patternLen; c++ )
    4962:	42bd      	cmp	r5, r7
    4964:	d107      	bne.n	4976 <Connect_send_CableCheck+0x6a>
	uart_unlockTx( UART_Master );
    4966:	2204      	movs	r2, #4
    4968:	2300      	movs	r3, #0
    496a:	70a2      	strb	r2, [r4, #2]
    496c:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    496e:	7022      	strb	r2, [r4, #0]
    4970:	7063      	strb	r3, [r4, #1]
}
    4972:	b003      	add	sp, #12
    4974:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4976:	2201      	movs	r2, #1
    4978:	4611      	mov	r1, r2
    497a:	4630      	mov	r0, r6
    497c:	f7ff fe0e 	bl	459c <Connect_addBytes.part.1>
    4980:	2200      	movs	r2, #0
    4982:	2101      	movs	r1, #1
    4984:	4630      	mov	r0, r6
    4986:	f7ff fe09 	bl	459c <Connect_addBytes.part.1>
    498a:	3501      	adds	r5, #1
    498c:	e7e9      	b.n	4962 <Connect_send_CableCheck+0x56>
    498e:	bf00      	nop
    4990:	1fff9dd2 	.word	0x1fff9dd2

00004994 <Connect_send_IdRequest>:
{
    4994:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uart_lockTx( UART_Master );
    4996:	4c0d      	ldr	r4, [pc, #52]	; (49cc <Connect_send_IdRequest+0x38>)
    4998:	78e3      	ldrb	r3, [r4, #3]
    499a:	2b00      	cmp	r3, #0
    499c:	d1fd      	bne.n	499a <Connect_send_IdRequest+0x6>
    499e:	2301      	movs	r3, #1
    49a0:	78a6      	ldrb	r6, [r4, #2]
    49a2:	70e3      	strb	r3, [r4, #3]
    49a4:	2e04      	cmp	r6, #4
    49a6:	d1fd      	bne.n	49a4 <Connect_send_IdRequest+0x10>
	uint8_t header[] = { 0x16, 0x01, IdRequest };
    49a8:	4b09      	ldr	r3, [pc, #36]	; (49d0 <Connect_send_IdRequest+0x3c>)
    49aa:	881a      	ldrh	r2, [r3, #0]
    49ac:	f8ad 2004 	strh.w	r2, [sp, #4]
	uart_lockTx( UART_Master );
    49b0:	2500      	movs	r5, #0
	uint8_t header[] = { 0x16, 0x01, IdRequest };
    49b2:	789b      	ldrb	r3, [r3, #2]
	uart_lockTx( UART_Master );
    49b4:	70a5      	strb	r5, [r4, #2]
    49b6:	2201      	movs	r2, #1
    49b8:	2103      	movs	r1, #3
    49ba:	a801      	add	r0, sp, #4
	uint8_t header[] = { 0x16, 0x01, IdRequest };
    49bc:	f88d 3006 	strb.w	r3, [sp, #6]
    49c0:	f7ff fdec 	bl	459c <Connect_addBytes.part.1>
	uart_unlockTx( UART_Master );
    49c4:	70a6      	strb	r6, [r4, #2]
    49c6:	70e5      	strb	r5, [r4, #3]
}
    49c8:	b002      	add	sp, #8
    49ca:	bd70      	pop	{r4, r5, r6, pc}
    49cc:	1fff9dd2 	.word	0x1fff9dd2
    49d0:	0000c80e 	.word	0x0000c80e

000049d4 <Connect_send_IdEnumeration>:
{
    49d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uart_lockTx( UART_Slave );
    49d6:	4c0e      	ldr	r4, [pc, #56]	; (4a10 <Connect_send_IdEnumeration+0x3c>)
    49d8:	7863      	ldrb	r3, [r4, #1]
    49da:	2b00      	cmp	r3, #0
    49dc:	d1fd      	bne.n	49da <Connect_send_IdEnumeration+0x6>
    49de:	2301      	movs	r3, #1
    49e0:	7826      	ldrb	r6, [r4, #0]
    49e2:	7063      	strb	r3, [r4, #1]
    49e4:	2e04      	cmp	r6, #4
    49e6:	d1fd      	bne.n	49e4 <Connect_send_IdEnumeration+0x10>
    49e8:	2500      	movs	r5, #0
	uint8_t header[] = { 0x16, 0x01, IdEnumeration, id };
    49ea:	f44f 738b 	mov.w	r3, #278	; 0x116
    49ee:	f8ad 3004 	strh.w	r3, [sp, #4]
    49f2:	f88d 0007 	strb.w	r0, [sp, #7]
    49f6:	2302      	movs	r3, #2
    49f8:	462a      	mov	r2, r5
    49fa:	4631      	mov	r1, r6
    49fc:	a801      	add	r0, sp, #4
	uart_lockTx( UART_Slave );
    49fe:	7025      	strb	r5, [r4, #0]
	uint8_t header[] = { 0x16, 0x01, IdEnumeration, id };
    4a00:	f88d 3006 	strb.w	r3, [sp, #6]
    4a04:	f7ff fdca 	bl	459c <Connect_addBytes.part.1>
	uart_unlockTx( UART_Slave );
    4a08:	7026      	strb	r6, [r4, #0]
    4a0a:	7065      	strb	r5, [r4, #1]
}
    4a0c:	b002      	add	sp, #8
    4a0e:	bd70      	pop	{r4, r5, r6, pc}
    4a10:	1fff9dd2 	.word	0x1fff9dd2

00004a14 <Connect_receive_IdRequest>:
{
    4a14:	b510      	push	{r4, lr}
	dbug_print("IdRequest");
    4a16:	480a      	ldr	r0, [pc, #40]	; (4a40 <Connect_receive_IdRequest+0x2c>)
{
    4a18:	4614      	mov	r4, r2
	dbug_print("IdRequest");
    4a1a:	f006 fcf1 	bl	b400 <_print>
	if ( uart_num == UART_Master )
    4a1e:	2c01      	cmp	r4, #1
    4a20:	d102      	bne.n	4a28 <Connect_receive_IdRequest+0x14>
		erro_print("Invalid IdRequest direction...");
    4a22:	4808      	ldr	r0, [pc, #32]	; (4a44 <Connect_receive_IdRequest+0x30>)
    4a24:	f006 fcec 	bl	b400 <_print>
	if ( Connect_master )
    4a28:	4b07      	ldr	r3, [pc, #28]	; (4a48 <Connect_receive_IdRequest+0x34>)
    4a2a:	781b      	ldrb	r3, [r3, #0]
    4a2c:	b123      	cbz	r3, 4a38 <Connect_receive_IdRequest+0x24>
		Connect_send_IdEnumeration( 1 );
    4a2e:	2001      	movs	r0, #1
    4a30:	f7ff ffd0 	bl	49d4 <Connect_send_IdEnumeration>
}
    4a34:	2001      	movs	r0, #1
    4a36:	bd10      	pop	{r4, pc}
		Connect_send_IdRequest();
    4a38:	f7ff ffac 	bl	4994 <Connect_send_IdRequest>
    4a3c:	e7fa      	b.n	4a34 <Connect_receive_IdRequest+0x20>
    4a3e:	bf00      	nop
    4a40:	0000ca0f 	.word	0x0000ca0f
    4a44:	0000ca2e 	.word	0x0000ca2e
    4a48:	1fff9300 	.word	0x1fff9300

00004a4c <Connect_send_IdReport>:
{
    4a4c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uart_lockTx( UART_Master );
    4a4e:	4c0e      	ldr	r4, [pc, #56]	; (4a88 <Connect_send_IdReport+0x3c>)
    4a50:	78e3      	ldrb	r3, [r4, #3]
    4a52:	2b00      	cmp	r3, #0
    4a54:	d1fd      	bne.n	4a52 <Connect_send_IdReport+0x6>
    4a56:	2301      	movs	r3, #1
    4a58:	78a5      	ldrb	r5, [r4, #2]
    4a5a:	70e3      	strb	r3, [r4, #3]
    4a5c:	2d04      	cmp	r5, #4
    4a5e:	d1fd      	bne.n	4a5c <Connect_send_IdReport+0x10>
	uint8_t header[] = { 0x16, 0x01, IdReport, id };
    4a60:	f44f 738b 	mov.w	r3, #278	; 0x116
	uart_lockTx( UART_Master );
    4a64:	2600      	movs	r6, #0
	uint8_t header[] = { 0x16, 0x01, IdReport, id };
    4a66:	f8ad 3004 	strh.w	r3, [sp, #4]
    4a6a:	f88d 0007 	strb.w	r0, [sp, #7]
    4a6e:	2303      	movs	r3, #3
    4a70:	2201      	movs	r2, #1
    4a72:	4629      	mov	r1, r5
    4a74:	a801      	add	r0, sp, #4
	uart_lockTx( UART_Master );
    4a76:	70a6      	strb	r6, [r4, #2]
	uint8_t header[] = { 0x16, 0x01, IdReport, id };
    4a78:	f88d 3006 	strb.w	r3, [sp, #6]
    4a7c:	f7ff fd8e 	bl	459c <Connect_addBytes.part.1>
	uart_unlockTx( UART_Master );
    4a80:	70a5      	strb	r5, [r4, #2]
    4a82:	70e6      	strb	r6, [r4, #3]
}
    4a84:	b002      	add	sp, #8
    4a86:	bd70      	pop	{r4, r5, r6, pc}
    4a88:	1fff9dd2 	.word	0x1fff9dd2

00004a8c <Connect_receive_IdEnumeration>:
{
    4a8c:	b538      	push	{r3, r4, r5, lr}
    4a8e:	4604      	mov	r4, r0
    4a90:	4615      	mov	r5, r2
	dbug_print("IdEnumeration");
    4a92:	480d      	ldr	r0, [pc, #52]	; (4ac8 <Connect_receive_IdEnumeration+0x3c>)
    4a94:	f006 fcb4 	bl	b400 <_print>
	if ( uart_num == UART_Slave )
    4a98:	b915      	cbnz	r5, 4aa0 <Connect_receive_IdEnumeration+0x14>
		erro_print("Invalid IdEnumeration direction...");
    4a9a:	480c      	ldr	r0, [pc, #48]	; (4acc <Connect_receive_IdEnumeration+0x40>)
    4a9c:	f006 fcb0 	bl	b400 <_print>
	Connect_id = id;
    4aa0:	4d0b      	ldr	r5, [pc, #44]	; (4ad0 <Connect_receive_IdEnumeration+0x44>)
	Connect_send_IdReport( id );
    4aa2:	4620      	mov	r0, r4
	Connect_id = id;
    4aa4:	702c      	strb	r4, [r5, #0]
	Connect_send_IdReport( id );
    4aa6:	f7ff ffd1 	bl	4a4c <Connect_send_IdReport>
	if ( Connect_id != 0 )
    4aaa:	782b      	ldrb	r3, [r5, #0]
    4aac:	b11b      	cbz	r3, 4ab6 <Connect_receive_IdEnumeration+0x2a>
		Output_update_external_current( 500 );
    4aae:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    4ab2:	f004 f821 	bl	8af8 <Output_update_external_current>
	if ( Connect_cableOkSlave )
    4ab6:	4b07      	ldr	r3, [pc, #28]	; (4ad4 <Connect_receive_IdEnumeration+0x48>)
    4ab8:	781b      	ldrb	r3, [r3, #0]
    4aba:	b11b      	cbz	r3, 4ac4 <Connect_receive_IdEnumeration+0x38>
		Connect_send_IdEnumeration( id + 1 );
    4abc:	1c60      	adds	r0, r4, #1
    4abe:	b2c0      	uxtb	r0, r0
    4ac0:	f7ff ff88 	bl	49d4 <Connect_send_IdEnumeration>
}
    4ac4:	2001      	movs	r0, #1
    4ac6:	bd38      	pop	{r3, r4, r5, pc}
    4ac8:	0000c974 	.word	0x0000c974
    4acc:	0000c997 	.word	0x0000c997
    4ad0:	1fff89fc 	.word	0x1fff89fc
    4ad4:	1fff92f9 	.word	0x1fff92f9

00004ad8 <Connect_receive_IdReport>:
{
    4ad8:	b538      	push	{r3, r4, r5, lr}
    4ada:	4615      	mov	r5, r2
    4adc:	4604      	mov	r4, r0
	dbug_print("IdReport");
    4ade:	4810      	ldr	r0, [pc, #64]	; (4b20 <Connect_receive_IdReport+0x48>)
    4ae0:	f006 fc8e 	bl	b400 <_print>
	if ( uart_num == UART_Master )
    4ae4:	2d01      	cmp	r5, #1
    4ae6:	d102      	bne.n	4aee <Connect_receive_IdReport+0x16>
		erro_print("Invalid IdRequest direction...");
    4ae8:	480e      	ldr	r0, [pc, #56]	; (4b24 <Connect_receive_IdReport+0x4c>)
    4aea:	f006 fc89 	bl	b400 <_print>
	if ( Connect_master )
    4aee:	4b0e      	ldr	r3, [pc, #56]	; (4b28 <Connect_receive_IdReport+0x50>)
    4af0:	781b      	ldrb	r3, [r3, #0]
    4af2:	b183      	cbz	r3, 4b16 <Connect_receive_IdReport+0x3e>
		info_msg("Id Reported: ");
    4af4:	480d      	ldr	r0, [pc, #52]	; (4b2c <Connect_receive_IdReport+0x54>)
    4af6:	f006 fc83 	bl	b400 <_print>
		printHex( id );
    4afa:	2101      	movs	r1, #1
    4afc:	4620      	mov	r0, r4
    4afe:	f006 fd27 	bl	b550 <printHex_op>
		print( NL );
    4b02:	480b      	ldr	r0, [pc, #44]	; (4b30 <Connect_receive_IdReport+0x58>)
    4b04:	f006 fc7c 	bl	b400 <_print>
		if ( id > Connect_maxId )
    4b08:	4b0a      	ldr	r3, [pc, #40]	; (4b34 <Connect_receive_IdReport+0x5c>)
    4b0a:	781a      	ldrb	r2, [r3, #0]
    4b0c:	42a2      	cmp	r2, r4
    4b0e:	d200      	bcs.n	4b12 <Connect_receive_IdReport+0x3a>
			Connect_maxId = id;
    4b10:	701c      	strb	r4, [r3, #0]
}
    4b12:	2001      	movs	r0, #1
    4b14:	bd38      	pop	{r3, r4, r5, pc}
		Connect_send_IdReport( id );
    4b16:	4620      	mov	r0, r4
    4b18:	f7ff ff98 	bl	4a4c <Connect_send_IdReport>
	return 1;
    4b1c:	e7f9      	b.n	4b12 <Connect_receive_IdReport+0x3a>
    4b1e:	bf00      	nop
    4b20:	0000c9d1 	.word	0x0000c9d1
    4b24:	0000ca2e 	.word	0x0000ca2e
    4b28:	1fff9300 	.word	0x1fff9300
    4b2c:	0000c9ef 	.word	0x0000c9ef
    4b30:	00010d99 	.word	0x00010d99
    4b34:	1fff9301 	.word	0x1fff9301

00004b38 <Connect_send_ScanCode>:
{
    4b38:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uart_lockTx( UART_Master );
    4b3c:	4c13      	ldr	r4, [pc, #76]	; (4b8c <Connect_send_ScanCode+0x54>)
    4b3e:	78e3      	ldrb	r3, [r4, #3]
{
    4b40:	4688      	mov	r8, r1
    4b42:	4617      	mov	r7, r2
	uart_lockTx( UART_Master );
    4b44:	2b00      	cmp	r3, #0
    4b46:	d1fd      	bne.n	4b44 <Connect_send_ScanCode+0xc>
    4b48:	2301      	movs	r3, #1
    4b4a:	78a5      	ldrb	r5, [r4, #2]
    4b4c:	70e3      	strb	r3, [r4, #3]
    4b4e:	2d04      	cmp	r5, #4
    4b50:	d1fd      	bne.n	4b4e <Connect_send_ScanCode+0x16>
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    4b52:	f44f 738b 	mov.w	r3, #278	; 0x116
	uart_lockTx( UART_Master );
    4b56:	2600      	movs	r6, #0
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    4b58:	f88d 0003 	strb.w	r0, [sp, #3]
    4b5c:	f88d 7004 	strb.w	r7, [sp, #4]
    4b60:	4668      	mov	r0, sp
    4b62:	2201      	movs	r2, #1
    4b64:	2105      	movs	r1, #5
	Connect_addBytes( (uint8_t*)scanCodeStateList, numScanCodes * TriggerGuideSize, UART_Master );
    4b66:	eb07 0747 	add.w	r7, r7, r7, lsl #1
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    4b6a:	f8ad 3000 	strh.w	r3, [sp]
	uart_lockTx( UART_Master );
    4b6e:	70a6      	strb	r6, [r4, #2]
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    4b70:	f88d 5002 	strb.w	r5, [sp, #2]
    4b74:	f7ff fd12 	bl	459c <Connect_addBytes.part.1>
	Connect_addBytes( (uint8_t*)scanCodeStateList, numScanCodes * TriggerGuideSize, UART_Master );
    4b78:	2201      	movs	r2, #1
    4b7a:	b2f9      	uxtb	r1, r7
    4b7c:	4640      	mov	r0, r8
    4b7e:	f7ff fe2b 	bl	47d8 <Connect_addBytes>
	uart_unlockTx( UART_Master );
    4b82:	70a5      	strb	r5, [r4, #2]
    4b84:	70e6      	strb	r6, [r4, #3]
}
    4b86:	b002      	add	sp, #8
    4b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4b8c:	1fff9dd2 	.word	0x1fff9dd2

00004b90 <cliFunc_connectCmd>:
{
    4b90:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    4b92:	aa01      	add	r2, sp, #4
    4b94:	4669      	mov	r1, sp
    4b96:	f006 f82b 	bl	abf0 <CLI_argumentIsolation>
	print( NL );
    4b9a:	4815      	ldr	r0, [pc, #84]	; (4bf0 <cliFunc_connectCmd+0x60>)
    4b9c:	f006 fc30 	bl	b400 <_print>
	switch ( numToInt( &arg1Ptr[0] ) )
    4ba0:	9800      	ldr	r0, [sp, #0]
    4ba2:	f006 fd40 	bl	b626 <numToInt>
    4ba6:	2804      	cmp	r0, #4
    4ba8:	d807      	bhi.n	4bba <cliFunc_connectCmd+0x2a>
    4baa:	e8df f000 	tbb	[pc, r0]
    4bae:	0903      	.short	0x0903
    4bb0:	100c      	.short	0x100c
    4bb2:	14          	.byte	0x14
    4bb3:	00          	.byte	0x00
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    4bb4:	2002      	movs	r0, #2
    4bb6:	f7ff fea9 	bl	490c <Connect_send_CableCheck>
}
    4bba:	b005      	add	sp, #20
    4bbc:	f85d fb04 	ldr.w	pc, [sp], #4
		Connect_send_IdRequest();
    4bc0:	f7ff fee8 	bl	4994 <Connect_send_IdRequest>
		break;
    4bc4:	e7f9      	b.n	4bba <cliFunc_connectCmd+0x2a>
		Connect_send_IdEnumeration( 5 );
    4bc6:	2005      	movs	r0, #5
    4bc8:	f7ff ff04 	bl	49d4 <Connect_send_IdEnumeration>
		break;
    4bcc:	e7f5      	b.n	4bba <cliFunc_connectCmd+0x2a>
		Connect_send_IdReport( 8 );
    4bce:	2008      	movs	r0, #8
    4bd0:	f7ff ff3c 	bl	4a4c <Connect_send_IdReport>
		break;
    4bd4:	e7f1      	b.n	4bba <cliFunc_connectCmd+0x2a>
		TriggerEvent scanCodes[] = { { 0x00, 0x01, 0x05 }, { 0x00, 0x03, 0x16 } };
    4bd6:	4b07      	ldr	r3, [pc, #28]	; (4bf4 <cliFunc_connectCmd+0x64>)
    4bd8:	6818      	ldr	r0, [r3, #0]
    4bda:	9002      	str	r0, [sp, #8]
    4bdc:	889b      	ldrh	r3, [r3, #4]
    4bde:	f8ad 300c 	strh.w	r3, [sp, #12]
		Connect_send_ScanCode( 10, scanCodes, 2 );
    4be2:	2202      	movs	r2, #2
    4be4:	a902      	add	r1, sp, #8
    4be6:	200a      	movs	r0, #10
    4be8:	f7ff ffa6 	bl	4b38 <Connect_send_ScanCode>
}
    4bec:	e7e5      	b.n	4bba <cliFunc_connectCmd+0x2a>
    4bee:	bf00      	nop
    4bf0:	00010d99 	.word	0x00010d99
    4bf4:	0000c811 	.word	0x0000c811

00004bf8 <Connect_send_RemoteCapability>:
{
    4bf8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if ( id == Connect_id )
    4bfc:	4e2a      	ldr	r6, [pc, #168]	; (4ca8 <Connect_send_RemoteCapability+0xb0>)
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4bfe:	f88d 2005 	strb.w	r2, [sp, #5]
	if ( id == Connect_id )
    4c02:	7832      	ldrb	r2, [r6, #0]
{
    4c04:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4c08:	f88d 1004 	strb.w	r1, [sp, #4]
{
    4c0c:	4605      	mov	r5, r0
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4c0e:	f44f 708b 	mov.w	r0, #278	; 0x116
    4c12:	f8ad 0000 	strh.w	r0, [sp]
	if ( id == Connect_id )
    4c16:	42aa      	cmp	r2, r5
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4c18:	f04f 0006 	mov.w	r0, #6
    4c1c:	f88d 0002 	strb.w	r0, [sp, #2]
    4c20:	f88d 5003 	strb.w	r5, [sp, #3]
    4c24:	f88d 3006 	strb.w	r3, [sp, #6]
    4c28:	f88d 7007 	strb.w	r7, [sp, #7]
	if ( id == Connect_id )
    4c2c:	d039      	beq.n	4ca2 <Connect_send_RemoteCapability+0xaa>
	if ( id > Connect_id )
    4c2e:	d21c      	bcs.n	4c6a <Connect_send_RemoteCapability+0x72>
		uart_lockTx( UART_Slave );
    4c30:	4c1e      	ldr	r4, [pc, #120]	; (4cac <Connect_send_RemoteCapability+0xb4>)
    4c32:	7863      	ldrb	r3, [r4, #1]
    4c34:	2b00      	cmp	r3, #0
    4c36:	d1fd      	bne.n	4c34 <Connect_send_RemoteCapability+0x3c>
    4c38:	2301      	movs	r3, #1
    4c3a:	f894 9000 	ldrb.w	r9, [r4]
    4c3e:	7063      	strb	r3, [r4, #1]
    4c40:	f1b9 0f04 	cmp.w	r9, #4
    4c44:	d1fc      	bne.n	4c40 <Connect_send_RemoteCapability+0x48>
    4c46:	f04f 0800 	mov.w	r8, #0
    4c4a:	4642      	mov	r2, r8
    4c4c:	2108      	movs	r1, #8
    4c4e:	4668      	mov	r0, sp
    4c50:	f884 8000 	strb.w	r8, [r4]
    4c54:	f7ff fca2 	bl	459c <Connect_addBytes.part.1>
		Connect_addBytes( args, numArgs, UART_Slave );
    4c58:	4642      	mov	r2, r8
    4c5a:	4639      	mov	r1, r7
    4c5c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    4c5e:	f7ff fdbb 	bl	47d8 <Connect_addBytes>
		uart_unlockTx( UART_Slave );
    4c62:	f884 9000 	strb.w	r9, [r4]
    4c66:	f884 8001 	strb.w	r8, [r4, #1]
	if ( id < Connect_id || id == 255 )
    4c6a:	7833      	ldrb	r3, [r6, #0]
    4c6c:	42ab      	cmp	r3, r5
    4c6e:	d801      	bhi.n	4c74 <Connect_send_RemoteCapability+0x7c>
    4c70:	2dff      	cmp	r5, #255	; 0xff
    4c72:	d116      	bne.n	4ca2 <Connect_send_RemoteCapability+0xaa>
		uart_lockTx( UART_Master );
    4c74:	4c0d      	ldr	r4, [pc, #52]	; (4cac <Connect_send_RemoteCapability+0xb4>)
    4c76:	78e3      	ldrb	r3, [r4, #3]
    4c78:	2b00      	cmp	r3, #0
    4c7a:	d1fd      	bne.n	4c78 <Connect_send_RemoteCapability+0x80>
    4c7c:	2301      	movs	r3, #1
    4c7e:	78a6      	ldrb	r6, [r4, #2]
    4c80:	70e3      	strb	r3, [r4, #3]
    4c82:	2e04      	cmp	r6, #4
    4c84:	d1fd      	bne.n	4c82 <Connect_send_RemoteCapability+0x8a>
    4c86:	2500      	movs	r5, #0
    4c88:	2201      	movs	r2, #1
    4c8a:	2108      	movs	r1, #8
    4c8c:	4668      	mov	r0, sp
    4c8e:	70a5      	strb	r5, [r4, #2]
    4c90:	f7ff fc84 	bl	459c <Connect_addBytes.part.1>
		Connect_addBytes( args, numArgs, UART_Master );
    4c94:	2201      	movs	r2, #1
    4c96:	4639      	mov	r1, r7
    4c98:	980b      	ldr	r0, [sp, #44]	; 0x2c
    4c9a:	f7ff fd9d 	bl	47d8 <Connect_addBytes>
		uart_unlockTx( UART_Master );
    4c9e:	70a6      	strb	r6, [r4, #2]
    4ca0:	70e5      	strb	r5, [r4, #3]
}
    4ca2:	b003      	add	sp, #12
    4ca4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4ca8:	1fff89fc 	.word	0x1fff89fc
    4cac:	1fff9dd2 	.word	0x1fff9dd2

00004cb0 <Connect_send_Idle>:
{
    4cb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uart_lockBothTx( UART_Slave, UART_Master );
    4cb2:	4c17      	ldr	r4, [pc, #92]	; (4d10 <Connect_send_Idle+0x60>)
    4cb4:	7862      	ldrb	r2, [r4, #1]
    4cb6:	78e3      	ldrb	r3, [r4, #3]
{
    4cb8:	4607      	mov	r7, r0
	uart_lockBothTx( UART_Slave, UART_Master );
    4cba:	2a00      	cmp	r2, #0
    4cbc:	d1fd      	bne.n	4cba <Connect_send_Idle+0xa>
    4cbe:	2b00      	cmp	r3, #0
    4cc0:	d1fd      	bne.n	4cbe <Connect_send_Idle+0xe>
    4cc2:	2301      	movs	r3, #1
    4cc4:	7063      	strb	r3, [r4, #1]
    4cc6:	70e3      	strb	r3, [r4, #3]
    4cc8:	7822      	ldrb	r2, [r4, #0]
    4cca:	78a3      	ldrb	r3, [r4, #2]
    4ccc:	2a04      	cmp	r2, #4
    4cce:	d1fd      	bne.n	4ccc <Connect_send_Idle+0x1c>
    4cd0:	2b04      	cmp	r3, #4
    4cd2:	d1fd      	bne.n	4cd0 <Connect_send_Idle+0x20>
	uint8_t value = 0x16;
    4cd4:	ae02      	add	r6, sp, #8
    4cd6:	2316      	movs	r3, #22
	uart_lockBothTx( UART_Slave, UART_Master );
    4cd8:	2500      	movs	r5, #0
	uint8_t value = 0x16;
    4cda:	f806 3d01 	strb.w	r3, [r6, #-1]!
	uart_lockBothTx( UART_Slave, UART_Master );
    4cde:	7025      	strb	r5, [r4, #0]
    4ce0:	70a5      	strb	r5, [r4, #2]
	for ( uint8_t c = 0; c < num; c++ )
    4ce2:	42bd      	cmp	r5, r7
    4ce4:	d107      	bne.n	4cf6 <Connect_send_Idle+0x46>
	uart_unlockTx( UART_Master );
    4ce6:	2204      	movs	r2, #4
    4ce8:	2300      	movs	r3, #0
    4cea:	70a2      	strb	r2, [r4, #2]
    4cec:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    4cee:	7022      	strb	r2, [r4, #0]
    4cf0:	7063      	strb	r3, [r4, #1]
}
    4cf2:	b003      	add	sp, #12
    4cf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4cf6:	2201      	movs	r2, #1
    4cf8:	4611      	mov	r1, r2
    4cfa:	4630      	mov	r0, r6
    4cfc:	f7ff fc4e 	bl	459c <Connect_addBytes.part.1>
    4d00:	2200      	movs	r2, #0
    4d02:	2101      	movs	r1, #1
    4d04:	4630      	mov	r0, r6
    4d06:	f7ff fc49 	bl	459c <Connect_addBytes.part.1>
    4d0a:	3501      	adds	r5, #1
    4d0c:	e7e9      	b.n	4ce2 <Connect_send_Idle+0x32>
    4d0e:	bf00      	nop
    4d10:	1fff9dd2 	.word	0x1fff9dd2

00004d14 <cliFunc_connectIdl>:
{
    4d14:	b507      	push	{r0, r1, r2, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    4d16:	aa01      	add	r2, sp, #4
    4d18:	4669      	mov	r1, sp
    4d1a:	f005 ff69 	bl	abf0 <CLI_argumentIsolation>
	print( NL );
    4d1e:	4809      	ldr	r0, [pc, #36]	; (4d44 <cliFunc_connectIdl+0x30>)
    4d20:	f006 fb6e 	bl	b400 <_print>
	info_msg("Sending Sync Idles...");
    4d24:	4808      	ldr	r0, [pc, #32]	; (4d48 <cliFunc_connectIdl+0x34>)
    4d26:	f006 fb6b 	bl	b400 <_print>
	uint8_t count = numToInt( &arg1Ptr[0] );
    4d2a:	9800      	ldr	r0, [sp, #0]
    4d2c:	f006 fc7b 	bl	b626 <numToInt>
    4d30:	b2c0      	uxtb	r0, r0
	if ( count == 0 )
    4d32:	2800      	cmp	r0, #0
	Connect_send_Idle( count );
    4d34:	bf08      	it	eq
    4d36:	2002      	moveq	r0, #2
    4d38:	f7ff ffba 	bl	4cb0 <Connect_send_Idle>
}
    4d3c:	b003      	add	sp, #12
    4d3e:	f85d fb04 	ldr.w	pc, [sp], #4
    4d42:	bf00      	nop
    4d44:	00010d99 	.word	0x00010d99
    4d48:	0000cb8e 	.word	0x0000cb8e

00004d4c <Connect_reset>:
{
    4d4c:	b510      	push	{r4, lr}
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    4d4e:	2208      	movs	r2, #8
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    4d50:	4c0c      	ldr	r4, [pc, #48]	; (4d84 <Connect_reset+0x38>)
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    4d52:	480d      	ldr	r0, [pc, #52]	; (4d88 <Connect_reset+0x3c>)
    4d54:	2100      	movs	r1, #0
    4d56:	f7fd fc73 	bl	2640 <memset>
	memset( (void*)uart_tx_buf,    0, sizeof( UARTRingBuf )  * UART_Num_Interfaces );
    4d5a:	f44f 7283 	mov.w	r2, #262	; 0x106
    4d5e:	2100      	movs	r1, #0
    4d60:	480a      	ldr	r0, [pc, #40]	; (4d8c <Connect_reset+0x40>)
    4d62:	f7fd fc6d 	bl	2640 <memset>
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    4d66:	2204      	movs	r2, #4
    4d68:	2100      	movs	r1, #0
    4d6a:	4620      	mov	r0, r4
    4d6c:	f7fd fc68 	bl	2640 <memset>
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4d70:	4b07      	ldr	r3, [pc, #28]	; (4d90 <Connect_reset+0x44>)
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    4d72:	2104      	movs	r1, #4
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4d74:	2280      	movs	r2, #128	; 0x80
    4d76:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    4d7a:	7021      	strb	r1, [r4, #0]
    4d7c:	70a1      	strb	r1, [r4, #2]
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4d7e:	f8a3 2102 	strh.w	r2, [r3, #258]	; 0x102
}
    4d82:	bd10      	pop	{r4, pc}
    4d84:	1fff9dd2 	.word	0x1fff9dd2
    4d88:	1fff9df0 	.word	0x1fff9df0
    4d8c:	1fff9cc6 	.word	0x1fff9cc6
    4d90:	1fff9df8 	.word	0x1fff9df8

00004d94 <cliFunc_connectRst>:
{
    4d94:	b508      	push	{r3, lr}
	print( NL );
    4d96:	4806      	ldr	r0, [pc, #24]	; (4db0 <cliFunc_connectRst+0x1c>)
    4d98:	f006 fb32 	bl	b400 <_print>
	info_msg("Resetting UARTConnect state...");
    4d9c:	4805      	ldr	r0, [pc, #20]	; (4db4 <cliFunc_connectRst+0x20>)
    4d9e:	f006 fb2f 	bl	b400 <_print>
	Connect_reset();
    4da2:	f7ff ffd3 	bl	4d4c <Connect_reset>
	Connect_id = 0xFF;
    4da6:	4b04      	ldr	r3, [pc, #16]	; (4db8 <cliFunc_connectRst+0x24>)
    4da8:	22ff      	movs	r2, #255	; 0xff
    4daa:	701a      	strb	r2, [r3, #0]
}
    4dac:	bd08      	pop	{r3, pc}
    4dae:	bf00      	nop
    4db0:	00010d99 	.word	0x00010d99
    4db4:	0000cc3c 	.word	0x0000cc3c
    4db8:	1fff89fc 	.word	0x1fff89fc

00004dbc <Connect_setup>:
{
    4dbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uarts_configured = 0;
    4dbe:	4d5b      	ldr	r5, [pc, #364]	; (4f2c <Connect_setup+0x170>)
    4dc0:	2300      	movs	r3, #0
{
    4dc2:	4604      	mov	r4, r0
	uarts_configured = 0;
    4dc4:	702b      	strb	r3, [r5, #0]
	if ( first )
    4dc6:	b119      	cbz	r1, 4dd0 <Connect_setup+0x14>
		CLI_registerDictionary( uartConnectCLIDict, uartConnectCLIDictName );
    4dc8:	4959      	ldr	r1, [pc, #356]	; (4f30 <Connect_setup+0x174>)
    4dca:	485a      	ldr	r0, [pc, #360]	; (4f34 <Connect_setup+0x178>)
    4dcc:	f005 ffaa 	bl	ad24 <CLI_registerDictionary>
	Connect_master = master;
    4dd0:	4b59      	ldr	r3, [pc, #356]	; (4f38 <Connect_setup+0x17c>)
    4dd2:	701c      	strb	r4, [r3, #0]
	if ( Connect_master )
    4dd4:	b114      	cbz	r4, 4ddc <Connect_setup+0x20>
		Connect_id = 0; // 0x00 is always the master Id
    4dd6:	4b59      	ldr	r3, [pc, #356]	; (4f3c <Connect_setup+0x180>)
    4dd8:	2200      	movs	r2, #0
    4dda:	701a      	strb	r2, [r3, #0]
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    4ddc:	4b58      	ldr	r3, [pc, #352]	; (4f40 <Connect_setup+0x184>)
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
    4dde:	4959      	ldr	r1, [pc, #356]	; (4f44 <Connect_setup+0x188>)
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    4de0:	681a      	ldr	r2, [r3, #0]
	DMAMUX0_CHCFG0 = 0;
    4de2:	4e59      	ldr	r6, [pc, #356]	; (4f48 <Connect_setup+0x18c>)
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    4de4:	4f59      	ldr	r7, [pc, #356]	; (4f4c <Connect_setup+0x190>)
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    4de6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    4dea:	601a      	str	r2, [r3, #0]
	SIM_SCGC4 |= SIM_SCGC4_UART1; // Disable clock gating
    4dec:	681a      	ldr	r2, [r3, #0]
    4dee:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    4df2:	601a      	str	r2, [r3, #0]
	PORTA_PCR1 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(2); // RX Pin
    4df4:	f240 2213 	movw	r2, #531	; 0x213
    4df8:	f8c3 2fd0 	str.w	r2, [r3, #4048]	; 0xfd0
	PORTA_PCR2 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2); // TX Pin
    4dfc:	f44f 7211 	mov.w	r2, #580	; 0x244
    4e00:	f8c3 2fd4 	str.w	r2, [r3, #4052]	; 0xfd4
	PORTE_PCR0 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); // RX Pin
    4e04:	4b52      	ldr	r3, [pc, #328]	; (4f50 <Connect_setup+0x194>)
    4e06:	f240 3213 	movw	r2, #787	; 0x313
    4e0a:	601a      	str	r2, [r3, #0]
	PORTE_PCR1 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); // TX Pin
    4e0c:	f44f 7251 	mov.w	r2, #836	; 0x344
    4e10:	605a      	str	r2, [r3, #4]
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
    4e12:	4b50      	ldr	r3, [pc, #320]	; (4f54 <Connect_setup+0x198>)
    4e14:	881a      	ldrh	r2, [r3, #0]
    4e16:	0a12      	lsrs	r2, r2, #8
    4e18:	700a      	strb	r2, [r1, #0]
	UART0_BDL = (uint8_t)Connect_baud;
    4e1a:	4a4f      	ldr	r2, [pc, #316]	; (4f58 <Connect_setup+0x19c>)
    4e1c:	7819      	ldrb	r1, [r3, #0]
    4e1e:	7011      	strb	r1, [r2, #0]
	UART0_C4  = Connect_baudFine;
    4e20:	494e      	ldr	r1, [pc, #312]	; (4f5c <Connect_setup+0x1a0>)
    4e22:	7808      	ldrb	r0, [r1, #0]
    4e24:	7250      	strb	r0, [r2, #9]
	UART1_BDH = (uint8_t)(Connect_baud >> 8);
    4e26:	881a      	ldrh	r2, [r3, #0]
    4e28:	484d      	ldr	r0, [pc, #308]	; (4f60 <Connect_setup+0x1a4>)
    4e2a:	0a12      	lsrs	r2, r2, #8
    4e2c:	7002      	strb	r2, [r0, #0]
	UART1_BDL = (uint8_t)Connect_baud;
    4e2e:	781a      	ldrb	r2, [r3, #0]
    4e30:	4b4c      	ldr	r3, [pc, #304]	; (4f64 <Connect_setup+0x1a8>)
    4e32:	701a      	strb	r2, [r3, #0]
	UART1_C4  = Connect_baudFine;
    4e34:	780a      	ldrb	r2, [r1, #0]
    4e36:	725a      	strb	r2, [r3, #9]
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    4e38:	4a4b      	ldr	r2, [pc, #300]	; (4f68 <Connect_setup+0x1ac>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    4e3a:	494c      	ldr	r1, [pc, #304]	; (4f6c <Connect_setup+0x1b0>)
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    4e3c:	2316      	movs	r3, #22
    4e3e:	7013      	strb	r3, [r2, #0]
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    4e40:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
	DMAMUX0_CHCFG1 = 0;
    4e44:	f5a0 2093 	sub.w	r0, r0, #301056	; 0x49800
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    4e48:	7013      	strb	r3, [r2, #0]
	UART0_PFIFO = UART_PFIFO_TXFE;
    4e4a:	4b49      	ldr	r3, [pc, #292]	; (4f70 <Connect_setup+0x1b4>)
    4e4c:	2280      	movs	r2, #128	; 0x80
    4e4e:	701a      	strb	r2, [r3, #0]
	UART1_PFIFO = UART_PFIFO_TXFE;
    4e50:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
	DMAMUX0_CHCFG1 = 0;
    4e54:	f2a0 70ff 	subw	r0, r0, #2047	; 0x7ff
	UART1_PFIFO = UART_PFIFO_TXFE;
    4e58:	701a      	strb	r2, [r3, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    4e5a:	680b      	ldr	r3, [r1, #0]
    4e5c:	f043 0302 	orr.w	r3, r3, #2
    4e60:	600b      	str	r3, [r1, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    4e62:	684b      	ldr	r3, [r1, #4]
    4e64:	f043 0302 	orr.w	r3, r3, #2
    4e68:	604b      	str	r3, [r1, #4]
	DMA_TCD0_CSR = 0;
    4e6a:	4b42      	ldr	r3, [pc, #264]	; (4f74 <Connect_setup+0x1b8>)
	DMAMUX0_CHCFG0 = 0;
    4e6c:	2400      	movs	r4, #0
    4e6e:	7034      	strb	r4, [r6, #0]
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    4e70:	f5a1 317f 	sub.w	r1, r1, #261120	; 0x3fc00
	DMAMUX0_CHCFG1 = 0;
    4e74:	7004      	strb	r4, [r0, #0]
	DMA_TCD0_CSR = 0;
    4e76:	801c      	strh	r4, [r3, #0]
	DMA_TCD1_CSR = 0;
    4e78:	841c      	strh	r4, [r3, #32]
	DMA_CR = 0;
    4e7a:	4b3f      	ldr	r3, [pc, #252]	; (4f78 <Connect_setup+0x1bc>)
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    4e7c:	f2a1 313a 	subw	r1, r1, #826	; 0x33a
	DMA_CR = 0;
    4e80:	601c      	str	r4, [r3, #0]
	DMA_DCHPRI0 = 0; // Ch 0, priority 0
    4e82:	f883 4103 	strb.w	r4, [r3, #259]	; 0x103
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    4e86:	2301      	movs	r3, #1
    4e88:	700b      	strb	r3, [r1, #0]
	DMA_EEI = 0;
    4e8a:	f841 4cee 	str.w	r4, [r1, #-238]
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    4e8e:	f8c1 7efe 	str.w	r7, [r1, #3838]	; 0xefe
    4e92:	f601 61fe 	addw	r1, r1, #3838	; 0xefe
	DMA_TCD1_SADDR = (uint32_t*)&UART1_D;
    4e96:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
    4e9a:	620f      	str	r7, [r1, #32]
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    4e9c:	f5a7 27c3 	sub.w	r7, r7, #399360	; 0x61800
	DMA_TCD0_SOFF = 0;
    4ea0:	808c      	strh	r4, [r1, #4]
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    4ea2:	f2a7 77f7 	subw	r7, r7, #2039	; 0x7f7
	DMA_TCD1_SOFF = 0;
    4ea6:	848c      	strh	r4, [r1, #36]	; 0x24
	DMA_TCD0_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    4ea8:	80cc      	strh	r4, [r1, #6]
	DMA_TCD1_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    4eaa:	84cc      	strh	r4, [r1, #38]	; 0x26
	DMA_TCD0_NBYTES_MLNO = 1;
    4eac:	608b      	str	r3, [r1, #8]
	DMA_TCD1_NBYTES_MLNO = 1;
    4eae:	628b      	str	r3, [r1, #40]	; 0x28
	DMA_TCD0_SLAST = 0;
    4eb0:	60cc      	str	r4, [r1, #12]
	DMA_TCD1_SLAST = 0;
    4eb2:	62cc      	str	r4, [r1, #44]	; 0x2c
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    4eb4:	4931      	ldr	r1, [pc, #196]	; (4f7c <Connect_setup+0x1c0>)
    4eb6:	6039      	str	r1, [r7, #0]
	DMA_TCD1_DADDR = (uint32_t*)uart_rx_buf[1].buffer;
    4eb8:	3182      	adds	r1, #130	; 0x82
    4eba:	6239      	str	r1, [r7, #32]
	DMA_TCD0_DOFF = 1;
    4ebc:	4930      	ldr	r1, [pc, #192]	; (4f80 <Connect_setup+0x1c4>)
    4ebe:	800b      	strh	r3, [r1, #0]
	DMA_TCD1_DOFF = 1;
    4ec0:	840b      	strh	r3, [r1, #32]
	DMA_TCD0_CITER_ELINKNO = UART_Buffer_Size;
    4ec2:	804a      	strh	r2, [r1, #2]
	DMA_TCD1_CITER_ELINKNO = UART_Buffer_Size;
    4ec4:	844a      	strh	r2, [r1, #34]	; 0x22
	DMA_TCD0_BITER_ELINKNO = UART_Buffer_Size;
    4ec6:	814a      	strh	r2, [r1, #10]
	DMA_TCD1_BITER_ELINKNO = UART_Buffer_Size;
    4ec8:	854a      	strh	r2, [r1, #42]	; 0x2a
	DMA_TCD0_DLASTSGA = -( UART_Buffer_Size );
    4eca:	f06f 027f 	mvn.w	r2, #127	; 0x7f
    4ece:	604a      	str	r2, [r1, #4]
	DMA_TCD1_DLASTSGA = -( UART_Buffer_Size );
    4ed0:	624a      	str	r2, [r1, #36]	; 0x24
	DMA_ERQ |= DMA_ERQ_ERQ0 | DMA_ERQ_ERQ1;
    4ed2:	f5a1 5180 	sub.w	r1, r1, #4096	; 0x1000
    4ed6:	3908      	subs	r1, #8
    4ed8:	680a      	ldr	r2, [r1, #0]
    4eda:	f042 0203 	orr.w	r2, r2, #3
    4ede:	600a      	str	r2, [r1, #0]
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
    4ee0:	2282      	movs	r2, #130	; 0x82
	UART0_C5 = UART_C5_RDMAS;
    4ee2:	f501 21c3 	add.w	r1, r1, #399360	; 0x61800
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
    4ee6:	7032      	strb	r2, [r6, #0]
	UART0_C5 = UART_C5_RDMAS;
    4ee8:	f201 71ff 	addw	r1, r1, #2047	; 0x7ff
	DMAMUX0_CHCFG1 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART1_RX;
    4eec:	2284      	movs	r2, #132	; 0x84
    4eee:	7002      	strb	r2, [r0, #0]
	UART0_C5 = UART_C5_RDMAS;
    4ef0:	2220      	movs	r2, #32
    4ef2:	700a      	strb	r2, [r1, #0]
	UART1_C5 = UART_C5_RDMAS;
    4ef4:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    4ef8:	700a      	strb	r2, [r1, #0]
	UART0_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    4efa:	4922      	ldr	r1, [pc, #136]	; (4f84 <Connect_setup+0x1c8>)
    4efc:	222c      	movs	r2, #44	; 0x2c
    4efe:	700a      	strb	r2, [r1, #0]
	UART1_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    4f00:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    4f04:	700a      	strb	r2, [r1, #0]
	NVIC_ENABLE_IRQ( IRQ_UART0_STATUS );
    4f06:	f102 22e0 	add.w	r2, r2, #3758153728	; 0xe000e000
    4f0a:	32d8      	adds	r2, #216	; 0xd8
    4f0c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    4f10:	6011      	str	r1, [r2, #0]
	NVIC_ENABLE_IRQ( IRQ_UART1_STATUS );
    4f12:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4f16:	6011      	str	r1, [r2, #0]
	uarts_configured = 1;
    4f18:	702b      	strb	r3, [r5, #0]
	Connect_reset();
    4f1a:	f7ff ff17 	bl	4d4c <Connect_reset>
	connectLatencyResource = Latency_add_resource("UARTConnect", LatencyOption_Ticks);
    4f1e:	4621      	mov	r1, r4
    4f20:	4819      	ldr	r0, [pc, #100]	; (4f88 <Connect_setup+0x1cc>)
    4f22:	f006 f991 	bl	b248 <Latency_add_resource>
    4f26:	4b19      	ldr	r3, [pc, #100]	; (4f8c <Connect_setup+0x1d0>)
    4f28:	7018      	strb	r0, [r3, #0]
}
    4f2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4f2c:	1fff9304 	.word	0x1fff9304
    4f30:	0000cfd4 	.word	0x0000cfd4
    4f34:	0000cf74 	.word	0x0000cf74
    4f38:	1fff9300 	.word	0x1fff9300
    4f3c:	1fff89fc 	.word	0x1fff89fc
    4f40:	40048034 	.word	0x40048034
    4f44:	4006a000 	.word	0x4006a000
    4f48:	40021000 	.word	0x40021000
    4f4c:	4006a007 	.word	0x4006a007
    4f50:	4004d000 	.word	0x4004d000
    4f54:	1fff89fa 	.word	0x1fff89fa
    4f58:	4006a001 	.word	0x4006a001
    4f5c:	1fff92e4 	.word	0x1fff92e4
    4f60:	4006b000 	.word	0x4006b000
    4f64:	4006b001 	.word	0x4006b001
    4f68:	4006a002 	.word	0x4006a002
    4f6c:	4004803c 	.word	0x4004803c
    4f70:	4006a010 	.word	0x4006a010
    4f74:	4000901c 	.word	0x4000901c
    4f78:	40008000 	.word	0x40008000
    4f7c:	1fff9df8 	.word	0x1fff9df8
    4f80:	40009014 	.word	0x40009014
    4f84:	4006a003 	.word	0x4006a003
    4f88:	0000cb56 	.word	0x0000cb56
    4f8c:	1fff9303 	.word	0x1fff9303

00004f90 <Connect_rx_process>:
{
    4f90:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	switch ( uartNum )
    4f94:	4604      	mov	r4, r0
    4f96:	b118      	cbz	r0, 4fa0 <Connect_rx_process+0x10>
    4f98:	2801      	cmp	r0, #1
    4f9a:	d011      	beq.n	4fc0 <Connect_rx_process+0x30>
	uint16_t bufpos = 0;
    4f9c:	2700      	movs	r7, #0
    4f9e:	e002      	b.n	4fa6 <Connect_rx_process+0x16>
	DMA_BUF_POS( 0, bufpos );
    4fa0:	4b5b      	ldr	r3, [pc, #364]	; (5110 <Connect_rx_process+0x180>)
	DMA_BUF_POS( 1, bufpos );
    4fa2:	881f      	ldrh	r7, [r3, #0]
    4fa4:	b2bf      	uxth	r7, r7
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
    4fa6:	2382      	movs	r3, #130	; 0x82
    4fa8:	fb03 fb04 	mul.w	fp, r3, r4
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    4fac:	f04f 0902 	mov.w	r9, #2
    4fb0:	4d58      	ldr	r5, [pc, #352]	; (5114 <Connect_rx_process+0x184>)
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    4fb2:	4b59      	ldr	r3, [pc, #356]	; (5118 <Connect_rx_process+0x188>)
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    4fb4:	eb09 0984 	add.w	r9, r9, r4, lsl #2
    4fb8:	44a9      	add	r9, r5
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    4fba:	eb03 0a0b 	add.w	sl, r3, fp
    4fbe:	e075      	b.n	50ac <Connect_rx_process+0x11c>
	DMA_BUF_POS( 1, bufpos );
    4fc0:	4b56      	ldr	r3, [pc, #344]	; (511c <Connect_rx_process+0x18c>)
    4fc2:	e7ee      	b.n	4fa2 <Connect_rx_process+0x12>
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    4fc4:	2280      	movs	r2, #128	; 0x80
			if ( bufpos == UART_Buffer_Size )
    4fc6:	4297      	cmp	r7, r2
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    4fc8:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
			if ( bufpos == UART_Buffer_Size )
    4fcc:	d179      	bne.n	50c2 <Connect_rx_process+0x132>
}
    4fce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ( Connect_debug )
    4fd2:	f898 3000 	ldrb.w	r3, [r8]
    4fd6:	b113      	cbz	r3, 4fde <Connect_rx_process+0x4e>
				print(" Wait ");
    4fd8:	4851      	ldr	r0, [pc, #324]	; (5120 <Connect_rx_process+0x190>)
    4fda:	f006 fa11 	bl	b400 <_print>
			uart_rx_status[ uartNum ].status = byte == 0x16 ? UARTStatus_SYN : UARTStatus_Wait;
    4fde:	f1a6 0316 	sub.w	r3, r6, #22
    4fe2:	425e      	negs	r6, r3
    4fe4:	415e      	adcs	r6, r3
    4fe6:	f805 6024 	strb.w	r6, [r5, r4, lsl #2]
		if ( Connect_debug )
    4fea:	f898 3000 	ldrb.w	r3, [r8]
    4fee:	2b00      	cmp	r3, #0
    4ff0:	d05c      	beq.n	50ac <Connect_rx_process+0x11c>
			print( NL );
    4ff2:	484c      	ldr	r0, [pc, #304]	; (5124 <Connect_rx_process+0x194>)
    4ff4:	f006 fa04 	bl	b400 <_print>
    4ff8:	e058      	b.n	50ac <Connect_rx_process+0x11c>
			if ( Connect_debug )
    4ffa:	f898 3000 	ldrb.w	r3, [r8]
    4ffe:	b113      	cbz	r3, 5006 <Connect_rx_process+0x76>
				print(" SYN ");
    5000:	4849      	ldr	r0, [pc, #292]	; (5128 <Connect_rx_process+0x198>)
    5002:	f006 f9fd 	bl	b400 <_print>
			uart_rx_status[ uartNum ].status = byte == 0x01 ? UARTStatus_SOH : UARTStatus_Wait;
    5006:	2e01      	cmp	r6, #1
    5008:	bf14      	ite	ne
    500a:	2300      	movne	r3, #0
    500c:	2302      	moveq	r3, #2
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    500e:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
				break;
    5012:	e7ea      	b.n	4fea <Connect_rx_process+0x5a>
			if ( Connect_debug )
    5014:	f898 3000 	ldrb.w	r3, [r8]
    5018:	b113      	cbz	r3, 5020 <Connect_rx_process+0x90>
				print(" SOH ");
    501a:	4844      	ldr	r0, [pc, #272]	; (512c <Connect_rx_process+0x19c>)
    501c:	f006 f9f0 	bl	b400 <_print>
			if ( byte == Command_SYN )
    5020:	2e16      	cmp	r6, #22
    5022:	d101      	bne.n	5028 <Connect_rx_process+0x98>
				uart_rx_status[ uartNum ].status = UARTStatus_SYN;
    5024:	2301      	movs	r3, #1
    5026:	e7f2      	b.n	500e <Connect_rx_process+0x7e>
			if ( byte < Command_TOP )
    5028:	2e08      	cmp	r6, #8
				uart_rx_status[ uartNum ].status = UARTStatus_Command;
    502a:	bf98      	it	ls
    502c:	2203      	movls	r2, #3
    502e:	ea4f 0384 	mov.w	r3, r4, lsl #2
    5032:	bf9b      	ittet	ls
    5034:	f805 2024 	strbls.w	r2, [r5, r4, lsl #2]
				uart_rx_status[ uartNum ].command = byte;
    5038:	18ea      	addls	r2, r5, r3
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    503a:	2200      	movhi	r2, #0
				uart_rx_status[ uartNum ].command = byte;
    503c:	7056      	strbls	r6, [r2, #1]
				uart_rx_status[ uartNum ].bytes_waiting = 0xFFFF;
    503e:	bf94      	ite	ls
    5040:	f64f 71ff 	movwls	r1, #65535	; 0xffff
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    5044:	f805 2024 	strbhi.w	r2, [r5, r4, lsl #2]
			switch ( uart_rx_status[ uartNum ].command )
    5048:	eb05 0603 	add.w	r6, r5, r3
				uart_rx_status[ uartNum ].bytes_waiting = 0xFFFF;
    504c:	bf98      	it	ls
    504e:	8051      	strhls	r1, [r2, #2]
			switch ( uart_rx_status[ uartNum ].command )
    5050:	7873      	ldrb	r3, [r6, #1]
    5052:	2b01      	cmp	r3, #1
    5054:	d106      	bne.n	5064 <Connect_rx_process+0xd4>
				Connect_receive_IdRequest( 0, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum );
    5056:	4622      	mov	r2, r4
    5058:	4649      	mov	r1, r9
    505a:	2000      	movs	r0, #0
    505c:	f7ff fcda 	bl	4a14 <Connect_receive_IdRequest>
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    5060:	2300      	movs	r3, #0
    5062:	e7d4      	b.n	500e <Connect_rx_process+0x7e>
				if ( Connect_debug )
    5064:	f898 3000 	ldrb.w	r3, [r8]
    5068:	b303      	cbz	r3, 50ac <Connect_rx_process+0x11c>
					print(" ### ");
    506a:	4831      	ldr	r0, [pc, #196]	; (5130 <Connect_rx_process+0x1a0>)
    506c:	f006 f9c8 	bl	b400 <_print>
					printHex( uart_rx_status[ uartNum ].command );
    5070:	7870      	ldrb	r0, [r6, #1]
    5072:	2101      	movs	r1, #1
    5074:	f006 fa6c 	bl	b550 <printHex_op>
    5078:	e7b7      	b.n	4fea <Connect_rx_process+0x5a>
			if ( Connect_debug )
    507a:	f898 3000 	ldrb.w	r3, [r8]
    507e:	b113      	cbz	r3, 5086 <Connect_rx_process+0xf6>
				print(" CMD ");
    5080:	482c      	ldr	r0, [pc, #176]	; (5134 <Connect_rx_process+0x1a4>)
    5082:	f006 f9bd 	bl	b400 <_print>
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    5086:	eb05 0384 	add.w	r3, r5, r4, lsl #2
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    508a:	4649      	mov	r1, r9
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    508c:	785a      	ldrb	r2, [r3, #1]
    508e:	4b2a      	ldr	r3, [pc, #168]	; (5138 <Connect_rx_process+0x1a8>)
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    5090:	4630      	mov	r0, r6
    5092:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5096:	4622      	mov	r2, r4
    5098:	4798      	blx	r3
    509a:	2800      	cmp	r0, #0
    509c:	d0a5      	beq.n	4fea <Connect_rx_process+0x5a>
    509e:	e7df      	b.n	5060 <Connect_rx_process+0xd0>
			erro_msg("Invalid UARTStatus...");
    50a0:	4826      	ldr	r0, [pc, #152]	; (513c <Connect_rx_process+0x1ac>)
    50a2:	f006 f9ad 	bl	b400 <_print>
			uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    50a6:	2300      	movs	r3, #0
    50a8:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
    50ac:	4b1a      	ldr	r3, [pc, #104]	; (5118 <Connect_rx_process+0x188>)
    50ae:	445b      	add	r3, fp
    50b0:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
    50b4:	4297      	cmp	r7, r2
    50b6:	d08a      	beq.n	4fce <Connect_rx_process+0x3e>
		if ( uart_rx_buf[ uartNum ].last_read == 0 )
    50b8:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
    50bc:	b292      	uxth	r2, r2
    50be:	2a00      	cmp	r2, #0
    50c0:	d080      	beq.n	4fc4 <Connect_rx_process+0x34>
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    50c2:	f8ba 3080 	ldrh.w	r3, [sl, #128]	; 0x80
		if ( Connect_debug )
    50c6:	f8df 807c 	ldr.w	r8, [pc, #124]	; 5144 <Connect_rx_process+0x1b4>
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    50ca:	b29b      	uxth	r3, r3
    50cc:	1e5a      	subs	r2, r3, #1
    50ce:	b292      	uxth	r2, r2
    50d0:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
    50d4:	f8aa 2080 	strh.w	r2, [sl, #128]	; 0x80
    50d8:	f81a 6003 	ldrb.w	r6, [sl, r3]
		if ( Connect_debug )
    50dc:	f898 3000 	ldrb.w	r3, [r8]
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    50e0:	b2f6      	uxtb	r6, r6
		if ( Connect_debug )
    50e2:	b133      	cbz	r3, 50f2 <Connect_rx_process+0x162>
			printHex( byte );
    50e4:	4630      	mov	r0, r6
    50e6:	2101      	movs	r1, #1
    50e8:	f006 fa32 	bl	b550 <printHex_op>
			print(" ");
    50ec:	4814      	ldr	r0, [pc, #80]	; (5140 <Connect_rx_process+0x1b0>)
    50ee:	f006 f987 	bl	b400 <_print>
		switch ( uart_rx_status[ uartNum ].status )
    50f2:	f815 3024 	ldrb.w	r3, [r5, r4, lsl #2]
    50f6:	2b03      	cmp	r3, #3
    50f8:	d8d2      	bhi.n	50a0 <Connect_rx_process+0x110>
    50fa:	a201      	add	r2, pc, #4	; (adr r2, 5100 <Connect_rx_process+0x170>)
    50fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5100:	00004fd3 	.word	0x00004fd3
    5104:	00004ffb 	.word	0x00004ffb
    5108:	00005015 	.word	0x00005015
    510c:	0000507b 	.word	0x0000507b
    5110:	40009016 	.word	0x40009016
    5114:	1fff9df0 	.word	0x1fff9df0
    5118:	1fff9df8 	.word	0x1fff9df8
    511c:	40009036 	.word	0x40009036
    5120:	0000caf4 	.word	0x0000caf4
    5124:	00010d99 	.word	0x00010d99
    5128:	0000cafb 	.word	0x0000cafb
    512c:	0000cb01 	.word	0x0000cb01
    5130:	0000cb07 	.word	0x0000cb07
    5134:	0000cb0d 	.word	0x0000cb0d
    5138:	1fff8a00 	.word	0x1fff8a00
    513c:	0000cb13 	.word	0x0000cb13
    5140:	00011f77 	.word	0x00011f77
    5144:	1fff92fa 	.word	0x1fff92fa

00005148 <Connect_scan>:
{
    5148:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	Latency_start_time( connectLatencyResource );
    514a:	4e62      	ldr	r6, [pc, #392]	; (52d4 <Connect_scan+0x18c>)
	if ( !Connect_master && Output_Available && !Connect_override )
    514c:	4c62      	ldr	r4, [pc, #392]	; (52d8 <Connect_scan+0x190>)
	Latency_start_time( connectLatencyResource );
    514e:	7830      	ldrb	r0, [r6, #0]
    5150:	f006 f8ca 	bl	b2e8 <Latency_start_time>
	if ( !Connect_master && Output_Available && !Connect_override )
    5154:	7822      	ldrb	r2, [r4, #0]
    5156:	b942      	cbnz	r2, 516a <Connect_scan+0x22>
    5158:	4b60      	ldr	r3, [pc, #384]	; (52dc <Connect_scan+0x194>)
    515a:	781a      	ldrb	r2, [r3, #0]
    515c:	b12a      	cbz	r2, 516a <Connect_scan+0x22>
    515e:	4a60      	ldr	r2, [pc, #384]	; (52e0 <Connect_scan+0x198>)
    5160:	7811      	ldrb	r1, [r2, #0]
    5162:	b911      	cbnz	r1, 516a <Connect_scan+0x22>
		Connect_setup( Output_Available, 0 );
    5164:	7818      	ldrb	r0, [r3, #0]
    5166:	f7ff fe29 	bl	4dbc <Connect_setup>
	uint32_t current_time = systick_millis_count;
    516a:	4b5e      	ldr	r3, [pc, #376]	; (52e4 <Connect_scan+0x19c>)
	if ( Connect_lastCheck != current_time
    516c:	4a5e      	ldr	r2, [pc, #376]	; (52e8 <Connect_scan+0x1a0>)
	uint32_t current_time = systick_millis_count;
    516e:	681b      	ldr	r3, [r3, #0]
	if ( Connect_lastCheck != current_time
    5170:	6811      	ldr	r1, [r2, #0]
    5172:	4299      	cmp	r1, r3
    5174:	d014      	beq.n	51a0 <Connect_scan+0x58>
		&& ( current_time & time_compare ) == time_compare
    5176:	f3c3 000a 	ubfx	r0, r3, #0, #11
    517a:	f240 71ff 	movw	r1, #2047	; 0x7ff
    517e:	4288      	cmp	r0, r1
    5180:	d10e      	bne.n	51a0 <Connect_scan+0x58>
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    5182:	2002      	movs	r0, #2
		Connect_lastCheck = current_time;
    5184:	6013      	str	r3, [r2, #0]
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    5186:	f7ff fbc1 	bl	490c <Connect_send_CableCheck>
		if ( !Connect_master && Connect_id == 0xFF && Connect_cableOkMaster )
    518a:	7823      	ldrb	r3, [r4, #0]
    518c:	b943      	cbnz	r3, 51a0 <Connect_scan+0x58>
    518e:	4b57      	ldr	r3, [pc, #348]	; (52ec <Connect_scan+0x1a4>)
    5190:	781b      	ldrb	r3, [r3, #0]
    5192:	2bff      	cmp	r3, #255	; 0xff
    5194:	d104      	bne.n	51a0 <Connect_scan+0x58>
    5196:	4b56      	ldr	r3, [pc, #344]	; (52f0 <Connect_scan+0x1a8>)
    5198:	781b      	ldrb	r3, [r3, #0]
    519a:	b10b      	cbz	r3, 51a0 <Connect_scan+0x58>
			Connect_send_IdRequest();
    519c:	f7ff fbfa 	bl	4994 <Connect_send_IdRequest>
	if ( uarts_configured )
    51a0:	4b54      	ldr	r3, [pc, #336]	; (52f4 <Connect_scan+0x1ac>)
    51a2:	781b      	ldrb	r3, [r3, #0]
    51a4:	b163      	cbz	r3, 51c0 <Connect_scan+0x78>
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    51a6:	4c54      	ldr	r4, [pc, #336]	; (52f8 <Connect_scan+0x1b0>)
    51a8:	78a3      	ldrb	r3, [r4, #2]
    51aa:	b973      	cbnz	r3, 51ca <Connect_scan+0x82>
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    51ac:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
    51b0:	2b00      	cmp	r3, #0
    51b2:	d14a      	bne.n	524a <Connect_scan+0x102>
		Connect_rx_process( 0 );
    51b4:	2000      	movs	r0, #0
    51b6:	f7ff feeb 	bl	4f90 <Connect_rx_process>
		Connect_rx_process( 1 );
    51ba:	2001      	movs	r0, #1
    51bc:	f7ff fee8 	bl	4f90 <Connect_rx_process>
	Latency_end_time( connectLatencyResource );
    51c0:	7830      	ldrb	r0, [r6, #0]
}
    51c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	Latency_end_time( connectLatencyResource );
    51c6:	f006 b8a1 	b.w	b30c <Latency_end_time>
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    51ca:	4f4c      	ldr	r7, [pc, #304]	; (52fc <Connect_scan+0x1b4>)
    51cc:	783b      	ldrb	r3, [r7, #0]
    51ce:	2b00      	cmp	r3, #0
    51d0:	d1ec      	bne.n	51ac <Connect_scan+0x64>
			uart_fillTxFifo( 0 );
    51d2:	4b4b      	ldr	r3, [pc, #300]	; (5300 <Connect_scan+0x1b8>)
    51d4:	781d      	ldrb	r5, [r3, #0]
    51d6:	4b4b      	ldr	r3, [pc, #300]	; (5304 <Connect_scan+0x1bc>)
    51d8:	08ad      	lsrs	r5, r5, #2
    51da:	781b      	ldrb	r3, [r3, #0]
    51dc:	f015 051c 	ands.w	r5, r5, #28
    51e0:	bf08      	it	eq
    51e2:	2501      	moveq	r5, #1
    51e4:	b1bb      	cbz	r3, 5216 <Connect_scan+0xce>
    51e6:	4848      	ldr	r0, [pc, #288]	; (5308 <Connect_scan+0x1c0>)
    51e8:	f006 f90a 	bl	b400 <_print>
    51ec:	2101      	movs	r1, #1
    51ee:	4628      	mov	r0, r5
    51f0:	f006 f9ae 	bl	b550 <printHex_op>
    51f4:	4845      	ldr	r0, [pc, #276]	; (530c <Connect_scan+0x1c4>)
    51f6:	f006 f903 	bl	b400 <_print>
    51fa:	2101      	movs	r1, #1
    51fc:	7838      	ldrb	r0, [r7, #0]
    51fe:	f006 f9a7 	bl	b550 <printHex_op>
    5202:	4842      	ldr	r0, [pc, #264]	; (530c <Connect_scan+0x1c4>)
    5204:	f006 f8fc 	bl	b400 <_print>
    5208:	78a0      	ldrb	r0, [r4, #2]
    520a:	2101      	movs	r1, #1
    520c:	f006 f9a0 	bl	b550 <printHex_op>
    5210:	483f      	ldr	r0, [pc, #252]	; (5310 <Connect_scan+0x1c8>)
    5212:	f006 f8f5 	bl	b400 <_print>
    5216:	783b      	ldrb	r3, [r7, #0]
    5218:	493e      	ldr	r1, [pc, #248]	; (5314 <Connect_scan+0x1cc>)
    521a:	1aed      	subs	r5, r5, r3
    521c:	b2ed      	uxtb	r5, r5
    521e:	2000      	movs	r0, #0
    5220:	2d00      	cmp	r5, #0
    5222:	d0c3      	beq.n	51ac <Connect_scan+0x64>
    5224:	78a3      	ldrb	r3, [r4, #2]
    5226:	2b00      	cmp	r3, #0
    5228:	d0c0      	beq.n	51ac <Connect_scan+0x64>
    522a:	7822      	ldrb	r2, [r4, #0]
    522c:	1c57      	adds	r7, r2, #1
    522e:	4422      	add	r2, r4
    5230:	7027      	strb	r7, [r4, #0]
    5232:	78d2      	ldrb	r2, [r2, #3]
    5234:	700a      	strb	r2, [r1, #0]
    5236:	3b01      	subs	r3, #1
    5238:	70a3      	strb	r3, [r4, #2]
    523a:	f994 3000 	ldrsb.w	r3, [r4]
    523e:	3d01      	subs	r5, #1
    5240:	2b00      	cmp	r3, #0
    5242:	bfb8      	it	lt
    5244:	7020      	strblt	r0, [r4, #0]
    5246:	b2ed      	uxtb	r5, r5
    5248:	e7ea      	b.n	5220 <Connect_scan+0xd8>
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    524a:	4f33      	ldr	r7, [pc, #204]	; (5318 <Connect_scan+0x1d0>)
    524c:	783b      	ldrb	r3, [r7, #0]
    524e:	2b00      	cmp	r3, #0
    5250:	d1b0      	bne.n	51b4 <Connect_scan+0x6c>
			uart_fillTxFifo( 1 );
    5252:	4b32      	ldr	r3, [pc, #200]	; (531c <Connect_scan+0x1d4>)
    5254:	781d      	ldrb	r5, [r3, #0]
    5256:	4b2b      	ldr	r3, [pc, #172]	; (5304 <Connect_scan+0x1bc>)
    5258:	08ad      	lsrs	r5, r5, #2
    525a:	781b      	ldrb	r3, [r3, #0]
    525c:	f015 051c 	ands.w	r5, r5, #28
    5260:	bf08      	it	eq
    5262:	2501      	moveq	r5, #1
    5264:	b1c3      	cbz	r3, 5298 <Connect_scan+0x150>
    5266:	482e      	ldr	r0, [pc, #184]	; (5320 <Connect_scan+0x1d8>)
    5268:	f006 f8ca 	bl	b400 <_print>
    526c:	2101      	movs	r1, #1
    526e:	4628      	mov	r0, r5
    5270:	f006 f96e 	bl	b550 <printHex_op>
    5274:	4825      	ldr	r0, [pc, #148]	; (530c <Connect_scan+0x1c4>)
    5276:	f006 f8c3 	bl	b400 <_print>
    527a:	2101      	movs	r1, #1
    527c:	7838      	ldrb	r0, [r7, #0]
    527e:	f006 f967 	bl	b550 <printHex_op>
    5282:	4822      	ldr	r0, [pc, #136]	; (530c <Connect_scan+0x1c4>)
    5284:	f006 f8bc 	bl	b400 <_print>
    5288:	f894 0085 	ldrb.w	r0, [r4, #133]	; 0x85
    528c:	2101      	movs	r1, #1
    528e:	f006 f95f 	bl	b550 <printHex_op>
    5292:	481f      	ldr	r0, [pc, #124]	; (5310 <Connect_scan+0x1c8>)
    5294:	f006 f8b4 	bl	b400 <_print>
    5298:	783b      	ldrb	r3, [r7, #0]
    529a:	4822      	ldr	r0, [pc, #136]	; (5324 <Connect_scan+0x1dc>)
    529c:	1aed      	subs	r5, r5, r3
    529e:	b2ed      	uxtb	r5, r5
    52a0:	2700      	movs	r7, #0
    52a2:	2d00      	cmp	r5, #0
    52a4:	d086      	beq.n	51b4 <Connect_scan+0x6c>
    52a6:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
    52aa:	2b00      	cmp	r3, #0
    52ac:	d082      	beq.n	51b4 <Connect_scan+0x6c>
    52ae:	f894 2083 	ldrb.w	r2, [r4, #131]	; 0x83
    52b2:	1c51      	adds	r1, r2, #1
    52b4:	4422      	add	r2, r4
    52b6:	3b01      	subs	r3, #1
    52b8:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
    52bc:	f884 1083 	strb.w	r1, [r4, #131]	; 0x83
    52c0:	3d01      	subs	r5, #1
    52c2:	7002      	strb	r2, [r0, #0]
    52c4:	f884 3085 	strb.w	r3, [r4, #133]	; 0x85
    52c8:	060b      	lsls	r3, r1, #24
    52ca:	bf48      	it	mi
    52cc:	f884 7083 	strbmi.w	r7, [r4, #131]	; 0x83
    52d0:	b2ed      	uxtb	r5, r5
    52d2:	e7e6      	b.n	52a2 <Connect_scan+0x15a>
    52d4:	1fff9303 	.word	0x1fff9303
    52d8:	1fff9300 	.word	0x1fff9300
    52dc:	1fffadba 	.word	0x1fffadba
    52e0:	1fff9302 	.word	0x1fff9302
    52e4:	1fff9158 	.word	0x1fff9158
    52e8:	1fff92fc 	.word	0x1fff92fc
    52ec:	1fff89fc 	.word	0x1fff89fc
    52f0:	1fff92f8 	.word	0x1fff92f8
    52f4:	1fff9304 	.word	0x1fff9304
    52f8:	1fff9cc6 	.word	0x1fff9cc6
    52fc:	4006a014 	.word	0x4006a014
    5300:	4006a010 	.word	0x4006a010
    5304:	1fff92fa 	.word	0x1fff92fa
    5308:	0000cb3e 	.word	0x0000cb3e
    530c:	0000b857 	.word	0x0000b857
    5310:	00010d99 	.word	0x00010d99
    5314:	4006a007 	.word	0x4006a007
    5318:	4006b014 	.word	0x4006b014
    531c:	4006b010 	.word	0x4006b010
    5320:	0000cb4a 	.word	0x0000cb4a
    5324:	4006b007 	.word	0x4006b007

00005328 <Connect_currentChange>:
}
    5328:	4770      	bx	lr
    532a:	0000      	movs	r0, r0

0000532c <Scan_setup>:

// ----- Functions -----

// Setup
inline void Scan_setup()
{
    532c:	b508      	push	{r3, lr}
	// Setup UART Connect, if Output_Available, this is the master node
	Connect_setup( Output_Available, 1 );
    532e:	4b08      	ldr	r3, [pc, #32]	; (5350 <Scan_setup+0x24>)
    5330:	2101      	movs	r1, #1
    5332:	7818      	ldrb	r0, [r3, #0]
    5334:	f7ff fd42 	bl	4dbc <Connect_setup>

	// Setup GPIO pins for matrix scanning
	Matrix_setup();
    5338:	f7fe f9a4 	bl	3684 <Matrix_setup>

	// Setup ISSI chip to control the leds
	LED_setup();
    533c:	f7fd fefa 	bl	3134 <LED_setup>

	// Setup the ST/NHD lcd display
	LCD_setup();
    5340:	f7fe fda2 	bl	3e88 <LCD_setup>

	// Setup Pixel Map
	Pixel_setup();
    5344:	f002 fe7c 	bl	8040 <Pixel_setup>

	// Start Matrix Scanner
	Matrix_start();
}
    5348:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	Matrix_start();
    534c:	f7fe bbd8 	b.w	3b00 <Matrix_start>
    5350:	1fffadba 	.word	0x1fffadba

00005354 <Scan_poll>:

// Main Poll Loop
// This is for operations that need to be run as often as possible
// Usually reserved for LED update routines and other things that need quick update rates
void Scan_poll()
{
    5354:	b508      	push	{r3, lr}
	// Prepare any LED events
	Pixel_process();
    5356:	f002 fd75 	bl	7e44 <Pixel_process>

	// Process any LED events
	LED_scan();
    535a:	f7fd ff49 	bl	31f0 <LED_scan>

	// Process any LCD events
	LCD_scan();
}
    535e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LCD_scan();
    5362:	f7fe be19 	b.w	3f98 <LCD_scan>

00005366 <Scan_periodic>:

// Main Periodic Scan
// This function is called periodically at a constant rate
// Useful for matrix scanning and anything that requires consistent attention
uint8_t Scan_periodic()
{
    5366:	b508      	push	{r3, lr}
	// Process any interconnect commands
	Connect_scan();
    5368:	f7ff feee 	bl	5148 <Connect_scan>

	// Scan Matrix
	return Matrix_single_scan();
}
    536c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return Matrix_single_scan();
    5370:	f7fe ba00 	b.w	3774 <Matrix_single_scan>

00005374 <Scan_finishedWithMacro>:


// Signal from Macro Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithMacro( uint8_t sentKeys )
{
}
    5374:	4770      	bx	lr

00005376 <Scan_finishedWithOutput>:
    5376:	4770      	bx	lr

00005378 <Scan_currentChange>:


// Signal from the Output Module that the available current has changed
// current - mA
void Scan_currentChange( unsigned int current )
{
    5378:	b510      	push	{r4, lr}
    537a:	4604      	mov	r4, r0
	// Indicate to all submodules current change
	Connect_currentChange( current );
    537c:	f7ff ffd4 	bl	5328 <Connect_currentChange>
	Matrix_currentChange( current );
    5380:	4620      	mov	r0, r4
    5382:	f7fe fbc1 	bl	3b08 <Matrix_currentChange>
	LED_currentChange( current );
    5386:	4620      	mov	r0, r4
    5388:	f7fd fff4 	bl	3374 <LED_currentChange>
	LCD_currentChange( current );
    538c:	4620      	mov	r0, r4
}
    538e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LCD_currentChange( current );
    5392:	f7fe be43 	b.w	401c <LCD_currentChange>
    5396:	0000      	movs	r0, r0

00005398 <cliFunc_posList>:
	print("."); \
	printInt16( Key_Position[ key ].name.f )

void cliFunc_posList( char* args )
{
	print( NL );
    5398:	4801      	ldr	r0, [pc, #4]	; (53a0 <cliFunc_posList+0x8>)
    539a:	f006 b831 	b.w	b400 <_print>
    539e:	bf00      	nop
    53a0:	00010d99 	.word	0x00010d99

000053a4 <cliFunc_capList>:
{
    53a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	print( NL );
    53a8:	4812      	ldr	r0, [pc, #72]	; (53f4 <cliFunc_capList+0x50>)
		print( NL "\t" );
    53aa:	f8df 8058 	ldr.w	r8, [pc, #88]	; 5404 <cliFunc_capList+0x60>
		print(" - ");
    53ae:	4f12      	ldr	r7, [pc, #72]	; (53f8 <cliFunc_capList+0x54>)
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
    53b0:	4e12      	ldr	r6, [pc, #72]	; (53fc <cliFunc_capList+0x58>)
	print( NL );
    53b2:	f006 f825 	bl	b400 <_print>
	info_msg("Capabilities List ");
    53b6:	4812      	ldr	r0, [pc, #72]	; (5400 <cliFunc_capList+0x5c>)
    53b8:	f006 f822 	bl	b400 <_print>
	printHex( CapabilitiesNum );
    53bc:	2101      	movs	r1, #1
    53be:	2015      	movs	r0, #21
    53c0:	f006 f8c6 	bl	b550 <printHex_op>
    53c4:	2400      	movs	r4, #0
		print( NL "\t" );
    53c6:	4640      	mov	r0, r8
    53c8:	f006 f81a 	bl	b400 <_print>
		printHex( cap );
    53cc:	2101      	movs	r1, #1
    53ce:	b2a0      	uxth	r0, r4
    53d0:	f006 f8be 	bl	b550 <printHex_op>
		print(" - ");
    53d4:	4638      	mov	r0, r7
    53d6:	f006 f813 	bl	b400 <_print>
		capability( 0, 0xFF, 0xFF, 0 );
    53da:	2300      	movs	r3, #0
    53dc:	22ff      	movs	r2, #255	; 0xff
    53de:	f856 5034 	ldr.w	r5, [r6, r4, lsl #3]
    53e2:	4611      	mov	r1, r2
    53e4:	4618      	mov	r0, r3
    53e6:	3401      	adds	r4, #1
    53e8:	47a8      	blx	r5
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
    53ea:	2c15      	cmp	r4, #21
    53ec:	d1eb      	bne.n	53c6 <cliFunc_capList+0x22>
}
    53ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    53f2:	bf00      	nop
    53f4:	00010d99 	.word	0x00010d99
    53f8:	0000bad4 	.word	0x0000bad4
    53fc:	0000cff0 	.word	0x0000cff0
    5400:	0000d8da 	.word	0x0000d8da
    5404:	0000d8ff 	.word	0x0000d8ff

00005408 <cliFunc_layerDebug>:
{
    5408:	b510      	push	{r4, lr}
	layerDebugMode = layerDebugMode ? 0 : 1;
    540a:	4c08      	ldr	r4, [pc, #32]	; (542c <cliFunc_layerDebug+0x24>)
	print( NL );
    540c:	4808      	ldr	r0, [pc, #32]	; (5430 <cliFunc_layerDebug+0x28>)
	layerDebugMode = layerDebugMode ? 0 : 1;
    540e:	7823      	ldrb	r3, [r4, #0]
    5410:	fab3 f383 	clz	r3, r3
    5414:	095b      	lsrs	r3, r3, #5
    5416:	7023      	strb	r3, [r4, #0]
	print( NL );
    5418:	f005 fff2 	bl	b400 <_print>
	info_msg("Layer Debug Mode: ");
    541c:	4805      	ldr	r0, [pc, #20]	; (5434 <cliFunc_layerDebug+0x2c>)
    541e:	f005 ffef 	bl	b400 <_print>
	printInt8( layerDebugMode );
    5422:	7820      	ldrb	r0, [r4, #0]
}
    5424:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( layerDebugMode );
    5428:	f006 b81c 	b.w	b464 <printInt8>
    542c:	1fffa140 	.word	0x1fffa140
    5430:	00010d99 	.word	0x00010d99
    5434:	0000d9ad 	.word	0x0000d9ad

00005438 <cliFunc_macroProc>:
{
    5438:	b510      	push	{r4, lr}
	macroPauseMode = macroPauseMode ? 0 : 1;
    543a:	4c08      	ldr	r4, [pc, #32]	; (545c <cliFunc_macroProc+0x24>)
	print( NL );
    543c:	4808      	ldr	r0, [pc, #32]	; (5460 <cliFunc_macroProc+0x28>)
	macroPauseMode = macroPauseMode ? 0 : 1;
    543e:	7823      	ldrb	r3, [r4, #0]
    5440:	fab3 f383 	clz	r3, r3
    5444:	095b      	lsrs	r3, r3, #5
    5446:	7023      	strb	r3, [r4, #0]
	print( NL );
    5448:	f005 ffda 	bl	b400 <_print>
	info_msg("Macro Processing Mode: ");
    544c:	4805      	ldr	r0, [pc, #20]	; (5464 <cliFunc_macroProc+0x2c>)
    544e:	f005 ffd7 	bl	b400 <_print>
	printInt8( macroPauseMode );
    5452:	7820      	ldrb	r0, [r4, #0]
}
    5454:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( macroPauseMode );
    5458:	f006 b804 	b.w	b464 <printInt8>
    545c:	1fff9f00 	.word	0x1fff9f00
    5460:	00010d99 	.word	0x00010d99
    5464:	0000e47f 	.word	0x0000e47f

00005468 <cliFunc_macroList>:
{
    5468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	print( NL );
    546a:	4849      	ldr	r0, [pc, #292]	; (5590 <cliFunc_macroList+0x128>)
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    546c:	4c49      	ldr	r4, [pc, #292]	; (5594 <cliFunc_macroList+0x12c>)
		printHex( macroTriggerEventBuffer[ key ].index );
    546e:	4f4a      	ldr	r7, [pc, #296]	; (5598 <cliFunc_macroList+0x130>)
		print(" ");
    5470:	4e4a      	ldr	r6, [pc, #296]	; (559c <cliFunc_macroList+0x134>)
	print( NL );
    5472:	f005 ffc5 	bl	b400 <_print>
	info_msg("Pending Key Events: ");
    5476:	484a      	ldr	r0, [pc, #296]	; (55a0 <cliFunc_macroList+0x138>)
    5478:	f005 ffc2 	bl	b400 <_print>
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    547c:	7820      	ldrb	r0, [r4, #0]
    547e:	f006 f80f 	bl	b4a0 <printInt16>
	print(" : ");
    5482:	4848      	ldr	r0, [pc, #288]	; (55a4 <cliFunc_macroList+0x13c>)
    5484:	f005 ffbc 	bl	b400 <_print>
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    5488:	2300      	movs	r3, #0
    548a:	7822      	ldrb	r2, [r4, #0]
    548c:	1c5d      	adds	r5, r3, #1
    548e:	b2db      	uxtb	r3, r3
    5490:	429a      	cmp	r2, r3
    5492:	d85c      	bhi.n	554e <cliFunc_macroList+0xe6>
	print( NL );
    5494:	483e      	ldr	r0, [pc, #248]	; (5590 <cliFunc_macroList+0x128>)
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    5496:	4c44      	ldr	r4, [pc, #272]	; (55a8 <cliFunc_macroList+0x140>)
		printHex( macroTriggerMacroPendingList[ macro ] );
    5498:	4e44      	ldr	r6, [pc, #272]	; (55ac <cliFunc_macroList+0x144>)
		print(" ");
    549a:	4f40      	ldr	r7, [pc, #256]	; (559c <cliFunc_macroList+0x134>)
	print( NL );
    549c:	f005 ffb0 	bl	b400 <_print>
	info_msg("Pending Trigger Macros: ");
    54a0:	4843      	ldr	r0, [pc, #268]	; (55b0 <cliFunc_macroList+0x148>)
    54a2:	f005 ffad 	bl	b400 <_print>
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    54a6:	8820      	ldrh	r0, [r4, #0]
    54a8:	f005 fffa 	bl	b4a0 <printInt16>
	print(" : ");
    54ac:	483d      	ldr	r0, [pc, #244]	; (55a4 <cliFunc_macroList+0x13c>)
    54ae:	f005 ffa7 	bl	b400 <_print>
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    54b2:	2300      	movs	r3, #0
    54b4:	8822      	ldrh	r2, [r4, #0]
    54b6:	1c5d      	adds	r5, r3, #1
    54b8:	b2db      	uxtb	r3, r3
    54ba:	4293      	cmp	r3, r2
    54bc:	d353      	bcc.n	5566 <cliFunc_macroList+0xfe>
	print( NL );
    54be:	4834      	ldr	r0, [pc, #208]	; (5590 <cliFunc_macroList+0x128>)
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    54c0:	4c3c      	ldr	r4, [pc, #240]	; (55b4 <cliFunc_macroList+0x14c>)
		print(" ");
    54c2:	4e36      	ldr	r6, [pc, #216]	; (559c <cliFunc_macroList+0x134>)
	print( NL );
    54c4:	f005 ff9c 	bl	b400 <_print>
	info_msg("Pending Result Macros: ");
    54c8:	483b      	ldr	r0, [pc, #236]	; (55b8 <cliFunc_macroList+0x150>)
    54ca:	f005 ff99 	bl	b400 <_print>
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    54ce:	f8b4 0318 	ldrh.w	r0, [r4, #792]	; 0x318
    54d2:	f005 ffe5 	bl	b4a0 <printInt16>
	print(" : ");
    54d6:	4833      	ldr	r0, [pc, #204]	; (55a4 <cliFunc_macroList+0x13c>)
    54d8:	f005 ff92 	bl	b400 <_print>
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    54dc:	2300      	movs	r3, #0
    54de:	f8b4 2318 	ldrh.w	r2, [r4, #792]	; 0x318
    54e2:	1c5d      	adds	r5, r3, #1
    54e4:	b2db      	uxtb	r3, r3
    54e6:	4293      	cmp	r3, r2
    54e8:	d347      	bcc.n	557a <cliFunc_macroList+0x112>
	print( NL );
    54ea:	4829      	ldr	r0, [pc, #164]	; (5590 <cliFunc_macroList+0x128>)
		print( NL );
    54ec:	4f28      	ldr	r7, [pc, #160]	; (5590 <cliFunc_macroList+0x128>)
		print("\tT");
    54ee:	4e33      	ldr	r6, [pc, #204]	; (55bc <cliFunc_macroList+0x154>)
		print(" : R");
    54f0:	4d33      	ldr	r5, [pc, #204]	; (55c0 <cliFunc_macroList+0x158>)
	print( NL );
    54f2:	f005 ff85 	bl	b400 <_print>
	info_msg("Trigger Macros Range: T0 -> T");
    54f6:	4833      	ldr	r0, [pc, #204]	; (55c4 <cliFunc_macroList+0x15c>)
    54f8:	f005 ff82 	bl	b400 <_print>
	printInt16( (uint16_t)TriggerMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    54fc:	2066      	movs	r0, #102	; 0x66
    54fe:	f005 ffcf 	bl	b4a0 <printInt16>
	print( NL );
    5502:	4823      	ldr	r0, [pc, #140]	; (5590 <cliFunc_macroList+0x128>)
    5504:	f005 ff7c 	bl	b400 <_print>
	info_msg("Result  Macros Range: R0 -> R");
    5508:	482f      	ldr	r0, [pc, #188]	; (55c8 <cliFunc_macroList+0x160>)
    550a:	f005 ff79 	bl	b400 <_print>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    550e:	2062      	movs	r0, #98	; 0x62
    5510:	f005 ffc6 	bl	b4a0 <printInt16>
	print( NL );
    5514:	481e      	ldr	r0, [pc, #120]	; (5590 <cliFunc_macroList+0x128>)
    5516:	f005 ff73 	bl	b400 <_print>
	info_msg("Trigger : Result Macro Pairs");
    551a:	482c      	ldr	r0, [pc, #176]	; (55cc <cliFunc_macroList+0x164>)
    551c:	f005 ff70 	bl	b400 <_print>
    5520:	2400      	movs	r4, #0
		print( NL );
    5522:	4638      	mov	r0, r7
    5524:	f005 ff6c 	bl	b400 <_print>
		print("\tT");
    5528:	4630      	mov	r0, r6
    552a:	f005 ff69 	bl	b400 <_print>
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
    552e:	b2a0      	uxth	r0, r4
    5530:	f005 ffb6 	bl	b4a0 <printInt16>
		print(" : R");
    5534:	4628      	mov	r0, r5
    5536:	f005 ff63 	bl	b400 <_print>
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
    553a:	4b25      	ldr	r3, [pc, #148]	; (55d0 <cliFunc_macroList+0x168>)
    553c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    5540:	3401      	adds	r4, #1
    5542:	7918      	ldrb	r0, [r3, #4]
    5544:	f005 ffac 	bl	b4a0 <printInt16>
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    5548:	2c67      	cmp	r4, #103	; 0x67
    554a:	d1ea      	bne.n	5522 <cliFunc_macroList+0xba>
}
    554c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		printHex( macroTriggerEventBuffer[ key ].index );
    554e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5552:	443b      	add	r3, r7
    5554:	2101      	movs	r1, #1
    5556:	7898      	ldrb	r0, [r3, #2]
    5558:	f005 fffa 	bl	b550 <printHex_op>
		print(" ");
    555c:	4630      	mov	r0, r6
    555e:	f005 ff4f 	bl	b400 <_print>
    5562:	462b      	mov	r3, r5
    5564:	e791      	b.n	548a <cliFunc_macroList+0x22>
		printHex( macroTriggerMacroPendingList[ macro ] );
    5566:	f836 0013 	ldrh.w	r0, [r6, r3, lsl #1]
    556a:	2101      	movs	r1, #1
    556c:	f005 fff0 	bl	b550 <printHex_op>
		print(" ");
    5570:	4638      	mov	r0, r7
    5572:	f005 ff45 	bl	b400 <_print>
    5576:	462b      	mov	r3, r5
    5578:	e79c      	b.n	54b4 <cliFunc_macroList+0x4c>
		printHex( macroResultMacroPendingList.data[ macro ].index );
    557a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    557e:	2101      	movs	r1, #1
    5580:	8898      	ldrh	r0, [r3, #4]
    5582:	f005 ffe5 	bl	b550 <printHex_op>
		print(" ");
    5586:	4630      	mov	r0, r6
    5588:	f005 ff3a 	bl	b400 <_print>
    558c:	462b      	mov	r3, r5
    558e:	e7a6      	b.n	54de <cliFunc_macroList+0x76>
    5590:	00010d99 	.word	0x00010d99
    5594:	1fff9f01 	.word	0x1fff9f01
    5598:	1fffa030 	.word	0x1fffa030
    559c:	00011f77 	.word	0x00011f77
    55a0:	0000e368 	.word	0x0000e368
    55a4:	0000e38f 	.word	0x0000e38f
    55a8:	1fff93de 	.word	0x1fff93de
    55ac:	1fff9310 	.word	0x1fff9310
    55b0:	0000e393 	.word	0x0000e393
    55b4:	1fffa3f4 	.word	0x1fffa3f4
    55b8:	0000e3be 	.word	0x0000e3be
    55bc:	0000e477 	.word	0x0000e477
    55c0:	0000e47a 	.word	0x0000e47a
    55c4:	0000e3e8 	.word	0x0000e3e8
    55c8:	0000e418 	.word	0x0000e418
    55cc:	0000e448 	.word	0x0000e448
    55d0:	0000d4f0 	.word	0x0000d4f0

000055d4 <cliFunc_macroDebug>:
{
    55d4:	b507      	push	{r0, r1, r2, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    55d6:	aa01      	add	r2, sp, #4
    55d8:	4669      	mov	r1, sp
    55da:	f005 fb09 	bl	abf0 <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    55de:	9b00      	ldr	r3, [sp, #0]
    55e0:	781b      	ldrb	r3, [r3, #0]
    55e2:	2b31      	cmp	r3, #49	; 0x31
    55e4:	d021      	beq.n	562a <cliFunc_macroDebug+0x56>
    55e6:	d803      	bhi.n	55f0 <cliFunc_macroDebug+0x1c>
    55e8:	b1fb      	cbz	r3, 562a <cliFunc_macroDebug+0x56>
}
    55ea:	b003      	add	sp, #12
    55ec:	f85d fb04 	ldr.w	pc, [sp], #4
	switch ( arg1Ptr[0] )
    55f0:	2b32      	cmp	r3, #50	; 0x32
    55f2:	d014      	beq.n	561e <cliFunc_macroDebug+0x4a>
    55f4:	2b33      	cmp	r3, #51	; 0x33
    55f6:	d1f8      	bne.n	55ea <cliFunc_macroDebug+0x16>
		macroDebugMode = macroDebugMode != 3 ? 3 : 0;
    55f8:	4b10      	ldr	r3, [pc, #64]	; (563c <cliFunc_macroDebug+0x68>)
    55fa:	781a      	ldrb	r2, [r3, #0]
    55fc:	2a03      	cmp	r2, #3
    55fe:	bf18      	it	ne
    5600:	2203      	movne	r2, #3
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    5602:	bf08      	it	eq
    5604:	2200      	moveq	r2, #0
    5606:	701a      	strb	r2, [r3, #0]
	print( NL );
    5608:	480d      	ldr	r0, [pc, #52]	; (5640 <cliFunc_macroDebug+0x6c>)
    560a:	f005 fef9 	bl	b400 <_print>
	info_msg("Macro Debug Mode: ");
    560e:	480d      	ldr	r0, [pc, #52]	; (5644 <cliFunc_macroDebug+0x70>)
    5610:	f005 fef6 	bl	b400 <_print>
	printInt8( macroDebugMode );
    5614:	4b09      	ldr	r3, [pc, #36]	; (563c <cliFunc_macroDebug+0x68>)
    5616:	7818      	ldrb	r0, [r3, #0]
    5618:	f005 ff24 	bl	b464 <printInt8>
    561c:	e7e5      	b.n	55ea <cliFunc_macroDebug+0x16>
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    561e:	4b07      	ldr	r3, [pc, #28]	; (563c <cliFunc_macroDebug+0x68>)
    5620:	781a      	ldrb	r2, [r3, #0]
    5622:	2a02      	cmp	r2, #2
    5624:	bf18      	it	ne
    5626:	2202      	movne	r2, #2
    5628:	e7eb      	b.n	5602 <cliFunc_macroDebug+0x2e>
		macroDebugMode = macroDebugMode != 1 ? 1 : 0;
    562a:	4a04      	ldr	r2, [pc, #16]	; (563c <cliFunc_macroDebug+0x68>)
    562c:	7813      	ldrb	r3, [r2, #0]
    562e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    5632:	bf18      	it	ne
    5634:	2301      	movne	r3, #1
    5636:	7013      	strb	r3, [r2, #0]
		break;
    5638:	e7e6      	b.n	5608 <cliFunc_macroDebug+0x34>
    563a:	bf00      	nop
    563c:	1fffa19b 	.word	0x1fffa19b
    5640:	00010d99 	.word	0x00010d99
    5644:	0000e343 	.word	0x0000e343

00005648 <cliFunc_capSelect>:
{
    5648:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char* arg2Ptr = args;
    564c:	2600      	movs	r6, #0
			info_msg("K");
    564e:	f8df b100 	ldr.w	fp, [pc, #256]	; 5750 <cliFunc_capSelect+0x108>
			print(" - ");
    5652:	f8df 9100 	ldr.w	r9, [pc, #256]	; 5754 <cliFunc_capSelect+0x10c>
	char* arg2Ptr = args;
    5656:	9001      	str	r0, [sp, #4]
{
    5658:	4604      	mov	r4, r0
	var_uint_t argSetCount = 0;
    565a:	46b0      	mov	r8, r6
	var_uint_t cap = 0;
    565c:	4637      	mov	r7, r6
	var_uint_t totalArgs = 2; // Always at least two args
    565e:	f04f 0a02 	mov.w	sl, #2
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5662:	aa01      	add	r2, sp, #4
    5664:	9801      	ldr	r0, [sp, #4]
    5666:	4669      	mov	r1, sp
    5668:	f005 fac2 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    566c:	9800      	ldr	r0, [sp, #0]
    566e:	7802      	ldrb	r2, [r0, #0]
    5670:	2a00      	cmp	r2, #0
    5672:	d051      	beq.n	5718 <cliFunc_capSelect+0xd0>
		if ( c == 0 ) switch ( arg1Ptr[0] )
    5674:	f016 0fff 	tst.w	r6, #255	; 0xff
    5678:	d114      	bne.n	56a4 <cliFunc_capSelect+0x5c>
    567a:	2a4b      	cmp	r2, #75	; 0x4b
    567c:	d112      	bne.n	56a4 <cliFunc_capSelect+0x5c>
			cap = numToInt( &arg1Ptr[1] );
    567e:	3001      	adds	r0, #1
    5680:	f005 ffd1 	bl	b626 <numToInt>
			totalArgs += CapabilitiesList[ cap ].argCount;
    5684:	4a2c      	ldr	r2, [pc, #176]	; (5738 <cliFunc_capSelect+0xf0>)
			cap = numToInt( &arg1Ptr[1] );
    5686:	b2c7      	uxtb	r7, r0
			totalArgs += CapabilitiesList[ cap ].argCount;
    5688:	eb02 02c7 	add.w	r2, r2, r7, lsl #3
			continue;
    568c:	4645      	mov	r5, r8
			totalArgs += CapabilitiesList[ cap ].argCount;
    568e:	7912      	ldrb	r2, [r2, #4]
    5690:	eb0a 0302 	add.w	r3, sl, r2
    5694:	fa5f fa83 	uxtb.w	sl, r3
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    5698:	45aa      	cmp	sl, r5
    569a:	f106 0601 	add.w	r6, r6, #1
    569e:	d93b      	bls.n	5718 <cliFunc_capSelect+0xd0>
    56a0:	46a8      	mov	r8, r5
    56a2:	e7de      	b.n	5662 <cliFunc_capSelect+0x1a>
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    56a4:	f005 ffbf 	bl	b626 <numToInt>
    56a8:	f108 0501 	add.w	r5, r8, #1
    56ac:	b2ed      	uxtb	r5, r5
		if ( argSetCount == totalArgs )
    56ae:	4555      	cmp	r5, sl
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    56b0:	f804 0008 	strb.w	r0, [r4, r8]
		if ( argSetCount == totalArgs )
    56b4:	d1f0      	bne.n	5698 <cliFunc_capSelect+0x50>
			print( NL );
    56b6:	4821      	ldr	r0, [pc, #132]	; (573c <cliFunc_capSelect+0xf4>)
    56b8:	f005 fea2 	bl	b400 <_print>
			info_msg("K");
    56bc:	4658      	mov	r0, fp
    56be:	f005 fe9f 	bl	b400 <_print>
			printInt8( cap );
    56c2:	4638      	mov	r0, r7
    56c4:	f005 fece 	bl	b464 <printInt8>
			print(" - ");
    56c8:	4648      	mov	r0, r9
    56ca:	f005 fe99 	bl	b400 <_print>
			printHex( argSet[0] );
    56ce:	2101      	movs	r1, #1
    56d0:	7820      	ldrb	r0, [r4, #0]
    56d2:	f005 ff3d 	bl	b550 <printHex_op>
			print(" - ");
    56d6:	4648      	mov	r0, r9
    56d8:	f005 fe92 	bl	b400 <_print>
			printHex( argSet[1] );
    56dc:	2101      	movs	r1, #1
    56de:	7860      	ldrb	r0, [r4, #1]
    56e0:	f005 ff36 	bl	b550 <printHex_op>
			print(" - ");
    56e4:	4648      	mov	r0, r9
    56e6:	f005 fe8b 	bl	b400 <_print>
			printHex( argSet[2] );
    56ea:	2101      	movs	r1, #1
    56ec:	78a0      	ldrb	r0, [r4, #2]
    56ee:	f005 ff2f 	bl	b550 <printHex_op>
			print( "..." NL );
    56f2:	4813      	ldr	r0, [pc, #76]	; (5740 <cliFunc_capSelect+0xf8>)
    56f4:	f005 fe84 	bl	b400 <_print>
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    56f8:	4a0f      	ldr	r2, [pc, #60]	; (5738 <cliFunc_capSelect+0xf0>)
    56fa:	4912      	ldr	r1, [pc, #72]	; (5744 <cliFunc_capSelect+0xfc>)
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    56fc:	2300      	movs	r3, #0
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    56fe:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
    5702:	4288      	cmp	r0, r1
    5704:	d10b      	bne.n	571e <cliFunc_capSelect+0xd6>
					print( NL );
    5706:	480d      	ldr	r0, [pc, #52]	; (573c <cliFunc_capSelect+0xf4>)
    5708:	f005 fe7a 	bl	b400 <_print>
					warn_print("flashModeEnabled not set, cancelling firmware reload...");
    570c:	480e      	ldr	r0, [pc, #56]	; (5748 <cliFunc_capSelect+0x100>)
    570e:	f005 fe77 	bl	b400 <_print>
					info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    5712:	480e      	ldr	r0, [pc, #56]	; (574c <cliFunc_capSelect+0x104>)
    5714:	f005 fe74 	bl	b400 <_print>
}
    5718:	b003      	add	sp, #12
    571a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    571e:	3301      	adds	r3, #1
    5720:	2b15      	cmp	r3, #21
    5722:	d1ec      	bne.n	56fe <cliFunc_capSelect+0xb6>
			capability( 0, argSet[0], argSet[1], &argSet[2] );
    5724:	f852 8037 	ldr.w	r8, [r2, r7, lsl #3]
    5728:	7821      	ldrb	r1, [r4, #0]
    572a:	7862      	ldrb	r2, [r4, #1]
    572c:	1ca3      	adds	r3, r4, #2
    572e:	2000      	movs	r0, #0
    5730:	47c0      	blx	r8
    5732:	46aa      	mov	sl, r5
    5734:	e7b0      	b.n	5698 <cliFunc_capSelect+0x50>
    5736:	bf00      	nop
    5738:	0000cff0 	.word	0x0000cff0
    573c:	00010d99 	.word	0x00010d99
    5740:	0000d960 	.word	0x0000d960
    5744:	00008a71 	.word	0x00008a71
    5748:	0000d917 	.word	0x0000d917
    574c:	0000d966 	.word	0x0000d966
    5750:	0000d903 	.word	0x0000d903
    5754:	0000bad4 	.word	0x0000bad4

00005758 <cliFunc_layerState>:
{
    5758:	b573      	push	{r0, r1, r4, r5, r6, lr}
	for ( uint8_t c = 0; c < 2; c++ )
    575a:	2400      	movs	r4, #0
	char* arg2Ptr = args;
    575c:	9001      	str	r0, [sp, #4]
	uint8_t arg1 = 0;
    575e:	4625      	mov	r5, r4
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5760:	9801      	ldr	r0, [sp, #4]
    5762:	aa01      	add	r2, sp, #4
    5764:	4669      	mov	r1, sp
    5766:	f005 fa43 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    576a:	9800      	ldr	r0, [sp, #0]
    576c:	7803      	ldrb	r3, [r0, #0]
    576e:	b1eb      	cbz	r3, 57ac <cliFunc_layerState+0x54>
		switch ( c )
    5770:	b93c      	cbnz	r4, 5782 <cliFunc_layerState+0x2a>
			if ( arg1Ptr[0] != 'L' )
    5772:	2b4c      	cmp	r3, #76	; 0x4c
    5774:	d11a      	bne.n	57ac <cliFunc_layerState+0x54>
			arg1 = (uint8_t)numToInt( &arg1Ptr[1] );
    5776:	3001      	adds	r0, #1
    5778:	f005 ff55 	bl	b626 <numToInt>
    577c:	2401      	movs	r4, #1
    577e:	b2c5      	uxtb	r5, r0
    5780:	e7ee      	b.n	5760 <cliFunc_layerState+0x8>
			arg2 = (uint8_t)numToInt( arg1Ptr );
    5782:	f005 ff50 	bl	b626 <numToInt>
    5786:	b2c6      	uxtb	r6, r0
			print( NL );
    5788:	4809      	ldr	r0, [pc, #36]	; (57b0 <cliFunc_layerState+0x58>)
    578a:	f005 fe39 	bl	b400 <_print>
			info_msg("Setting Layer L");
    578e:	4809      	ldr	r0, [pc, #36]	; (57b4 <cliFunc_layerState+0x5c>)
    5790:	f005 fe36 	bl	b400 <_print>
			printInt8( arg1 );
    5794:	4628      	mov	r0, r5
    5796:	f005 fe65 	bl	b464 <printInt8>
			print(" to - ");
    579a:	4807      	ldr	r0, [pc, #28]	; (57b8 <cliFunc_layerState+0x60>)
    579c:	f005 fe30 	bl	b400 <_print>
			printHex( arg2 );
    57a0:	4621      	mov	r1, r4
    57a2:	4630      	mov	r0, r6
    57a4:	f005 fed4 	bl	b550 <printHex_op>
			LayerState[ arg1 ] = arg2;
    57a8:	4b04      	ldr	r3, [pc, #16]	; (57bc <cliFunc_layerState+0x64>)
    57aa:	555e      	strb	r6, [r3, r5]
}
    57ac:	b002      	add	sp, #8
    57ae:	bd70      	pop	{r4, r5, r6, pc}
    57b0:	00010d99 	.word	0x00010d99
    57b4:	0000e31a 	.word	0x0000e31a
    57b8:	0000e33c 	.word	0x0000e33c
    57bc:	1fffa02e 	.word	0x1fffa02e

000057c0 <cliFunc_macroStep>:
{
    57c0:	b507      	push	{r0, r1, r2, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    57c2:	aa01      	add	r2, sp, #4
    57c4:	4669      	mov	r1, sp
    57c6:	f005 fa13 	bl	abf0 <CLI_argumentIsolation>
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    57ca:	9800      	ldr	r0, [sp, #0]
    57cc:	f005 ff2b 	bl	b626 <numToInt>
    57d0:	b2c0      	uxtb	r0, r0
	if ( count == 0 )
    57d2:	2800      	cmp	r0, #0
	macroStepCounter = count;
    57d4:	4b03      	ldr	r3, [pc, #12]	; (57e4 <cliFunc_macroStep+0x24>)
		count = 1;
    57d6:	bf08      	it	eq
    57d8:	2001      	moveq	r0, #1
	macroStepCounter = count;
    57da:	8018      	strh	r0, [r3, #0]
}
    57dc:	b003      	add	sp, #12
    57de:	f85d fb04 	ldr.w	pc, [sp], #4
    57e2:	bf00      	nop
    57e4:	1fffa13e 	.word	0x1fffa13e

000057e8 <cliFunc_layerList>:
{
    57e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	print( NL );
    57ec:	482b      	ldr	r0, [pc, #172]	; (589c <cliFunc_layerList+0xb4>)
		print( NL "\t" );
    57ee:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 58c0 <cliFunc_layerList+0xd8>
		print(" - ");
    57f2:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 58c4 <cliFunc_layerList+0xdc>
		print( NL "\t\t Layer State: " );
    57f6:	4f2a      	ldr	r7, [pc, #168]	; (58a0 <cliFunc_layerList+0xb8>)
		printHex( LayerState[ layer ] );
    57f8:	4e2a      	ldr	r6, [pc, #168]	; (58a4 <cliFunc_layerList+0xbc>)
		print(" First -> Last Indices: ");
    57fa:	4d2b      	ldr	r5, [pc, #172]	; (58a8 <cliFunc_layerList+0xc0>)
		print(" -> ");
    57fc:	4c2b      	ldr	r4, [pc, #172]	; (58ac <cliFunc_layerList+0xc4>)
	print( NL );
    57fe:	f005 fdff 	bl	b400 <_print>
	info_msg("Layer List");
    5802:	482b      	ldr	r0, [pc, #172]	; (58b0 <cliFunc_layerList+0xc8>)
    5804:	f005 fdfc 	bl	b400 <_print>
		print( NL "\t" );
    5808:	4648      	mov	r0, r9
    580a:	f005 fdf9 	bl	b400 <_print>
		printHex( layer );
    580e:	2101      	movs	r1, #1
    5810:	2000      	movs	r0, #0
    5812:	f005 fe9d 	bl	b550 <printHex_op>
		print(" - ");
    5816:	4640      	mov	r0, r8
    5818:	f005 fdf2 	bl	b400 <_print>
		dPrint( (char*)LayerIndex[ layer ].name );
    581c:	4825      	ldr	r0, [pc, #148]	; (58b4 <cliFunc_layerList+0xcc>)
    581e:	f003 f9b6 	bl	8b8e <Output_putstr>
			print(" \033[1m(default)\033[0m");
    5822:	4825      	ldr	r0, [pc, #148]	; (58b8 <cliFunc_layerList+0xd0>)
    5824:	f005 fdec 	bl	b400 <_print>
		print( NL "\t\t Layer State: " );
    5828:	4638      	mov	r0, r7
    582a:	f005 fde9 	bl	b400 <_print>
		printHex( LayerState[ layer ] );
    582e:	2101      	movs	r1, #1
    5830:	7830      	ldrb	r0, [r6, #0]
    5832:	f005 fe8d 	bl	b550 <printHex_op>
		print(" First -> Last Indices: ");
    5836:	4628      	mov	r0, r5
    5838:	f005 fde2 	bl	b400 <_print>
		printHex( LayerIndex[ layer ].first );
    583c:	2101      	movs	r1, #1
    583e:	2000      	movs	r0, #0
    5840:	f005 fe86 	bl	b550 <printHex_op>
		print(" -> ");
    5844:	4620      	mov	r0, r4
    5846:	f005 fddb 	bl	b400 <_print>
		printHex( LayerIndex[ layer ].last );
    584a:	2101      	movs	r1, #1
    584c:	205a      	movs	r0, #90	; 0x5a
    584e:	f005 fe7f 	bl	b550 <printHex_op>
		print( NL "\t" );
    5852:	4648      	mov	r0, r9
    5854:	f005 fdd4 	bl	b400 <_print>
		printHex( layer );
    5858:	2101      	movs	r1, #1
    585a:	4608      	mov	r0, r1
    585c:	f005 fe78 	bl	b550 <printHex_op>
		print(" - ");
    5860:	4640      	mov	r0, r8
    5862:	f005 fdcd 	bl	b400 <_print>
		dPrint( (char*)LayerIndex[ layer ].name );
    5866:	4815      	ldr	r0, [pc, #84]	; (58bc <cliFunc_layerList+0xd4>)
    5868:	f003 f991 	bl	8b8e <Output_putstr>
		print( NL "\t\t Layer State: " );
    586c:	4638      	mov	r0, r7
    586e:	f005 fdc7 	bl	b400 <_print>
		printHex( LayerState[ layer ] );
    5872:	2101      	movs	r1, #1
    5874:	7870      	ldrb	r0, [r6, #1]
    5876:	f005 fe6b 	bl	b550 <printHex_op>
		print(" First -> Last Indices: ");
    587a:	4628      	mov	r0, r5
    587c:	f005 fdc0 	bl	b400 <_print>
		printHex( LayerIndex[ layer ].first );
    5880:	2101      	movs	r1, #1
    5882:	2003      	movs	r0, #3
    5884:	f005 fe64 	bl	b550 <printHex_op>
		print(" -> ");
    5888:	4620      	mov	r0, r4
    588a:	f005 fdb9 	bl	b400 <_print>
		printHex( LayerIndex[ layer ].last );
    588e:	2101      	movs	r1, #1
    5890:	2058      	movs	r0, #88	; 0x58
}
    5892:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		printHex( LayerIndex[ layer ].last );
    5896:	f005 be5b 	b.w	b550 <printHex_op>
    589a:	bf00      	nop
    589c:	00010d99 	.word	0x00010d99
    58a0:	0000de7b 	.word	0x0000de7b
    58a4:	1fffa02e 	.word	0x1fffa02e
    58a8:	0000de8e 	.word	0x0000de8e
    58ac:	0000c911 	.word	0x0000c911
    58b0:	0000d9d2 	.word	0x0000d9d2
    58b4:	0000d9ef 	.word	0x0000d9ef
    58b8:	0000de68 	.word	0x0000de68
    58bc:	0000dea7 	.word	0x0000dea7
    58c0:	0000d8ff 	.word	0x0000d8ff
    58c4:	0000bad4 	.word	0x0000bad4

000058c8 <cliFunc_voteDebug>:
	}
	*/
}

void cliFunc_voteDebug( char* args )
{
    58c8:	b513      	push	{r0, r1, r4, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    58ca:	aa01      	add	r2, sp, #4
    58cc:	4669      	mov	r1, sp
    58ce:	f005 f98f 	bl	abf0 <CLI_argumentIsolation>

	// Set the vote debug flag depending on the argument
	switch ( arg1Ptr[0] )
    58d2:	9b00      	ldr	r3, [sp, #0]
    58d4:	781b      	ldrb	r3, [r3, #0]
    58d6:	2b01      	cmp	r3, #1
    58d8:	d80f      	bhi.n	58fa <cliFunc_voteDebug+0x32>
	{
	// No argument
	case 1:
	case '\0':
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    58da:	4c09      	ldr	r4, [pc, #36]	; (5900 <cliFunc_voteDebug+0x38>)
	// Invalid argument
	default:
		return;
	}

	print( NL );
    58dc:	4809      	ldr	r0, [pc, #36]	; (5904 <cliFunc_voteDebug+0x3c>)
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    58de:	7823      	ldrb	r3, [r4, #0]
    58e0:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    58e4:	bf18      	it	ne
    58e6:	2301      	movne	r3, #1
    58e8:	7023      	strb	r3, [r4, #0]
	print( NL );
    58ea:	f005 fd89 	bl	b400 <_print>
	info_msg("Vote Debug Mode: ");
    58ee:	4806      	ldr	r0, [pc, #24]	; (5908 <cliFunc_voteDebug+0x40>)
    58f0:	f005 fd86 	bl	b400 <_print>
	printInt8( voteDebugMode );
    58f4:	7820      	ldrb	r0, [r4, #0]
    58f6:	f005 fdb5 	bl	b464 <printInt8>
}
    58fa:	b002      	add	sp, #8
    58fc:	bd10      	pop	{r4, pc}
    58fe:	bf00      	nop
    5900:	1fff9f04 	.word	0x1fff9f04
    5904:	00010d99 	.word	0x00010d99
    5908:	0000e4a9 	.word	0x0000e4a9

0000590c <Macro_layerState.part.1>:
void Macro_layerState( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    590c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	while ( stackItem < macroLayerIndexStackSize )
    590e:	4d2c      	ldr	r5, [pc, #176]	; (59c0 <Macro_layerState.part.1+0xb4>)
		if ( macroLayerIndexStack[ stackItem ] == layer )
    5910:	4b2c      	ldr	r3, [pc, #176]	; (59c4 <Macro_layerState.part.1+0xb8>)
	while ( stackItem < macroLayerIndexStackSize )
    5912:	882f      	ldrh	r7, [r5, #0]
    5914:	2600      	movs	r6, #0
    5916:	b2b2      	uxth	r2, r6
    5918:	42ba      	cmp	r2, r7
    591a:	d335      	bcc.n	5988 <Macro_layerState.part.1+0x7c>
	uint8_t inLayerIndexStack = 0;
    591c:	2100      	movs	r1, #0
	if ( LayerState[ layer ] & layerState )
    591e:	4c2a      	ldr	r4, [pc, #168]	; (59c8 <Macro_layerState.part.1+0xbc>)
    5920:	7863      	ldrb	r3, [r4, #1]
    5922:	4203      	tst	r3, r0
		LayerState[ layer ] &= ~layerState;
    5924:	bf14      	ite	ne
    5926:	4383      	bicne	r3, r0
		LayerState[ layer ] |= layerState;
    5928:	4303      	orreq	r3, r0
    592a:	7063      	strb	r3, [r4, #1]
	if ( !inLayerIndexStack )
    592c:	b929      	cbnz	r1, 593a <Macro_layerState.part.1+0x2e>
		macroLayerIndexStack[ macroLayerIndexStackSize++ ] = layer;
    592e:	1c7b      	adds	r3, r7, #1
    5930:	802b      	strh	r3, [r5, #0]
    5932:	4b24      	ldr	r3, [pc, #144]	; (59c4 <Macro_layerState.part.1+0xb8>)
    5934:	2001      	movs	r0, #1
    5936:	f823 0017 	strh.w	r0, [r3, r7, lsl #1]
	if ( LayerState[ layer ] == 0x00 && inLayerIndexStack )
    593a:	7863      	ldrb	r3, [r4, #1]
    593c:	b943      	cbnz	r3, 5950 <Macro_layerState.part.1+0x44>
    593e:	b139      	cbz	r1, 5950 <Macro_layerState.part.1+0x44>
    5940:	4b20      	ldr	r3, [pc, #128]	; (59c4 <Macro_layerState.part.1+0xb8>)
		while ( stackItem < macroLayerIndexStackSize )
    5942:	8829      	ldrh	r1, [r5, #0]
    5944:	eb03 0346 	add.w	r3, r3, r6, lsl #1
    5948:	428a      	cmp	r2, r1
    594a:	d325      	bcc.n	5998 <Macro_layerState.part.1+0x8c>
		macroLayerIndexStackSize--;
    594c:	3901      	subs	r1, #1
    594e:	8029      	strh	r1, [r5, #0]
	if ( layerDebugMode )
    5950:	4b1e      	ldr	r3, [pc, #120]	; (59cc <Macro_layerState.part.1+0xc0>)
    5952:	781b      	ldrb	r3, [r3, #0]
    5954:	b393      	cbz	r3, 59bc <Macro_layerState.part.1+0xb0>
		dbug_msg("Layer ");
    5956:	481e      	ldr	r0, [pc, #120]	; (59d0 <Macro_layerState.part.1+0xc4>)
			print(":");
    5958:	4e1e      	ldr	r6, [pc, #120]	; (59d4 <Macro_layerState.part.1+0xc8>)
		dbug_msg("Layer ");
    595a:	f005 fd51 	bl	b400 <_print>
			printHex_op( LayerState[ index ], 0 );
    595e:	7820      	ldrb	r0, [r4, #0]
    5960:	2100      	movs	r1, #0
    5962:	f005 fdf5 	bl	b550 <printHex_op>
    5966:	7860      	ldrb	r0, [r4, #1]
    5968:	2100      	movs	r1, #0
    596a:	f005 fdf1 	bl	b550 <printHex_op>
		print(" 0");
    596e:	481a      	ldr	r0, [pc, #104]	; (59d8 <Macro_layerState.part.1+0xcc>)
    5970:	f005 fd46 	bl	b400 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    5974:	882c      	ldrh	r4, [r5, #0]
    5976:	4d13      	ldr	r5, [pc, #76]	; (59c4 <Macro_layerState.part.1+0xb8>)
    5978:	eb05 0544 	add.w	r5, r5, r4, lsl #1
    597c:	b99c      	cbnz	r4, 59a6 <Macro_layerState.part.1+0x9a>
		print( NL );
    597e:	4817      	ldr	r0, [pc, #92]	; (59dc <Macro_layerState.part.1+0xd0>)
}
    5980:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		print( NL );
    5984:	f005 bd3c 	b.w	b400 <_print>
		if ( macroLayerIndexStack[ stackItem ] == layer )
    5988:	f833 1016 	ldrh.w	r1, [r3, r6, lsl #1]
    598c:	2901      	cmp	r1, #1
    598e:	f106 0401 	add.w	r4, r6, #1
    5992:	d0c4      	beq.n	591e <Macro_layerState.part.1+0x12>
    5994:	4626      	mov	r6, r4
    5996:	e7be      	b.n	5916 <Macro_layerState.part.1+0xa>
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
    5998:	f833 0f02 	ldrh.w	r0, [r3, #2]!
    599c:	f823 0c02 	strh.w	r0, [r3, #-2]
			stackItem++;
    59a0:	3201      	adds	r2, #1
    59a2:	b292      	uxth	r2, r2
    59a4:	e7d0      	b.n	5948 <Macro_layerState.part.1+0x3c>
			print(":");
    59a6:	4630      	mov	r0, r6
    59a8:	f005 fd2a 	bl	b400 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    59ac:	3c01      	subs	r4, #1
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
    59ae:	2100      	movs	r1, #0
    59b0:	f835 0d02 	ldrh.w	r0, [r5, #-2]!
    59b4:	f005 fdcc 	bl	b550 <printHex_op>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    59b8:	b2a4      	uxth	r4, r4
    59ba:	e7df      	b.n	597c <Macro_layerState.part.1+0x70>
}
    59bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    59be:	bf00      	nop
    59c0:	1fff930e 	.word	0x1fff930e
    59c4:	1fff9308 	.word	0x1fff9308
    59c8:	1fffa02e 	.word	0x1fffa02e
    59cc:	1fffa140 	.word	0x1fffa140
    59d0:	0000d19c 	.word	0x0000d19c
    59d4:	0000f857 	.word	0x0000f857
    59d8:	0000d1b6 	.word	0x0000d1b6
    59dc:	00010d99 	.word	0x00010d99

000059e0 <Macro_layerState_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    59e0:	2aff      	cmp	r2, #255	; 0xff
    59e2:	d104      	bne.n	59ee <Macro_layerState_capability+0xe>
    59e4:	29ff      	cmp	r1, #255	; 0xff
    59e6:	d105      	bne.n	59f4 <Macro_layerState_capability+0x14>
		print("Macro_layerState(layerIndex,layerState)");
    59e8:	4806      	ldr	r0, [pc, #24]	; (5a04 <Macro_layerState_capability+0x24>)
    59ea:	f005 bd09 	b.w	b400 <_print>
	if ( stateType == 0x00 && state == 0x02 ) // Hold condition
    59ee:	b90a      	cbnz	r2, 59f4 <Macro_layerState_capability+0x14>
    59f0:	2902      	cmp	r1, #2
    59f2:	d005      	beq.n	5a00 <Macro_layerState_capability+0x20>
	if ( layer >= LayerNum || layer == 0 )
    59f4:	881a      	ldrh	r2, [r3, #0]
    59f6:	2a01      	cmp	r2, #1
    59f8:	d102      	bne.n	5a00 <Macro_layerState_capability+0x20>
    59fa:	7898      	ldrb	r0, [r3, #2]
    59fc:	f7ff bf86 	b.w	590c <Macro_layerState.part.1>
}
    5a00:	4770      	bx	lr
    5a02:	bf00      	nop
    5a04:	0000d1b9 	.word	0x0000d1b9

00005a08 <Macro_layerLatch_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    5a08:	2aff      	cmp	r2, #255	; 0xff
    5a0a:	d104      	bne.n	5a16 <Macro_layerLatch_capability+0xe>
    5a0c:	29ff      	cmp	r1, #255	; 0xff
    5a0e:	d105      	bne.n	5a1c <Macro_layerLatch_capability+0x14>
		print("Macro_layerLatch(layerIndex)");
    5a10:	4806      	ldr	r0, [pc, #24]	; (5a2c <Macro_layerLatch_capability+0x24>)
    5a12:	f005 bcf5 	b.w	b400 <_print>
	if ( stateType == 0x00 && state != 0x03 ) // Only on release
    5a16:	b90a      	cbnz	r2, 5a1c <Macro_layerLatch_capability+0x14>
    5a18:	2903      	cmp	r1, #3
    5a1a:	d105      	bne.n	5a28 <Macro_layerLatch_capability+0x20>
	if ( layer >= LayerNum || layer == 0 )
    5a1c:	881b      	ldrh	r3, [r3, #0]
    5a1e:	2b01      	cmp	r3, #1
    5a20:	d102      	bne.n	5a28 <Macro_layerLatch_capability+0x20>
    5a22:	2002      	movs	r0, #2
    5a24:	f7ff bf72 	b.w	590c <Macro_layerState.part.1>
}
    5a28:	4770      	bx	lr
    5a2a:	bf00      	nop
    5a2c:	0000d0f0 	.word	0x0000d0f0

00005a30 <Macro_layerLock_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    5a30:	2aff      	cmp	r2, #255	; 0xff
    5a32:	d104      	bne.n	5a3e <Macro_layerLock_capability+0xe>
    5a34:	29ff      	cmp	r1, #255	; 0xff
    5a36:	d105      	bne.n	5a44 <Macro_layerLock_capability+0x14>
		print("Macro_layerLock(layerIndex)");
    5a38:	4806      	ldr	r0, [pc, #24]	; (5a54 <Macro_layerLock_capability+0x24>)
    5a3a:	f005 bce1 	b.w	b400 <_print>
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    5a3e:	b90a      	cbnz	r2, 5a44 <Macro_layerLock_capability+0x14>
    5a40:	2901      	cmp	r1, #1
    5a42:	d105      	bne.n	5a50 <Macro_layerLock_capability+0x20>
	if ( layer >= LayerNum || layer == 0 )
    5a44:	881b      	ldrh	r3, [r3, #0]
    5a46:	2b01      	cmp	r3, #1
    5a48:	d102      	bne.n	5a50 <Macro_layerLock_capability+0x20>
    5a4a:	2004      	movs	r0, #4
    5a4c:	f7ff bf5e 	b.w	590c <Macro_layerState.part.1>
}
    5a50:	4770      	bx	lr
    5a52:	bf00      	nop
    5a54:	0000d10d 	.word	0x0000d10d

00005a58 <Macro_layerShift_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    5a58:	2aff      	cmp	r2, #255	; 0xff
    5a5a:	d104      	bne.n	5a66 <Macro_layerShift_capability+0xe>
    5a5c:	29ff      	cmp	r1, #255	; 0xff
    5a5e:	d106      	bne.n	5a6e <Macro_layerShift_capability+0x16>
		print("Macro_layerShift(layerIndex)");
    5a60:	480a      	ldr	r0, [pc, #40]	; (5a8c <Macro_layerShift_capability+0x34>)
    5a62:	f005 bccd 	b.w	b400 <_print>
	if ( stateType == 0x00 && ( state == 0x00 || state == 0x02 ) ) // Only pass press or release conditions
    5a66:	b912      	cbnz	r2, 5a6e <Macro_layerShift_capability+0x16>
    5a68:	f011 0ffd 	tst.w	r1, #253	; 0xfd
    5a6c:	d00c      	beq.n	5a88 <Macro_layerShift_capability+0x30>
	uint16_t layer = *(uint16_t*)(&args[0]);
    5a6e:	8818      	ldrh	r0, [r3, #0]
	if ( LayerState[ layer ] != 0x00 && state == 0x01 )
    5a70:	4b07      	ldr	r3, [pc, #28]	; (5a90 <Macro_layerShift_capability+0x38>)
    5a72:	5c1b      	ldrb	r3, [r3, r0]
    5a74:	b113      	cbz	r3, 5a7c <Macro_layerShift_capability+0x24>
    5a76:	2901      	cmp	r1, #1
    5a78:	d102      	bne.n	5a80 <Macro_layerShift_capability+0x28>
    5a7a:	4770      	bx	lr
	if ( LayerState[ layer ] == 0x00 && state == 0x03 )
    5a7c:	2903      	cmp	r1, #3
    5a7e:	d003      	beq.n	5a88 <Macro_layerShift_capability+0x30>
	if ( layer >= LayerNum || layer == 0 )
    5a80:	2801      	cmp	r0, #1
    5a82:	d101      	bne.n	5a88 <Macro_layerShift_capability+0x30>
    5a84:	f7ff bf42 	b.w	590c <Macro_layerState.part.1>
}
    5a88:	4770      	bx	lr
    5a8a:	bf00      	nop
    5a8c:	0000d17f 	.word	0x0000d17f
    5a90:	1fffa02e 	.word	0x1fffa02e

00005a94 <Macro_layerRotate_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    5a94:	2aff      	cmp	r2, #255	; 0xff
{
    5a96:	b538      	push	{r3, r4, r5, lr}
    5a98:	461d      	mov	r5, r3
	if ( stateType == 0xFF && state == 0xFF )
    5a9a:	d106      	bne.n	5aaa <Macro_layerRotate_capability+0x16>
    5a9c:	29ff      	cmp	r1, #255	; 0xff
    5a9e:	d107      	bne.n	5ab0 <Macro_layerRotate_capability+0x1c>
		print("Macro_layerRotate(previous)");
    5aa0:	4813      	ldr	r0, [pc, #76]	; (5af0 <Macro_layerRotate_capability+0x5c>)
}
    5aa2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print("Macro_layerRotate(previous)");
    5aa6:	f005 bcab 	b.w	b400 <_print>
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    5aaa:	b90a      	cbnz	r2, 5ab0 <Macro_layerRotate_capability+0x1c>
    5aac:	2901      	cmp	r1, #1
    5aae:	d11d      	bne.n	5aec <Macro_layerRotate_capability+0x58>
	if ( Macro_rotationLayer != 0 )
    5ab0:	4c10      	ldr	r4, [pc, #64]	; (5af4 <Macro_layerRotate_capability+0x60>)
	if ( layer >= LayerNum || layer == 0 )
    5ab2:	8823      	ldrh	r3, [r4, #0]
    5ab4:	2b01      	cmp	r3, #1
    5ab6:	d102      	bne.n	5abe <Macro_layerRotate_capability+0x2a>
    5ab8:	2004      	movs	r0, #4
    5aba:	f7ff ff27 	bl	590c <Macro_layerState.part.1>
	if ( !direction )
    5abe:	782b      	ldrb	r3, [r5, #0]
    5ac0:	8822      	ldrh	r2, [r4, #0]
    5ac2:	b963      	cbnz	r3, 5ade <Macro_layerRotate_capability+0x4a>
		Macro_rotationLayer++;
    5ac4:	3201      	adds	r2, #1
    5ac6:	b292      	uxth	r2, r2
		if ( Macro_rotationLayer >= LayerNum )
    5ac8:	2a01      	cmp	r2, #1
    5aca:	d80d      	bhi.n	5ae8 <Macro_layerRotate_capability+0x54>
		Macro_rotationLayer++;
    5acc:	8022      	strh	r2, [r4, #0]
	if ( layer >= LayerNum || layer == 0 )
    5ace:	8823      	ldrh	r3, [r4, #0]
    5ad0:	2b01      	cmp	r3, #1
    5ad2:	d10b      	bne.n	5aec <Macro_layerRotate_capability+0x58>
    5ad4:	2004      	movs	r0, #4
}
    5ad6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5ada:	f7ff bf17 	b.w	590c <Macro_layerState.part.1>
		Macro_rotationLayer--;
    5ade:	1e53      	subs	r3, r2, #1
    5ae0:	b29b      	uxth	r3, r3
		if ( Macro_rotationLayer >= LayerNum )
    5ae2:	2b01      	cmp	r3, #1
			Macro_rotationLayer = LayerNum - 1;
    5ae4:	bf88      	it	hi
    5ae6:	2301      	movhi	r3, #1
    5ae8:	8023      	strh	r3, [r4, #0]
    5aea:	e7f0      	b.n	5ace <Macro_layerRotate_capability+0x3a>
}
    5aec:	bd38      	pop	{r3, r4, r5, pc}
    5aee:	bf00      	nop
    5af0:	0000d163 	.word	0x0000d163
    5af4:	1fff9f02 	.word	0x1fff9f02

00005af8 <Macro_showScheduleType>:
	switch ( state )
    5af8:	2804      	cmp	r0, #4
    5afa:	d01b      	beq.n	5b34 <Macro_showScheduleType+0x3c>
    5afc:	d808      	bhi.n	5b10 <Macro_showScheduleType+0x18>
    5afe:	2801      	cmp	r0, #1
    5b00:	d00f      	beq.n	5b22 <Macro_showScheduleType+0x2a>
    5b02:	d315      	bcc.n	5b30 <Macro_showScheduleType+0x38>
    5b04:	2802      	cmp	r0, #2
    5b06:	d00f      	beq.n	5b28 <Macro_showScheduleType+0x30>
    5b08:	2803      	cmp	r0, #3
    5b0a:	d00f      	beq.n	5b2c <Macro_showScheduleType+0x34>
		print("\033[1;31mINVALID\033[0m");
    5b0c:	480d      	ldr	r0, [pc, #52]	; (5b44 <Macro_showScheduleType+0x4c>)
    5b0e:	e009      	b.n	5b24 <Macro_showScheduleType+0x2c>
	switch ( state )
    5b10:	2806      	cmp	r0, #6
    5b12:	d013      	beq.n	5b3c <Macro_showScheduleType+0x44>
    5b14:	d310      	bcc.n	5b38 <Macro_showScheduleType+0x40>
    5b16:	2807      	cmp	r0, #7
    5b18:	d012      	beq.n	5b40 <Macro_showScheduleType+0x48>
    5b1a:	28ff      	cmp	r0, #255	; 0xff
    5b1c:	d1f6      	bne.n	5b0c <Macro_showScheduleType+0x14>
		print("Debug");
    5b1e:	480a      	ldr	r0, [pc, #40]	; (5b48 <Macro_showScheduleType+0x50>)
    5b20:	e000      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("\033[1;33mP\033[0m");
    5b22:	480a      	ldr	r0, [pc, #40]	; (5b4c <Macro_showScheduleType+0x54>)
		print("\033[1;31mINVALID\033[0m");
    5b24:	f005 bc6c 	b.w	b400 <_print>
		print("\033[1;32mH\033[0m");
    5b28:	4809      	ldr	r0, [pc, #36]	; (5b50 <Macro_showScheduleType+0x58>)
    5b2a:	e7fb      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("\033[1;35mR\033[0m");
    5b2c:	4809      	ldr	r0, [pc, #36]	; (5b54 <Macro_showScheduleType+0x5c>)
    5b2e:	e7f9      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("\033[1mO\033[0m");
    5b30:	4809      	ldr	r0, [pc, #36]	; (5b58 <Macro_showScheduleType+0x60>)
    5b32:	e7f7      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("UP");
    5b34:	4809      	ldr	r0, [pc, #36]	; (5b5c <Macro_showScheduleType+0x64>)
    5b36:	e7f5      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("UR");
    5b38:	4809      	ldr	r0, [pc, #36]	; (5b60 <Macro_showScheduleType+0x68>)
    5b3a:	e7f3      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("Done");
    5b3c:	4809      	ldr	r0, [pc, #36]	; (5b64 <Macro_showScheduleType+0x6c>)
    5b3e:	e7f1      	b.n	5b24 <Macro_showScheduleType+0x2c>
		print("Repeat");
    5b40:	4809      	ldr	r0, [pc, #36]	; (5b68 <Macro_showScheduleType+0x70>)
    5b42:	e7ef      	b.n	5b24 <Macro_showScheduleType+0x2c>
    5b44:	0000d336 	.word	0x0000d336
    5b48:	0000f084 	.word	0x0000f084
    5b4c:	0000ba61 	.word	0x0000ba61
    5b50:	0000ba6e 	.word	0x0000ba6e
    5b54:	0000ba7b 	.word	0x0000ba7b
    5b58:	0000ba57 	.word	0x0000ba57
    5b5c:	0000d324 	.word	0x0000d324
    5b60:	0000d327 	.word	0x0000d327
    5b64:	0000d32a 	.word	0x0000d32a
    5b68:	0000d32f 	.word	0x0000d32f

00005b6c <Macro_showTriggerType>:
	switch ( type )
    5b6c:	2808      	cmp	r0, #8
    5b6e:	d806      	bhi.n	5b7e <Macro_showTriggerType+0x12>
    5b70:	2805      	cmp	r0, #5
    5b72:	d20c      	bcs.n	5b8e <Macro_showTriggerType+0x22>
    5b74:	2803      	cmp	r0, #3
    5b76:	d808      	bhi.n	5b8a <Macro_showTriggerType+0x1e>
		print("Sw");
    5b78:	4808      	ldr	r0, [pc, #32]	; (5b9c <Macro_showTriggerType+0x30>)
		print("Debug");
    5b7a:	f005 bc41 	b.w	b400 <_print>
	switch ( type )
    5b7e:	280c      	cmp	r0, #12
    5b80:	d907      	bls.n	5b92 <Macro_showTriggerType+0x26>
    5b82:	28ff      	cmp	r0, #255	; 0xff
    5b84:	d007      	beq.n	5b96 <Macro_showTriggerType+0x2a>
		print("INVALID");
    5b86:	4806      	ldr	r0, [pc, #24]	; (5ba0 <Macro_showTriggerType+0x34>)
    5b88:	e7f7      	b.n	5b7a <Macro_showTriggerType+0xe>
		print("LED");
    5b8a:	4806      	ldr	r0, [pc, #24]	; (5ba4 <Macro_showTriggerType+0x38>)
    5b8c:	e7f5      	b.n	5b7a <Macro_showTriggerType+0xe>
		print("An");
    5b8e:	4806      	ldr	r0, [pc, #24]	; (5ba8 <Macro_showTriggerType+0x3c>)
    5b90:	e7f3      	b.n	5b7a <Macro_showTriggerType+0xe>
		print("Layer");
    5b92:	4806      	ldr	r0, [pc, #24]	; (5bac <Macro_showTriggerType+0x40>)
    5b94:	e7f1      	b.n	5b7a <Macro_showTriggerType+0xe>
		print("Debug");
    5b96:	4806      	ldr	r0, [pc, #24]	; (5bb0 <Macro_showTriggerType+0x44>)
    5b98:	e7ef      	b.n	5b7a <Macro_showTriggerType+0xe>
    5b9a:	bf00      	nop
    5b9c:	0000d349 	.word	0x0000d349
    5ba0:	0000d359 	.word	0x0000d359
    5ba4:	0000d34c 	.word	0x0000d34c
    5ba8:	0000d350 	.word	0x0000d350
    5bac:	0000d353 	.word	0x0000d353
    5bb0:	0000f084 	.word	0x0000f084

00005bb4 <Macro_showTriggerEvent>:
{
    5bb4:	b538      	push	{r3, r4, r5, lr}
	print(" ");
    5bb6:	4d0c      	ldr	r5, [pc, #48]	; (5be8 <Macro_showTriggerEvent+0x34>)
{
    5bb8:	4604      	mov	r4, r0
	Macro_showTriggerType( event->type );
    5bba:	7800      	ldrb	r0, [r0, #0]
    5bbc:	f7ff ffd6 	bl	5b6c <Macro_showTriggerType>
	print(" ");
    5bc0:	4628      	mov	r0, r5
    5bc2:	f005 fc1d 	bl	b400 <_print>
	Macro_showScheduleType( event->state );
    5bc6:	7860      	ldrb	r0, [r4, #1]
    5bc8:	f7ff ff96 	bl	5af8 <Macro_showScheduleType>
	print(" ");
    5bcc:	4628      	mov	r0, r5
    5bce:	f005 fc17 	bl	b400 <_print>
	printInt8( event->type );
    5bd2:	7820      	ldrb	r0, [r4, #0]
    5bd4:	f005 fc46 	bl	b464 <printInt8>
	print(":");
    5bd8:	4804      	ldr	r0, [pc, #16]	; (5bec <Macro_showTriggerEvent+0x38>)
    5bda:	f005 fc11 	bl	b400 <_print>
	printInt8( event->index );
    5bde:	78a0      	ldrb	r0, [r4, #2]
}
    5be0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	printInt8( event->index );
    5be4:	f005 bc3e 	b.w	b464 <printInt8>
    5be8:	00011f77 	.word	0x00011f77
    5bec:	0000f857 	.word	0x0000f857

00005bf0 <Macro_layerLookup>:
{
    5bf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if ( event->type == 0x00 && event->state != 0x01 )
    5bf4:	7803      	ldrb	r3, [r0, #0]
	uint8_t index = event->index;
    5bf6:	7884      	ldrb	r4, [r0, #2]
{
    5bf8:	460e      	mov	r6, r1
	if ( event->type == 0x00 && event->state != 0x01 )
    5bfa:	bb03      	cbnz	r3, 5c3e <Macro_layerLookup+0x4e>
    5bfc:	7843      	ldrb	r3, [r0, #1]
    5bfe:	2b01      	cmp	r3, #1
    5c00:	d01d      	beq.n	5c3e <Macro_layerLookup+0x4e>
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    5c02:	4b3a      	ldr	r3, [pc, #232]	; (5cec <Macro_layerLookup+0xfc>)
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    5c04:	483a      	ldr	r0, [pc, #232]	; (5cf0 <Macro_layerLookup+0x100>)
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    5c06:	5d1a      	ldrb	r2, [r3, r4]
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    5c08:	230c      	movs	r3, #12
    5c0a:	4353      	muls	r3, r2
    5c0c:	18c1      	adds	r1, r0, r3
		nat_ptr_t *trigger_list = map[ index - layer->first ];
    5c0e:	58c3      	ldr	r3, [r0, r3]
    5c10:	7a09      	ldrb	r1, [r1, #8]
    5c12:	1a64      	subs	r4, r4, r1
    5c14:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
		uint8_t latch = LayerState[ cachedLayer ] & 0x02;
    5c18:	4b36      	ldr	r3, [pc, #216]	; (5cf4 <Macro_layerLookup+0x104>)
    5c1a:	5c9b      	ldrb	r3, [r3, r2]
		if ( latch && latch_expire )
    5c1c:	079b      	lsls	r3, r3, #30
    5c1e:	d50b      	bpl.n	5c38 <Macro_layerLookup+0x48>
    5c20:	b156      	cbz	r6, 5c38 <Macro_layerLookup+0x48>
	if ( layer >= LayerNum || layer == 0 )
    5c22:	2a01      	cmp	r2, #1
    5c24:	d102      	bne.n	5c2c <Macro_layerLookup+0x3c>
    5c26:	2002      	movs	r0, #2
    5c28:	f7ff fe70 	bl	590c <Macro_layerState.part.1>
			LCD_layerStack_capability( 0, 0, 0, 0 );
    5c2c:	2300      	movs	r3, #0
    5c2e:	461a      	mov	r2, r3
    5c30:	4619      	mov	r1, r3
    5c32:	4618      	mov	r0, r3
    5c34:	f7fe fa96 	bl	4164 <LCD_layerStack_capability>
}
    5c38:	4628      	mov	r0, r5
    5c3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    5c3e:	4b2e      	ldr	r3, [pc, #184]	; (5cf8 <Macro_layerLookup+0x108>)
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    5c40:	4f2e      	ldr	r7, [pc, #184]	; (5cfc <Macro_layerLookup+0x10c>)
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    5c42:	881d      	ldrh	r5, [r3, #0]
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    5c44:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 5cf4 <Macro_layerLookup+0x104>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    5c48:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5c4c:	429d      	cmp	r5, r3
    5c4e:	d10b      	bne.n	5c68 <Macro_layerLookup+0x78>
		&& index <= layer->last
    5c50:	2c5a      	cmp	r4, #90	; 0x5a
    5c52:	d83e      	bhi.n	5cd2 <Macro_layerLookup+0xe2>
		&& *map[ index - layer->first ] != 0 )
    5c54:	4b2a      	ldr	r3, [pc, #168]	; (5d00 <Macro_layerLookup+0x110>)
    5c56:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
    5c5a:	682b      	ldr	r3, [r5, #0]
    5c5c:	2b00      	cmp	r3, #0
    5c5e:	d038      	beq.n	5cd2 <Macro_layerLookup+0xe2>
		macroTriggerEventLayerCache[ index ] = 0;
    5c60:	4b22      	ldr	r3, [pc, #136]	; (5cec <Macro_layerLookup+0xfc>)
    5c62:	2200      	movs	r2, #0
    5c64:	551a      	strb	r2, [r3, r4]
		return map[ index - layer->first ];
    5c66:	e7e7      	b.n	5c38 <Macro_layerLookup+0x48>
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    5c68:	f837 a015 	ldrh.w	sl, [r7, r5, lsl #1]
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    5c6c:	f818 200a 	ldrb.w	r2, [r8, sl]
		if ( latch && latch_expire )
    5c70:	f012 0902 	ands.w	r9, r2, #2
    5c74:	d006      	beq.n	5c84 <Macro_layerLookup+0x94>
    5c76:	b12e      	cbz	r6, 5c84 <Macro_layerLookup+0x94>
	if ( layer >= LayerNum || layer == 0 )
    5c78:	f1ba 0f01 	cmp.w	sl, #1
    5c7c:	d102      	bne.n	5c84 <Macro_layerLookup+0x94>
    5c7e:	2002      	movs	r0, #2
    5c80:	f7ff fe44 	bl	590c <Macro_layerState.part.1>
		if ( (LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x01) ^ (latch>>1) ^ ((LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x04)>>2) )
    5c84:	f837 1015 	ldrh.w	r1, [r7, r5, lsl #1]
    5c88:	f818 2001 	ldrb.w	r2, [r8, r1]
    5c8c:	f002 0301 	and.w	r3, r2, #1
    5c90:	ea83 0959 	eor.w	r9, r3, r9, lsr #1
    5c94:	f3c2 0280 	ubfx	r2, r2, #2, #1
    5c98:	4591      	cmp	r9, r2
    5c9a:	d017      	beq.n	5ccc <Macro_layerLookup+0xdc>
			nat_ptr_t **map = (nat_ptr_t**)layer->triggerMap;
    5c9c:	230c      	movs	r3, #12
    5c9e:	4a14      	ldr	r2, [pc, #80]	; (5cf0 <Macro_layerLookup+0x100>)
    5ca0:	fb03 f30a 	mul.w	r3, r3, sl
    5ca4:	18d0      	adds	r0, r2, r3
    5ca6:	58d2      	ldr	r2, [r2, r3]
			if ( map != 0
    5ca8:	b182      	cbz	r2, 5ccc <Macro_layerLookup+0xdc>
				&& index <= layer->last
    5caa:	7a43      	ldrb	r3, [r0, #9]
    5cac:	42a3      	cmp	r3, r4
    5cae:	d30d      	bcc.n	5ccc <Macro_layerLookup+0xdc>
				&& index >= layer->first
    5cb0:	7a03      	ldrb	r3, [r0, #8]
    5cb2:	42a3      	cmp	r3, r4
    5cb4:	d80a      	bhi.n	5ccc <Macro_layerLookup+0xdc>
				&& *map[ index - layer->first ] != 0 )
    5cb6:	1ae3      	subs	r3, r4, r3
    5cb8:	eb02 0083 	add.w	r0, r2, r3, lsl #2
    5cbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5cc0:	681b      	ldr	r3, [r3, #0]
    5cc2:	b11b      	cbz	r3, 5ccc <Macro_layerLookup+0xdc>
				macroTriggerEventLayerCache[ index ] = macroLayerIndexStack[ layerIndex ];
    5cc4:	4b09      	ldr	r3, [pc, #36]	; (5cec <Macro_layerLookup+0xfc>)
    5cc6:	5519      	strb	r1, [r3, r4]
				return map[ index - layer->first ];
    5cc8:	6805      	ldr	r5, [r0, #0]
    5cca:	e7b5      	b.n	5c38 <Macro_layerLookup+0x48>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    5ccc:	3d01      	subs	r5, #1
    5cce:	b2ad      	uxth	r5, r5
    5cd0:	e7ba      	b.n	5c48 <Macro_layerLookup+0x58>
	erro_msg("Index has no defined Trigger Macro: ");
    5cd2:	480c      	ldr	r0, [pc, #48]	; (5d04 <Macro_layerLookup+0x114>)
    5cd4:	f005 fb94 	bl	b400 <_print>
	printHex( index );
    5cd8:	2101      	movs	r1, #1
    5cda:	4620      	mov	r0, r4
    5cdc:	f005 fc38 	bl	b550 <printHex_op>
	print( NL );
    5ce0:	4809      	ldr	r0, [pc, #36]	; (5d08 <Macro_layerLookup+0x118>)
    5ce2:	f005 fb8d 	bl	b400 <_print>
	return 0;
    5ce6:	2500      	movs	r5, #0
    5ce8:	e7a6      	b.n	5c38 <Macro_layerLookup+0x48>
    5cea:	bf00      	nop
    5cec:	1fffa141 	.word	0x1fffa141
    5cf0:	0000d09c 	.word	0x0000d09c
    5cf4:	1fffa02e 	.word	0x1fffa02e
    5cf8:	1fff930e 	.word	0x1fff930e
    5cfc:	1fff9308 	.word	0x1fff9308
    5d00:	1fff8a1c 	.word	0x1fff8a1c
    5d04:	0000d129 	.word	0x0000d129
    5d08:	00010d99 	.word	0x00010d99

00005d0c <Macro_pressReleaseAdd>:
{
    5d0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5d0e:	4604      	mov	r4, r0
	switch ( trigger->type )
    5d10:	7800      	ldrb	r0, [r0, #0]
    5d12:	bb18      	cbnz	r0, 5d5c <Macro_pressReleaseAdd+0x50>
		switch ( trigger->state )
    5d14:	7863      	ldrb	r3, [r4, #1]
    5d16:	2b03      	cmp	r3, #3
    5d18:	d903      	bls.n	5d22 <Macro_pressReleaseAdd+0x16>
			erro_msg("Invalid key state - ");
    5d1a:	4824      	ldr	r0, [pc, #144]	; (5dac <Macro_pressReleaseAdd+0xa0>)
		erro_msg("Invalid type - ");
    5d1c:	f005 fb70 	bl	b400 <_print>
		error = 1;
    5d20:	2001      	movs	r0, #1
	if ( trigger->index > MaxScanCode )
    5d22:	78a7      	ldrb	r7, [r4, #2]
    5d24:	2f5a      	cmp	r7, #90	; 0x5a
    5d26:	d91b      	bls.n	5d60 <Macro_pressReleaseAdd+0x54>
		warn_msg("ScanCode is out of range/not defined - ");
    5d28:	4821      	ldr	r0, [pc, #132]	; (5db0 <Macro_pressReleaseAdd+0xa4>)
    5d2a:	f005 fb69 	bl	b400 <_print>
		printHex( trigger->type );
    5d2e:	2101      	movs	r1, #1
    5d30:	7820      	ldrb	r0, [r4, #0]
    5d32:	f005 fc0d 	bl	b550 <printHex_op>
		print(" ");
    5d36:	481f      	ldr	r0, [pc, #124]	; (5db4 <Macro_pressReleaseAdd+0xa8>)
    5d38:	f005 fb62 	bl	b400 <_print>
		printHex( trigger->state );
    5d3c:	2101      	movs	r1, #1
    5d3e:	7860      	ldrb	r0, [r4, #1]
    5d40:	f005 fc06 	bl	b550 <printHex_op>
		print(" ");
    5d44:	481b      	ldr	r0, [pc, #108]	; (5db4 <Macro_pressReleaseAdd+0xa8>)
    5d46:	f005 fb5b 	bl	b400 <_print>
		printHex( trigger->index );
    5d4a:	2101      	movs	r1, #1
    5d4c:	78a0      	ldrb	r0, [r4, #2]
    5d4e:	f005 fbff 	bl	b550 <printHex_op>
		print( NL );
    5d52:	4819      	ldr	r0, [pc, #100]	; (5db8 <Macro_pressReleaseAdd+0xac>)
    5d54:	f005 fb54 	bl	b400 <_print>
		return 2;
    5d58:	2002      	movs	r0, #2
}
    5d5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		erro_msg("Invalid type - ");
    5d5c:	4817      	ldr	r0, [pc, #92]	; (5dbc <Macro_pressReleaseAdd+0xb0>)
    5d5e:	e7dd      	b.n	5d1c <Macro_pressReleaseAdd+0x10>
	if ( error )
    5d60:	2800      	cmp	r0, #0
    5d62:	d1e4      	bne.n	5d2e <Macro_pressReleaseAdd+0x22>
	for ( var_uint_t c = 0; c < macroInterconnectCacheSize; c++ )
    5d64:	4d16      	ldr	r5, [pc, #88]	; (5dc0 <Macro_pressReleaseAdd+0xb4>)
    5d66:	f8df c05c 	ldr.w	ip, [pc, #92]	; 5dc4 <Macro_pressReleaseAdd+0xb8>
    5d6a:	782b      	ldrb	r3, [r5, #0]
    5d6c:	4602      	mov	r2, r0
    5d6e:	b2d1      	uxtb	r1, r2
    5d70:	428b      	cmp	r3, r1
    5d72:	d80c      	bhi.n	5d8e <Macro_pressReleaseAdd+0x82>
	macroInterconnectCache[ macroInterconnectCacheSize++ ] = *trigger;
    5d74:	1c5a      	adds	r2, r3, #1
    5d76:	702a      	strb	r2, [r5, #0]
    5d78:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5d7c:	8821      	ldrh	r1, [r4, #0]
    5d7e:	f82c 1003 	strh.w	r1, [ip, r3]
    5d82:	eb0c 0203 	add.w	r2, ip, r3
    5d86:	78a3      	ldrb	r3, [r4, #2]
    5d88:	7093      	strb	r3, [r2, #2]
	return 1;
    5d8a:	2001      	movs	r0, #1
    5d8c:	e7e5      	b.n	5d5a <Macro_pressReleaseAdd+0x4e>
		if ( macroInterconnectCache[ c ].index == trigger->index )
    5d8e:	4611      	mov	r1, r2
    5d90:	3201      	adds	r2, #1
    5d92:	eb02 0642 	add.w	r6, r2, r2, lsl #1
    5d96:	4466      	add	r6, ip
    5d98:	f816 6c01 	ldrb.w	r6, [r6, #-1]
    5d9c:	42be      	cmp	r6, r7
    5d9e:	d1e6      	bne.n	5d6e <Macro_pressReleaseAdd+0x62>
			macroInterconnectCache[ c ].state = trigger->state;
    5da0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    5da4:	4461      	add	r1, ip
    5da6:	7863      	ldrb	r3, [r4, #1]
    5da8:	704b      	strb	r3, [r1, #1]
			return 0;
    5daa:	e7d6      	b.n	5d5a <Macro_pressReleaseAdd+0x4e>
    5dac:	0000d28b 	.word	0x0000d28b
    5db0:	0000d2da 	.word	0x0000d2da
    5db4:	00011f77 	.word	0x00011f77
    5db8:	00010d99 	.word	0x00010d99
    5dbc:	0000d2b5 	.word	0x0000d2b5
    5dc0:	1fff9305 	.word	0x1fff9305
    5dc4:	1fffa19c 	.word	0x1fffa19c

00005dc8 <Macro_keyState>:
{
    5dc8:	b570      	push	{r4, r5, r6, lr}
	if ( !Connect_master )
    5dca:	4b12      	ldr	r3, [pc, #72]	; (5e14 <Macro_keyState+0x4c>)
    5dcc:	781b      	ldrb	r3, [r3, #0]
{
    5dce:	4604      	mov	r4, r0
	if ( !Connect_master )
    5dd0:	b913      	cbnz	r3, 5dd8 <Macro_keyState+0x10>
		switch ( state )
    5dd2:	b1e9      	cbz	r1, 5e10 <Macro_keyState+0x48>
    5dd4:	2902      	cmp	r1, #2
    5dd6:	d01b      	beq.n	5e10 <Macro_keyState+0x48>
	switch ( state )
    5dd8:	1e4b      	subs	r3, r1, #1
    5dda:	2b02      	cmp	r3, #2
    5ddc:	d818      	bhi.n	5e10 <Macro_keyState+0x48>
		if ( scanCode > MaxScanCode )
    5dde:	2c5a      	cmp	r4, #90	; 0x5a
    5de0:	d90a      	bls.n	5df8 <Macro_keyState+0x30>
			warn_msg("ScanCode is out of range/not defined: ");
    5de2:	480d      	ldr	r0, [pc, #52]	; (5e18 <Macro_keyState+0x50>)
    5de4:	f005 fb0c 	bl	b400 <_print>
			printInt16( scanCode );
    5de8:	4620      	mov	r0, r4
    5dea:	f005 fb59 	bl	b4a0 <printInt16>
			print( NL );
    5dee:	480b      	ldr	r0, [pc, #44]	; (5e1c <Macro_keyState+0x54>)
}
    5df0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			print( NL );
    5df4:	f005 bb04 	b.w	b400 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    5df8:	4a09      	ldr	r2, [pc, #36]	; (5e20 <Macro_keyState+0x58>)
    5dfa:	4d0a      	ldr	r5, [pc, #40]	; (5e24 <Macro_keyState+0x5c>)
    5dfc:	7813      	ldrb	r3, [r2, #0]
    5dfe:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    5e02:	182e      	adds	r6, r5, r0
		macroTriggerEventBufferSize++;
    5e04:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    5e06:	7071      	strb	r1, [r6, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    5e08:	2100      	movs	r1, #0
    5e0a:	5429      	strb	r1, [r5, r0]
			index = scanCode;
    5e0c:	70b4      	strb	r4, [r6, #2]
		macroTriggerEventBufferSize++;
    5e0e:	7013      	strb	r3, [r2, #0]
}
    5e10:	bd70      	pop	{r4, r5, r6, pc}
    5e12:	bf00      	nop
    5e14:	1fff9300 	.word	0x1fff9300
    5e18:	0000d0b4 	.word	0x0000d0b4
    5e1c:	00010d99 	.word	0x00010d99
    5e20:	1fff9f01 	.word	0x1fff9f01
    5e24:	1fffa030 	.word	0x1fffa030

00005e28 <cliFunc_keyHold>:
{
    5e28:	b513      	push	{r0, r1, r4, lr}
	char* arg2Ptr = args;
    5e2a:	ac02      	add	r4, sp, #8
    5e2c:	f844 0d04 	str.w	r0, [r4, #-4]!
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5e30:	9801      	ldr	r0, [sp, #4]
    5e32:	4622      	mov	r2, r4
    5e34:	4669      	mov	r1, sp
    5e36:	f004 fedb 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    5e3a:	9800      	ldr	r0, [sp, #0]
    5e3c:	7803      	ldrb	r3, [r0, #0]
    5e3e:	b14b      	cbz	r3, 5e54 <cliFunc_keyHold+0x2c>
		switch ( arg1Ptr[0] )
    5e40:	2b53      	cmp	r3, #83	; 0x53
    5e42:	d1f5      	bne.n	5e30 <cliFunc_keyHold+0x8>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x02 ); // Hold scancode
    5e44:	3001      	adds	r0, #1
    5e46:	f005 fbee 	bl	b626 <numToInt>
    5e4a:	2102      	movs	r1, #2
    5e4c:	b2c0      	uxtb	r0, r0
    5e4e:	f7ff ffbb 	bl	5dc8 <Macro_keyState>
			break;
    5e52:	e7ed      	b.n	5e30 <cliFunc_keyHold+0x8>
}
    5e54:	b002      	add	sp, #8
    5e56:	bd10      	pop	{r4, pc}

00005e58 <cliFunc_keyPress>:
{
    5e58:	b513      	push	{r0, r1, r4, lr}
	char* arg2Ptr = args;
    5e5a:	ac02      	add	r4, sp, #8
    5e5c:	f844 0d04 	str.w	r0, [r4, #-4]!
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5e60:	9801      	ldr	r0, [sp, #4]
    5e62:	4622      	mov	r2, r4
    5e64:	4669      	mov	r1, sp
    5e66:	f004 fec3 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    5e6a:	9800      	ldr	r0, [sp, #0]
    5e6c:	7803      	ldrb	r3, [r0, #0]
    5e6e:	b14b      	cbz	r3, 5e84 <cliFunc_keyPress+0x2c>
		switch ( arg1Ptr[0] )
    5e70:	2b53      	cmp	r3, #83	; 0x53
    5e72:	d1f5      	bne.n	5e60 <cliFunc_keyPress+0x8>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x01 ); // Press scancode
    5e74:	3001      	adds	r0, #1
    5e76:	f005 fbd6 	bl	b626 <numToInt>
    5e7a:	2101      	movs	r1, #1
    5e7c:	b2c0      	uxtb	r0, r0
    5e7e:	f7ff ffa3 	bl	5dc8 <Macro_keyState>
			break;
    5e82:	e7ed      	b.n	5e60 <cliFunc_keyPress+0x8>
}
    5e84:	b002      	add	sp, #8
    5e86:	bd10      	pop	{r4, pc}

00005e88 <cliFunc_keyRelease>:
{
    5e88:	b513      	push	{r0, r1, r4, lr}
	char* arg2Ptr = args;
    5e8a:	ac02      	add	r4, sp, #8
    5e8c:	f844 0d04 	str.w	r0, [r4, #-4]!
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5e90:	9801      	ldr	r0, [sp, #4]
    5e92:	4622      	mov	r2, r4
    5e94:	4669      	mov	r1, sp
    5e96:	f004 feab 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    5e9a:	9800      	ldr	r0, [sp, #0]
    5e9c:	7803      	ldrb	r3, [r0, #0]
    5e9e:	b14b      	cbz	r3, 5eb4 <cliFunc_keyRelease+0x2c>
		switch ( arg1Ptr[0] )
    5ea0:	2b53      	cmp	r3, #83	; 0x53
    5ea2:	d1f5      	bne.n	5e90 <cliFunc_keyRelease+0x8>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x03 ); // Release scancode
    5ea4:	3001      	adds	r0, #1
    5ea6:	f005 fbbe 	bl	b626 <numToInt>
    5eaa:	2103      	movs	r1, #3
    5eac:	b2c0      	uxtb	r0, r0
    5eae:	f7ff ff8b 	bl	5dc8 <Macro_keyState>
			break;
    5eb2:	e7ed      	b.n	5e90 <cliFunc_keyRelease+0x8>
}
    5eb4:	b002      	add	sp, #8
    5eb6:	bd10      	pop	{r4, pc}

00005eb8 <Macro_appendResultMacroToPendingList>:
{
    5eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    5eba:	4b21      	ldr	r3, [pc, #132]	; (5f40 <Macro_appendResultMacroToPendingList+0x88>)
	var_uint_t resultMacroIndex = triggerMacro->result;
    5ebc:	7902      	ldrb	r2, [r0, #4]
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    5ebe:	f8b3 1318 	ldrh.w	r1, [r3, #792]	; 0x318
    5ec2:	2500      	movs	r5, #0
    5ec4:	b296      	uxth	r6, r2
    5ec6:	b2ec      	uxtb	r4, r5
    5ec8:	428c      	cmp	r4, r1
    5eca:	d31e      	bcc.n	5f0a <Macro_appendResultMacroToPendingList+0x52>
	macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ].index = resultMacroIndex;
    5ecc:	1c4c      	adds	r4, r1, #1
	macroResultMacroPendingList.data[ macroResultMacroPendingList.size ].trigger = (TriggerMacro*)triggerMacro;
    5ece:	f843 0031 	str.w	r0, [r3, r1, lsl #3]
	macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ].index = resultMacroIndex;
    5ed2:	f8a3 4318 	strh.w	r4, [r3, #792]	; 0x318
    5ed6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5eda:	6800      	ldr	r0, [r0, #0]
	macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ].index = resultMacroIndex;
    5edc:	809e      	strh	r6, [r3, #4]
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5ede:	7803      	ldrb	r3, [r0, #0]
	var_uint_t pos = 0;
    5ee0:	2100      	movs	r1, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5ee2:	b9cb      	cbnz	r3, 5f18 <Macro_appendResultMacroToPendingList+0x60>
	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    5ee4:	4401      	add	r1, r0
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerEventBuffer[ keyIndex ].state;
    5ee6:	4817      	ldr	r0, [pc, #92]	; (5f44 <Macro_appendResultMacroToPendingList+0x8c>)
	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    5ee8:	f811 7c01 	ldrb.w	r7, [r1, #-1]
	for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
    5eec:	4916      	ldr	r1, [pc, #88]	; (5f48 <Macro_appendResultMacroToPendingList+0x90>)
    5eee:	4c17      	ldr	r4, [pc, #92]	; (5f4c <Macro_appendResultMacroToPendingList+0x94>)
    5ef0:	780e      	ldrb	r6, [r1, #0]
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerEventBuffer[ keyIndex ].state;
    5ef2:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    5ef6:	4401      	add	r1, r0
	for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
    5ef8:	b2d8      	uxtb	r0, r3
    5efa:	4286      	cmp	r6, r0
    5efc:	d813      	bhi.n	5f26 <Macro_appendResultMacroToPendingList+0x6e>
	ResultMacroRecordList[ resultMacroIndex ].pos = 0;
    5efe:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    5f02:	4b10      	ldr	r3, [pc, #64]	; (5f44 <Macro_appendResultMacroToPendingList+0x8c>)
    5f04:	2100      	movs	r1, #0
    5f06:	5499      	strb	r1, [r3, r2]
    5f08:	e005      	b.n	5f16 <Macro_appendResultMacroToPendingList+0x5e>
		if ( macroResultMacroPendingList.data[ macro ].index == resultMacroIndex )
    5f0a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    5f0e:	3501      	adds	r5, #1
    5f10:	88a4      	ldrh	r4, [r4, #4]
    5f12:	42b4      	cmp	r4, r6
    5f14:	d1d7      	bne.n	5ec6 <Macro_appendResultMacroToPendingList+0xe>
}
    5f16:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pos += TriggerGuideSize * comboLength + 1;
    5f18:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5f1c:	3301      	adds	r3, #1
    5f1e:	440b      	add	r3, r1
    5f20:	b2d9      	uxtb	r1, r3
		comboLength = triggerMacro->guide[ pos ];
    5f22:	5c43      	ldrb	r3, [r0, r1]
    5f24:	e7dd      	b.n	5ee2 <Macro_appendResultMacroToPendingList+0x2a>
    5f26:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    5f2a:	1905      	adds	r5, r0, r4
    5f2c:	3301      	adds	r3, #1
		if ( macroTriggerEventBuffer[ keyIndex ].index == scanCode )
    5f2e:	f895 c002 	ldrb.w	ip, [r5, #2]
    5f32:	45bc      	cmp	ip, r7
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerEventBuffer[ keyIndex ].state;
    5f34:	bf01      	itttt	eq
    5f36:	786d      	ldrbeq	r5, [r5, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerEventBuffer[ keyIndex ].type;
    5f38:	5d00      	ldrbeq	r0, [r0, r4]
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerEventBuffer[ keyIndex ].state;
    5f3a:	704d      	strbeq	r5, [r1, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerEventBuffer[ keyIndex ].type;
    5f3c:	7088      	strbeq	r0, [r1, #2]
    5f3e:	e7db      	b.n	5ef8 <Macro_appendResultMacroToPendingList+0x40>
    5f40:	1fffa3f4 	.word	0x1fffa3f4
    5f44:	1fff9f05 	.word	0x1fff9f05
    5f48:	1fff9f01 	.word	0x1fff9f01
    5f4c:	1fffa030 	.word	0x1fffa030

00005f50 <Macro_poll>:
	Result_process_delayed();
    5f50:	f000 bae2 	b.w	6518 <Result_process_delayed>

00005f54 <Macro_periodic>:
{
    5f54:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	Latency_start_time( macroLatencyResource );
    5f58:	4f48      	ldr	r7, [pc, #288]	; (607c <Macro_periodic+0x128>)
    5f5a:	4c49      	ldr	r4, [pc, #292]	; (6080 <Macro_periodic+0x12c>)
    5f5c:	7838      	ldrb	r0, [r7, #0]
    5f5e:	f005 f9c3 	bl	b2e8 <Latency_start_time>
	if ( !Connect_master )
    5f62:	4b48      	ldr	r3, [pc, #288]	; (6084 <Macro_periodic+0x130>)
    5f64:	781d      	ldrb	r5, [r3, #0]
    5f66:	b94d      	cbnz	r5, 5f7c <Macro_periodic+0x28>
		if ( macroTriggerEventBufferSize > 0 )
    5f68:	7822      	ldrb	r2, [r4, #0]
    5f6a:	b12a      	cbz	r2, 5f78 <Macro_periodic+0x24>
			Connect_send_ScanCode( Connect_id, macroTriggerEventBuffer, macroTriggerEventBufferSize );
    5f6c:	4b46      	ldr	r3, [pc, #280]	; (6088 <Macro_periodic+0x134>)
    5f6e:	4947      	ldr	r1, [pc, #284]	; (608c <Macro_periodic+0x138>)
    5f70:	7818      	ldrb	r0, [r3, #0]
    5f72:	f7fe fde1 	bl	4b38 <Connect_send_ScanCode>
			macroTriggerEventBufferSize = 0;
    5f76:	7025      	strb	r5, [r4, #0]
}
    5f78:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ( Connect_master && macroInterconnectCacheSize > 0 )
    5f7c:	4e44      	ldr	r6, [pc, #272]	; (6090 <Macro_periodic+0x13c>)
    5f7e:	7833      	ldrb	r3, [r6, #0]
    5f80:	b953      	cbnz	r3, 5f98 <Macro_periodic+0x44>
	switch ( macroDebugMode )
    5f82:	4e44      	ldr	r6, [pc, #272]	; (6094 <Macro_periodic+0x140>)
    5f84:	7833      	ldrb	r3, [r6, #0]
    5f86:	3b01      	subs	r3, #1
    5f88:	2b01      	cmp	r3, #1
    5f8a:	d848      	bhi.n	601e <Macro_periodic+0xca>
    5f8c:	2500      	movs	r5, #0
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    5f8e:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 608c <Macro_periodic+0x138>
			print( NL );
    5f92:	f8df 910c 	ldr.w	r9, [pc, #268]	; 60a0 <Macro_periodic+0x14c>
    5f96:	e03e      	b.n	6016 <Macro_periodic+0xc2>
    5f98:	4d3f      	ldr	r5, [pc, #252]	; (6098 <Macro_periodic+0x144>)
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    5f9a:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 608c <Macro_periodic+0x138>
				erro_print("Interconnect Trigger Event Type - Not Implemented");
    5f9e:	f8df b114 	ldr.w	fp, [pc, #276]	; 60b4 <Macro_periodic+0x160>
		macroInterconnectCacheSize = 0;
    5fa2:	2200      	movs	r2, #0
    5fa4:	f04f 0803 	mov.w	r8, #3
    5fa8:	7032      	strb	r2, [r6, #0]
    5faa:	fb18 5803 	smlabb	r8, r8, r3, r5
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    5fae:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
		for ( uint8_t c = 0; c < currentInterconnectCacheSize; c++ )
    5fb2:	4545      	cmp	r5, r8
    5fb4:	7823      	ldrb	r3, [r4, #0]
    5fb6:	d0e4      	beq.n	5f82 <Macro_periodic+0x2e>
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    5fb8:	1c5a      	adds	r2, r3, #1
    5fba:	7022      	strb	r2, [r4, #0]
    5fbc:	462a      	mov	r2, r5
    5fbe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5fc2:	f832 0d01 	ldrh.w	r0, [r2, #-1]!
    5fc6:	f829 0003 	strh.w	r0, [r9, r3]
    5fca:	eb09 0103 	add.w	r1, r9, r3
    5fce:	7893      	ldrb	r3, [r2, #2]
    5fd0:	708b      	strb	r3, [r1, #2]
			switch ( macroInterconnectCache[ c ].type )
    5fd2:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    5fd6:	b983      	cbnz	r3, 5ffa <Macro_periodic+0xa6>
				switch ( macroInterconnectCache[ c ].state )
    5fd8:	782b      	ldrb	r3, [r5, #0]
    5fda:	2b01      	cmp	r3, #1
    5fdc:	d10d      	bne.n	5ffa <Macro_periodic+0xa6>
					macroInterconnectCache[ c ].state = 0x02;
    5fde:	2302      	movs	r3, #2
    5fe0:	702b      	strb	r3, [r5, #0]
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    5fe2:	7833      	ldrb	r3, [r6, #0]
    5fe4:	8810      	ldrh	r0, [r2, #0]
    5fe6:	1c59      	adds	r1, r3, #1
    5fe8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5fec:	7031      	strb	r1, [r6, #0]
    5fee:	f82a 0003 	strh.w	r0, [sl, r3]
    5ff2:	eb0a 0103 	add.w	r1, sl, r3
    5ff6:	7893      	ldrb	r3, [r2, #2]
    5ff8:	708b      	strb	r3, [r1, #2]
				erro_print("Interconnect Trigger Event Type - Not Implemented");
    5ffa:	4658      	mov	r0, fp
    5ffc:	f005 fa00 	bl	b400 <_print>
    6000:	3503      	adds	r5, #3
    6002:	e7d6      	b.n	5fb2 <Macro_periodic+0x5e>
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    6004:	eb05 0045 	add.w	r0, r5, r5, lsl #1
    6008:	4440      	add	r0, r8
    600a:	f7ff fdd3 	bl	5bb4 <Macro_showTriggerEvent>
			print( NL );
    600e:	4648      	mov	r0, r9
    6010:	f005 f9f6 	bl	b400 <_print>
    6014:	3501      	adds	r5, #1
		for ( uint16_t trigger = 0; trigger < macroTriggerEventBufferSize; trigger++ )
    6016:	7822      	ldrb	r2, [r4, #0]
    6018:	b2ab      	uxth	r3, r5
    601a:	429a      	cmp	r2, r3
    601c:	d8f2      	bhi.n	6004 <Macro_periodic+0xb0>
	if ( macroTriggerEventBufferSize >= MaxScanCode )
    601e:	7823      	ldrb	r3, [r4, #0]
    6020:	2b59      	cmp	r3, #89	; 0x59
    6022:	d90a      	bls.n	603a <Macro_periodic+0xe6>
			erro_msg("Macro Trigger Event Overflow! Serious Bug! ");
    6024:	481d      	ldr	r0, [pc, #116]	; (609c <Macro_periodic+0x148>)
    6026:	f005 f9eb 	bl	b400 <_print>
			printInt16( macroTriggerEventBufferSize );
    602a:	7820      	ldrb	r0, [r4, #0]
    602c:	f005 fa38 	bl	b4a0 <printInt16>
			print( NL );
    6030:	481b      	ldr	r0, [pc, #108]	; (60a0 <Macro_periodic+0x14c>)
    6032:	f005 f9e5 	bl	b400 <_print>
			macroTriggerEventBufferSize = 0;
    6036:	2300      	movs	r3, #0
    6038:	7023      	strb	r3, [r4, #0]
	if ( macroPauseMode )
    603a:	4b1a      	ldr	r3, [pc, #104]	; (60a4 <Macro_periodic+0x150>)
    603c:	781b      	ldrb	r3, [r3, #0]
    603e:	b143      	cbz	r3, 6052 <Macro_periodic+0xfe>
		if ( macroStepCounter == 0 )
    6040:	4a19      	ldr	r2, [pc, #100]	; (60a8 <Macro_periodic+0x154>)
    6042:	8813      	ldrh	r3, [r2, #0]
    6044:	2b00      	cmp	r3, #0
    6046:	d097      	beq.n	5f78 <Macro_periodic+0x24>
		macroStepCounter--;
    6048:	3b01      	subs	r3, #1
		dbug_print("Macro Step");
    604a:	4818      	ldr	r0, [pc, #96]	; (60ac <Macro_periodic+0x158>)
		macroStepCounter--;
    604c:	8013      	strh	r3, [r2, #0]
		dbug_print("Macro Step");
    604e:	f005 f9d7 	bl	b400 <_print>
	Trigger_process();
    6052:	f000 fcad 	bl	69b0 <Trigger_process>
	Result_process();
    6056:	f000 fa83 	bl	6560 <Result_process>
	Scan_finishedWithMacro( macroTriggerEventBufferSize );
    605a:	7820      	ldrb	r0, [r4, #0]
    605c:	f7ff f98a 	bl	5374 <Scan_finishedWithMacro>
	macroTriggerEventBufferSize = 0;
    6060:	2500      	movs	r5, #0
	Latency_end_time( macroLatencyResource );
    6062:	7838      	ldrb	r0, [r7, #0]
	macroTriggerEventBufferSize = 0;
    6064:	7025      	strb	r5, [r4, #0]
	Latency_end_time( macroLatencyResource );
    6066:	f005 f951 	bl	b30c <Latency_end_time>
	if ( macroDebugMode == 1 || macroDebugMode == 3 )
    606a:	7833      	ldrb	r3, [r6, #0]
    606c:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    6070:	2b01      	cmp	r3, #1
		USBKeys_primary.changed = 0;
    6072:	bf04      	itt	eq
    6074:	4b0e      	ldreq	r3, [pc, #56]	; (60b0 <Macro_periodic+0x15c>)
    6076:	f883 5020 	strbeq.w	r5, [r3, #32]
    607a:	e77d      	b.n	5f78 <Macro_periodic+0x24>
    607c:	1fff9306 	.word	0x1fff9306
    6080:	1fff9f01 	.word	0x1fff9f01
    6084:	1fff9300 	.word	0x1fff9300
    6088:	1fff89fc 	.word	0x1fff89fc
    608c:	1fffa030 	.word	0x1fffa030
    6090:	1fff9305 	.word	0x1fff9305
    6094:	1fffa19b 	.word	0x1fffa19b
    6098:	1fffa19d 	.word	0x1fffa19d
    609c:	0000d22a 	.word	0x0000d22a
    60a0:	00010d99 	.word	0x00010d99
    60a4:	1fff9f00 	.word	0x1fff9f00
    60a8:	1fffa13e 	.word	0x1fffa13e
    60ac:	0000d26b 	.word	0x0000d26b
    60b0:	1fffadee 	.word	0x1fffadee
    60b4:	0000d1e1 	.word	0x0000d1e1

000060b8 <Macro_setup>:
{
    60b8:	b510      	push	{r4, lr}
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    60ba:	490f      	ldr	r1, [pc, #60]	; (60f8 <Macro_setup+0x40>)
    60bc:	480f      	ldr	r0, [pc, #60]	; (60fc <Macro_setup+0x44>)
    60be:	f004 fe31 	bl	ad24 <CLI_registerDictionary>
	macroDebugMode = 0;
    60c2:	4b0f      	ldr	r3, [pc, #60]	; (6100 <Macro_setup+0x48>)
    60c4:	2400      	movs	r4, #0
    60c6:	701c      	strb	r4, [r3, #0]
	macroPauseMode = 0;
    60c8:	4b0e      	ldr	r3, [pc, #56]	; (6104 <Macro_setup+0x4c>)
    60ca:	701c      	strb	r4, [r3, #0]
	macroStepCounter = 0;
    60cc:	4b0e      	ldr	r3, [pc, #56]	; (6108 <Macro_setup+0x50>)
    60ce:	801c      	strh	r4, [r3, #0]
	voteDebugMode = 0;
    60d0:	4b0e      	ldr	r3, [pc, #56]	; (610c <Macro_setup+0x54>)
    60d2:	701c      	strb	r4, [r3, #0]
	macroTriggerEventBufferSize = 0;
    60d4:	4b0e      	ldr	r3, [pc, #56]	; (6110 <Macro_setup+0x58>)
    60d6:	701c      	strb	r4, [r3, #0]
	Macro_rotationLayer = 0;
    60d8:	4b0e      	ldr	r3, [pc, #56]	; (6114 <Macro_setup+0x5c>)
    60da:	801c      	strh	r4, [r3, #0]
	layerDebugMode = 0;
    60dc:	4b0e      	ldr	r3, [pc, #56]	; (6118 <Macro_setup+0x60>)
    60de:	701c      	strb	r4, [r3, #0]
	Trigger_setup();
    60e0:	f000 fc58 	bl	6994 <Trigger_setup>
	Result_setup();
    60e4:	f000 fa00 	bl	64e8 <Result_setup>
	macroLatencyResource = Latency_add_resource("PartialMap", LatencyOption_Ticks);
    60e8:	4621      	mov	r1, r4
    60ea:	480c      	ldr	r0, [pc, #48]	; (611c <Macro_setup+0x64>)
    60ec:	f005 f8ac 	bl	b248 <Latency_add_resource>
    60f0:	4b0b      	ldr	r3, [pc, #44]	; (6120 <Macro_setup+0x68>)
    60f2:	7018      	strb	r0, [r3, #0]
}
    60f4:	bd10      	pop	{r4, pc}
    60f6:	bf00      	nop
    60f8:	0000ec0c 	.word	0x0000ec0c
    60fc:	0000eb4c 	.word	0x0000eb4c
    6100:	1fffa19b 	.word	0x1fffa19b
    6104:	1fff9f00 	.word	0x1fff9f00
    6108:	1fffa13e 	.word	0x1fffa13e
    610c:	1fff9f04 	.word	0x1fff9f04
    6110:	1fff9f01 	.word	0x1fff9f01
    6114:	1fff9f02 	.word	0x1fff9f02
    6118:	1fffa140 	.word	0x1fffa140
    611c:	0000d317 	.word	0x0000d317
    6120:	1fff9306 	.word	0x1fff9306

00006124 <macroDebugShowTrigger>:
	if ( index >= TriggerMacroNum )
    6124:	2866      	cmp	r0, #102	; 0x66
{
    6126:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    612a:	4606      	mov	r6, r0
	if ( index >= TriggerMacroNum )
    612c:	d831      	bhi.n	6192 <macroDebugShowTrigger+0x6e>
	print( NL );
    612e:	4835      	ldr	r0, [pc, #212]	; (6204 <macroDebugShowTrigger+0xe0>)
	uint8_t comboLength = macro->guide[ pos ];
    6130:	4f35      	ldr	r7, [pc, #212]	; (6208 <macroDebugShowTrigger+0xe4>)
			print("|");
    6132:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 6230 <macroDebugShowTrigger+0x10c>
			print(";");
    6136:	f8df b0fc 	ldr.w	fp, [pc, #252]	; 6234 <macroDebugShowTrigger+0x110>
	print( NL );
    613a:	f005 f961 	bl	b400 <_print>
	info_msg("Trigger Macro Index: ");
    613e:	4833      	ldr	r0, [pc, #204]	; (620c <macroDebugShowTrigger+0xe8>)
    6140:	f005 f95e 	bl	b400 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    6144:	4630      	mov	r0, r6
    6146:	f005 f9ab 	bl	b4a0 <printInt16>
	print( NL );
    614a:	482e      	ldr	r0, [pc, #184]	; (6204 <macroDebugShowTrigger+0xe0>)
    614c:	f005 f958 	bl	b400 <_print>
	uint8_t comboLength = macro->guide[ pos ];
    6150:	f857 8036 	ldr.w	r8, [r7, r6, lsl #3]
    6154:	f898 5000 	ldrb.w	r5, [r8]
	var_uint_t pos = 0;
    6158:	2400      	movs	r4, #0
	while ( comboLength != 0 )
    615a:	b9e5      	cbnz	r5, 6196 <macroDebugShowTrigger+0x72>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    615c:	4c2c      	ldr	r4, [pc, #176]	; (6210 <macroDebugShowTrigger+0xec>)
	print( NL "Position: " );
    615e:	482d      	ldr	r0, [pc, #180]	; (6214 <macroDebugShowTrigger+0xf0>)
    6160:	f005 f94e 	bl	b400 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    6164:	eb07 07c6 	add.w	r7, r7, r6, lsl #3
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    6168:	f814 0016 	ldrb.w	r0, [r4, r6, lsl #1]
    616c:	f005 f998 	bl	b4a0 <printInt16>
	print( NL "Result Macro Index: " );
    6170:	4829      	ldr	r0, [pc, #164]	; (6218 <macroDebugShowTrigger+0xf4>)
    6172:	f005 f945 	bl	b400 <_print>
	switch ( record->state )
    6176:	eb04 0646 	add.w	r6, r4, r6, lsl #1
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    617a:	7938      	ldrb	r0, [r7, #4]
    617c:	f005 f990 	bl	b4a0 <printInt16>
	print( NL "Trigger Macro State: " );
    6180:	4826      	ldr	r0, [pc, #152]	; (621c <macroDebugShowTrigger+0xf8>)
    6182:	f005 f93d 	bl	b400 <_print>
	switch ( record->state )
    6186:	7873      	ldrb	r3, [r6, #1]
    6188:	2b01      	cmp	r3, #1
    618a:	d037      	beq.n	61fc <macroDebugShowTrigger+0xd8>
    618c:	d331      	bcc.n	61f2 <macroDebugShowTrigger+0xce>
    618e:	2b02      	cmp	r3, #2
    6190:	d036      	beq.n	6200 <macroDebugShowTrigger+0xdc>
}
    6192:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		var_uint_t comboPos = ++pos;
    6196:	3401      	adds	r4, #1
    6198:	b2e4      	uxtb	r4, r4
		while ( pos < comboLength * TriggerGuideSize + comboPos )
    619a:	2303      	movs	r3, #3
    619c:	fb13 4505 	smlabb	r5, r3, r5, r4
    61a0:	42ac      	cmp	r4, r5
    61a2:	eb08 0a04 	add.w	sl, r8, r4
    61a6:	d307      	bcc.n	61b8 <macroDebugShowTrigger+0x94>
		comboLength = macro->guide[ pos ];
    61a8:	f89a 5000 	ldrb.w	r5, [sl]
		if ( comboLength != 0 )
    61ac:	2d00      	cmp	r5, #0
    61ae:	d0d5      	beq.n	615c <macroDebugShowTrigger+0x38>
			print(";");
    61b0:	4658      	mov	r0, fp
    61b2:	f005 f925 	bl	b400 <_print>
    61b6:	e7d0      	b.n	615a <macroDebugShowTrigger+0x36>
			printHex( guide->scanCode );
    61b8:	2101      	movs	r1, #1
    61ba:	f89a 0002 	ldrb.w	r0, [sl, #2]
    61be:	f005 f9c7 	bl	b550 <printHex_op>
			print("|");
    61c2:	4648      	mov	r0, r9
    61c4:	f005 f91c 	bl	b400 <_print>
			printHex( guide->type );
    61c8:	2101      	movs	r1, #1
    61ca:	f818 0004 	ldrb.w	r0, [r8, r4]
    61ce:	f005 f9bf 	bl	b550 <printHex_op>
			pos += TriggerGuideSize;
    61d2:	3403      	adds	r4, #3
			print("|");
    61d4:	4648      	mov	r0, r9
    61d6:	f005 f913 	bl	b400 <_print>
			pos += TriggerGuideSize;
    61da:	b2e4      	uxtb	r4, r4
			printHex( guide->state );
    61dc:	2101      	movs	r1, #1
    61de:	f89a 0001 	ldrb.w	r0, [sl, #1]
    61e2:	f005 f9b5 	bl	b550 <printHex_op>
			if ( pos < comboLength * TriggerGuideSize + comboPos )
    61e6:	42ac      	cmp	r4, r5
    61e8:	d2da      	bcs.n	61a0 <macroDebugShowTrigger+0x7c>
				print("+");
    61ea:	480d      	ldr	r0, [pc, #52]	; (6220 <macroDebugShowTrigger+0xfc>)
    61ec:	f005 f908 	bl	b400 <_print>
    61f0:	e7d6      	b.n	61a0 <macroDebugShowTrigger+0x7c>
	case TriggerMacro_Press:   print("Press");   break;
    61f2:	480c      	ldr	r0, [pc, #48]	; (6224 <macroDebugShowTrigger+0x100>)
}
    61f4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	case TriggerMacro_Waiting: print("Waiting"); break;
    61f8:	f005 b902 	b.w	b400 <_print>
	case TriggerMacro_Release: print("Release"); break;
    61fc:	480a      	ldr	r0, [pc, #40]	; (6228 <macroDebugShowTrigger+0x104>)
    61fe:	e7f9      	b.n	61f4 <macroDebugShowTrigger+0xd0>
	case TriggerMacro_Waiting: print("Waiting"); break;
    6200:	480a      	ldr	r0, [pc, #40]	; (622c <macroDebugShowTrigger+0x108>)
    6202:	e7f7      	b.n	61f4 <macroDebugShowTrigger+0xd0>
    6204:	00010d99 	.word	0x00010d99
    6208:	0000d4f0 	.word	0x0000d4f0
    620c:	0000ecbf 	.word	0x0000ecbf
    6210:	1fffa2aa 	.word	0x1fffa2aa
    6214:	0000eceb 	.word	0x0000eceb
    6218:	0000ecf8 	.word	0x0000ecf8
    621c:	0000ed0f 	.word	0x0000ed0f
    6220:	0000c85a 	.word	0x0000c85a
    6224:	0000f014 	.word	0x0000f014
    6228:	0000f01d 	.word	0x0000f01d
    622c:	0000ed27 	.word	0x0000ed27
    6230:	0000ece7 	.word	0x0000ece7
    6234:	0000ece9 	.word	0x0000ece9

00006238 <macroDebugShowResult>:
	if ( index >= ResultMacroNum )
    6238:	2862      	cmp	r0, #98	; 0x62
{
    623a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    623e:	4605      	mov	r5, r0
	if ( index >= ResultMacroNum )
    6240:	f200 8092 	bhi.w	6368 <macroDebugShowResult+0x130>
	print( NL );
    6244:	484a      	ldr	r0, [pc, #296]	; (6370 <macroDebugShowResult+0x138>)
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    6246:	f8df 815c 	ldr.w	r8, [pc, #348]	; 63a4 <macroDebugShowResult+0x16c>
	print( NL );
    624a:	f005 f8d9 	bl	b400 <_print>
	info_msg("Result Macro Index: ");
    624e:	4849      	ldr	r0, [pc, #292]	; (6374 <macroDebugShowResult+0x13c>)
    6250:	f005 f8d6 	bl	b400 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    6254:	4628      	mov	r0, r5
    6256:	f005 f923 	bl	b4a0 <printInt16>
	print( NL );
    625a:	4845      	ldr	r0, [pc, #276]	; (6370 <macroDebugShowResult+0x138>)
    625c:	f005 f8d0 	bl	b400 <_print>
	uint8_t comboLength = macro->guide[ pos++ ];
    6260:	4b45      	ldr	r3, [pc, #276]	; (6378 <macroDebugShowResult+0x140>)
    6262:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    6266:	f897 9000 	ldrb.w	r9, [r7]
    626a:	2401      	movs	r4, #1
	while ( comboLength != 0 )
    626c:	f1b9 0f00 	cmp.w	r9, #0
    6270:	d178      	bne.n	6364 <macroDebugShowResult+0x12c>
	print( NL "Position: " );
    6272:	4842      	ldr	r0, [pc, #264]	; (637c <macroDebugShowResult+0x144>)
    6274:	f005 f8c4 	bl	b400 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    6278:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    627c:	4b40      	ldr	r3, [pc, #256]	; (6380 <macroDebugShowResult+0x148>)
    627e:	195c      	adds	r4, r3, r5
    6280:	5d58      	ldrb	r0, [r3, r5]
    6282:	f005 f90d 	bl	b4a0 <printInt16>
	print( NL "Final Trigger State (State/Type): " );
    6286:	483f      	ldr	r0, [pc, #252]	; (6384 <macroDebugShowResult+0x14c>)
    6288:	f005 f8ba 	bl	b400 <_print>
	printHex( record->state );
    628c:	2101      	movs	r1, #1
    628e:	7860      	ldrb	r0, [r4, #1]
    6290:	f005 f95e 	bl	b550 <printHex_op>
	print("/");
    6294:	483c      	ldr	r0, [pc, #240]	; (6388 <macroDebugShowResult+0x150>)
    6296:	f005 f8b3 	bl	b400 <_print>
	printHex( record->stateType );
    629a:	78a0      	ldrb	r0, [r4, #2]
    629c:	2101      	movs	r1, #1
}
    629e:	b003      	add	sp, #12
    62a0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	printHex( record->stateType );
    62a4:	f005 b954 	b.w	b550 <printHex_op>
			printHex( guide->index );
    62a8:	2101      	movs	r1, #1
    62aa:	4658      	mov	r0, fp
    62ac:	f005 f950 	bl	b550 <printHex_op>
			print("|");
    62b0:	4836      	ldr	r0, [pc, #216]	; (638c <macroDebugShowResult+0x154>)
    62b2:	f005 f8a5 	bl	b400 <_print>
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    62b6:	5d3b      	ldrb	r3, [r7, r4]
    62b8:	2101      	movs	r1, #1
    62ba:	f838 0033 	ldrh.w	r0, [r8, r3, lsl #3]
    62be:	f005 f947 	bl	b550 <printHex_op>
			print("|");
    62c2:	4832      	ldr	r0, [pc, #200]	; (638c <macroDebugShowResult+0x154>)
    62c4:	f005 f89c 	bl	b400 <_print>
				(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    62c8:	5d3b      	ldrb	r3, [r7, r4]
			capability( 0, 0xFF, 0xFF, 0 );
    62ca:	22ff      	movs	r2, #255	; 0xff
    62cc:	f858 b033 	ldr.w	fp, [r8, r3, lsl #3]
    62d0:	2300      	movs	r3, #0
    62d2:	4611      	mov	r1, r2
    62d4:	4618      	mov	r0, r3
    62d6:	47d8      	blx	fp
			print("(");
    62d8:	482d      	ldr	r0, [pc, #180]	; (6390 <macroDebugShowResult+0x158>)
    62da:	f005 f891 	bl	b400 <_print>
    62de:	2200      	movs	r2, #0
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    62e0:	f89a 3000 	ldrb.w	r3, [sl]
    62e4:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    62e8:	fa5f fb82 	uxtb.w	fp, r2
    62ec:	7919      	ldrb	r1, [r3, #4]
    62ee:	4559      	cmp	r1, fp
    62f0:	d821      	bhi.n	6336 <macroDebugShowResult+0xfe>
			print(")");
    62f2:	4828      	ldr	r0, [pc, #160]	; (6394 <macroDebugShowResult+0x15c>)
    62f4:	f005 f884 	bl	b400 <_print>
			pos += ResultGuideSize( guide );
    62f8:	f89a 3000 	ldrb.w	r3, [sl]
    62fc:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
			funcCount++;
    6300:	3601      	adds	r6, #1
			pos += ResultGuideSize( guide );
    6302:	791b      	ldrb	r3, [r3, #4]
			funcCount++;
    6304:	b2f6      	uxtb	r6, r6
			pos += ResultGuideSize( guide );
    6306:	3301      	adds	r3, #1
    6308:	441c      	add	r4, r3
			if ( funcCount < comboLength )
    630a:	454e      	cmp	r6, r9
			pos += ResultGuideSize( guide );
    630c:	b2e4      	uxtb	r4, r4
			if ( funcCount < comboLength )
    630e:	d202      	bcs.n	6316 <macroDebugShowResult+0xde>
				print("+");
    6310:	4821      	ldr	r0, [pc, #132]	; (6398 <macroDebugShowResult+0x160>)
    6312:	f005 f875 	bl	b400 <_print>
		while ( funcCount < comboLength )
    6316:	454e      	cmp	r6, r9
    6318:	eb07 0a04 	add.w	sl, r7, r4
    631c:	f817 b004 	ldrb.w	fp, [r7, r4]
    6320:	d1c2      	bne.n	62a8 <macroDebugShowResult+0x70>
		comboLength = macro->guide[ pos++ ];
    6322:	3401      	adds	r4, #1
    6324:	b2e4      	uxtb	r4, r4
		if ( comboLength != 0 )
    6326:	f1bb 0f00 	cmp.w	fp, #0
    632a:	d002      	beq.n	6332 <macroDebugShowResult+0xfa>
			print(";");
    632c:	481b      	ldr	r0, [pc, #108]	; (639c <macroDebugShowResult+0x164>)
    632e:	f005 f867 	bl	b400 <_print>
		var_uint_t funcCount = 0;
    6332:	46d9      	mov	r9, fp
    6334:	e79a      	b.n	626c <macroDebugShowResult+0x34>
				printHex( (&guide->args)[ arg ] );
    6336:	eb0a 000b 	add.w	r0, sl, fp
    633a:	2101      	movs	r1, #1
    633c:	7840      	ldrb	r0, [r0, #1]
    633e:	9201      	str	r2, [sp, #4]
    6340:	f005 f906 	bl	b550 <printHex_op>
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
    6344:	f89a 1000 	ldrb.w	r1, [sl]
    6348:	9a01      	ldr	r2, [sp, #4]
    634a:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
    634e:	f10b 0301 	add.w	r3, fp, #1
    6352:	7909      	ldrb	r1, [r1, #4]
    6354:	428b      	cmp	r3, r1
    6356:	da03      	bge.n	6360 <macroDebugShowResult+0x128>
					print(",");
    6358:	4811      	ldr	r0, [pc, #68]	; (63a0 <macroDebugShowResult+0x168>)
    635a:	f005 f851 	bl	b400 <_print>
    635e:	9a01      	ldr	r2, [sp, #4]
    6360:	3201      	adds	r2, #1
    6362:	e7bd      	b.n	62e0 <macroDebugShowResult+0xa8>
		var_uint_t funcCount = 0;
    6364:	2600      	movs	r6, #0
    6366:	e7d6      	b.n	6316 <macroDebugShowResult+0xde>
}
    6368:	b003      	add	sp, #12
    636a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    636e:	bf00      	nop
    6370:	00010d99 	.word	0x00010d99
    6374:	0000ec73 	.word	0x0000ec73
    6378:	0000d364 	.word	0x0000d364
    637c:	0000eceb 	.word	0x0000eceb
    6380:	1fff9f05 	.word	0x1fff9f05
    6384:	0000ec9a 	.word	0x0000ec9a
    6388:	0000b857 	.word	0x0000b857
    638c:	0000ece7 	.word	0x0000ece7
    6390:	0000f97f 	.word	0x0000f97f
    6394:	000106cd 	.word	0x000106cd
    6398:	0000c85a 	.word	0x0000c85a
    639c:	0000ece9 	.word	0x0000ece9
    63a0:	0000d322 	.word	0x0000d322
    63a4:	0000cff0 	.word	0x0000cff0

000063a8 <cliFunc_macroShow>:
{
    63a8:	b513      	push	{r0, r1, r4, lr}
	char* arg2Ptr = args;
    63aa:	ac02      	add	r4, sp, #8
    63ac:	f844 0d04 	str.w	r0, [r4, #-4]!
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    63b0:	9801      	ldr	r0, [sp, #4]
    63b2:	4622      	mov	r2, r4
    63b4:	4669      	mov	r1, sp
    63b6:	f004 fc1b 	bl	abf0 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    63ba:	9800      	ldr	r0, [sp, #0]
    63bc:	7803      	ldrb	r3, [r0, #0]
    63be:	b18b      	cbz	r3, 63e4 <cliFunc_macroShow+0x3c>
		switch ( arg1Ptr[0] )
    63c0:	2b52      	cmp	r3, #82	; 0x52
    63c2:	d008      	beq.n	63d6 <cliFunc_macroShow+0x2e>
    63c4:	2b54      	cmp	r3, #84	; 0x54
    63c6:	d1f3      	bne.n	63b0 <cliFunc_macroShow+0x8>
			macroDebugShowTrigger( numToInt( &arg1Ptr[1] ) );
    63c8:	3001      	adds	r0, #1
    63ca:	f005 f92c 	bl	b626 <numToInt>
    63ce:	b2c0      	uxtb	r0, r0
    63d0:	f7ff fea8 	bl	6124 <macroDebugShowTrigger>
			break;
    63d4:	e7ec      	b.n	63b0 <cliFunc_macroShow+0x8>
			macroDebugShowResult( numToInt( &arg1Ptr[1] ) );
    63d6:	3001      	adds	r0, #1
    63d8:	f005 f925 	bl	b626 <numToInt>
    63dc:	b2c0      	uxtb	r0, r0
    63de:	f7ff ff2b 	bl	6238 <macroDebugShowResult>
			break;
    63e2:	e7e5      	b.n	63b0 <cliFunc_macroShow+0x8>
}
    63e4:	b002      	add	sp, #8
    63e6:	bd10      	pop	{r4, pc}

000063e8 <Macro_evalResultMacro>:

// ----- Functions -----

// Evaluate/Update ResultMacro
ResultMacroEval Macro_evalResultMacro( ResultPendingElem resultElem )
{
    63e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    63ec:	b087      	sub	sp, #28
    63ee:	ab06      	add	r3, sp, #24
    63f0:	e903 0003 	stmdb	r3, {r0, r1}
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultElem.index ];
    63f4:	f8bd 7014 	ldrh.w	r7, [sp, #20]
    63f8:	9b04      	ldr	r3, [sp, #16]
	ResultMacroRecord *record = &ResultMacroRecordList[ resultElem.index ];

	// Current Macro position
	var_uint_t pos = record->pos;
    63fa:	4e36      	ldr	r6, [pc, #216]	; (64d4 <Macro_evalResultMacro+0xec>)
    63fc:	9301      	str	r3, [sp, #4]
    63fe:	007d      	lsls	r5, r7, #1
    6400:	19eb      	adds	r3, r5, r7
	{
		// Assign TriggerGuide element (key type, state and scancode)
		ResultGuide *guide = (ResultGuide*)(&macro->guide[ comboItem ]);

		// Determine if this is a safe capability (i.e. can be execute it immediately)
		if ( CapabilitiesList[ guide->index ].features & CapabilityFeature_Safe )
    6402:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 64e0 <Macro_evalResultMacro+0xf8>
	var_uint_t pos = record->pos;
    6406:	5cf4      	ldrb	r4, [r6, r3]
	uint8_t comboLength = macro->guide[ pos ];
    6408:	4b33      	ldr	r3, [pc, #204]	; (64d8 <Macro_evalResultMacro+0xf0>)

			// Call capability
			capability( resultElem.trigger, record->state, record->stateType, &guide->args );
		}
		// Otherwise, queue up the capability for later
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    640a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 64e4 <Macro_evalResultMacro+0xfc>
	uint8_t comboLength = macro->guide[ pos ];
    640e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    6412:	9600      	str	r6, [sp, #0]
    6414:	5d1a      	ldrb	r2, [r3, r4]
    6416:	9203      	str	r2, [sp, #12]
	var_uint_t comboItem = pos + 1;
    6418:	3401      	adds	r4, #1
    641a:	b2e4      	uxtb	r4, r4
	while ( funcCount < comboLength )
    641c:	f04f 0b00 	mov.w	fp, #0
    6420:	9302      	str	r3, [sp, #8]
    6422:	9b02      	ldr	r3, [sp, #8]
    6424:	9a03      	ldr	r2, [sp, #12]
    6426:	eb03 0904 	add.w	r9, r3, r4
    642a:	fa5f f38b 	uxtb.w	r3, fp
    642e:	429a      	cmp	r2, r3
    6430:	d80c      	bhi.n	644c <Macro_evalResultMacro+0x64>
		funcCount++;
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
	}

	// Move to next item in the sequence
	record->pos = comboItem;
    6432:	9b00      	ldr	r3, [sp, #0]
    6434:	443d      	add	r5, r7
    6436:	555c      	strb	r4, [r3, r5]

	// If the ResultMacro is finished, remove
	if ( macro->guide[ comboItem ] == 0 )
    6438:	f899 3000 	ldrb.w	r3, [r9]
    643c:	2b00      	cmp	r3, #0
    643e:	d146      	bne.n	64ce <Macro_evalResultMacro+0xe6>
	{
		record->pos = 0;
    6440:	9a00      	ldr	r2, [sp, #0]
    6442:	5553      	strb	r3, [r2, r5]
		return ResultMacroEval_Remove;
    6444:	2001      	movs	r0, #1
	}

	// Otherwise leave the macro in the list
	return ResultMacroEval_DoNothing;
}
    6446:	b007      	add	sp, #28
    6448:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ( CapabilitiesList[ guide->index ].features & CapabilityFeature_Safe )
    644c:	9b02      	ldr	r3, [sp, #8]
    644e:	5d19      	ldrb	r1, [r3, r4]
    6450:	eb0a 03c1 	add.w	r3, sl, r1, lsl #3
    6454:	795b      	ldrb	r3, [r3, #5]
    6456:	07db      	lsls	r3, r3, #31
    6458:	d516      	bpl.n	6488 <Macro_evalResultMacro+0xa0>
			capability( resultElem.trigger, record->state, record->stateType, &guide->args );
    645a:	9b00      	ldr	r3, [sp, #0]
    645c:	19e8      	adds	r0, r5, r7
    645e:	4418      	add	r0, r3
    6460:	f85a 3031 	ldr.w	r3, [sl, r1, lsl #3]
    6464:	7882      	ldrb	r2, [r0, #2]
    6466:	7841      	ldrb	r1, [r0, #1]
    6468:	9801      	ldr	r0, [sp, #4]
    646a:	461e      	mov	r6, r3
    646c:	f109 0301 	add.w	r3, r9, #1
    6470:	47b0      	blx	r6
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
    6472:	f899 3000 	ldrb.w	r3, [r9]
    6476:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
    647a:	f10b 0b01 	add.w	fp, fp, #1
    647e:	791b      	ldrb	r3, [r3, #4]
    6480:	3301      	adds	r3, #1
    6482:	441c      	add	r4, r3
    6484:	b2e4      	uxtb	r4, r4
    6486:	e7cc      	b.n	6422 <Macro_evalResultMacro+0x3a>
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    6488:	f898 3078 	ldrb.w	r3, [r8, #120]	; 0x78
    648c:	2b09      	cmp	r3, #9
    648e:	d81a      	bhi.n	64c6 <Macro_evalResultMacro+0xde>
			uint8_t size = macroResultDelayedCapabilities.size;
    6490:	f898 3078 	ldrb.w	r3, [r8, #120]	; 0x78
			macroResultDelayedCapabilities.stack[ size ].trigger         = resultElem.trigger;
    6494:	9801      	ldr	r0, [sp, #4]
    6496:	220c      	movs	r2, #12
    6498:	435a      	muls	r2, r3
    649a:	eb08 0302 	add.w	r3, r8, r2
    649e:	f848 0002 	str.w	r0, [r8, r2]
			macroResultDelayedCapabilities.stack[ size ].state           = record->state;
    64a2:	9800      	ldr	r0, [sp, #0]
    64a4:	19ea      	adds	r2, r5, r7
    64a6:	4402      	add	r2, r0
    64a8:	7850      	ldrb	r0, [r2, #1]
    64aa:	7118      	strb	r0, [r3, #4]
			macroResultDelayedCapabilities.stack[ size ].stateType       = record->stateType;
    64ac:	7892      	ldrb	r2, [r2, #2]
    64ae:	715a      	strb	r2, [r3, #5]
			macroResultDelayedCapabilities.stack[ size ].args            = &guide->args;
    64b0:	f109 0201 	add.w	r2, r9, #1
			macroResultDelayedCapabilities.stack[ size ].capabilityIndex = guide->index;
    64b4:	7199      	strb	r1, [r3, #6]
			macroResultDelayedCapabilities.stack[ size ].args            = &guide->args;
    64b6:	609a      	str	r2, [r3, #8]
			macroResultDelayedCapabilities.size++;
    64b8:	f898 3078 	ldrb.w	r3, [r8, #120]	; 0x78
    64bc:	3301      	adds	r3, #1
    64be:	b2db      	uxtb	r3, r3
    64c0:	f888 3078 	strb.w	r3, [r8, #120]	; 0x78
    64c4:	e7d5      	b.n	6472 <Macro_evalResultMacro+0x8a>
			warn_print("Delayed capability stack full!");
    64c6:	4805      	ldr	r0, [pc, #20]	; (64dc <Macro_evalResultMacro+0xf4>)
    64c8:	f004 ff9a 	bl	b400 <_print>
    64cc:	e7d1      	b.n	6472 <Macro_evalResultMacro+0x8a>
	return ResultMacroEval_DoNothing;
    64ce:	2000      	movs	r0, #0
    64d0:	e7b9      	b.n	6446 <Macro_evalResultMacro+0x5e>
    64d2:	bf00      	nop
    64d4:	1fff9f05 	.word	0x1fff9f05
    64d8:	0000d364 	.word	0x0000d364
    64dc:	0000f22b 	.word	0x0000f22b
    64e0:	0000cff0 	.word	0x0000cff0
    64e4:	1fffa378 	.word	0x1fffa378

000064e8 <Result_setup>:


void Result_setup()
{
	// Initialize macroResultMacroPendingList
	macroResultMacroPendingList.size = 0;
    64e8:	4a08      	ldr	r2, [pc, #32]	; (650c <Result_setup+0x24>)
    64ea:	2300      	movs	r3, #0
    64ec:	f8a2 3318 	strh.w	r3, [r2, #792]	; 0x318
    64f0:	4a07      	ldr	r2, [pc, #28]	; (6510 <Result_setup+0x28>)
    64f2:	f202 1129 	addw	r1, r2, #297	; 0x129

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
	{
		ResultMacroRecordList[ macro ].pos       = 0;
    64f6:	7013      	strb	r3, [r2, #0]
		ResultMacroRecordList[ macro ].state     = 0;
    64f8:	7053      	strb	r3, [r2, #1]
		ResultMacroRecordList[ macro ].stateType = 0;
    64fa:	7093      	strb	r3, [r2, #2]
    64fc:	3203      	adds	r2, #3
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
    64fe:	428a      	cmp	r2, r1
    6500:	d1f9      	bne.n	64f6 <Result_setup+0xe>
	}

	// Reset delayed capabilities stack
	macroResultDelayedCapabilities.size = 0;
    6502:	4a04      	ldr	r2, [pc, #16]	; (6514 <Result_setup+0x2c>)
    6504:	f882 3078 	strb.w	r3, [r2, #120]	; 0x78
}
    6508:	4770      	bx	lr
    650a:	bf00      	nop
    650c:	1fffa3f4 	.word	0x1fffa3f4
    6510:	1fff9f05 	.word	0x1fff9f05
    6514:	1fffa378 	.word	0x1fffa378

00006518 <Result_process_delayed>:

// Process delayed capabilities
// Capabilities that are not called immediately (i.e. ones that are not deemed as thread safe)
// are processed with this function
void Result_process_delayed()
{
    6518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Process stack until empty
	// For each empty, make sure interrupts are disabled
	while ( macroResultDelayedCapabilities.size > 0 )
    651a:	4c0f      	ldr	r4, [pc, #60]	; (6558 <Result_process_delayed+0x40>)
		// Lookup stack
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];

		// Do lookup on capability function
		void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    651c:	4e0f      	ldr	r6, [pc, #60]	; (655c <Result_process_delayed+0x44>)
    651e:	250c      	movs	r5, #12
	while ( macroResultDelayedCapabilities.size > 0 )
    6520:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    6524:	b91b      	cbnz	r3, 652e <Result_process_delayed+0x16>
		macroResultDelayedCapabilities.size--;
	}

	// Re-enable periodic interrupts
	Periodic_enable();
}
    6526:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	Periodic_enable();
    652a:	f7fc b9f5 	b.w	2918 <Periodic_enable>
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];
    652e:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    6532:	3b01      	subs	r3, #1
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    6534:	436b      	muls	r3, r5
    6536:	18e7      	adds	r7, r4, r3
    6538:	f897 c006 	ldrb.w	ip, [r7, #6]
		capability( item->trigger, item->state, item->stateType, item->args );
    653c:	58e0      	ldr	r0, [r4, r3]
    653e:	7939      	ldrb	r1, [r7, #4]
    6540:	797a      	ldrb	r2, [r7, #5]
    6542:	68bb      	ldr	r3, [r7, #8]
    6544:	f856 703c 	ldr.w	r7, [r6, ip, lsl #3]
    6548:	47b8      	blx	r7
		macroResultDelayedCapabilities.size--;
    654a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    654e:	3b01      	subs	r3, #1
    6550:	b2db      	uxtb	r3, r3
    6552:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    6556:	e7e3      	b.n	6520 <Result_process_delayed+0x8>
    6558:	1fffa378 	.word	0x1fffa378
    655c:	0000cff0 	.word	0x0000cff0

00006560 <Result_process>:


void Result_process()
{
    6560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	index_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    6564:	2400      	movs	r4, #0
    6566:	4e11      	ldr	r6, [pc, #68]	; (65ac <Result_process+0x4c>)
	index_uint_t macroResultMacroPendingListTail = 0;
    6568:	4627      	mov	r7, r4
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    656a:	f8b6 2318 	ldrh.w	r2, [r6, #792]	; 0x318
    656e:	b2a3      	uxth	r3, r4
    6570:	429a      	cmp	r2, r3
    6572:	d805      	bhi.n	6580 <Result_process+0x20>
			break;
		}
	}

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingList.size = macroResultMacroPendingListTail;
    6574:	f8a6 7318 	strh.w	r7, [r6, #792]	; 0x318

	// Disable periodic interrupts if we have delayed capabilities
	Periodic_disable();
}
    6578:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	Periodic_disable();
    657c:	f7fc b9d2 	b.w	2924 <Periodic_disable>
    6580:	b2a5      	uxth	r5, r4
		switch ( Macro_evalResultMacro( macroResultMacroPendingList.data[ macro ] ) )
    6582:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
    6586:	e895 0003 	ldmia.w	r5, {r0, r1}
    658a:	f7ff ff2d 	bl	63e8 <Macro_evalResultMacro>
    658e:	2801      	cmp	r0, #1
    6590:	d00a      	beq.n	65a8 <Result_process+0x48>
			memcpy( &macroResultMacroPendingList.data[ macroResultMacroPendingListTail++ ],
    6592:	eb06 00c7 	add.w	r0, r6, r7, lsl #3
    6596:	2208      	movs	r2, #8
    6598:	4629      	mov	r1, r5
    659a:	f107 0801 	add.w	r8, r7, #1
    659e:	f7fc f857 	bl	2650 <memcpy>
    65a2:	fa1f f888 	uxth.w	r8, r8
    65a6:	4647      	mov	r7, r8
    65a8:	3401      	adds	r4, #1
    65aa:	e7de      	b.n	656a <Result_process+0xa>
    65ac:	1fffa3f4 	.word	0x1fffa3f4

000065b0 <Trigger_showTriggerMacroVote>:
void Trigger_showTriggerMacroVote( TriggerMacroVote vote )
{
	const char *result = "";

	// Static voting
	switch ( vote )
    65b0:	2808      	cmp	r0, #8
{
    65b2:	b510      	push	{r4, lr}
    65b4:	4604      	mov	r4, r0
	switch ( vote )
    65b6:	d01e      	beq.n	65f6 <Trigger_showTriggerMacroVote+0x46>
    65b8:	d80c      	bhi.n	65d4 <Trigger_showTriggerMacroVote+0x24>
    65ba:	b1d0      	cbz	r0, 65f2 <Trigger_showTriggerMacroVote+0x42>
	case TriggerMacroVote_PassRelease:
		result = "V:PR";
		break;

	default:
		print("V:");
    65bc:	480f      	ldr	r0, [pc, #60]	; (65fc <Trigger_showTriggerMacroVote+0x4c>)
    65be:	f004 ff1f 	bl	b400 <_print>
		if ( vote & TriggerMacroVote_Fail )
    65c2:	07e1      	lsls	r1, r4, #31
    65c4:	d502      	bpl.n	65cc <Trigger_showTriggerMacroVote+0x1c>
		{
			print("F");
    65c6:	480e      	ldr	r0, [pc, #56]	; (6600 <Trigger_showTriggerMacroVote+0x50>)
    65c8:	f004 ff1a 	bl	b400 <_print>
		}
		if ( vote & TriggerMacroVote_DoNothingRelease )
    65cc:	0762      	lsls	r2, r4, #29
    65ce:	d50c      	bpl.n	65ea <Trigger_showTriggerMacroVote+0x3a>
		{
			print("NR");
    65d0:	480c      	ldr	r0, [pc, #48]	; (6604 <Trigger_showTriggerMacroVote+0x54>)
    65d2:	e006      	b.n	65e2 <Trigger_showTriggerMacroVote+0x32>
	switch ( vote )
    65d4:	2810      	cmp	r0, #16
    65d6:	d003      	beq.n	65e0 <Trigger_showTriggerMacroVote+0x30>
    65d8:	2818      	cmp	r0, #24
    65da:	d1ef      	bne.n	65bc <Trigger_showTriggerMacroVote+0xc>
		result = "V:PR";
    65dc:	480a      	ldr	r0, [pc, #40]	; (6608 <Trigger_showTriggerMacroVote+0x58>)
		break;
    65de:	e000      	b.n	65e2 <Trigger_showTriggerMacroVote+0x32>
		result = "V:R";
    65e0:	480a      	ldr	r0, [pc, #40]	; (660c <Trigger_showTriggerMacroVote+0x5c>)
		}
		return;
	}

	print( result );
}
    65e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( result );
    65e6:	f004 bf0b 	b.w	b400 <_print>
		else if ( vote & TriggerMacroVote_DoNothing )
    65ea:	07a3      	lsls	r3, r4, #30
    65ec:	d505      	bpl.n	65fa <Trigger_showTriggerMacroVote+0x4a>
			print("N");
    65ee:	4808      	ldr	r0, [pc, #32]	; (6610 <Trigger_showTriggerMacroVote+0x60>)
    65f0:	e7f7      	b.n	65e2 <Trigger_showTriggerMacroVote+0x32>
		result = "V:I";
    65f2:	4808      	ldr	r0, [pc, #32]	; (6614 <Trigger_showTriggerMacroVote+0x64>)
    65f4:	e7f5      	b.n	65e2 <Trigger_showTriggerMacroVote+0x32>
		result = "V:P";
    65f6:	4808      	ldr	r0, [pc, #32]	; (6618 <Trigger_showTriggerMacroVote+0x68>)
    65f8:	e7f3      	b.n	65e2 <Trigger_showTriggerMacroVote+0x32>
}
    65fa:	bd10      	pop	{r4, pc}
    65fc:	0000f3a1 	.word	0x0000f3a1
    6600:	0000f3a4 	.word	0x0000f3a4
    6604:	0000f3a6 	.word	0x0000f3a6
    6608:	0000f39c 	.word	0x0000f39c
    660c:	0000f394 	.word	0x0000f394
    6610:	0000f3a9 	.word	0x0000f3a9
    6614:	0000f390 	.word	0x0000f390
    6618:	0000f398 	.word	0x0000f398

0000661c <Macro_isLongResultMacro>:

// -- General --

// Determine if long ResultMacro (more than 1 seqence element)
uint8_t Macro_isLongResultMacro( const ResultMacro *macro )
{
    661c:	b570      	push	{r4, r5, r6, lr}
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    661e:	6804      	ldr	r4, [r0, #0]
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    6620:	4e08      	ldr	r6, [pc, #32]	; (6644 <Macro_isLongResultMacro+0x28>)
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    6622:	7825      	ldrb	r5, [r4, #0]
    6624:	2200      	movs	r2, #0
	var_uint_t position = 1;
    6626:	2301      	movs	r3, #1
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    6628:	b2d1      	uxtb	r1, r2
    662a:	428d      	cmp	r5, r1
    662c:	5ce0      	ldrb	r0, [r4, r3]
    662e:	d800      	bhi.n	6632 <Macro_isLongResultMacro+0x16>
	return macro->guide[ position ];
}
    6630:	bd70      	pop	{r4, r5, r6, pc}
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    6632:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
    6636:	3201      	adds	r2, #1
    6638:	7901      	ldrb	r1, [r0, #4]
    663a:	3101      	adds	r1, #1
    663c:	440b      	add	r3, r1
    663e:	b2db      	uxtb	r3, r3
    6640:	e7f2      	b.n	6628 <Macro_isLongResultMacro+0xc>
    6642:	bf00      	nop
    6644:	0000cff0 	.word	0x0000cff0

00006648 <Trigger_isLongTriggerMacro>:
uint8_t Trigger_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    6648:	6802      	ldr	r2, [r0, #0]
    664a:	7813      	ldrb	r3, [r2, #0]
    664c:	2103      	movs	r1, #3
    664e:	fb01 2303 	mla	r3, r1, r3, r2
}
    6652:	7858      	ldrb	r0, [r3, #1]
    6654:	4770      	bx	lr
    6656:	0000      	movs	r0, r0

00006658 <Trigger_evalShortTriggerMacroVote>:


// Votes on the given key vs. guide, short macros
TriggerMacroVote Trigger_evalShortTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide )
{
    6658:	b508      	push	{r3, lr}
	// Depending on key type
	switch ( guide->type )
    665a:	780b      	ldrb	r3, [r1, #0]
    665c:	2b0d      	cmp	r3, #13
    665e:	d825      	bhi.n	66ac <Trigger_evalShortTriggerMacroVote+0x54>
    6660:	e8df f003 	tbb	[pc, r3]
    6664:	24242407 	.word	0x24242407
    6668:	24241e19 	.word	0x24241e19
    666c:	24242024 	.word	0x24242024
    6670:	2224      	.short	0x2224
	{
	// Normal State Type
	case TriggerType_Switch1:
		// For short TriggerMacros completely ignore incorrect keys
		if ( guide->scanCode == event->index )
    6672:	788a      	ldrb	r2, [r1, #2]
    6674:	7883      	ldrb	r3, [r0, #2]
    6676:	429a      	cmp	r2, r3
    6678:	d11a      	bne.n	66b0 <Trigger_evalShortTriggerMacroVote+0x58>
		{
			switch ( event->state )
    667a:	7843      	ldrb	r3, [r0, #1]
    667c:	2b02      	cmp	r3, #2
    667e:	d006      	beq.n	668e <Trigger_evalShortTriggerMacroVote+0x36>
    6680:	2b03      	cmp	r3, #3
    6682:	d006      	beq.n	6692 <Trigger_evalShortTriggerMacroVote+0x3a>
    6684:	2b01      	cmp	r3, #1
			case ScheduleType_R:
				return TriggerMacroVote_Release;

			// Invalid state, fail
			default:
				return TriggerMacroVote_Fail;
    6686:	bf0c      	ite	eq
    6688:	2008      	moveq	r0, #8
    668a:	2001      	movne	r0, #1
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
}
    668c:	bd08      	pop	{r3, pc}
				return TriggerMacroVote_PassRelease;
    668e:	2018      	movs	r0, #24
    6690:	e7fc      	b.n	668c <Trigger_evalShortTriggerMacroVote+0x34>
				return TriggerMacroVote_Release;
    6692:	2010      	movs	r0, #16
    6694:	e7fa      	b.n	668c <Trigger_evalShortTriggerMacroVote+0x34>
		erro_print("LED State Type - Not implemented...");
    6696:	4807      	ldr	r0, [pc, #28]	; (66b4 <Trigger_evalShortTriggerMacroVote+0x5c>)
		erro_print("Animation State Type - Not implement...");
    6698:	f004 feb2 	bl	b400 <_print>
	return TriggerMacroVote_Invalid;
    669c:	2000      	movs	r0, #0
		break;
    669e:	e7f5      	b.n	668c <Trigger_evalShortTriggerMacroVote+0x34>
		erro_print("Analog State Type - Not implemented...");
    66a0:	4805      	ldr	r0, [pc, #20]	; (66b8 <Trigger_evalShortTriggerMacroVote+0x60>)
    66a2:	e7f9      	b.n	6698 <Trigger_evalShortTriggerMacroVote+0x40>
		erro_print("Layer State Type - Not implemented...");
    66a4:	4805      	ldr	r0, [pc, #20]	; (66bc <Trigger_evalShortTriggerMacroVote+0x64>)
    66a6:	e7f7      	b.n	6698 <Trigger_evalShortTriggerMacroVote+0x40>
		erro_print("Animation State Type - Not implement...");
    66a8:	4805      	ldr	r0, [pc, #20]	; (66c0 <Trigger_evalShortTriggerMacroVote+0x68>)
    66aa:	e7f5      	b.n	6698 <Trigger_evalShortTriggerMacroVote+0x40>
		erro_print("Invalid State Type. This is a bug.");
    66ac:	4805      	ldr	r0, [pc, #20]	; (66c4 <Trigger_evalShortTriggerMacroVote+0x6c>)
    66ae:	e7f3      	b.n	6698 <Trigger_evalShortTriggerMacroVote+0x40>
		return TriggerMacroVote_DoNothing;
    66b0:	2002      	movs	r0, #2
    66b2:	e7eb      	b.n	668c <Trigger_evalShortTriggerMacroVote+0x34>
    66b4:	0000f261 	.word	0x0000f261
    66b8:	0000f29c 	.word	0x0000f29c
    66bc:	0000f2da 	.word	0x0000f2da
    66c0:	0000f317 	.word	0x0000f317
    66c4:	0000f356 	.word	0x0000f356

000066c8 <Trigger_evalLongTriggerMacroVote>:


// Votes on the given key vs. guide, long macros
// A long macro is defined as a guide with more than 1 combo
TriggerMacroVote Trigger_evalLongTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide )
{
    66c8:	b508      	push	{r3, lr}
	// Depending on key type
	switch ( guide->type )
    66ca:	780b      	ldrb	r3, [r1, #0]
    66cc:	2b0d      	cmp	r3, #13
    66ce:	d82a      	bhi.n	6726 <Trigger_evalLongTriggerMacroVote+0x5e>
    66d0:	e8df f003 	tbb	[pc, r3]
    66d4:	29292907 	.word	0x29292907
    66d8:	2929231e 	.word	0x2929231e
    66dc:	29292529 	.word	0x29292529
    66e0:	2729      	.short	0x2729
	{
	// Normal State Type
	case TriggerType_Switch1:
		// Depending on the state of the buffered key, make voting decision
		// Incorrect key
		if ( guide->scanCode != event->index )
    66e2:	7889      	ldrb	r1, [r1, #2]
    66e4:	7882      	ldrb	r2, [r0, #2]
    66e6:	7843      	ldrb	r3, [r0, #1]
    66e8:	4291      	cmp	r1, r2
    66ea:	d007      	beq.n	66fc <Trigger_evalLongTriggerMacroVote+0x34>
		{
			switch ( event->state )
    66ec:	2b02      	cmp	r3, #2
    66ee:	d01c      	beq.n	672a <Trigger_evalLongTriggerMacroVote+0x62>
    66f0:	2b03      	cmp	r3, #3
				return TriggerMacroVote_Fail;
    66f2:	bf08      	it	eq
    66f4:	2006      	moveq	r0, #6
    66f6:	bf18      	it	ne
    66f8:	2001      	movne	r0, #1
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
}
    66fa:	bd08      	pop	{r3, pc}
			switch ( event->state )
    66fc:	2b02      	cmp	r3, #2
    66fe:	d016      	beq.n	672e <Trigger_evalLongTriggerMacroVote+0x66>
    6700:	2b03      	cmp	r3, #3
    6702:	d003      	beq.n	670c <Trigger_evalLongTriggerMacroVote+0x44>
    6704:	2b01      	cmp	r3, #1
				return TriggerMacroVote_Fail;
    6706:	bf08      	it	eq
    6708:	2008      	moveq	r0, #8
    670a:	e7f4      	b.n	66f6 <Trigger_evalLongTriggerMacroVote+0x2e>
				return TriggerMacroVote_Release;
    670c:	2010      	movs	r0, #16
    670e:	e7f4      	b.n	66fa <Trigger_evalLongTriggerMacroVote+0x32>
		erro_print("LED State Type - Not implemented...");
    6710:	4808      	ldr	r0, [pc, #32]	; (6734 <Trigger_evalLongTriggerMacroVote+0x6c>)
		erro_print("Invalid State Type. This is a bug.");
    6712:	f004 fe75 	bl	b400 <_print>
	return TriggerMacroVote_Invalid;
    6716:	2000      	movs	r0, #0
		break;
    6718:	e7ef      	b.n	66fa <Trigger_evalLongTriggerMacroVote+0x32>
		erro_print("Analog State Type - Not implemented...");
    671a:	4807      	ldr	r0, [pc, #28]	; (6738 <Trigger_evalLongTriggerMacroVote+0x70>)
    671c:	e7f9      	b.n	6712 <Trigger_evalLongTriggerMacroVote+0x4a>
		erro_print("Layer State Type - Not implemented...");
    671e:	4807      	ldr	r0, [pc, #28]	; (673c <Trigger_evalLongTriggerMacroVote+0x74>)
    6720:	e7f7      	b.n	6712 <Trigger_evalLongTriggerMacroVote+0x4a>
		erro_print("Animation State Type - Not implement...");
    6722:	4807      	ldr	r0, [pc, #28]	; (6740 <Trigger_evalLongTriggerMacroVote+0x78>)
    6724:	e7f5      	b.n	6712 <Trigger_evalLongTriggerMacroVote+0x4a>
		erro_print("Invalid State Type. This is a bug.");
    6726:	4807      	ldr	r0, [pc, #28]	; (6744 <Trigger_evalLongTriggerMacroVote+0x7c>)
    6728:	e7f3      	b.n	6712 <Trigger_evalLongTriggerMacroVote+0x4a>
				return TriggerMacroVote_DoNothing;
    672a:	4618      	mov	r0, r3
    672c:	e7e5      	b.n	66fa <Trigger_evalLongTriggerMacroVote+0x32>
				return TriggerMacroVote_PassRelease;
    672e:	2018      	movs	r0, #24
    6730:	e7e3      	b.n	66fa <Trigger_evalLongTriggerMacroVote+0x32>
    6732:	bf00      	nop
    6734:	0000f261 	.word	0x0000f261
    6738:	0000f29c 	.word	0x0000f29c
    673c:	0000f2da 	.word	0x0000f2da
    6740:	0000f317 	.word	0x0000f317
    6744:	0000f356 	.word	0x0000f356

00006748 <Trigger_evalTriggerMacro>:


// Evaluate/Update TriggerMacro
TriggerMacroEval Trigger_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    6748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    674c:	4b5e      	ldr	r3, [pc, #376]	; (68c8 <Trigger_evalTriggerMacro+0x180>)
    674e:	495f      	ldr	r1, [pc, #380]	; (68cc <Trigger_evalTriggerMacro+0x184>)
    6750:	eb03 0240 	add.w	r2, r3, r0, lsl #1
{
    6754:	4605      	mov	r5, r0
    6756:	f851 8030 	ldr.w	r8, [r1, r0, lsl #3]
	if ( record->state == TriggerMacro_Release )
    675a:	7850      	ldrb	r0, [r2, #1]
{
    675c:	b085      	sub	sp, #20
	if ( record->state == TriggerMacro_Release )
    675e:	2801      	cmp	r0, #1
    6760:	9102      	str	r1, [sp, #8]
    6762:	d10b      	bne.n	677c <Trigger_evalTriggerMacro+0x34>
	{
		record->state = TriggerMacro_Waiting;
    6764:	2102      	movs	r1, #2
    6766:	7051      	strb	r1, [r2, #1]
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    6768:	f813 1015 	ldrb.w	r1, [r3, r5, lsl #1]
    676c:	f818 2001 	ldrb.w	r2, [r8, r1]
    6770:	3101      	adds	r1, #1
    6772:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    6776:	440a      	add	r2, r1
    6778:	f803 2015 	strb.w	r2, [r3, r5, lsl #1]
	}

	// Current Macro position
	var_uint_t pos = record->pos;
    677c:	f813 9015 	ldrb.w	r9, [r3, r5, lsl #1]

	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    6780:	f818 3009 	ldrb.w	r3, [r8, r9]
    6784:	eb03 0343 	add.w	r3, r3, r3, lsl #1

	// If no combo items are left, remove the TriggerMacro from the pending list
	if ( comboLength == 0 )
    6788:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
    678c:	9303      	str	r3, [sp, #12]
    678e:	d103      	bne.n	6798 <Trigger_evalTriggerMacro+0x50>
	{
		return TriggerMacroEval_Remove;
    6790:	2003      	movs	r0, #3
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
		return TriggerMacroEval_Remove;

	return TriggerMacroEval_DoNothing;
}
    6792:	b005      	add	sp, #20
    6794:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    6798:	9b02      	ldr	r3, [sp, #8]
    679a:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
	uint8_t longMacro = Trigger_isLongTriggerMacro( macro );
    679e:	4618      	mov	r0, r3
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    67a0:	9300      	str	r3, [sp, #0]
	uint8_t longMacro = Trigger_isLongTriggerMacro( macro );
    67a2:	f7ff ff51 	bl	6648 <Trigger_isLongTriggerMacro>
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    67a6:	f109 0301 	add.w	r3, r9, #1
	uint8_t longMacro = Trigger_isLongTriggerMacro( macro );
    67aa:	4607      	mov	r7, r0
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    67ac:	fa5f fa83 	uxtb.w	sl, r3
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    67b0:	2400      	movs	r4, #0
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    67b2:	9b03      	ldr	r3, [sp, #12]
    67b4:	eb09 0603 	add.w	r6, r9, r3
    67b8:	4556      	cmp	r6, sl
    67ba:	da31      	bge.n	6820 <Trigger_evalTriggerMacro+0xd8>
	if ( longMacro && overallVote & TriggerMacroVote_DoNothingRelease && pos == 0 )
    67bc:	b137      	cbz	r7, 67cc <Trigger_evalTriggerMacro+0x84>
    67be:	0760      	lsls	r0, r4, #29
    67c0:	d504      	bpl.n	67cc <Trigger_evalTriggerMacro+0x84>
    67c2:	f1b9 0f00 	cmp.w	r9, #0
    67c6:	d101      	bne.n	67cc <Trigger_evalTriggerMacro+0x84>
		overallVote |= TriggerMacroVote_Fail;
    67c8:	f044 0401 	orr.w	r4, r4, #1
	switch ( voteDebugMode )
    67cc:	4b40      	ldr	r3, [pc, #256]	; (68d0 <Trigger_evalTriggerMacro+0x188>)
    67ce:	781b      	ldrb	r3, [r3, #0]
    67d0:	2b01      	cmp	r3, #1
    67d2:	d105      	bne.n	67e0 <Trigger_evalTriggerMacro+0x98>
		Trigger_showTriggerMacroVote( overallVote );
    67d4:	4620      	mov	r0, r4
    67d6:	f7ff feeb 	bl	65b0 <Trigger_showTriggerMacroVote>
		print( NL );
    67da:	483e      	ldr	r0, [pc, #248]	; (68d4 <Trigger_evalTriggerMacro+0x18c>)
    67dc:	f004 fe10 	bl	b400 <_print>
	if ( overallVote & TriggerMacroVote_Fail )
    67e0:	07e1      	lsls	r1, r4, #31
    67e2:	d4d5      	bmi.n	6790 <Trigger_evalTriggerMacro+0x48>
	else if ( overallVote & TriggerMacroVote_DoNothing && longMacro )
    67e4:	07a2      	lsls	r2, r4, #30
    67e6:	d500      	bpl.n	67ea <Trigger_evalTriggerMacro+0xa2>
    67e8:	b9c7      	cbnz	r7, 681c <Trigger_evalTriggerMacro+0xd4>
	else if ( overallVote & TriggerMacroVote_Release && record->state == TriggerMacro_Press )
    67ea:	f014 0110 	ands.w	r1, r4, #16
    67ee:	d044      	beq.n	687a <Trigger_evalTriggerMacro+0x132>
    67f0:	4b35      	ldr	r3, [pc, #212]	; (68c8 <Trigger_evalTriggerMacro+0x180>)
    67f2:	eb03 0245 	add.w	r2, r3, r5, lsl #1
    67f6:	7850      	ldrb	r0, [r2, #1]
    67f8:	2800      	cmp	r0, #0
    67fa:	d13e      	bne.n	687a <Trigger_evalTriggerMacro+0x132>
		record->state = TriggerMacro_Release;
    67fc:	2101      	movs	r1, #1
    67fe:	7051      	strb	r1, [r2, #1]
		if ( macro->guide[ record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1 ] == 0 )
    6800:	f813 3015 	ldrb.w	r3, [r3, r5, lsl #1]
    6804:	f818 1003 	ldrb.w	r1, [r8, r3]
    6808:	2203      	movs	r2, #3
    680a:	3301      	adds	r3, #1
    680c:	fb12 3301 	smlabb	r3, r2, r1, r3
    6810:	f818 3003 	ldrb.w	r3, [r8, r3]
    6814:	2b00      	cmp	r3, #0
    6816:	d04b      	beq.n	68b0 <Trigger_evalTriggerMacro+0x168>
	if ( !longMacro )
    6818:	2f00      	cmp	r7, #0
    681a:	d0b9      	beq.n	6790 <Trigger_evalTriggerMacro+0x48>
	return TriggerMacroEval_DoNothing;
    681c:	2000      	movs	r0, #0
    681e:	e7b8      	b.n	6792 <Trigger_evalTriggerMacro+0x4a>
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    6820:	eb08 030a 	add.w	r3, r8, sl
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    6824:	f04f 0b00 	mov.w	fp, #0
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    6828:	9301      	str	r3, [sp, #4]
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
    682a:	465e      	mov	r6, fp
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    682c:	4b2a      	ldr	r3, [pc, #168]	; (68d8 <Trigger_evalTriggerMacro+0x190>)
    682e:	7819      	ldrb	r1, [r3, #0]
    6830:	fa5f f08b 	uxtb.w	r0, fp
    6834:	4281      	cmp	r1, r0
    6836:	d801      	bhi.n	683c <Trigger_evalTriggerMacro+0xf4>
		if ( !longMacro && vote < TriggerMacroVote_Pass )
    6838:	b98f      	cbnz	r7, 685e <Trigger_evalTriggerMacro+0x116>
    683a:	e01b      	b.n	6874 <Trigger_evalTriggerMacro+0x12c>
			TriggerEvent *triggerInfo = &macroTriggerEventBuffer[ key ];
    683c:	4b27      	ldr	r3, [pc, #156]	; (68dc <Trigger_evalTriggerMacro+0x194>)
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide )
    683e:	9901      	ldr	r1, [sp, #4]
			TriggerEvent *triggerInfo = &macroTriggerEventBuffer[ key ];
    6840:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6844:	4418      	add	r0, r3
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide );
    6846:	b187      	cbz	r7, 686a <Trigger_evalTriggerMacro+0x122>
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide )
    6848:	f7ff ff3e 	bl	66c8 <Trigger_evalLongTriggerMacroVote>
			vote |= longMacro
    684c:	4306      	orrs	r6, r0
    684e:	b2f6      	uxtb	r6, r6
			if ( vote >= TriggerMacroVote_Pass )
    6850:	2e07      	cmp	r6, #7
    6852:	f10b 0b01 	add.w	fp, fp, #1
    6856:	d9e9      	bls.n	682c <Trigger_evalTriggerMacro+0xe4>
				vote &= TriggerMacroVote_Release | TriggerMacroVote_PassRelease | TriggerMacroVote_Pass;
    6858:	f006 0618 	and.w	r6, r6, #24
		if ( !longMacro && vote < TriggerMacroVote_Pass )
    685c:	b147      	cbz	r7, 6870 <Trigger_evalTriggerMacro+0x128>
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    685e:	f10a 0303 	add.w	r3, sl, #3
		overallVote |= vote;
    6862:	4334      	orrs	r4, r6
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    6864:	fa5f fa83 	uxtb.w	sl, r3
    6868:	e7a3      	b.n	67b2 <Trigger_evalTriggerMacro+0x6a>
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide );
    686a:	f7ff fef5 	bl	6658 <Trigger_evalShortTriggerMacroVote>
    686e:	e7ed      	b.n	684c <Trigger_evalTriggerMacro+0x104>
		if ( !longMacro && vote < TriggerMacroVote_Pass )
    6870:	2e07      	cmp	r6, #7
    6872:	d8f4      	bhi.n	685e <Trigger_evalTriggerMacro+0x116>
			vote |= TriggerMacroVote_Fail;
    6874:	f046 0601 	orr.w	r6, r6, #1
    6878:	e7f1      	b.n	685e <Trigger_evalTriggerMacro+0x116>
	else if ( overallVote & TriggerMacroVote_Pass
    687a:	0723      	lsls	r3, r4, #28
    687c:	d521      	bpl.n	68c2 <Trigger_evalTriggerMacro+0x17a>
		&& ( record->state == TriggerMacro_Waiting || record->state == TriggerMacro_Press ) )
    687e:	4b12      	ldr	r3, [pc, #72]	; (68c8 <Trigger_evalTriggerMacro+0x180>)
    6880:	eb03 0345 	add.w	r3, r3, r5, lsl #1
    6884:	785a      	ldrb	r2, [r3, #1]
    6886:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
    688a:	d11a      	bne.n	68c2 <Trigger_evalTriggerMacro+0x17a>
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    688c:	44b0      	add	r8, r6
		record->state = TriggerMacro_Press;
    688e:	705a      	strb	r2, [r3, #1]
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    6890:	f898 3001 	ldrb.w	r3, [r8, #1]
    6894:	2b00      	cmp	r3, #0
    6896:	d1bf      	bne.n	6818 <Trigger_evalTriggerMacro+0xd0>
			if ( Macro_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    6898:	9b02      	ldr	r3, [sp, #8]
    689a:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    689e:	4b10      	ldr	r3, [pc, #64]	; (68e0 <Trigger_evalTriggerMacro+0x198>)
    68a0:	7928      	ldrb	r0, [r5, #4]
    68a2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    68a6:	f7ff feb9 	bl	661c <Macro_isLongResultMacro>
    68aa:	b118      	cbz	r0, 68b4 <Trigger_evalTriggerMacro+0x16c>
				if ( overallVote == TriggerMacroVote_Pass )
    68ac:	2c08      	cmp	r4, #8
    68ae:	d1b3      	bne.n	6818 <Trigger_evalTriggerMacro+0xd0>
			return TriggerMacroEval_DoResultAndRemove;
    68b0:	2002      	movs	r0, #2
    68b2:	e76e      	b.n	6792 <Trigger_evalTriggerMacro+0x4a>
				if ( Trigger_isLongTriggerMacro( macro ) )
    68b4:	9800      	ldr	r0, [sp, #0]
    68b6:	f7ff fec7 	bl	6648 <Trigger_isLongTriggerMacro>
    68ba:	2800      	cmp	r0, #0
    68bc:	d1f8      	bne.n	68b0 <Trigger_evalTriggerMacro+0x168>
					return TriggerMacroEval_DoResult;
    68be:	2001      	movs	r0, #1
    68c0:	e767      	b.n	6792 <Trigger_evalTriggerMacro+0x4a>
	else if ( overallVote & TriggerMacroVote_Release )
    68c2:	2900      	cmp	r1, #0
    68c4:	d0a8      	beq.n	6818 <Trigger_evalTriggerMacro+0xd0>
    68c6:	e7f3      	b.n	68b0 <Trigger_evalTriggerMacro+0x168>
    68c8:	1fffa2aa 	.word	0x1fffa2aa
    68cc:	0000d4f0 	.word	0x0000d4f0
    68d0:	1fff9f04 	.word	0x1fff9f04
    68d4:	00010d99 	.word	0x00010d99
    68d8:	1fff9f01 	.word	0x1fff9f01
    68dc:	1fffa030 	.word	0x1fffa030
    68e0:	0000d364 	.word	0x0000d364

000068e4 <Trigger_updateTriggerMacroPendingList>:


// Update pending trigger list
void Trigger_updateTriggerMacroPendingList()
{
    68e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			//  triggerList needs to be added
			var_uint_t pending = 0;
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
			{
				// Stop scanning if the trigger macro index is found in the pending list
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    68e8:	f8df 809c 	ldr.w	r8, [pc, #156]	; 6988 <Trigger_updateTriggerMacroPendingList+0xa4>
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    68ec:	2400      	movs	r4, #0
    68ee:	4b24      	ldr	r3, [pc, #144]	; (6980 <Trigger_updateTriggerMacroPendingList+0x9c>)
    68f0:	781b      	ldrb	r3, [r3, #0]
    68f2:	b2e0      	uxtb	r0, r4
    68f4:	4283      	cmp	r3, r0
    68f6:	d802      	bhi.n	68fe <Trigger_updateTriggerMacroPendingList+0x1a>
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
			}
		}
	}
}
    68f8:	b003      	add	sp, #12
    68fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ( macroTriggerEventBuffer[ key ].state == 0x00 && macroTriggerEventBuffer[ key ].state != 0x01 )
    68fe:	4b21      	ldr	r3, [pc, #132]	; (6984 <Trigger_updateTriggerMacroPendingList+0xa0>)
    6900:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6904:	4418      	add	r0, r3
    6906:	7841      	ldrb	r1, [r0, #1]
    6908:	b1c9      	cbz	r1, 693e <Trigger_updateTriggerMacroPendingList+0x5a>
		nat_ptr_t *triggerList = Macro_layerLookup( &macroTriggerEventBuffer[ key ], latch_expire );
    690a:	1ecb      	subs	r3, r1, #3
    690c:	4259      	negs	r1, r3
    690e:	4159      	adcs	r1, r3
    6910:	f7ff f96e 	bl	5bf0 <Macro_layerLookup>
		if ( triggerList == 0 )
    6914:	b198      	cbz	r0, 693e <Trigger_updateTriggerMacroPendingList+0x5a>
		nat_ptr_t triggerListSize = triggerList[0];
    6916:	6801      	ldr	r1, [r0, #0]
    6918:	f8df c070 	ldr.w	ip, [pc, #112]	; 698c <Trigger_updateTriggerMacroPendingList+0xa8>
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
    691c:	f8df e070 	ldr.w	lr, [pc, #112]	; 6990 <Trigger_updateTriggerMacroPendingList+0xac>
    6920:	f8bc 3000 	ldrh.w	r3, [ip]
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    6924:	2201      	movs	r2, #1
    6926:	2500      	movs	r5, #0
    6928:	4411      	add	r1, r2
    692a:	9101      	str	r1, [sp, #4]
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
    692c:	46a9      	mov	r9, r5
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
    692e:	f04f 0a02 	mov.w	sl, #2
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    6932:	9901      	ldr	r1, [sp, #4]
    6934:	428a      	cmp	r2, r1
    6936:	d304      	bcc.n	6942 <Trigger_updateTriggerMacroPendingList+0x5e>
    6938:	b10d      	cbz	r5, 693e <Trigger_updateTriggerMacroPendingList+0x5a>
    693a:	f8ac 3000 	strh.w	r3, [ip]
    693e:	3401      	adds	r4, #1
    6940:	e7d5      	b.n	68ee <Trigger_updateTriggerMacroPendingList+0xa>
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    6942:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    6946:	2700      	movs	r7, #0
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    6948:	fa1f fb81 	uxth.w	fp, r1
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    694c:	b2fe      	uxtb	r6, r7
    694e:	429e      	cmp	r6, r3
    6950:	d30c      	bcc.n	696c <Trigger_updateTriggerMacroPendingList+0x88>
			if ( pending == macroTriggerMacroPendingListSize )
    6952:	d111      	bne.n	6978 <Trigger_updateTriggerMacroPendingList+0x94>
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    6954:	f828 1016 	strh.w	r1, [r8, r6, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
    6958:	f80e 9011 	strb.w	r9, [lr, r1, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
    695c:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    6960:	3301      	adds	r3, #1
    6962:	b29b      	uxth	r3, r3
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
    6964:	f881 a001 	strb.w	sl, [r1, #1]
    6968:	2501      	movs	r5, #1
    696a:	e005      	b.n	6978 <Trigger_updateTriggerMacroPendingList+0x94>
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    696c:	f838 6016 	ldrh.w	r6, [r8, r6, lsl #1]
    6970:	455e      	cmp	r6, fp
    6972:	f107 0701 	add.w	r7, r7, #1
    6976:	d1e9      	bne.n	694c <Trigger_updateTriggerMacroPendingList+0x68>
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    6978:	3201      	adds	r2, #1
    697a:	b2d2      	uxtb	r2, r2
    697c:	e7d9      	b.n	6932 <Trigger_updateTriggerMacroPendingList+0x4e>
    697e:	bf00      	nop
    6980:	1fff9f01 	.word	0x1fff9f01
    6984:	1fffa030 	.word	0x1fffa030
    6988:	1fff9310 	.word	0x1fff9310
    698c:	1fff93de 	.word	0x1fff93de
    6990:	1fffa2aa 	.word	0x1fffa2aa

00006994 <Trigger_setup>:
	return 0;
}


void Trigger_setup()
{
    6994:	2300      	movs	r3, #0
	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		TriggerMacroRecordList[ macro ].pos   = 0;
    6996:	4a05      	ldr	r2, [pc, #20]	; (69ac <Trigger_setup+0x18>)
{
    6998:	b510      	push	{r4, lr}
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    699a:	2002      	movs	r0, #2
		TriggerMacroRecordList[ macro ].pos   = 0;
    699c:	461c      	mov	r4, r3
    699e:	1899      	adds	r1, r3, r2
    69a0:	549c      	strb	r4, [r3, r2]
    69a2:	3302      	adds	r3, #2
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    69a4:	2bce      	cmp	r3, #206	; 0xce
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    69a6:	7048      	strb	r0, [r1, #1]
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    69a8:	d1f9      	bne.n	699e <Trigger_setup+0xa>
	}
}
    69aa:	bd10      	pop	{r4, pc}
    69ac:	1fffa2aa 	.word	0x1fffa2aa

000069b0 <Trigger_process>:


void Trigger_process()
{
    69b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Update pending trigger list, before processing TriggerMacros
	Trigger_updateTriggerMacroPendingList();
    69b4:	f7ff ff96 	bl	68e4 <Trigger_updateTriggerMacroPendingList>
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Iterate through the pending TriggerMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    69b8:	2700      	movs	r7, #0
    69ba:	f8df 8064 	ldr.w	r8, [pc, #100]	; 6a20 <Trigger_process+0x70>
	{
		switch ( Trigger_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
    69be:	4d16      	ldr	r5, [pc, #88]	; (6a18 <Trigger_process+0x68>)
	var_uint_t macroTriggerMacroPendingListTail = 0;
    69c0:	463e      	mov	r6, r7
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    69c2:	f8b8 3000 	ldrh.w	r3, [r8]
    69c6:	b2fc      	uxtb	r4, r7
    69c8:	429c      	cmp	r4, r3
    69ca:	d303      	bcc.n	69d4 <Trigger_process+0x24>
			break;
		}
	}

	// Update the macroTriggerMacroPendingListSize with the tail pointer
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
    69cc:	f8a8 6000 	strh.w	r6, [r8]
}
    69d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		switch ( Trigger_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
    69d4:	f815 0014 	ldrb.w	r0, [r5, r4, lsl #1]
    69d8:	f7ff feb6 	bl	6748 <Trigger_evalTriggerMacro>
    69dc:	2802      	cmp	r0, #2
    69de:	d012      	beq.n	6a06 <Trigger_process+0x56>
    69e0:	2803      	cmp	r0, #3
    69e2:	d00e      	beq.n	6a02 <Trigger_process+0x52>
    69e4:	2801      	cmp	r0, #1
    69e6:	d106      	bne.n	69f6 <Trigger_process+0x46>
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    69e8:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
    69ec:	4b0b      	ldr	r3, [pc, #44]	; (6a1c <Trigger_process+0x6c>)
    69ee:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    69f2:	f7ff fa61 	bl	5eb8 <Macro_appendResultMacroToPendingList>
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = macroTriggerMacroPendingList[ macro ];
    69f6:	1c73      	adds	r3, r6, #1
    69f8:	f835 2014 	ldrh.w	r2, [r5, r4, lsl #1]
    69fc:	f825 2016 	strh.w	r2, [r5, r6, lsl #1]
    6a00:	b2de      	uxtb	r6, r3
    6a02:	3701      	adds	r7, #1
    6a04:	e7dd      	b.n	69c2 <Trigger_process+0x12>
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    6a06:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
    6a0a:	4b04      	ldr	r3, [pc, #16]	; (6a1c <Trigger_process+0x6c>)
    6a0c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    6a10:	f7ff fa52 	bl	5eb8 <Macro_appendResultMacroToPendingList>
    6a14:	e7f5      	b.n	6a02 <Trigger_process+0x52>
    6a16:	bf00      	nop
    6a18:	1fff9310 	.word	0x1fff9310
    6a1c:	0000d4f0 	.word	0x0000d4f0
    6a20:	1fff93de 	.word	0x1fff93de

00006a24 <cliFunc_aniAdd>:
	// Toggle pixel
	Pixel_pixelToggle( elem );
}
void cliFunc_aniAdd( char* args )
{
	print( NL ); // No \r\n by default after the command is entered
    6a24:	4801      	ldr	r0, [pc, #4]	; (6a2c <cliFunc_aniAdd+0x8>)
    6a26:	f004 bceb 	b.w	b400 <_print>
    6a2a:	bf00      	nop
    6a2c:	00010d99 	.word	0x00010d99

00006a30 <cliFunc_aniDel>:
	Pixel_AnimationStack.size++;
	*/
}

void cliFunc_aniDel( char* args )
{
    6a30:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    6a32:	4804      	ldr	r0, [pc, #16]	; (6a44 <cliFunc_aniDel+0x14>)
    6a34:	f004 fce4 	bl	b400 <_print>

	// TODO
	Pixel_AnimationStack.size--;
    6a38:	4a03      	ldr	r2, [pc, #12]	; (6a48 <cliFunc_aniDel+0x18>)
    6a3a:	8813      	ldrh	r3, [r2, #0]
    6a3c:	3b01      	subs	r3, #1
    6a3e:	8013      	strh	r3, [r2, #0]
}
    6a40:	bd08      	pop	{r3, pc}
    6a42:	bf00      	nop
    6a44:	00010d99 	.word	0x00010d99
    6a48:	1fffa710 	.word	0x1fffa710

00006a4c <cliFunc_aniStack>:

void cliFunc_aniStack( char* args )
{
    6a4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	print(NL);
    6a50:	4825      	ldr	r0, [pc, #148]	; (6ae8 <cliFunc_aniStack+0x9c>)
	info_msg("Stack Size: ");
	printInt16( Pixel_AnimationStack.size );
    6a52:	4d26      	ldr	r5, [pc, #152]	; (6aec <cliFunc_aniStack+0xa0>)
	for ( uint8_t pos = 0; pos < Pixel_AnimationStack.size; pos++ )
	{
		print(NL);
    6a54:	f8df 9090 	ldr.w	r9, [pc, #144]	; 6ae8 <cliFunc_aniStack+0x9c>
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
		print(" index(");
    6a58:	4e25      	ldr	r6, [pc, #148]	; (6af0 <cliFunc_aniStack+0xa4>)
		printInt16( elem->index );
		print(") pos(");
    6a5a:	4f26      	ldr	r7, [pc, #152]	; (6af4 <cliFunc_aniStack+0xa8>)
	print(NL);
    6a5c:	f004 fcd0 	bl	b400 <_print>
	info_msg("Stack Size: ");
    6a60:	4825      	ldr	r0, [pc, #148]	; (6af8 <cliFunc_aniStack+0xac>)
    6a62:	f004 fccd 	bl	b400 <_print>
	printInt16( Pixel_AnimationStack.size );
    6a66:	8828      	ldrh	r0, [r5, #0]
    6a68:	f004 fd1a 	bl	b4a0 <printInt16>
	for ( uint8_t pos = 0; pos < Pixel_AnimationStack.size; pos++ )
    6a6c:	2300      	movs	r3, #0
    6a6e:	b2dc      	uxtb	r4, r3
    6a70:	f103 0801 	add.w	r8, r3, #1
    6a74:	882b      	ldrh	r3, [r5, #0]
    6a76:	429c      	cmp	r4, r3
    6a78:	d301      	bcc.n	6a7e <cliFunc_aniStack+0x32>
		printInt8( elem->ffunc );
		print(") pfunc(");
		printInt8( elem->pfunc );
		print(")");
	}
}
    6a7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		print(NL);
    6a7e:	4648      	mov	r0, r9
    6a80:	f004 fcbe 	bl	b400 <_print>
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    6a84:	eb05 0384 	add.w	r3, r5, r4, lsl #2
		print(" index(");
    6a88:	4630      	mov	r0, r6
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    6a8a:	685c      	ldr	r4, [r3, #4]
		print(" index(");
    6a8c:	f004 fcb8 	bl	b400 <_print>
		printInt16( elem->index );
    6a90:	88a0      	ldrh	r0, [r4, #4]
    6a92:	f004 fd05 	bl	b4a0 <printInt16>
		print(") pos(");
    6a96:	4638      	mov	r0, r7
    6a98:	f004 fcb2 	bl	b400 <_print>
		printInt16( elem->pos );
    6a9c:	88e0      	ldrh	r0, [r4, #6]
    6a9e:	f004 fcff 	bl	b4a0 <printInt16>
		print(") loops(");
    6aa2:	4816      	ldr	r0, [pc, #88]	; (6afc <cliFunc_aniStack+0xb0>)
    6aa4:	f004 fcac 	bl	b400 <_print>
		printInt8( elem->loops );
    6aa8:	7a60      	ldrb	r0, [r4, #9]
    6aaa:	f004 fcdb 	bl	b464 <printInt8>
		print(") framedelay(");
    6aae:	4814      	ldr	r0, [pc, #80]	; (6b00 <cliFunc_aniStack+0xb4>)
    6ab0:	f004 fca6 	bl	b400 <_print>
		printInt8( elem->framedelay );
    6ab4:	7aa0      	ldrb	r0, [r4, #10]
    6ab6:	f004 fcd5 	bl	b464 <printInt8>
		print(") frameoption(");
    6aba:	4812      	ldr	r0, [pc, #72]	; (6b04 <cliFunc_aniStack+0xb8>)
    6abc:	f004 fca0 	bl	b400 <_print>
		printInt8( elem->frameoption );
    6ac0:	7ae0      	ldrb	r0, [r4, #11]
    6ac2:	f004 fccf 	bl	b464 <printInt8>
		print(") ffunc(");
    6ac6:	4810      	ldr	r0, [pc, #64]	; (6b08 <cliFunc_aniStack+0xbc>)
    6ac8:	f004 fc9a 	bl	b400 <_print>
		printInt8( elem->ffunc );
    6acc:	7b20      	ldrb	r0, [r4, #12]
    6ace:	f004 fcc9 	bl	b464 <printInt8>
		print(") pfunc(");
    6ad2:	480e      	ldr	r0, [pc, #56]	; (6b0c <cliFunc_aniStack+0xc0>)
    6ad4:	f004 fc94 	bl	b400 <_print>
		printInt8( elem->pfunc );
    6ad8:	7b60      	ldrb	r0, [r4, #13]
    6ada:	f004 fcc3 	bl	b464 <printInt8>
		print(")");
    6ade:	480c      	ldr	r0, [pc, #48]	; (6b10 <cliFunc_aniStack+0xc4>)
    6ae0:	f004 fc8e 	bl	b400 <_print>
    6ae4:	4643      	mov	r3, r8
    6ae6:	e7c2      	b.n	6a6e <cliFunc_aniStack+0x22>
    6ae8:	00010d99 	.word	0x00010d99
    6aec:	1fffa710 	.word	0x1fffa710
    6af0:	0000f943 	.word	0x0000f943
    6af4:	0000f94b 	.word	0x0000f94b
    6af8:	0000f924 	.word	0x0000f924
    6afc:	0000f952 	.word	0x0000f952
    6b00:	0000f95b 	.word	0x0000f95b
    6b04:	0000f969 	.word	0x0000f969
    6b08:	0000f978 	.word	0x0000f978
    6b0c:	0000f981 	.word	0x0000f981
    6b10:	000106cd 	.word	0x000106cd

00006b14 <cliFunc_pixelList>:
{
    6b14:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6b18:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    6b1a:	4840      	ldr	r0, [pc, #256]	; (6c1c <cliFunc_pixelList+0x108>)
    6b1c:	f004 fc70 	bl	b400 <_print>
	char* arg2Ptr = args;
    6b20:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    6b22:	4669      	mov	r1, sp
	char* arg2Ptr = args;
    6b24:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    6b28:	4620      	mov	r0, r4
    6b2a:	f004 f861 	bl	abf0 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    6b2e:	9b00      	ldr	r3, [sp, #0]
    6b30:	781b      	ldrb	r3, [r3, #0]
    6b32:	2b42      	cmp	r3, #66	; 0x42
    6b34:	d001      	beq.n	6b3a <cliFunc_pixelList+0x26>
    6b36:	2b62      	cmp	r3, #98	; 0x62
    6b38:	d122      	bne.n	6b80 <cliFunc_pixelList+0x6c>
		info_msg("Buffer List");
    6b3a:	4839      	ldr	r0, [pc, #228]	; (6c20 <cliFunc_pixelList+0x10c>)
			printHex32( (uint32_t)(uintptr_t)(Pixel_Buffers[ buf ].data) );
    6b3c:	4c39      	ldr	r4, [pc, #228]	; (6c24 <cliFunc_pixelList+0x110>)
		info_msg("Buffer List");
    6b3e:	f004 fc5f 	bl	b400 <_print>
			print( NL "\t" );
    6b42:	4839      	ldr	r0, [pc, #228]	; (6c28 <cliFunc_pixelList+0x114>)
    6b44:	f004 fc5c 	bl	b400 <_print>
			printInt8( buf );
    6b48:	2000      	movs	r0, #0
    6b4a:	f004 fc8b 	bl	b464 <printInt8>
			print(":");
    6b4e:	4837      	ldr	r0, [pc, #220]	; (6c2c <cliFunc_pixelList+0x118>)
    6b50:	f004 fc56 	bl	b400 <_print>
			printHex32( (uint32_t)(uintptr_t)(Pixel_Buffers[ buf ].data) );
    6b54:	2101      	movs	r1, #1
    6b56:	6860      	ldr	r0, [r4, #4]
    6b58:	f004 fd32 	bl	b5c0 <printHex32_op>
			print(":width(");
    6b5c:	4834      	ldr	r0, [pc, #208]	; (6c30 <cliFunc_pixelList+0x11c>)
    6b5e:	f004 fc4f 	bl	b400 <_print>
			printInt8( Pixel_Buffers[ buf ].width );
    6b62:	7860      	ldrb	r0, [r4, #1]
    6b64:	f004 fc7e 	bl	b464 <printInt8>
			print("):size(");
    6b68:	4832      	ldr	r0, [pc, #200]	; (6c34 <cliFunc_pixelList+0x120>)
    6b6a:	f004 fc49 	bl	b400 <_print>
			printInt8( Pixel_Buffers[ buf ].size );
    6b6e:	7820      	ldrb	r0, [r4, #0]
    6b70:	f004 fc78 	bl	b464 <printInt8>
			print(")");
    6b74:	4830      	ldr	r0, [pc, #192]	; (6c38 <cliFunc_pixelList+0x124>)
    6b76:	f004 fc43 	bl	b400 <_print>
}
    6b7a:	b003      	add	sp, #12
    6b7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		info_msg("Pixel List - <num>[<ch1>,...]<width>:...");
    6b80:	482e      	ldr	r0, [pc, #184]	; (6c3c <cliFunc_pixelList+0x128>)
    6b82:	4c2f      	ldr	r4, [pc, #188]	; (6c40 <cliFunc_pixelList+0x12c>)
				print( NL );
    6b84:	4f25      	ldr	r7, [pc, #148]	; (6c1c <cliFunc_pixelList+0x108>)
			print(":");
    6b86:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 6c2c <cliFunc_pixelList+0x118>
		info_msg("Pixel List - <num>[<ch1>,...]<width>:...");
    6b8a:	f004 fc39 	bl	b400 <_print>
    6b8e:	2500      	movs	r5, #0
    6b90:	4626      	mov	r6, r4
    6b92:	fa1f f985 	uxth.w	r9, r5
			if ( pixel % 5 == 0 )
    6b96:	2305      	movs	r3, #5
    6b98:	fbb9 f3f3 	udiv	r3, r9, r3
    6b9c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    6ba0:	eba9 0303 	sub.w	r3, r9, r3
    6ba4:	b29b      	uxth	r3, r3
    6ba6:	b913      	cbnz	r3, 6bae <cliFunc_pixelList+0x9a>
				print( NL );
    6ba8:	4638      	mov	r0, r7
    6baa:	f004 fc29 	bl	b400 <_print>
			printHex_op( pixel, 2 );
    6bae:	2102      	movs	r1, #2
    6bb0:	4648      	mov	r0, r9
    6bb2:	f004 fccd 	bl	b550 <printHex_op>
			print(":");
    6bb6:	4640      	mov	r0, r8
    6bb8:	f004 fc22 	bl	b400 <_print>
			printInt8( elem->width );
    6bbc:	7820      	ldrb	r0, [r4, #0]
				print(",");
    6bbe:	f8df b090 	ldr.w	fp, [pc, #144]	; 6c50 <cliFunc_pixelList+0x13c>
			printInt8( elem->width );
    6bc2:	f004 fc4f 	bl	b464 <printInt8>
			print("[");
    6bc6:	481f      	ldr	r0, [pc, #124]	; (6c44 <cliFunc_pixelList+0x130>)
    6bc8:	f004 fc1a 	bl	b400 <_print>
			printHex_op( elem->indices[0], 2 );
    6bcc:	2102      	movs	r1, #2
    6bce:	8860      	ldrh	r0, [r4, #2]
    6bd0:	f004 fcbe 	bl	b550 <printHex_op>
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    6bd4:	f04f 0901 	mov.w	r9, #1
				printHex_op( elem->indices[ch], 2 );
    6bd8:	ea4f 0a85 	mov.w	sl, r5, lsl #2
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    6bdc:	7863      	ldrb	r3, [r4, #1]
    6bde:	454b      	cmp	r3, r9
    6be0:	d80b      	bhi.n	6bfa <cliFunc_pixelList+0xe6>
			print("]");
    6be2:	4819      	ldr	r0, [pc, #100]	; (6c48 <cliFunc_pixelList+0x134>)
    6be4:	f004 fc0c 	bl	b400 <_print>
    6be8:	3501      	adds	r5, #1
			print("  ");
    6bea:	4818      	ldr	r0, [pc, #96]	; (6c4c <cliFunc_pixelList+0x138>)
    6bec:	f004 fc08 	bl	b400 <_print>
		for ( uint16_t pixel = 0; pixel < Pixel_TotalPixels_KLL; pixel++ )
    6bf0:	2d26      	cmp	r5, #38	; 0x26
    6bf2:	f104 0408 	add.w	r4, r4, #8
    6bf6:	d1cc      	bne.n	6b92 <cliFunc_pixelList+0x7e>
    6bf8:	e7bf      	b.n	6b7a <cliFunc_pixelList+0x66>
				print(",");
    6bfa:	4658      	mov	r0, fp
    6bfc:	f004 fc00 	bl	b400 <_print>
				printHex_op( elem->indices[ch], 2 );
    6c00:	eb0a 0309 	add.w	r3, sl, r9
    6c04:	eb06 0343 	add.w	r3, r6, r3, lsl #1
    6c08:	2102      	movs	r1, #2
    6c0a:	8858      	ldrh	r0, [r3, #2]
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    6c0c:	f109 0901 	add.w	r9, r9, #1
				printHex_op( elem->indices[ch], 2 );
    6c10:	f004 fc9e 	bl	b550 <printHex_op>
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    6c14:	fa5f f989 	uxtb.w	r9, r9
    6c18:	e7e0      	b.n	6bdc <cliFunc_pixelList+0xc8>
    6c1a:	bf00      	nop
    6c1c:	00010d99 	.word	0x00010d99
    6c20:	0000fa5e 	.word	0x0000fa5e
    6c24:	1fff8ce0 	.word	0x1fff8ce0
    6c28:	0000d8ff 	.word	0x0000d8ff
    6c2c:	0000f857 	.word	0x0000f857
    6c30:	0000fa7c 	.word	0x0000fa7c
    6c34:	0000fa84 	.word	0x0000fa84
    6c38:	000106cd 	.word	0x000106cd
    6c3c:	0000fa8c 	.word	0x0000fa8c
    6c40:	0000fff0 	.word	0x0000fff0
    6c44:	00010e97 	.word	0x00010e97
    6c48:	0000fac7 	.word	0x0000fac7
    6c4c:	00011f76 	.word	0x00011f76
    6c50:	0000d322 	.word	0x0000d322

00006c54 <Pixel_AnimationIndex_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    6c54:	2aff      	cmp	r2, #255	; 0xff
{
    6c56:	b510      	push	{r4, lr}
	if ( stateType == 0xFF && state == 0xFF )
    6c58:	d106      	bne.n	6c68 <Pixel_AnimationIndex_capability+0x14>
    6c5a:	29ff      	cmp	r1, #255	; 0xff
    6c5c:	d104      	bne.n	6c68 <Pixel_AnimationIndex_capability+0x14>
		print("Pixel_AnimationIndex_capability(settingindex)");
    6c5e:	4808      	ldr	r0, [pc, #32]	; (6c80 <Pixel_AnimationIndex_capability+0x2c>)
}
    6c60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print( NL );
    6c64:	f004 bbcc 	b.w	b400 <_print>
	if ( state != 0x01 )
    6c68:	2901      	cmp	r1, #1
    6c6a:	d108      	bne.n	6c7e <Pixel_AnimationIndex_capability+0x2a>
	uint16_t index = *(uint16_t*)(&args[0]);
    6c6c:	881c      	ldrh	r4, [r3, #0]
		warn_msg("Invalid AnimationSetting index: ");
    6c6e:	4805      	ldr	r0, [pc, #20]	; (6c84 <Pixel_AnimationIndex_capability+0x30>)
    6c70:	f004 fbc6 	bl	b400 <_print>
		printInt16( index );
    6c74:	4620      	mov	r0, r4
    6c76:	f004 fc13 	bl	b4a0 <printInt16>
		print( NL );
    6c7a:	4803      	ldr	r0, [pc, #12]	; (6c88 <Pixel_AnimationIndex_capability+0x34>)
    6c7c:	e7f0      	b.n	6c60 <Pixel_AnimationIndex_capability+0xc>
}
    6c7e:	bd10      	pop	{r4, pc}
    6c80:	0000f3d3 	.word	0x0000f3d3
    6c84:	0000f401 	.word	0x0000f401
    6c88:	00010d99 	.word	0x00010d99

00006c8c <Pixel_Pixel_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    6c8c:	2aff      	cmp	r2, #255	; 0xff
    6c8e:	d104      	bne.n	6c9a <Pixel_Pixel_capability+0xe>
    6c90:	29ff      	cmp	r1, #255	; 0xff
    6c92:	d102      	bne.n	6c9a <Pixel_Pixel_capability+0xe>
		print("Pixel_Pixel_capability(pixel,chan,value)");
    6c94:	4801      	ldr	r0, [pc, #4]	; (6c9c <Pixel_Pixel_capability+0x10>)
    6c96:	f004 bbb3 	b.w	b400 <_print>
}
    6c9a:	4770      	bx	lr
    6c9c:	0000f484 	.word	0x0000f484

00006ca0 <Pixel_AnimationControl_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    6ca0:	2aff      	cmp	r2, #255	; 0xff
    6ca2:	d104      	bne.n	6cae <Pixel_AnimationControl_capability+0xe>
    6ca4:	29ff      	cmp	r1, #255	; 0xff
    6ca6:	d102      	bne.n	6cae <Pixel_AnimationControl_capability+0xe>
		print("Pixel_AnimationControl_capability(func)");
    6ca8:	4812      	ldr	r0, [pc, #72]	; (6cf4 <Pixel_AnimationControl_capability+0x54>)
    6caa:	f004 bba9 	b.w	b400 <_print>
	if ( state != 0x01 )
    6cae:	2901      	cmp	r1, #1
    6cb0:	d10f      	bne.n	6cd2 <Pixel_AnimationControl_capability+0x32>
	switch ( arg )
    6cb2:	781b      	ldrb	r3, [r3, #0]
    6cb4:	2b06      	cmp	r3, #6
    6cb6:	d80c      	bhi.n	6cd2 <Pixel_AnimationControl_capability+0x32>
    6cb8:	e8df f003 	tbb	[pc, r3]
    6cbc:	120c0f04 	.word	0x120c0f04
    6cc0:	1815      	.short	0x1815
    6cc2:	08          	.byte	0x08
    6cc3:	00          	.byte	0x00
		switch ( Pixel_animationControl )
    6cc4:	4b0c      	ldr	r3, [pc, #48]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6cc6:	781b      	ldrb	r3, [r3, #0]
    6cc8:	2b01      	cmp	r3, #1
    6cca:	d803      	bhi.n	6cd4 <Pixel_AnimationControl_capability+0x34>
			Pixel_animationControl = AnimationControl_Pause;
    6ccc:	4b0a      	ldr	r3, [pc, #40]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6cce:	2202      	movs	r2, #2
		Pixel_animationControl = AnimationControl_WipePause;
    6cd0:	701a      	strb	r2, [r3, #0]
}
    6cd2:	4770      	bx	lr
			Pixel_animationControl = AnimationControl_Forward;
    6cd4:	4b08      	ldr	r3, [pc, #32]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6cd6:	2200      	movs	r2, #0
    6cd8:	e7fa      	b.n	6cd0 <Pixel_AnimationControl_capability+0x30>
		Pixel_animationControl = AnimationControl_ForwardOne;
    6cda:	4b07      	ldr	r3, [pc, #28]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6cdc:	2201      	movs	r2, #1
    6cde:	e7f7      	b.n	6cd0 <Pixel_AnimationControl_capability+0x30>
		Pixel_animationControl = AnimationControl_Stop;
    6ce0:	4b05      	ldr	r3, [pc, #20]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6ce2:	2203      	movs	r2, #3
    6ce4:	e7f4      	b.n	6cd0 <Pixel_AnimationControl_capability+0x30>
		Pixel_animationControl = AnimationControl_Reset;
    6ce6:	4b04      	ldr	r3, [pc, #16]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6ce8:	2204      	movs	r2, #4
    6cea:	e7f1      	b.n	6cd0 <Pixel_AnimationControl_capability+0x30>
		Pixel_animationControl = AnimationControl_WipePause;
    6cec:	4b02      	ldr	r3, [pc, #8]	; (6cf8 <Pixel_AnimationControl_capability+0x58>)
    6cee:	2205      	movs	r2, #5
    6cf0:	e7ee      	b.n	6cd0 <Pixel_AnimationControl_capability+0x30>
    6cf2:	bf00      	nop
    6cf4:	0000f3ab 	.word	0x0000f3ab
    6cf8:	1fffa764 	.word	0x1fffa764

00006cfc <Pixel_showPixelElement>:
{
    6cfc:	b570      	push	{r4, r5, r6, lr}
    6cfe:	4605      	mov	r5, r0
	print("W:");
    6d00:	4811      	ldr	r0, [pc, #68]	; (6d48 <Pixel_showPixelElement+0x4c>)
		print(",");
    6d02:	4e12      	ldr	r6, [pc, #72]	; (6d4c <Pixel_showPixelElement+0x50>)
	print("W:");
    6d04:	f004 fb7c 	bl	b400 <_print>
	printInt8( elem->width );
    6d08:	7828      	ldrb	r0, [r5, #0]
    6d0a:	f004 fbab 	bl	b464 <printInt8>
	print(" C:");
    6d0e:	4810      	ldr	r0, [pc, #64]	; (6d50 <Pixel_showPixelElement+0x54>)
    6d10:	f004 fb76 	bl	b400 <_print>
	printInt8( elem->channels );
    6d14:	7868      	ldrb	r0, [r5, #1]
    6d16:	f004 fba5 	bl	b464 <printInt8>
	print(" I:");
    6d1a:	480e      	ldr	r0, [pc, #56]	; (6d54 <Pixel_showPixelElement+0x58>)
    6d1c:	f004 fb70 	bl	b400 <_print>
	printInt16( elem->indices[0] );
    6d20:	8868      	ldrh	r0, [r5, #2]
    6d22:	f004 fbbd 	bl	b4a0 <printInt16>
	for ( uint8_t c = 1; c < elem->channels; c++ )
    6d26:	2401      	movs	r4, #1
    6d28:	786b      	ldrb	r3, [r5, #1]
    6d2a:	42a3      	cmp	r3, r4
    6d2c:	d800      	bhi.n	6d30 <Pixel_showPixelElement+0x34>
}
    6d2e:	bd70      	pop	{r4, r5, r6, pc}
		print(",");
    6d30:	4630      	mov	r0, r6
    6d32:	f004 fb65 	bl	b400 <_print>
		printInt16( elem->indices[c] );
    6d36:	eb05 0344 	add.w	r3, r5, r4, lsl #1
	for ( uint8_t c = 1; c < elem->channels; c++ )
    6d3a:	3401      	adds	r4, #1
		printInt16( elem->indices[c] );
    6d3c:	8858      	ldrh	r0, [r3, #2]
    6d3e:	f004 fbaf 	bl	b4a0 <printInt16>
	for ( uint8_t c = 1; c < elem->channels; c++ )
    6d42:	b2e4      	uxtb	r4, r4
    6d44:	e7f0      	b.n	6d28 <Pixel_showPixelElement+0x2c>
    6d46:	bf00      	nop
    6d48:	0000f852 	.word	0x0000f852
    6d4c:	0000d322 	.word	0x0000d322
    6d50:	0000f855 	.word	0x0000f855
    6d54:	0000f859 	.word	0x0000f859

00006d58 <Pixel_clearAnimations>:
	Pixel_AnimationStack.size = 0;
    6d58:	4a06      	ldr	r2, [pc, #24]	; (6d74 <Pixel_clearAnimations+0x1c>)
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    6d5a:	4807      	ldr	r0, [pc, #28]	; (6d78 <Pixel_clearAnimations+0x20>)
	Pixel_AnimationStack.size = 0;
    6d5c:	2300      	movs	r3, #0
    6d5e:	8013      	strh	r3, [r2, #0]
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    6d60:	f64f 71ff 	movw	r1, #65535	; 0xffff
    6d64:	181a      	adds	r2, r3, r0
    6d66:	3310      	adds	r3, #16
	for ( uint16_t pos = 0; pos < Pixel_AnimationStackSize; pos++ )
    6d68:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    6d6c:	8091      	strh	r1, [r2, #4]
	for ( uint16_t pos = 0; pos < Pixel_AnimationStackSize; pos++ )
    6d6e:	d1f9      	bne.n	6d64 <Pixel_clearAnimations+0xc>
}
    6d70:	4770      	bx	lr
    6d72:	bf00      	nop
    6d74:	1fffa710 	.word	0x1fffa710
    6d78:	1fffa768 	.word	0x1fffa768

00006d7c <Pixel_lookupAnimation>:
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    6d7c:	4b08      	ldr	r3, [pc, #32]	; (6da0 <Pixel_lookupAnimation+0x24>)
{
    6d7e:	b530      	push	{r4, r5, lr}
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    6d80:	881c      	ldrh	r4, [r3, #0]
    6d82:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    6d86:	428c      	cmp	r4, r1
    6d88:	d802      	bhi.n	6d90 <Pixel_lookupAnimation+0x14>
	return NULL;
    6d8a:	2200      	movs	r2, #0
}
    6d8c:	4610      	mov	r0, r2
    6d8e:	bd30      	pop	{r4, r5, pc}
		if ( Pixel_AnimationStack.stack[pos]->index == index )
    6d90:	f853 2f04 	ldr.w	r2, [r3, #4]!
    6d94:	8895      	ldrh	r5, [r2, #4]
    6d96:	4285      	cmp	r5, r0
    6d98:	d0f8      	beq.n	6d8c <Pixel_lookupAnimation+0x10>
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    6d9a:	3101      	adds	r1, #1
    6d9c:	b289      	uxth	r1, r1
    6d9e:	e7f2      	b.n	6d86 <Pixel_lookupAnimation+0xa>
    6da0:	1fffa710 	.word	0x1fffa710

00006da4 <Pixel_addAnimation>:
{
    6da4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ( element->replace )
    6da6:	7b85      	ldrb	r5, [r0, #14]
{
    6da8:	4604      	mov	r4, r0
	if ( element->replace )
    6daa:	b1ed      	cbz	r5, 6de8 <Pixel_addAnimation+0x44>
		AnimationStackElement *found = Pixel_lookupAnimation( element->index, 0 );
    6dac:	2100      	movs	r1, #0
    6dae:	8880      	ldrh	r0, [r0, #4]
    6db0:	f7ff ffe4 	bl	6d7c <Pixel_lookupAnimation>
		if ( found != NULL && ( found->trigger == element->trigger || element->replace == AnimationReplaceType_All ) )
    6db4:	b1c0      	cbz	r0, 6de8 <Pixel_addAnimation+0x44>
    6db6:	6802      	ldr	r2, [r0, #0]
    6db8:	6823      	ldr	r3, [r4, #0]
    6dba:	429a      	cmp	r2, r3
    6dbc:	d001      	beq.n	6dc2 <Pixel_addAnimation+0x1e>
    6dbe:	2d02      	cmp	r5, #2
    6dc0:	d112      	bne.n	6de8 <Pixel_addAnimation+0x44>
			found->pos = element->pos;
    6dc2:	88e3      	ldrh	r3, [r4, #6]
    6dc4:	80c3      	strh	r3, [r0, #6]
			found->subpos = element->subpos;
    6dc6:	7a23      	ldrb	r3, [r4, #8]
    6dc8:	7203      	strb	r3, [r0, #8]
			found->loops = element->loops;
    6dca:	7a63      	ldrb	r3, [r4, #9]
    6dcc:	7243      	strb	r3, [r0, #9]
			found->pfunc = element->pfunc;
    6dce:	7b63      	ldrb	r3, [r4, #13]
    6dd0:	7343      	strb	r3, [r0, #13]
			found->ffunc = element->ffunc;
    6dd2:	7b23      	ldrb	r3, [r4, #12]
    6dd4:	7303      	strb	r3, [r0, #12]
			found->framedelay = element->framedelay;
    6dd6:	7aa3      	ldrb	r3, [r4, #10]
    6dd8:	7283      	strb	r3, [r0, #10]
			found->frameoption = element->frameoption;
    6dda:	7ae3      	ldrb	r3, [r4, #11]
    6ddc:	72c3      	strb	r3, [r0, #11]
			found->state = element->state;
    6dde:	7be3      	ldrb	r3, [r4, #15]
			found->replace = element->replace;
    6de0:	7385      	strb	r5, [r0, #14]
			found->state = element->state;
    6de2:	73c3      	strb	r3, [r0, #15]
		return 0;
    6de4:	2000      	movs	r0, #0
    6de6:	e01f      	b.n	6e28 <Pixel_addAnimation+0x84>
	if ( Pixel_AnimationStack.size >= Pixel_AnimationStackSize )
    6de8:	4b10      	ldr	r3, [pc, #64]	; (6e2c <Pixel_addAnimation+0x88>)
    6dea:	8819      	ldrh	r1, [r3, #0]
    6dec:	2913      	cmp	r1, #19
    6dee:	d903      	bls.n	6df8 <Pixel_addAnimation+0x54>
		warn_print("Animation stack is full...");
    6df0:	480f      	ldr	r0, [pc, #60]	; (6e30 <Pixel_addAnimation+0x8c>)
		erro_print("Animation Stack memory leak...this is a bug!");
    6df2:	f004 fb05 	bl	b400 <_print>
    6df6:	e7f5      	b.n	6de4 <Pixel_addAnimation+0x40>
		if ( Pixel_AnimationElement_Stor[pos].index == 0xFFFF )
    6df8:	4d0e      	ldr	r5, [pc, #56]	; (6e34 <Pixel_addAnimation+0x90>)
    6dfa:	2200      	movs	r2, #0
    6dfc:	f64f 76ff 	movw	r6, #65535	; 0xffff
    6e00:	eb05 1002 	add.w	r0, r5, r2, lsl #4
    6e04:	8887      	ldrh	r7, [r0, #4]
    6e06:	42b7      	cmp	r7, r6
    6e08:	d004      	beq.n	6e14 <Pixel_addAnimation+0x70>
    6e0a:	3201      	adds	r2, #1
	for ( ; pos < Pixel_AnimationStackSize; pos++ )
    6e0c:	2a14      	cmp	r2, #20
    6e0e:	d1f7      	bne.n	6e00 <Pixel_addAnimation+0x5c>
		erro_print("Animation Stack memory leak...this is a bug!");
    6e10:	4809      	ldr	r0, [pc, #36]	; (6e38 <Pixel_addAnimation+0x94>)
    6e12:	e7ee      	b.n	6df2 <Pixel_addAnimation+0x4e>
	Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = &Pixel_AnimationElement_Stor[pos];
    6e14:	1c4a      	adds	r2, r1, #1
    6e16:	801a      	strh	r2, [r3, #0]
    6e18:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	memcpy( &Pixel_AnimationElement_Stor[pos], element, sizeof(AnimationStackElement) );
    6e1c:	2210      	movs	r2, #16
    6e1e:	4621      	mov	r1, r4
	Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = &Pixel_AnimationElement_Stor[pos];
    6e20:	6058      	str	r0, [r3, #4]
	memcpy( &Pixel_AnimationElement_Stor[pos], element, sizeof(AnimationStackElement) );
    6e22:	f7fb fc15 	bl	2650 <memcpy>
	return 1;
    6e26:	2001      	movs	r0, #1
}
    6e28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6e2a:	bf00      	nop
    6e2c:	1fffa710 	.word	0x1fffa710
    6e30:	0000f4ad 	.word	0x0000f4ad
    6e34:	1fffa768 	.word	0x1fffa768
    6e38:	0000f4df 	.word	0x0000f4df

00006e3c <Pixel_Animation_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    6e3c:	2aff      	cmp	r2, #255	; 0xff
{
    6e3e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if ( stateType == 0xFF && state == 0xFF )
    6e40:	d107      	bne.n	6e52 <Pixel_Animation_capability+0x16>
    6e42:	29ff      	cmp	r1, #255	; 0xff
    6e44:	d105      	bne.n	6e52 <Pixel_Animation_capability+0x16>
		print("Pixel_Animation_capability(index,loops,pfunc,framedelay,frameoption,replace)");
    6e46:	4812      	ldr	r0, [pc, #72]	; (6e90 <Pixel_Animation_capability+0x54>)
    6e48:	f004 fada 	bl	b400 <_print>
}
    6e4c:	b005      	add	sp, #20
    6e4e:	f85d fb04 	ldr.w	pc, [sp], #4
	if ( state != 0x01 )
    6e52:	2901      	cmp	r1, #1
    6e54:	d1fa      	bne.n	6e4c <Pixel_Animation_capability+0x10>
	element.pos = 0; // TODO (HaaTa) Start at specific frame
    6e56:	2200      	movs	r2, #0
    6e58:	f8ad 2006 	strh.w	r2, [sp, #6]
	element.subpos = 0;
    6e5c:	f88d 2008 	strb.w	r2, [sp, #8]
	element.index = *(uint16_t*)(&args[0]);
    6e60:	881a      	ldrh	r2, [r3, #0]
    6e62:	f8ad 2004 	strh.w	r2, [sp, #4]
	element.loops = *(uint8_t*)(&args[2]);
    6e66:	789a      	ldrb	r2, [r3, #2]
    6e68:	f88d 2009 	strb.w	r2, [sp, #9]
	element.pfunc = *(uint8_t*)(&args[3]);
    6e6c:	78da      	ldrb	r2, [r3, #3]
    6e6e:	f88d 200d 	strb.w	r2, [sp, #13]
	element.framedelay = *(uint8_t*)(&args[4]);
    6e72:	791a      	ldrb	r2, [r3, #4]
	element.trigger = trigger;
    6e74:	9000      	str	r0, [sp, #0]
	element.framedelay = *(uint8_t*)(&args[4]);
    6e76:	f88d 200a 	strb.w	r2, [sp, #10]
	Pixel_addAnimation( &element );
    6e7a:	4668      	mov	r0, sp
	element.frameoption = *(uint8_t*)(&args[5]);
    6e7c:	795a      	ldrb	r2, [r3, #5]
	element.replace = *(uint8_t*)(&args[6]);
    6e7e:	799b      	ldrb	r3, [r3, #6]
	element.frameoption = *(uint8_t*)(&args[5]);
    6e80:	f88d 200b 	strb.w	r2, [sp, #11]
	element.replace = *(uint8_t*)(&args[6]);
    6e84:	f88d 300e 	strb.w	r3, [sp, #14]
	Pixel_addAnimation( &element );
    6e88:	f7ff ff8c 	bl	6da4 <Pixel_addAnimation>
    6e8c:	e7de      	b.n	6e4c <Pixel_Animation_capability+0x10>
    6e8e:	bf00      	nop
    6e90:	0000f437 	.word	0x0000f437

00006e94 <Pixel_bufferMap>:
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    6e94:	288f      	cmp	r0, #143	; 0x8f
{
    6e96:	b510      	push	{r4, lr}
    6e98:	4604      	mov	r4, r0
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    6e9a:	d914      	bls.n	6ec6 <Pixel_bufferMap+0x32>
	else if ( channel < 288 ) return &Pixel_Buffers[1];
    6e9c:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
    6ea0:	d313      	bcc.n	6eca <Pixel_bufferMap+0x36>
	else if ( channel < 432 ) return &Pixel_Buffers[2];
    6ea2:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
    6ea6:	d312      	bcc.n	6ece <Pixel_bufferMap+0x3a>
	else if ( channel < 576 ) return &Pixel_Buffers[3];
    6ea8:	f5b0 7f10 	cmp.w	r0, #576	; 0x240
    6eac:	d311      	bcc.n	6ed2 <Pixel_bufferMap+0x3e>
	erro_msg("Invalid channel: ");
    6eae:	480a      	ldr	r0, [pc, #40]	; (6ed8 <Pixel_bufferMap+0x44>)
    6eb0:	f004 faa6 	bl	b400 <_print>
	printHex( channel );
    6eb4:	2101      	movs	r1, #1
    6eb6:	4620      	mov	r0, r4
    6eb8:	f004 fb4a 	bl	b550 <printHex_op>
	print( NL );
    6ebc:	4807      	ldr	r0, [pc, #28]	; (6edc <Pixel_bufferMap+0x48>)
    6ebe:	f004 fa9f 	bl	b400 <_print>
    6ec2:	2000      	movs	r0, #0
}
    6ec4:	bd10      	pop	{r4, pc}
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    6ec6:	4806      	ldr	r0, [pc, #24]	; (6ee0 <Pixel_bufferMap+0x4c>)
    6ec8:	e7fc      	b.n	6ec4 <Pixel_bufferMap+0x30>
	else if ( channel < 288 ) return &Pixel_Buffers[1];
    6eca:	4806      	ldr	r0, [pc, #24]	; (6ee4 <Pixel_bufferMap+0x50>)
    6ecc:	e7fa      	b.n	6ec4 <Pixel_bufferMap+0x30>
	else if ( channel < 432 ) return &Pixel_Buffers[2];
    6ece:	4806      	ldr	r0, [pc, #24]	; (6ee8 <Pixel_bufferMap+0x54>)
    6ed0:	e7f8      	b.n	6ec4 <Pixel_bufferMap+0x30>
	else if ( channel < 576 ) return &Pixel_Buffers[3];
    6ed2:	4806      	ldr	r0, [pc, #24]	; (6eec <Pixel_bufferMap+0x58>)
    6ed4:	e7f6      	b.n	6ec4 <Pixel_bufferMap+0x30>
    6ed6:	bf00      	nop
    6ed8:	0000f523 	.word	0x0000f523
    6edc:	00010d99 	.word	0x00010d99
    6ee0:	1fff8ce0 	.word	0x1fff8ce0
    6ee4:	1fff8ce8 	.word	0x1fff8ce8
    6ee8:	1fff8cf0 	.word	0x1fff8cf0
    6eec:	1fff8cf8 	.word	0x1fff8cf8

00006ef0 <Pixel_pixelEvaluation>:
{
    6ef0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ef4:	4607      	mov	r7, r0
	if ( elem == 0 )
    6ef6:	4688      	mov	r8, r1
    6ef8:	b139      	cbz	r1, 6f0a <Pixel_pixelEvaluation+0x1a>
    6efa:	784b      	ldrb	r3, [r1, #1]
    6efc:	1c8e      	adds	r6, r1, #2
    6efe:	eb06 0943 	add.w	r9, r6, r3, lsl #1
	uint8_t position_iter = 0;
    6f02:	f04f 0a00 	mov.w	sl, #0
	for ( uint8_t ch = 0; ch < channels; ch++ )
    6f06:	454e      	cmp	r6, r9
    6f08:	d102      	bne.n	6f10 <Pixel_pixelEvaluation+0x20>
}
    6f0a:	b003      	add	sp, #12
    6f0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t ch_pos = elem->indices[ch];
    6f10:	f836 bb02 	ldrh.w	fp, [r6], #2
		PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
    6f14:	4658      	mov	r0, fp
    6f16:	f7ff ffbd 	bl	6e94 <Pixel_bufferMap>
		if ( pixbuf == 0 )
    6f1a:	4604      	mov	r4, r0
    6f1c:	2800      	cmp	r0, #0
    6f1e:	d0f4      	beq.n	6f0a <Pixel_pixelEvaluation+0x1a>
		switch ( elem->width )
    6f20:	f898 0000 	ldrb.w	r0, [r8]
		PixelChange change = (PixelChange)mod->data[ position_iter++ ];
    6f24:	eb07 010a 	add.w	r1, r7, sl
    6f28:	f10a 0501 	add.w	r5, sl, #1
		switch ( elem->width )
    6f2c:	2810      	cmp	r0, #16
		PixelChange change = (PixelChange)mod->data[ position_iter++ ];
    6f2e:	b2ed      	uxtb	r5, r5
    6f30:	7949      	ldrb	r1, [r1, #5]
		switch ( elem->width )
    6f32:	d014      	beq.n	6f5e <Pixel_pixelEvaluation+0x6e>
    6f34:	2820      	cmp	r0, #32
    6f36:	d01c      	beq.n	6f72 <Pixel_pixelEvaluation+0x82>
    6f38:	2808      	cmp	r0, #8
    6f3a:	d12b      	bne.n	6f94 <Pixel_pixelEvaluation+0xa4>
			mod_value = mod->data[ position_iter++ ];
    6f3c:	443d      	add	r5, r7
    6f3e:	f10a 0202 	add.w	r2, sl, #2
    6f42:	7968      	ldrb	r0, [r5, #5]
    6f44:	b2d5      	uxtb	r5, r2
		switch ( change )
    6f46:	2906      	cmp	r1, #6
    6f48:	f200 8150 	bhi.w	71ec <Pixel_pixelEvaluation+0x2fc>
    6f4c:	e8df f011 	tbh	[pc, r1, lsl #1]
    6f50:	00490029 	.word	0x00490029
    6f54:	00d8006e 	.word	0x00d8006e
    6f58:	008e0116 	.word	0x008e0116
    6f5c:	00b3      	.short	0x00b3
				( mod->data[ position_iter + 2 ] << 8 );
    6f5e:	443d      	add	r5, r7
    6f60:	f895 c007 	ldrb.w	ip, [r5, #7]
			mod_value = mod->data[ position_iter + 1 ] |
    6f64:	79a8      	ldrb	r0, [r5, #6]
			position_iter += 2;
    6f66:	f10a 0503 	add.w	r5, sl, #3
			mod_value = mod->data[ position_iter + 1 ] |
    6f6a:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
			position_iter += 4;
    6f6e:	b2ed      	uxtb	r5, r5
			break;
    6f70:	e7e9      	b.n	6f46 <Pixel_pixelEvaluation+0x56>
				( mod->data[ position_iter + 2 ] << 8 ) |
    6f72:	443d      	add	r5, r7
				( mod->data[ position_iter + 3 ] << 16 ) |
    6f74:	7a28      	ldrb	r0, [r5, #8]
				( mod->data[ position_iter + 2 ] << 8 ) |
    6f76:	f895 c007 	ldrb.w	ip, [r5, #7]
				( mod->data[ position_iter + 3 ] << 16 ) |
    6f7a:	0400      	lsls	r0, r0, #16
				( mod->data[ position_iter + 2 ] << 8 ) |
    6f7c:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
			mod_value = mod->data[ position_iter + 1 ] |
    6f80:	f895 c006 	ldrb.w	ip, [r5, #6]
				( mod->data[ position_iter + 4 ] << 24 );
    6f84:	7a6d      	ldrb	r5, [r5, #9]
				( mod->data[ position_iter + 2 ] << 8 ) |
    6f86:	ea40 000c 	orr.w	r0, r0, ip
				( mod->data[ position_iter + 3 ] << 16 ) |
    6f8a:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
			position_iter += 4;
    6f8e:	f10a 0505 	add.w	r5, sl, #5
    6f92:	e7ec      	b.n	6f6e <Pixel_pixelEvaluation+0x7e>
			warn_print("Invalid PixelElement width mapping");
    6f94:	4896      	ldr	r0, [pc, #600]	; (71f0 <Pixel_pixelEvaluation+0x300>)
    6f96:	9101      	str	r1, [sp, #4]
    6f98:	f004 fa32 	bl	b400 <_print>
		uint32_t mod_value = 0;
    6f9c:	2000      	movs	r0, #0
    6f9e:	9901      	ldr	r1, [sp, #4]
			break;
    6fa0:	e7d1      	b.n	6f46 <Pixel_pixelEvaluation+0x56>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, = );
    6fa2:	7862      	ldrb	r2, [r4, #1]
    6fa4:	2a10      	cmp	r2, #16
    6fa6:	d00a      	beq.n	6fbe <Pixel_pixelEvaluation+0xce>
    6fa8:	2a20      	cmp	r2, #32
    6faa:	d00f      	beq.n	6fcc <Pixel_pixelEvaluation+0xdc>
    6fac:	2a08      	cmp	r2, #8
    6fae:	d114      	bne.n	6fda <Pixel_pixelEvaluation+0xea>
    6fb0:	8862      	ldrh	r2, [r4, #2]
    6fb2:	ebab 0302 	sub.w	r3, fp, r2
    6fb6:	6862      	ldr	r2, [r4, #4]
    6fb8:	54d0      	strb	r0, [r2, r3]
	uint8_t position_iter = 0;
    6fba:	46aa      	mov	sl, r5
    6fbc:	e7a3      	b.n	6f06 <Pixel_pixelEvaluation+0x16>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, = );
    6fbe:	8862      	ldrh	r2, [r4, #2]
    6fc0:	ebab 0302 	sub.w	r3, fp, r2
    6fc4:	6862      	ldr	r2, [r4, #4]
    6fc6:	f822 0013 	strh.w	r0, [r2, r3, lsl #1]
    6fca:	e7f6      	b.n	6fba <Pixel_pixelEvaluation+0xca>
    6fcc:	8862      	ldrh	r2, [r4, #2]
    6fce:	ebab 0302 	sub.w	r3, fp, r2
    6fd2:	6862      	ldr	r2, [r4, #4]
    6fd4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    6fd8:	e7ef      	b.n	6fba <Pixel_pixelEvaluation+0xca>
    6fda:	4886      	ldr	r0, [pc, #536]	; (71f4 <Pixel_pixelEvaluation+0x304>)
			warn_print("Unimplemented pixel modifier");
    6fdc:	f004 fa10 	bl	b400 <_print>
			break;
    6fe0:	e7eb      	b.n	6fba <Pixel_pixelEvaluation+0xca>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    6fe2:	7862      	ldrb	r2, [r4, #1]
    6fe4:	2a10      	cmp	r2, #16
    6fe6:	d00b      	beq.n	7000 <Pixel_pixelEvaluation+0x110>
    6fe8:	2a20      	cmp	r2, #32
    6fea:	d013      	beq.n	7014 <Pixel_pixelEvaluation+0x124>
    6fec:	2a08      	cmp	r2, #8
    6fee:	d11b      	bne.n	7028 <Pixel_pixelEvaluation+0x138>
    6ff0:	8862      	ldrh	r2, [r4, #2]
    6ff2:	6861      	ldr	r1, [r4, #4]
    6ff4:	ebab 0302 	sub.w	r3, fp, r2
    6ff8:	5cca      	ldrb	r2, [r1, r3]
    6ffa:	4410      	add	r0, r2
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    6ffc:	54c8      	strb	r0, [r1, r3]
    6ffe:	e7dc      	b.n	6fba <Pixel_pixelEvaluation+0xca>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    7000:	8862      	ldrh	r2, [r4, #2]
    7002:	6861      	ldr	r1, [r4, #4]
    7004:	ebab 0302 	sub.w	r3, fp, r2
    7008:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    700c:	4410      	add	r0, r2
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    700e:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
    7012:	e7d2      	b.n	6fba <Pixel_pixelEvaluation+0xca>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    7014:	8862      	ldrh	r2, [r4, #2]
    7016:	6861      	ldr	r1, [r4, #4]
    7018:	ebab 0302 	sub.w	r3, fp, r2
    701c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    7020:	4410      	add	r0, r2
				PixelBuf32( pixbuf, ch_pos ) -= (uint32_t)mod_value;
    7022:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    7026:	e7c8      	b.n	6fba <Pixel_pixelEvaluation+0xca>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    7028:	4873      	ldr	r0, [pc, #460]	; (71f8 <Pixel_pixelEvaluation+0x308>)
    702a:	e7d7      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    702c:	7862      	ldrb	r2, [r4, #1]
    702e:	2a10      	cmp	r2, #16
    7030:	d00a      	beq.n	7048 <Pixel_pixelEvaluation+0x158>
    7032:	2a20      	cmp	r2, #32
    7034:	d010      	beq.n	7058 <Pixel_pixelEvaluation+0x168>
    7036:	2a08      	cmp	r2, #8
    7038:	d116      	bne.n	7068 <Pixel_pixelEvaluation+0x178>
    703a:	8862      	ldrh	r2, [r4, #2]
    703c:	6861      	ldr	r1, [r4, #4]
    703e:	ebab 0302 	sub.w	r3, fp, r2
    7042:	5cca      	ldrb	r2, [r1, r3]
    7044:	1a10      	subs	r0, r2, r0
    7046:	e7d9      	b.n	6ffc <Pixel_pixelEvaluation+0x10c>
    7048:	8862      	ldrh	r2, [r4, #2]
    704a:	6861      	ldr	r1, [r4, #4]
    704c:	ebab 0302 	sub.w	r3, fp, r2
    7050:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    7054:	1a10      	subs	r0, r2, r0
    7056:	e7da      	b.n	700e <Pixel_pixelEvaluation+0x11e>
    7058:	8862      	ldrh	r2, [r4, #2]
    705a:	6861      	ldr	r1, [r4, #4]
    705c:	ebab 0302 	sub.w	r3, fp, r2
    7060:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    7064:	1a10      	subs	r0, r2, r0
    7066:	e7dc      	b.n	7022 <Pixel_pixelEvaluation+0x132>
    7068:	4864      	ldr	r0, [pc, #400]	; (71fc <Pixel_pixelEvaluation+0x30c>)
    706a:	e7b7      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, <<= );
    706c:	7862      	ldrb	r2, [r4, #1]
    706e:	2a10      	cmp	r2, #16
    7070:	d00c      	beq.n	708c <Pixel_pixelEvaluation+0x19c>
    7072:	2a20      	cmp	r2, #32
    7074:	d014      	beq.n	70a0 <Pixel_pixelEvaluation+0x1b0>
    7076:	2a08      	cmp	r2, #8
    7078:	d11b      	bne.n	70b2 <Pixel_pixelEvaluation+0x1c2>
    707a:	8862      	ldrh	r2, [r4, #2]
    707c:	6861      	ldr	r1, [r4, #4]
    707e:	ebab 0302 	sub.w	r3, fp, r2
    7082:	b2c0      	uxtb	r0, r0
    7084:	5cca      	ldrb	r2, [r1, r3]
    7086:	fa02 f000 	lsl.w	r0, r2, r0
    708a:	e7b7      	b.n	6ffc <Pixel_pixelEvaluation+0x10c>
    708c:	8862      	ldrh	r2, [r4, #2]
    708e:	6861      	ldr	r1, [r4, #4]
    7090:	ebab 0302 	sub.w	r3, fp, r2
    7094:	b280      	uxth	r0, r0
    7096:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    709a:	fa02 f000 	lsl.w	r0, r2, r0
    709e:	e7b6      	b.n	700e <Pixel_pixelEvaluation+0x11e>
    70a0:	8862      	ldrh	r2, [r4, #2]
    70a2:	6861      	ldr	r1, [r4, #4]
    70a4:	ebab 0302 	sub.w	r3, fp, r2
    70a8:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    70ac:	fa02 f000 	lsl.w	r0, r2, r0
    70b0:	e7b7      	b.n	7022 <Pixel_pixelEvaluation+0x132>
    70b2:	4853      	ldr	r0, [pc, #332]	; (7200 <Pixel_pixelEvaluation+0x310>)
    70b4:	e792      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, >>= );
    70b6:	7862      	ldrb	r2, [r4, #1]
    70b8:	2a10      	cmp	r2, #16
    70ba:	d00c      	beq.n	70d6 <Pixel_pixelEvaluation+0x1e6>
    70bc:	2a20      	cmp	r2, #32
    70be:	d014      	beq.n	70ea <Pixel_pixelEvaluation+0x1fa>
    70c0:	2a08      	cmp	r2, #8
    70c2:	d11b      	bne.n	70fc <Pixel_pixelEvaluation+0x20c>
    70c4:	8862      	ldrh	r2, [r4, #2]
    70c6:	6861      	ldr	r1, [r4, #4]
    70c8:	ebab 0302 	sub.w	r3, fp, r2
    70cc:	b2c0      	uxtb	r0, r0
    70ce:	5cca      	ldrb	r2, [r1, r3]
    70d0:	fa42 f000 	asr.w	r0, r2, r0
    70d4:	e792      	b.n	6ffc <Pixel_pixelEvaluation+0x10c>
    70d6:	8862      	ldrh	r2, [r4, #2]
    70d8:	6861      	ldr	r1, [r4, #4]
    70da:	ebab 0302 	sub.w	r3, fp, r2
    70de:	b280      	uxth	r0, r0
    70e0:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    70e4:	fa42 f000 	asr.w	r0, r2, r0
    70e8:	e791      	b.n	700e <Pixel_pixelEvaluation+0x11e>
    70ea:	8862      	ldrh	r2, [r4, #2]
    70ec:	6861      	ldr	r1, [r4, #4]
    70ee:	ebab 0302 	sub.w	r3, fp, r2
    70f2:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    70f6:	fa22 f000 	lsr.w	r0, r2, r0
    70fa:	e792      	b.n	7022 <Pixel_pixelEvaluation+0x132>
    70fc:	4841      	ldr	r0, [pc, #260]	; (7204 <Pixel_pixelEvaluation+0x314>)
    70fe:	e76d      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
			switch ( pixbuf->width )
    7100:	7862      	ldrb	r2, [r4, #1]
    7102:	2a10      	cmp	r2, #16
    7104:	d015      	beq.n	7132 <Pixel_pixelEvaluation+0x242>
    7106:	2a20      	cmp	r2, #32
    7108:	d028      	beq.n	715c <Pixel_pixelEvaluation+0x26c>
    710a:	2a08      	cmp	r2, #8
    710c:	d134      	bne.n	7178 <Pixel_pixelEvaluation+0x288>
				uint8_t prev = PixelBuf8( pixbuf, ch_pos );
    710e:	8862      	ldrh	r2, [r4, #2]
    7110:	6863      	ldr	r3, [r4, #4]
    7112:	ebab 0202 	sub.w	r2, fp, r2
    7116:	5c99      	ldrb	r1, [r3, r2]
				PixelBuf8( pixbuf, ch_pos ) += (uint8_t)mod_value;
    7118:	4408      	add	r0, r1
    711a:	5498      	strb	r0, [r3, r2]
				if ( prev > PixelBuf8( pixbuf, ch_pos ) )
    711c:	8862      	ldrh	r2, [r4, #2]
    711e:	ebab 0302 	sub.w	r3, fp, r2
    7122:	6862      	ldr	r2, [r4, #4]
    7124:	5cd0      	ldrb	r0, [r2, r3]
    7126:	4288      	cmp	r0, r1
    7128:	f4bf af47 	bcs.w	6fba <Pixel_pixelEvaluation+0xca>
					PixelBuf8( pixbuf, ch_pos ) = 0xFF;
    712c:	21ff      	movs	r1, #255	; 0xff
					PixelBuf8( pixbuf, ch_pos ) = 0;
    712e:	54d1      	strb	r1, [r2, r3]
    7130:	e743      	b.n	6fba <Pixel_pixelEvaluation+0xca>
				PixelBuf16( pixbuf, ch_pos ) += (uint16_t)mod_value;
    7132:	8861      	ldrh	r1, [r4, #2]
    7134:	6862      	ldr	r2, [r4, #4]
    7136:	ebab 0101 	sub.w	r1, fp, r1
    713a:	f832 c011 	ldrh.w	ip, [r2, r1, lsl #1]
    713e:	4460      	add	r0, ip
    7140:	f822 0011 	strh.w	r0, [r2, r1, lsl #1]
				if ( 0xFF < PixelBuf16( pixbuf, ch_pos ) )
    7144:	8861      	ldrh	r1, [r4, #2]
    7146:	ebab 0301 	sub.w	r3, fp, r1
    714a:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    714e:	29ff      	cmp	r1, #255	; 0xff
    7150:	f67f af33 	bls.w	6fba <Pixel_pixelEvaluation+0xca>
					PixelBuf16( pixbuf, ch_pos ) = 0xFF;
    7154:	21ff      	movs	r1, #255	; 0xff
					PixelBuf16( pixbuf, ch_pos ) = 0;
    7156:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    715a:	e72e      	b.n	6fba <Pixel_pixelEvaluation+0xca>
				uint32_t prev = PixelBuf32( pixbuf, ch_pos );
    715c:	8862      	ldrh	r2, [r4, #2]
    715e:	6861      	ldr	r1, [r4, #4]
    7160:	ebab 0302 	sub.w	r3, fp, r2
    7164:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    7168:	1880      	adds	r0, r0, r2
    716a:	f4ff af5a 	bcc.w	7022 <Pixel_pixelEvaluation+0x132>
					PixelBuf32( pixbuf, ch_pos ) = 0xFFFFFFFF;
    716e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7172:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    7176:	e720      	b.n	6fba <Pixel_pixelEvaluation+0xca>
				warn_print("Invalid width mapping on set");
    7178:	4823      	ldr	r0, [pc, #140]	; (7208 <Pixel_pixelEvaluation+0x318>)
    717a:	e72f      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
			switch ( pixbuf->width )
    717c:	7862      	ldrb	r2, [r4, #1]
    717e:	2a10      	cmp	r2, #16
    7180:	d014      	beq.n	71ac <Pixel_pixelEvaluation+0x2bc>
    7182:	2a20      	cmp	r2, #32
    7184:	d026      	beq.n	71d4 <Pixel_pixelEvaluation+0x2e4>
    7186:	2a08      	cmp	r2, #8
    7188:	d1f6      	bne.n	7178 <Pixel_pixelEvaluation+0x288>
				uint8_t prev = PixelBuf8( pixbuf, ch_pos );
    718a:	8862      	ldrh	r2, [r4, #2]
    718c:	6863      	ldr	r3, [r4, #4]
    718e:	ebab 0202 	sub.w	r2, fp, r2
    7192:	5c99      	ldrb	r1, [r3, r2]
				PixelBuf8( pixbuf, ch_pos ) -= (uint8_t)mod_value;
    7194:	1a08      	subs	r0, r1, r0
    7196:	5498      	strb	r0, [r3, r2]
				if ( prev < PixelBuf8( pixbuf, ch_pos ) )
    7198:	8862      	ldrh	r2, [r4, #2]
    719a:	ebab 0302 	sub.w	r3, fp, r2
    719e:	6862      	ldr	r2, [r4, #4]
    71a0:	5cd0      	ldrb	r0, [r2, r3]
    71a2:	4288      	cmp	r0, r1
    71a4:	f67f af09 	bls.w	6fba <Pixel_pixelEvaluation+0xca>
					PixelBuf8( pixbuf, ch_pos ) = 0;
    71a8:	2100      	movs	r1, #0
    71aa:	e7c0      	b.n	712e <Pixel_pixelEvaluation+0x23e>
				uint16_t prev = PixelBuf16( pixbuf, ch_pos );
    71ac:	f8b4 c002 	ldrh.w	ip, [r4, #2]
    71b0:	6862      	ldr	r2, [r4, #4]
    71b2:	ebab 0c0c 	sub.w	ip, fp, ip
    71b6:	f832 101c 	ldrh.w	r1, [r2, ip, lsl #1]
				PixelBuf16( pixbuf, ch_pos ) -= (uint16_t)mod_value;
    71ba:	1a08      	subs	r0, r1, r0
    71bc:	f822 001c 	strh.w	r0, [r2, ip, lsl #1]
				if ( prev < PixelBuf16( pixbuf, ch_pos ) )
    71c0:	8860      	ldrh	r0, [r4, #2]
    71c2:	ebab 0300 	sub.w	r3, fp, r0
    71c6:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    71ca:	4288      	cmp	r0, r1
    71cc:	f67f aef5 	bls.w	6fba <Pixel_pixelEvaluation+0xca>
					PixelBuf16( pixbuf, ch_pos ) = 0;
    71d0:	2100      	movs	r1, #0
    71d2:	e7c0      	b.n	7156 <Pixel_pixelEvaluation+0x266>
				uint32_t prev = PixelBuf32( pixbuf, ch_pos );
    71d4:	8862      	ldrh	r2, [r4, #2]
    71d6:	6861      	ldr	r1, [r4, #4]
    71d8:	ebab 0302 	sub.w	r3, fp, r2
    71dc:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    71e0:	1a22      	subs	r2, r4, r0
				PixelBuf32( pixbuf, ch_pos ) -= (uint32_t)mod_value;
    71e2:	4284      	cmp	r4, r0
    71e4:	bf2c      	ite	cs
    71e6:	4610      	movcs	r0, r2
    71e8:	2000      	movcc	r0, #0
    71ea:	e71a      	b.n	7022 <Pixel_pixelEvaluation+0x132>
			warn_print("Unimplemented pixel modifier");
    71ec:	4807      	ldr	r0, [pc, #28]	; (720c <Pixel_pixelEvaluation+0x31c>)
    71ee:	e6f5      	b.n	6fdc <Pixel_pixelEvaluation+0xec>
    71f0:	0000f67a 	.word	0x0000f67a
    71f4:	0000f6b4 	.word	0x0000f6b4
    71f8:	0000f6e7 	.word	0x0000f6e7
    71fc:	0000f71b 	.word	0x0000f71b
    7200:	0000f74f 	.word	0x0000f74f
    7204:	0000f784 	.word	0x0000f784
    7208:	0000f7b9 	.word	0x0000f7b9
    720c:	0000f7ed 	.word	0x0000f7ed

00007210 <Pixel_pixelTweenNextPos>:
{
    7210:	b508      	push	{r3, lr}
	if ( elem != 0 )
    7212:	b130      	cbz	r0, 7222 <Pixel_pixelTweenNextPos+0x12>
		ret = ( ( elem->width / 8 + sizeof( PixelChange ) ) * elem->channels ) + sizeof( PixelModElement );
    7214:	7803      	ldrb	r3, [r0, #0]
    7216:	7840      	ldrb	r0, [r0, #1]
    7218:	08db      	lsrs	r3, r3, #3
		ret = ( ( prev->width / 8 + sizeof( PixelChange ) ) * prev->channels ) + sizeof( PixelModElement );
    721a:	fb03 0000 	mla	r0, r3, r0, r0
    721e:	3005      	adds	r0, #5
}
    7220:	bd08      	pop	{r3, pc}
	if ( prev != 0 )
    7222:	b119      	cbz	r1, 722c <Pixel_pixelTweenNextPos+0x1c>
		ret = ( ( prev->width / 8 + sizeof( PixelChange ) ) * prev->channels ) + sizeof( PixelModElement );
    7224:	7808      	ldrb	r0, [r1, #0]
    7226:	08c3      	lsrs	r3, r0, #3
    7228:	7848      	ldrb	r0, [r1, #1]
    722a:	e7f6      	b.n	721a <Pixel_pixelTweenNextPos+0xa>
	erro_print("Pixel Tween Bug!");
    722c:	4802      	ldr	r0, [pc, #8]	; (7238 <Pixel_pixelTweenNextPos+0x28>)
    722e:	f004 f8e7 	bl	b400 <_print>
	return ret;
    7232:	200b      	movs	r0, #11
    7234:	e7f4      	b.n	7220 <Pixel_pixelTweenNextPos+0x10>
    7236:	bf00      	nop
    7238:	0000f821 	.word	0x0000f821

0000723c <Pixel_channelSet>:
{
    723c:	b570      	push	{r4, r5, r6, lr}
    723e:	4604      	mov	r4, r0
    7240:	460e      	mov	r6, r1
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    7242:	f7ff fe27 	bl	6e94 <Pixel_bufferMap>
	switch ( pixbuf->width )
    7246:	7843      	ldrb	r3, [r0, #1]
    7248:	2b08      	cmp	r3, #8
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    724a:	4605      	mov	r5, r0
	switch ( pixbuf->width )
    724c:	d014      	beq.n	7278 <Pixel_channelSet+0x3c>
    724e:	2b10      	cmp	r3, #16
    7250:	d017      	beq.n	7282 <Pixel_channelSet+0x46>
    7252:	b1ab      	cbz	r3, 7280 <Pixel_channelSet+0x44>
		warn_msg("ChanSet Unknown width: ");
    7254:	480e      	ldr	r0, [pc, #56]	; (7290 <Pixel_channelSet+0x54>)
    7256:	f004 f8d3 	bl	b400 <_print>
		printInt8( pixbuf->width );
    725a:	7868      	ldrb	r0, [r5, #1]
    725c:	f004 f902 	bl	b464 <printInt8>
		print(" Ch: ");
    7260:	480c      	ldr	r0, [pc, #48]	; (7294 <Pixel_channelSet+0x58>)
    7262:	f004 f8cd 	bl	b400 <_print>
		printHex( channel );
    7266:	4620      	mov	r0, r4
    7268:	2101      	movs	r1, #1
    726a:	f004 f971 	bl	b550 <printHex_op>
		print( NL );
    726e:	480a      	ldr	r0, [pc, #40]	; (7298 <Pixel_channelSet+0x5c>)
}
    7270:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print( NL );
    7274:	f004 b8c4 	b.w	b400 <_print>
		PixelBuf8( pixbuf, channel ) = (uint8_t)value;
    7278:	8843      	ldrh	r3, [r0, #2]
    727a:	1ae4      	subs	r4, r4, r3
    727c:	6843      	ldr	r3, [r0, #4]
    727e:	551e      	strb	r6, [r3, r4]
}
    7280:	bd70      	pop	{r4, r5, r6, pc}
		PixelBuf16( pixbuf, channel ) = (uint16_t)value;
    7282:	8843      	ldrh	r3, [r0, #2]
    7284:	1ae4      	subs	r4, r4, r3
    7286:	6843      	ldr	r3, [r0, #4]
    7288:	f823 6014 	strh.w	r6, [r3, r4, lsl #1]
}
    728c:	e7f8      	b.n	7280 <Pixel_channelSet+0x44>
    728e:	bf00      	nop
    7290:	0000f54a 	.word	0x0000f54a
    7294:	0000f577 	.word	0x0000f577
    7298:	00010d99 	.word	0x00010d99

0000729c <Pixel_channelToggle>:
{
    729c:	b538      	push	{r3, r4, r5, lr}
    729e:	4604      	mov	r4, r0
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    72a0:	f7ff fdf8 	bl	6e94 <Pixel_bufferMap>
	switch ( pixbuf->width )
    72a4:	7843      	ldrb	r3, [r0, #1]
    72a6:	2b08      	cmp	r3, #8
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    72a8:	4605      	mov	r5, r0
	switch ( pixbuf->width )
    72aa:	d014      	beq.n	72d6 <Pixel_channelToggle+0x3a>
    72ac:	2b10      	cmp	r3, #16
    72ae:	d01a      	beq.n	72e6 <Pixel_channelToggle+0x4a>
    72b0:	b1c3      	cbz	r3, 72e4 <Pixel_channelToggle+0x48>
		warn_msg("ChanToggle Unknown width: ");
    72b2:	4812      	ldr	r0, [pc, #72]	; (72fc <Pixel_channelToggle+0x60>)
    72b4:	f004 f8a4 	bl	b400 <_print>
		printInt8( pixbuf->width );
    72b8:	7868      	ldrb	r0, [r5, #1]
    72ba:	f004 f8d3 	bl	b464 <printInt8>
		print(" Ch: ");
    72be:	4810      	ldr	r0, [pc, #64]	; (7300 <Pixel_channelToggle+0x64>)
    72c0:	f004 f89e 	bl	b400 <_print>
		printHex( channel );
    72c4:	4620      	mov	r0, r4
    72c6:	2101      	movs	r1, #1
    72c8:	f004 f942 	bl	b550 <printHex_op>
		print( NL );
    72cc:	480d      	ldr	r0, [pc, #52]	; (7304 <Pixel_channelToggle+0x68>)
}
    72ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print( NL );
    72d2:	f004 b895 	b.w	b400 <_print>
		PixelBuf8( pixbuf, channel ) ^= 128;
    72d6:	8843      	ldrh	r3, [r0, #2]
    72d8:	6842      	ldr	r2, [r0, #4]
    72da:	1ae4      	subs	r4, r4, r3
    72dc:	5d13      	ldrb	r3, [r2, r4]
    72de:	f083 0380 	eor.w	r3, r3, #128	; 0x80
    72e2:	5513      	strb	r3, [r2, r4]
}
    72e4:	bd38      	pop	{r3, r4, r5, pc}
		PixelBuf16( pixbuf, channel ) ^= 128;
    72e6:	8843      	ldrh	r3, [r0, #2]
    72e8:	6842      	ldr	r2, [r0, #4]
    72ea:	1ae4      	subs	r4, r4, r3
    72ec:	f832 3014 	ldrh.w	r3, [r2, r4, lsl #1]
    72f0:	f083 0380 	eor.w	r3, r3, #128	; 0x80
    72f4:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
}
    72f8:	e7f4      	b.n	72e4 <Pixel_channelToggle+0x48>
    72fa:	bf00      	nop
    72fc:	0000f57d 	.word	0x0000f57d
    7300:	0000f577 	.word	0x0000f577
    7304:	00010d99 	.word	0x00010d99

00007308 <cliFunc_chanTest>:
{
    7308:	b513      	push	{r0, r1, r4, lr}
    730a:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    730c:	4834      	ldr	r0, [pc, #208]	; (73e0 <cliFunc_chanTest+0xd8>)
    730e:	f004 f877 	bl	b400 <_print>
	char* arg2Ptr = args;
    7312:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7314:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    7316:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    731a:	4669      	mov	r1, sp
    731c:	f003 fc68 	bl	abf0 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    7320:	9b00      	ldr	r3, [sp, #0]
    7322:	4c30      	ldr	r4, [pc, #192]	; (73e4 <cliFunc_chanTest+0xdc>)
    7324:	781b      	ldrb	r3, [r3, #0]
    7326:	2b53      	cmp	r3, #83	; 0x53
    7328:	d042      	beq.n	73b0 <cliFunc_chanTest+0xa8>
    732a:	d82e      	bhi.n	738a <cliFunc_chanTest+0x82>
    732c:	2b46      	cmp	r3, #70	; 0x46
    732e:	d033      	beq.n	7398 <cliFunc_chanTest+0x90>
    7330:	d81f      	bhi.n	7372 <cliFunc_chanTest+0x6a>
    7332:	2b41      	cmp	r3, #65	; 0x41
    7334:	d042      	beq.n	73bc <cliFunc_chanTest+0xb4>
	if ( *arg1Ptr != '\0' )
    7336:	9800      	ldr	r0, [sp, #0]
    7338:	7803      	ldrb	r3, [r0, #0]
    733a:	b113      	cbz	r3, 7342 <cliFunc_chanTest+0x3a>
		Pixel_testPos = numToInt( arg1Ptr );
    733c:	f004 f973 	bl	b626 <numToInt>
    7340:	8020      	strh	r0, [r4, #0]
	print( NL );
    7342:	4827      	ldr	r0, [pc, #156]	; (73e0 <cliFunc_chanTest+0xd8>)
    7344:	f004 f85c 	bl	b400 <_print>
	info_msg("Channel: ");
    7348:	4827      	ldr	r0, [pc, #156]	; (73e8 <cliFunc_chanTest+0xe0>)
    734a:	f004 f859 	bl	b400 <_print>
	printInt16( Pixel_testPos );
    734e:	8820      	ldrh	r0, [r4, #0]
    7350:	f004 f8a6 	bl	b4a0 <printInt16>
	print( NL );
    7354:	4822      	ldr	r0, [pc, #136]	; (73e0 <cliFunc_chanTest+0xd8>)
    7356:	f004 f853 	bl	b400 <_print>
	Pixel_channelToggle( Pixel_testPos );
    735a:	8820      	ldrh	r0, [r4, #0]
    735c:	f7ff ff9e 	bl	729c <Pixel_channelToggle>
	Pixel_testPos++;
    7360:	8823      	ldrh	r3, [r4, #0]
    7362:	3301      	adds	r3, #1
    7364:	b29b      	uxth	r3, r3
	if ( Pixel_testPos >= Pixel_TotalChannels_KLL )
    7366:	2b8f      	cmp	r3, #143	; 0x8f
		Pixel_testPos = 0;
    7368:	bf88      	it	hi
    736a:	2300      	movhi	r3, #0
    736c:	8023      	strh	r3, [r4, #0]
}
    736e:	b002      	add	sp, #8
    7370:	bd10      	pop	{r4, pc}
	switch ( *arg1Ptr )
    7372:	2b4f      	cmp	r3, #79	; 0x4f
    7374:	d02b      	beq.n	73ce <cliFunc_chanTest+0xc6>
    7376:	2b52      	cmp	r3, #82	; 0x52
    7378:	d1dd      	bne.n	7336 <cliFunc_chanTest+0x2e>
		info_msg("Channel roll test");
    737a:	481c      	ldr	r0, [pc, #112]	; (73ec <cliFunc_chanTest+0xe4>)
    737c:	f004 f840 	bl	b400 <_print>
		Pixel_testPos = 0;
    7380:	2300      	movs	r3, #0
    7382:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Chan_Roll;
    7384:	2202      	movs	r2, #2
    7386:	4b1a      	ldr	r3, [pc, #104]	; (73f0 <cliFunc_chanTest+0xe8>)
    7388:	e01f      	b.n	73ca <cliFunc_chanTest+0xc2>
	switch ( *arg1Ptr )
    738a:	2b6f      	cmp	r3, #111	; 0x6f
    738c:	d01f      	beq.n	73ce <cliFunc_chanTest+0xc6>
    738e:	d80b      	bhi.n	73a8 <cliFunc_chanTest+0xa0>
    7390:	2b61      	cmp	r3, #97	; 0x61
    7392:	d013      	beq.n	73bc <cliFunc_chanTest+0xb4>
    7394:	2b66      	cmp	r3, #102	; 0x66
    7396:	d1ce      	bne.n	7336 <cliFunc_chanTest+0x2e>
		info_msg("Enable all pixels");
    7398:	4816      	ldr	r0, [pc, #88]	; (73f4 <cliFunc_chanTest+0xec>)
    739a:	f004 f831 	bl	b400 <_print>
		Pixel_testPos = 0;
    739e:	2300      	movs	r3, #0
    73a0:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Chan_Full;
    73a2:	2203      	movs	r2, #3
    73a4:	4b12      	ldr	r3, [pc, #72]	; (73f0 <cliFunc_chanTest+0xe8>)
    73a6:	e010      	b.n	73ca <cliFunc_chanTest+0xc2>
	switch ( *arg1Ptr )
    73a8:	2b72      	cmp	r3, #114	; 0x72
    73aa:	d0e6      	beq.n	737a <cliFunc_chanTest+0x72>
    73ac:	2b73      	cmp	r3, #115	; 0x73
    73ae:	d1c2      	bne.n	7336 <cliFunc_chanTest+0x2e>
		info_msg("Stopping channel test");
    73b0:	4811      	ldr	r0, [pc, #68]	; (73f8 <cliFunc_chanTest+0xf0>)
    73b2:	f004 f825 	bl	b400 <_print>
		Pixel_testMode = PixelTest_Off;
    73b6:	4b0e      	ldr	r3, [pc, #56]	; (73f0 <cliFunc_chanTest+0xe8>)
    73b8:	2200      	movs	r2, #0
    73ba:	e006      	b.n	73ca <cliFunc_chanTest+0xc2>
		info_msg("All channel test");
    73bc:	480f      	ldr	r0, [pc, #60]	; (73fc <cliFunc_chanTest+0xf4>)
    73be:	f004 f81f 	bl	b400 <_print>
		Pixel_testPos = 0;
    73c2:	2300      	movs	r3, #0
    73c4:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Chan_All;
    73c6:	4b0a      	ldr	r3, [pc, #40]	; (73f0 <cliFunc_chanTest+0xe8>)
    73c8:	2201      	movs	r2, #1
		Pixel_testMode = PixelTest_Chan_Off;
    73ca:	701a      	strb	r2, [r3, #0]
		break;
    73cc:	e7b3      	b.n	7336 <cliFunc_chanTest+0x2e>
		info_msg("Disable all pixels");
    73ce:	480c      	ldr	r0, [pc, #48]	; (7400 <cliFunc_chanTest+0xf8>)
    73d0:	f004 f816 	bl	b400 <_print>
		Pixel_testPos = 0;
    73d4:	2300      	movs	r3, #0
    73d6:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Chan_Off;
    73d8:	2204      	movs	r2, #4
    73da:	4b05      	ldr	r3, [pc, #20]	; (73f0 <cliFunc_chanTest+0xe8>)
    73dc:	e7f5      	b.n	73ca <cliFunc_chanTest+0xc2>
    73de:	bf00      	nop
    73e0:	00010d99 	.word	0x00010d99
    73e4:	1fff93e0 	.word	0x1fff93e0
    73e8:	0000fa42 	.word	0x0000fa42
    73ec:	0000f9ad 	.word	0x0000f9ad
    73f0:	1fffa8a8 	.word	0x1fffa8a8
    73f4:	0000f9f9 	.word	0x0000f9f9
    73f8:	0000f9d1 	.word	0x0000f9d1
    73fc:	0000f98a 	.word	0x0000f98a
    7400:	0000fa1d 	.word	0x0000fa1d

00007404 <Pixel_pixelSet>:
{
    7404:	b570      	push	{r4, r5, r6, lr}
	for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    7406:	2300      	movs	r3, #0
{
    7408:	4604      	mov	r4, r0
    740a:	460e      	mov	r6, r1
	for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    740c:	7862      	ldrb	r2, [r4, #1]
    740e:	1c5d      	adds	r5, r3, #1
    7410:	b2db      	uxtb	r3, r3
    7412:	429a      	cmp	r2, r3
    7414:	d800      	bhi.n	7418 <Pixel_pixelSet+0x14>
}
    7416:	bd70      	pop	{r4, r5, r6, pc}
		Pixel_channelSet( elem->indices[ch], value );
    7418:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    741c:	4631      	mov	r1, r6
    741e:	8858      	ldrh	r0, [r3, #2]
    7420:	f7ff ff0c 	bl	723c <Pixel_channelSet>
    7424:	462b      	mov	r3, r5
    7426:	e7f1      	b.n	740c <Pixel_pixelSet+0x8>

00007428 <Pixel_clearPixels>:
{
    7428:	b538      	push	{r3, r4, r5, lr}
		Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    742a:	4d05      	ldr	r5, [pc, #20]	; (7440 <Pixel_clearPixels+0x18>)
{
    742c:	2400      	movs	r4, #0
		Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    742e:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
    7432:	2100      	movs	r1, #0
    7434:	3401      	adds	r4, #1
    7436:	f7ff ffe5 	bl	7404 <Pixel_pixelSet>
	for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    743a:	2c26      	cmp	r4, #38	; 0x26
    743c:	d1f7      	bne.n	742e <Pixel_clearPixels+0x6>
}
    743e:	bd38      	pop	{r3, r4, r5, pc}
    7440:	0000fff0 	.word	0x0000fff0

00007444 <Pixel_pixelToggle>:
{
    7444:	b538      	push	{r3, r4, r5, lr}
    7446:	4604      	mov	r4, r0
	for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    7448:	2300      	movs	r3, #0
    744a:	7862      	ldrb	r2, [r4, #1]
    744c:	1c5d      	adds	r5, r3, #1
    744e:	b2db      	uxtb	r3, r3
    7450:	429a      	cmp	r2, r3
    7452:	d800      	bhi.n	7456 <Pixel_pixelToggle+0x12>
}
    7454:	bd38      	pop	{r3, r4, r5, pc}
		Pixel_channelToggle( elem->indices[ch] );
    7456:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    745a:	8858      	ldrh	r0, [r3, #2]
    745c:	f7ff ff1e 	bl	729c <Pixel_channelToggle>
    7460:	462b      	mov	r3, r5
    7462:	e7f2      	b.n	744a <Pixel_pixelToggle+0x6>

00007464 <cliFunc_pixelTest>:
{
    7464:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7466:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    7468:	483b      	ldr	r0, [pc, #236]	; (7558 <cliFunc_pixelTest+0xf4>)
    746a:	f003 ffc9 	bl	b400 <_print>
	char* arg2Ptr = args;
    746e:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7470:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    7472:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7476:	4669      	mov	r1, sp
    7478:	f003 fbba 	bl	abf0 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    747c:	9800      	ldr	r0, [sp, #0]
    747e:	7803      	ldrb	r3, [r0, #0]
    7480:	2b53      	cmp	r3, #83	; 0x53
    7482:	d04e      	beq.n	7522 <cliFunc_pixelTest+0xbe>
    7484:	d839      	bhi.n	74fa <cliFunc_pixelTest+0x96>
    7486:	2b46      	cmp	r3, #70	; 0x46
    7488:	d03e      	beq.n	7508 <cliFunc_pixelTest+0xa4>
    748a:	d829      	bhi.n	74e0 <cliFunc_pixelTest+0x7c>
    748c:	2b41      	cmp	r3, #65	; 0x41
    748e:	d04e      	beq.n	752e <cliFunc_pixelTest+0xca>
    7490:	4c32      	ldr	r4, [pc, #200]	; (755c <cliFunc_pixelTest+0xf8>)
	if ( *arg1Ptr != '\0' )
    7492:	b113      	cbz	r3, 749a <cliFunc_pixelTest+0x36>
		Pixel_testPos = numToInt( arg1Ptr );
    7494:	f004 f8c7 	bl	b626 <numToInt>
    7498:	8020      	strh	r0, [r4, #0]
	print( NL );
    749a:	482f      	ldr	r0, [pc, #188]	; (7558 <cliFunc_pixelTest+0xf4>)
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_testPos ];
    749c:	4d30      	ldr	r5, [pc, #192]	; (7560 <cliFunc_pixelTest+0xfc>)
	print( NL );
    749e:	f003 ffaf 	bl	b400 <_print>
	info_msg("Pixel: ");
    74a2:	4830      	ldr	r0, [pc, #192]	; (7564 <cliFunc_pixelTest+0x100>)
    74a4:	f003 ffac 	bl	b400 <_print>
	printInt16( Pixel_testPos + 1 );
    74a8:	8820      	ldrh	r0, [r4, #0]
    74aa:	3001      	adds	r0, #1
    74ac:	b280      	uxth	r0, r0
    74ae:	f003 fff7 	bl	b4a0 <printInt16>
	print(" ");
    74b2:	482d      	ldr	r0, [pc, #180]	; (7568 <cliFunc_pixelTest+0x104>)
    74b4:	f003 ffa4 	bl	b400 <_print>
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_testPos ];
    74b8:	8823      	ldrh	r3, [r4, #0]
    74ba:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
	Pixel_showPixelElement( elem );
    74be:	4628      	mov	r0, r5
    74c0:	f7ff fc1c 	bl	6cfc <Pixel_showPixelElement>
	print( NL );
    74c4:	4824      	ldr	r0, [pc, #144]	; (7558 <cliFunc_pixelTest+0xf4>)
    74c6:	f003 ff9b 	bl	b400 <_print>
	Pixel_pixelToggle( elem );
    74ca:	4628      	mov	r0, r5
    74cc:	f7ff ffba 	bl	7444 <Pixel_pixelToggle>
	Pixel_testPos++;
    74d0:	8823      	ldrh	r3, [r4, #0]
    74d2:	3301      	adds	r3, #1
    74d4:	b29b      	uxth	r3, r3
	if ( Pixel_testPos >= Pixel_TotalPixels_KLL )
    74d6:	2b25      	cmp	r3, #37	; 0x25
		Pixel_testPos = 0;
    74d8:	bf88      	it	hi
    74da:	2300      	movhi	r3, #0
    74dc:	8023      	strh	r3, [r4, #0]
    74de:	e02f      	b.n	7540 <cliFunc_pixelTest+0xdc>
	switch ( *arg1Ptr )
    74e0:	2b4f      	cmp	r3, #79	; 0x4f
    74e2:	d02f      	beq.n	7544 <cliFunc_pixelTest+0xe0>
    74e4:	2b52      	cmp	r3, #82	; 0x52
    74e6:	d1d3      	bne.n	7490 <cliFunc_pixelTest+0x2c>
		info_msg("Pixel roll test");
    74e8:	4820      	ldr	r0, [pc, #128]	; (756c <cliFunc_pixelTest+0x108>)
    74ea:	f003 ff89 	bl	b400 <_print>
		Pixel_testPos = 0;
    74ee:	4b1b      	ldr	r3, [pc, #108]	; (755c <cliFunc_pixelTest+0xf8>)
    74f0:	2200      	movs	r2, #0
    74f2:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Roll;
    74f4:	4b1e      	ldr	r3, [pc, #120]	; (7570 <cliFunc_pixelTest+0x10c>)
    74f6:	2206      	movs	r2, #6
    74f8:	e021      	b.n	753e <cliFunc_pixelTest+0xda>
	switch ( *arg1Ptr )
    74fa:	2b6f      	cmp	r3, #111	; 0x6f
    74fc:	d022      	beq.n	7544 <cliFunc_pixelTest+0xe0>
    74fe:	d80c      	bhi.n	751a <cliFunc_pixelTest+0xb6>
    7500:	2b61      	cmp	r3, #97	; 0x61
    7502:	d014      	beq.n	752e <cliFunc_pixelTest+0xca>
    7504:	2b66      	cmp	r3, #102	; 0x66
    7506:	d1c3      	bne.n	7490 <cliFunc_pixelTest+0x2c>
		info_msg("Enable all pixels");
    7508:	481a      	ldr	r0, [pc, #104]	; (7574 <cliFunc_pixelTest+0x110>)
    750a:	f003 ff79 	bl	b400 <_print>
		Pixel_testPos = 0;
    750e:	4b13      	ldr	r3, [pc, #76]	; (755c <cliFunc_pixelTest+0xf8>)
    7510:	2200      	movs	r2, #0
    7512:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Full;
    7514:	4b16      	ldr	r3, [pc, #88]	; (7570 <cliFunc_pixelTest+0x10c>)
    7516:	2207      	movs	r2, #7
    7518:	e011      	b.n	753e <cliFunc_pixelTest+0xda>
	switch ( *arg1Ptr )
    751a:	2b72      	cmp	r3, #114	; 0x72
    751c:	d0e4      	beq.n	74e8 <cliFunc_pixelTest+0x84>
    751e:	2b73      	cmp	r3, #115	; 0x73
    7520:	d1b6      	bne.n	7490 <cliFunc_pixelTest+0x2c>
		info_msg("Stopping pixel test");
    7522:	4815      	ldr	r0, [pc, #84]	; (7578 <cliFunc_pixelTest+0x114>)
    7524:	f003 ff6c 	bl	b400 <_print>
		Pixel_testMode = PixelTest_Off;
    7528:	4b11      	ldr	r3, [pc, #68]	; (7570 <cliFunc_pixelTest+0x10c>)
    752a:	2200      	movs	r2, #0
    752c:	e007      	b.n	753e <cliFunc_pixelTest+0xda>
		info_msg("All pixel test");
    752e:	4813      	ldr	r0, [pc, #76]	; (757c <cliFunc_pixelTest+0x118>)
    7530:	f003 ff66 	bl	b400 <_print>
		Pixel_testPos = 0;
    7534:	4b09      	ldr	r3, [pc, #36]	; (755c <cliFunc_pixelTest+0xf8>)
    7536:	2200      	movs	r2, #0
    7538:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_All;
    753a:	4b0d      	ldr	r3, [pc, #52]	; (7570 <cliFunc_pixelTest+0x10c>)
    753c:	2205      	movs	r2, #5
		Pixel_testMode = PixelTest_Pixel_Off;
    753e:	701a      	strb	r2, [r3, #0]
}
    7540:	b003      	add	sp, #12
    7542:	bd30      	pop	{r4, r5, pc}
		info_msg("Disable all pixels");
    7544:	480e      	ldr	r0, [pc, #56]	; (7580 <cliFunc_pixelTest+0x11c>)
    7546:	f003 ff5b 	bl	b400 <_print>
		Pixel_testPos = 0;
    754a:	4b04      	ldr	r3, [pc, #16]	; (755c <cliFunc_pixelTest+0xf8>)
    754c:	2200      	movs	r2, #0
    754e:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Off;
    7550:	4b07      	ldr	r3, [pc, #28]	; (7570 <cliFunc_pixelTest+0x10c>)
    7552:	2208      	movs	r2, #8
    7554:	e7f3      	b.n	753e <cliFunc_pixelTest+0xda>
    7556:	bf00      	nop
    7558:	00010d99 	.word	0x00010d99
    755c:	1fff93e0 	.word	0x1fff93e0
    7560:	0000fff0 	.word	0x0000fff0
    7564:	0000fbd3 	.word	0x0000fbd3
    7568:	00011f77 	.word	0x00011f77
    756c:	0000fb8b 	.word	0x0000fb8b
    7570:	1fffa8a8 	.word	0x1fffa8a8
    7574:	0000f9f9 	.word	0x0000f9f9
    7578:	0000fbad 	.word	0x0000fbad
    757c:	0000fb6a 	.word	0x0000fb6a
    7580:	0000fa1d 	.word	0x0000fa1d

00007584 <cliFunc_pixelSCTest>:
{
    7584:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7586:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    7588:	4832      	ldr	r0, [pc, #200]	; (7654 <cliFunc_pixelSCTest+0xd0>)
    758a:	f003 ff39 	bl	b400 <_print>
	char* arg2Ptr = args;
    758e:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7590:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    7592:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7596:	4669      	mov	r1, sp
    7598:	f003 fb2a 	bl	abf0 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    759c:	9b00      	ldr	r3, [sp, #0]
    759e:	4c2e      	ldr	r4, [pc, #184]	; (7658 <cliFunc_pixelSCTest+0xd4>)
    75a0:	781b      	ldrb	r3, [r3, #0]
    75a2:	2b53      	cmp	r3, #83	; 0x53
    75a4:	d050      	beq.n	7648 <cliFunc_pixelSCTest+0xc4>
    75a6:	d838      	bhi.n	761a <cliFunc_pixelSCTest+0x96>
    75a8:	2b41      	cmp	r3, #65	; 0x41
    75aa:	d03c      	beq.n	7626 <cliFunc_pixelSCTest+0xa2>
    75ac:	2b52      	cmp	r3, #82	; 0x52
    75ae:	d043      	beq.n	7638 <cliFunc_pixelSCTest+0xb4>
	if ( *arg1Ptr != '\0' )
    75b0:	9800      	ldr	r0, [sp, #0]
    75b2:	7803      	ldrb	r3, [r0, #0]
    75b4:	b113      	cbz	r3, 75bc <cliFunc_pixelSCTest+0x38>
		Pixel_testPos = numToInt( arg1Ptr );
    75b6:	f004 f836 	bl	b626 <numToInt>
    75ba:	8020      	strh	r0, [r4, #0]
	uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    75bc:	8822      	ldrh	r2, [r4, #0]
    75be:	4b27      	ldr	r3, [pc, #156]	; (765c <cliFunc_pixelSCTest+0xd8>)
	print( NL );
    75c0:	4824      	ldr	r0, [pc, #144]	; (7654 <cliFunc_pixelSCTest+0xd0>)
	uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    75c2:	f833 6012 	ldrh.w	r6, [r3, r2, lsl #1]
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    75c6:	4d26      	ldr	r5, [pc, #152]	; (7660 <cliFunc_pixelSCTest+0xdc>)
	print( NL );
    75c8:	f003 ff1a 	bl	b400 <_print>
	info_msg("ScanCode: ");
    75cc:	4825      	ldr	r0, [pc, #148]	; (7664 <cliFunc_pixelSCTest+0xe0>)
    75ce:	f003 ff17 	bl	b400 <_print>
	printInt16( Pixel_testPos + 1 );
    75d2:	8820      	ldrh	r0, [r4, #0]
    75d4:	3001      	adds	r0, #1
    75d6:	b280      	uxth	r0, r0
    75d8:	f003 ff62 	bl	b4a0 <printInt16>
	print(" Pixel: ");
    75dc:	4822      	ldr	r0, [pc, #136]	; (7668 <cliFunc_pixelSCTest+0xe4>)
    75de:	f003 ff0f 	bl	b400 <_print>
	printInt16( pixel );
    75e2:	4630      	mov	r0, r6
    75e4:	f003 ff5c 	bl	b4a0 <printInt16>
	print(" ");
    75e8:	4820      	ldr	r0, [pc, #128]	; (766c <cliFunc_pixelSCTest+0xe8>)
    75ea:	f003 ff09 	bl	b400 <_print>
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    75ee:	1e73      	subs	r3, r6, #1
    75f0:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
	Pixel_showPixelElement( elem );
    75f4:	4628      	mov	r0, r5
    75f6:	f7ff fb81 	bl	6cfc <Pixel_showPixelElement>
	print( NL );
    75fa:	4816      	ldr	r0, [pc, #88]	; (7654 <cliFunc_pixelSCTest+0xd0>)
    75fc:	f003 ff00 	bl	b400 <_print>
	Pixel_testPos++;
    7600:	8823      	ldrh	r3, [r4, #0]
    7602:	3301      	adds	r3, #1
    7604:	b29b      	uxth	r3, r3
	if ( Pixel_testPos >= MaxScanCode_KLL )
    7606:	2b59      	cmp	r3, #89	; 0x59
		Pixel_testPos = 0;
    7608:	bf88      	it	hi
    760a:	2300      	movhi	r3, #0
    760c:	8023      	strh	r3, [r4, #0]
	if ( pixel == 0 )
    760e:	b116      	cbz	r6, 7616 <cliFunc_pixelSCTest+0x92>
	Pixel_pixelToggle( elem );
    7610:	4628      	mov	r0, r5
    7612:	f7ff ff17 	bl	7444 <Pixel_pixelToggle>
}
    7616:	b002      	add	sp, #8
    7618:	bd70      	pop	{r4, r5, r6, pc}
	switch ( *arg1Ptr )
    761a:	2b72      	cmp	r3, #114	; 0x72
    761c:	d00c      	beq.n	7638 <cliFunc_pixelSCTest+0xb4>
    761e:	2b73      	cmp	r3, #115	; 0x73
    7620:	d012      	beq.n	7648 <cliFunc_pixelSCTest+0xc4>
    7622:	2b61      	cmp	r3, #97	; 0x61
    7624:	d1c4      	bne.n	75b0 <cliFunc_pixelSCTest+0x2c>
		info_msg("All scancode pixel test");
    7626:	4812      	ldr	r0, [pc, #72]	; (7670 <cliFunc_pixelSCTest+0xec>)
    7628:	f003 feea 	bl	b400 <_print>
		Pixel_testPos = 0;
    762c:	2300      	movs	r3, #0
    762e:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Scan_All;
    7630:	4b10      	ldr	r3, [pc, #64]	; (7674 <cliFunc_pixelSCTest+0xf0>)
    7632:	2209      	movs	r2, #9
		Pixel_testMode = PixelTest_Off;
    7634:	701a      	strb	r2, [r3, #0]
		break;
    7636:	e7bb      	b.n	75b0 <cliFunc_pixelSCTest+0x2c>
		info_msg("Scancode pixel roll test");
    7638:	480f      	ldr	r0, [pc, #60]	; (7678 <cliFunc_pixelSCTest+0xf4>)
    763a:	f003 fee1 	bl	b400 <_print>
		Pixel_testPos = 0;
    763e:	2300      	movs	r3, #0
    7640:	8023      	strh	r3, [r4, #0]
		Pixel_testMode = PixelTest_Scan_Roll;
    7642:	220a      	movs	r2, #10
    7644:	4b0b      	ldr	r3, [pc, #44]	; (7674 <cliFunc_pixelSCTest+0xf0>)
    7646:	e7f5      	b.n	7634 <cliFunc_pixelSCTest+0xb0>
		info_msg("Stopping scancode pixel test");
    7648:	480c      	ldr	r0, [pc, #48]	; (767c <cliFunc_pixelSCTest+0xf8>)
    764a:	f003 fed9 	bl	b400 <_print>
		Pixel_testMode = PixelTest_Off;
    764e:	4b09      	ldr	r3, [pc, #36]	; (7674 <cliFunc_pixelSCTest+0xf0>)
    7650:	2200      	movs	r2, #0
    7652:	e7ef      	b.n	7634 <cliFunc_pixelSCTest+0xb0>
    7654:	00010d99 	.word	0x00010d99
    7658:	1fff93e0 	.word	0x1fff93e0
    765c:	0001017a 	.word	0x0001017a
    7660:	0000fff0 	.word	0x0000fff0
    7664:	0000fb4d 	.word	0x0000fb4d
    7668:	0000fbe4 	.word	0x0000fbe4
    766c:	00011f77 	.word	0x00011f77
    7670:	0000fac9 	.word	0x0000fac9
    7674:	1fffa8a8 	.word	0x1fffa8a8
    7678:	0000faf3 	.word	0x0000faf3
    767c:	0000fb1e 	.word	0x0000fb1e

00007680 <cliFunc_pixelXYTest>:
{
    7680:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7684:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    7686:	4872      	ldr	r0, [pc, #456]	; (7850 <cliFunc_pixelXYTest+0x1d0>)
    7688:	f003 feba 	bl	b400 <_print>
	char* arg2Ptr = args;
    768c:	aa02      	add	r2, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    768e:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    7690:	f842 4d04 	str.w	r4, [r2, #-4]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7694:	4669      	mov	r1, sp
    7696:	f003 faab 	bl	abf0 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    769a:	9800      	ldr	r0, [sp, #0]
    769c:	7803      	ldrb	r3, [r0, #0]
    769e:	2b56      	cmp	r3, #86	; 0x56
    76a0:	d07f      	beq.n	77a2 <cliFunc_pixelXYTest+0x122>
    76a2:	d856      	bhi.n	7752 <cliFunc_pixelXYTest+0xd2>
    76a4:	2b48      	cmp	r3, #72	; 0x48
    76a6:	d05b      	beq.n	7760 <cliFunc_pixelXYTest+0xe0>
    76a8:	d849      	bhi.n	773e <cliFunc_pixelXYTest+0xbe>
    76aa:	2b41      	cmp	r3, #65	; 0x41
    76ac:	f000 80aa 	beq.w	7804 <cliFunc_pixelXYTest+0x184>
    76b0:	4c68      	ldr	r4, [pc, #416]	; (7854 <cliFunc_pixelXYTest+0x1d4>)
	if ( *arg1Ptr != '\0' )
    76b2:	b113      	cbz	r3, 76ba <cliFunc_pixelXYTest+0x3a>
		Pixel_testPos = numToInt( arg1Ptr );
    76b4:	f003 ffb7 	bl	b626 <numToInt>
    76b8:	8020      	strh	r0, [r4, #0]
	uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    76ba:	8822      	ldrh	r2, [r4, #0]
    76bc:	4b66      	ldr	r3, [pc, #408]	; (7858 <cliFunc_pixelXYTest+0x1d8>)
	print( NL );
    76be:	4864      	ldr	r0, [pc, #400]	; (7850 <cliFunc_pixelXYTest+0x1d0>)
	uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    76c0:	f833 6012 	ldrh.w	r6, [r3, r2, lsl #1]
	print( NL );
    76c4:	f003 fe9c 	bl	b400 <_print>
	info_msg("Position (x,y): ");
    76c8:	4864      	ldr	r0, [pc, #400]	; (785c <cliFunc_pixelXYTest+0x1dc>)
    76ca:	f003 fe99 	bl	b400 <_print>
	printInt16( Pixel_testPos % Pixel_DisplayMapping_Cols_KLL );
    76ce:	8820      	ldrh	r0, [r4, #0]
    76d0:	2511      	movs	r5, #17
    76d2:	fbb0 f3f5 	udiv	r3, r0, r5
    76d6:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    76da:	1ac0      	subs	r0, r0, r3
    76dc:	b280      	uxth	r0, r0
    76de:	f003 fedf 	bl	b4a0 <printInt16>
	print(",");
    76e2:	485f      	ldr	r0, [pc, #380]	; (7860 <cliFunc_pixelXYTest+0x1e0>)
    76e4:	f003 fe8c 	bl	b400 <_print>
	printInt16( Pixel_testPos / Pixel_DisplayMapping_Cols_KLL );
    76e8:	8820      	ldrh	r0, [r4, #0]
    76ea:	fbb0 f0f5 	udiv	r0, r0, r5
    76ee:	f003 fed7 	bl	b4a0 <printInt16>
	print(":");
    76f2:	485c      	ldr	r0, [pc, #368]	; (7864 <cliFunc_pixelXYTest+0x1e4>)
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    76f4:	4d5c      	ldr	r5, [pc, #368]	; (7868 <cliFunc_pixelXYTest+0x1e8>)
	print(":");
    76f6:	f003 fe83 	bl	b400 <_print>
	printInt16( Pixel_testPos );
    76fa:	8820      	ldrh	r0, [r4, #0]
    76fc:	f003 fed0 	bl	b4a0 <printInt16>
	print(" Pixel: ");
    7700:	485a      	ldr	r0, [pc, #360]	; (786c <cliFunc_pixelXYTest+0x1ec>)
    7702:	f003 fe7d 	bl	b400 <_print>
	printInt16( pixel );
    7706:	4630      	mov	r0, r6
    7708:	f003 feca 	bl	b4a0 <printInt16>
	print(" ");
    770c:	4858      	ldr	r0, [pc, #352]	; (7870 <cliFunc_pixelXYTest+0x1f0>)
    770e:	f003 fe77 	bl	b400 <_print>
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    7712:	1e73      	subs	r3, r6, #1
    7714:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
	Pixel_showPixelElement( elem );
    7718:	4628      	mov	r0, r5
    771a:	f7ff faef 	bl	6cfc <Pixel_showPixelElement>
	print( NL );
    771e:	484c      	ldr	r0, [pc, #304]	; (7850 <cliFunc_pixelXYTest+0x1d0>)
    7720:	f003 fe6e 	bl	b400 <_print>
	Pixel_testPos++;
    7724:	8823      	ldrh	r3, [r4, #0]
    7726:	3301      	adds	r3, #1
    7728:	b29b      	uxth	r3, r3
	if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    772a:	2b76      	cmp	r3, #118	; 0x76
		Pixel_testPos = 0;
    772c:	bf88      	it	hi
    772e:	2300      	movhi	r3, #0
    7730:	8023      	strh	r3, [r4, #0]
	if ( pixel == 0 )
    7732:	2e00      	cmp	r6, #0
    7734:	d06f      	beq.n	7816 <cliFunc_pixelXYTest+0x196>
	Pixel_pixelToggle( elem );
    7736:	4628      	mov	r0, r5
    7738:	f7ff fe84 	bl	7444 <Pixel_pixelToggle>
    773c:	e06b      	b.n	7816 <cliFunc_pixelXYTest+0x196>
	switch ( *arg1Ptr )
    773e:	2b52      	cmp	r3, #82	; 0x52
    7740:	d06c      	beq.n	781c <cliFunc_pixelXYTest+0x19c>
    7742:	2b53      	cmp	r3, #83	; 0x53
    7744:	d1b4      	bne.n	76b0 <cliFunc_pixelXYTest+0x30>
		info_msg("Stopping x,y pixel test");
    7746:	484b      	ldr	r0, [pc, #300]	; (7874 <cliFunc_pixelXYTest+0x1f4>)
    7748:	f003 fe5a 	bl	b400 <_print>
		Pixel_testMode = PixelTest_Off;
    774c:	4b4a      	ldr	r3, [pc, #296]	; (7878 <cliFunc_pixelXYTest+0x1f8>)
    774e:	2200      	movs	r2, #0
    7750:	e060      	b.n	7814 <cliFunc_pixelXYTest+0x194>
	switch ( *arg1Ptr )
    7752:	2b72      	cmp	r3, #114	; 0x72
    7754:	d062      	beq.n	781c <cliFunc_pixelXYTest+0x19c>
    7756:	d820      	bhi.n	779a <cliFunc_pixelXYTest+0x11a>
    7758:	2b61      	cmp	r3, #97	; 0x61
    775a:	d053      	beq.n	7804 <cliFunc_pixelXYTest+0x184>
    775c:	2b68      	cmp	r3, #104	; 0x68
    775e:	d1a7      	bne.n	76b0 <cliFunc_pixelXYTest+0x30>
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    7760:	4d3c      	ldr	r5, [pc, #240]	; (7854 <cliFunc_pixelXYTest+0x1d4>)
		info_msg("Horizontal: ");
    7762:	4846      	ldr	r0, [pc, #280]	; (787c <cliFunc_pixelXYTest+0x1fc>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    7764:	882b      	ldrh	r3, [r5, #0]
			uint16_t pixel = Pixel_DisplayMapping[ pos ];
    7766:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 7858 <cliFunc_pixelXYTest+0x1d8>
			print(" ");
    776a:	f8df 9104 	ldr.w	r9, [pc, #260]	; 7870 <cliFunc_pixelXYTest+0x1f0>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    776e:	4f3e      	ldr	r7, [pc, #248]	; (7868 <cliFunc_pixelXYTest+0x1e8>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    7770:	2b06      	cmp	r3, #6
			Pixel_testPos = 0;
    7772:	bf84      	itt	hi
    7774:	2300      	movhi	r3, #0
    7776:	802b      	strhhi	r3, [r5, #0]
		info_msg("Horizontal: ");
    7778:	f003 fe42 	bl	b400 <_print>
		printInt16( Pixel_testPos );
    777c:	8828      	ldrh	r0, [r5, #0]
    777e:	f003 fe8f 	bl	b4a0 <printInt16>
		for ( uint16_t pos = Pixel_DisplayMapping_Cols_KLL * Pixel_testPos;
    7782:	882c      	ldrh	r4, [r5, #0]
    7784:	eb04 1404 	add.w	r4, r4, r4, lsl #4
    7788:	b2a4      	uxth	r4, r4
			pos < Pixel_DisplayMapping_Cols_KLL * ( Pixel_testPos + 1);
    778a:	882b      	ldrh	r3, [r5, #0]
    778c:	3301      	adds	r3, #1
    778e:	eb03 1203 	add.w	r2, r3, r3, lsl #4
		for ( uint16_t pos = Pixel_DisplayMapping_Cols_KLL * Pixel_testPos;
    7792:	4294      	cmp	r4, r2
    7794:	db4b      	blt.n	782e <cliFunc_pixelXYTest+0x1ae>
		Pixel_testPos++;
    7796:	802b      	strh	r3, [r5, #0]
		return;
    7798:	e03d      	b.n	7816 <cliFunc_pixelXYTest+0x196>
	switch ( *arg1Ptr )
    779a:	2b73      	cmp	r3, #115	; 0x73
    779c:	d0d3      	beq.n	7746 <cliFunc_pixelXYTest+0xc6>
    779e:	2b76      	cmp	r3, #118	; 0x76
    77a0:	d186      	bne.n	76b0 <cliFunc_pixelXYTest+0x30>
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    77a2:	4c2c      	ldr	r4, [pc, #176]	; (7854 <cliFunc_pixelXYTest+0x1d4>)
		info_msg("Vertical: ");
    77a4:	4836      	ldr	r0, [pc, #216]	; (7880 <cliFunc_pixelXYTest+0x200>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    77a6:	8823      	ldrh	r3, [r4, #0]
			print(" ");
    77a8:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 7870 <cliFunc_pixelXYTest+0x1f0>
			uint16_t pixel = Pixel_DisplayMapping[ pos_calc ];
    77ac:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 7858 <cliFunc_pixelXYTest+0x1d8>
			print(":");
    77b0:	4f2c      	ldr	r7, [pc, #176]	; (7864 <cliFunc_pixelXYTest+0x1e4>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    77b2:	2b10      	cmp	r3, #16
			Pixel_testPos = 0;
    77b4:	bf84      	itt	hi
    77b6:	2300      	movhi	r3, #0
    77b8:	8023      	strhhi	r3, [r4, #0]
		info_msg("Vertical: ");
    77ba:	f003 fe21 	bl	b400 <_print>
		printInt16( Pixel_testPos );
    77be:	8820      	ldrh	r0, [r4, #0]
    77c0:	f003 fe6e 	bl	b4a0 <printInt16>
    77c4:	2500      	movs	r5, #0
			uint16_t pos_calc = pos * Pixel_DisplayMapping_Cols_KLL + Pixel_testPos;
    77c6:	8826      	ldrh	r6, [r4, #0]
    77c8:	442e      	add	r6, r5
    77ca:	b2b6      	uxth	r6, r6
			print(" ");
    77cc:	4648      	mov	r0, r9
    77ce:	f003 fe17 	bl	b400 <_print>
			printInt16( pos_calc );
    77d2:	4630      	mov	r0, r6
    77d4:	f003 fe64 	bl	b4a0 <printInt16>
			uint16_t pixel = Pixel_DisplayMapping[ pos_calc ];
    77d8:	f838 6016 	ldrh.w	r6, [r8, r6, lsl #1]
			print(":");
    77dc:	4638      	mov	r0, r7
    77de:	f003 fe0f 	bl	b400 <_print>
			printInt16( pixel );
    77e2:	4630      	mov	r0, r6
    77e4:	f003 fe5c 	bl	b4a0 <printInt16>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    77e8:	481f      	ldr	r0, [pc, #124]	; (7868 <cliFunc_pixelXYTest+0x1e8>)
    77ea:	3e01      	subs	r6, #1
    77ec:	3511      	adds	r5, #17
    77ee:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
    77f2:	b2ad      	uxth	r5, r5
    77f4:	f7ff fe26 	bl	7444 <Pixel_pixelToggle>
		for ( uint16_t pos = 0; pos < Pixel_DisplayMapping_Rows_KLL; pos++ )
    77f8:	2d77      	cmp	r5, #119	; 0x77
    77fa:	d1e4      	bne.n	77c6 <cliFunc_pixelXYTest+0x146>
		Pixel_testPos++;
    77fc:	8823      	ldrh	r3, [r4, #0]
    77fe:	3301      	adds	r3, #1
    7800:	8023      	strh	r3, [r4, #0]
		return;
    7802:	e008      	b.n	7816 <cliFunc_pixelXYTest+0x196>
		info_msg("All x,y pixel test");
    7804:	481f      	ldr	r0, [pc, #124]	; (7884 <cliFunc_pixelXYTest+0x204>)
    7806:	f003 fdfb 	bl	b400 <_print>
		Pixel_testPos = 0;
    780a:	4b12      	ldr	r3, [pc, #72]	; (7854 <cliFunc_pixelXYTest+0x1d4>)
    780c:	2200      	movs	r2, #0
    780e:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_XY_All;
    7810:	4b19      	ldr	r3, [pc, #100]	; (7878 <cliFunc_pixelXYTest+0x1f8>)
    7812:	220b      	movs	r2, #11
		Pixel_testMode = PixelTest_XY_Roll;
    7814:	701a      	strb	r2, [r3, #0]
}
    7816:	b003      	add	sp, #12
    7818:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		info_msg("x,y pixel roll test");
    781c:	481a      	ldr	r0, [pc, #104]	; (7888 <cliFunc_pixelXYTest+0x208>)
    781e:	f003 fdef 	bl	b400 <_print>
		Pixel_testPos = 0;
    7822:	4b0c      	ldr	r3, [pc, #48]	; (7854 <cliFunc_pixelXYTest+0x1d4>)
    7824:	2200      	movs	r2, #0
    7826:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_XY_Roll;
    7828:	4b13      	ldr	r3, [pc, #76]	; (7878 <cliFunc_pixelXYTest+0x1f8>)
    782a:	220c      	movs	r2, #12
    782c:	e7f2      	b.n	7814 <cliFunc_pixelXYTest+0x194>
			uint16_t pixel = Pixel_DisplayMapping[ pos ];
    782e:	f838 6014 	ldrh.w	r6, [r8, r4, lsl #1]
			print(" ");
    7832:	4648      	mov	r0, r9
    7834:	f003 fde4 	bl	b400 <_print>
			printInt16( pixel );
    7838:	4630      	mov	r0, r6
    783a:	f003 fe31 	bl	b4a0 <printInt16>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    783e:	1e70      	subs	r0, r6, #1
    7840:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
			pos++
    7844:	3401      	adds	r4, #1
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    7846:	f7ff fdfd 	bl	7444 <Pixel_pixelToggle>
			pos++
    784a:	b2a4      	uxth	r4, r4
    784c:	e79d      	b.n	778a <cliFunc_pixelXYTest+0x10a>
    784e:	bf00      	nop
    7850:	00010d99 	.word	0x00010d99
    7854:	1fff93e0 	.word	0x1fff93e0
    7858:	0000ff02 	.word	0x0000ff02
    785c:	0000fc9e 	.word	0x0000fc9e
    7860:	0000d322 	.word	0x0000d322
    7864:	0000f857 	.word	0x0000f857
    7868:	0000fff0 	.word	0x0000fff0
    786c:	0000fbe4 	.word	0x0000fbe4
    7870:	00011f77 	.word	0x00011f77
    7874:	0000fc38 	.word	0x0000fc38
    7878:	1fffa8a8 	.word	0x1fffa8a8
    787c:	0000fc62 	.word	0x0000fc62
    7880:	0000fc81 	.word	0x0000fc81
    7884:	0000fbed 	.word	0x0000fbed
    7888:	0000fc12 	.word	0x0000fc12

0000788c <Pixel_determineLastTriggerScanCode>:
{
    788c:	b510      	push	{r4, lr}
	if ( trigger == 0 )
    788e:	b170      	cbz	r0, 78ae <Pixel_determineLastTriggerScanCode+0x22>
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    7890:	6804      	ldr	r4, [r0, #0]
	for ( var_uint_t pos = 0; ; pos += trigger->guide[ pos ] * TriggerGuideSize + 1 )
    7892:	2200      	movs	r2, #0
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    7894:	5ca3      	ldrb	r3, [r4, r2]
		curScanCode = guide->scanCode;
    7896:	18a1      	adds	r1, r4, r2
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    7898:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    789c:	b2db      	uxtb	r3, r3
		curScanCode = guide->scanCode;
    789e:	78c8      	ldrb	r0, [r1, #3]
		if ( trigger->guide[ pos + comboLength + 1 ] == 0 )
    78a0:	4419      	add	r1, r3
    78a2:	7849      	ldrb	r1, [r1, #1]
    78a4:	b119      	cbz	r1, 78ae <Pixel_determineLastTriggerScanCode+0x22>
	for ( var_uint_t pos = 0; ; pos += trigger->guide[ pos ] * TriggerGuideSize + 1 )
    78a6:	3301      	adds	r3, #1
    78a8:	4413      	add	r3, r2
    78aa:	b2da      	uxtb	r2, r3
    78ac:	e7f2      	b.n	7894 <Pixel_determineLastTriggerScanCode+0x8>
}
    78ae:	bd10      	pop	{r4, pc}

000078b0 <Pixel_fillPixelLookup>:
{
    78b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    78b4:	f8dd 8018 	ldr.w	r8, [sp, #24]
    78b8:	4614      	mov	r4, r2
	*valid = 0;
    78ba:	2200      	movs	r2, #0
    78bc:	f8a8 2000 	strh.w	r2, [r8]
	*elem = 0;
    78c0:	600a      	str	r2, [r1, #0]
	switch ( mod->type )
    78c2:	7802      	ldrb	r2, [r0, #0]
    78c4:	3a01      	subs	r2, #1
{
    78c6:	4607      	mov	r7, r0
    78c8:	460e      	mov	r6, r1
	switch ( mod->type )
    78ca:	2a08      	cmp	r2, #8
    78cc:	d80e      	bhi.n	78ec <Pixel_fillPixelLookup+0x3c>
    78ce:	e8df f002 	tbb	[pc, r2]
    78d2:	0f05      	.short	0x0f05
    78d4:	0d6b5a39 	.word	0x0d6b5a39
    78d8:	a785      	.short	0xa785
    78da:	d0          	.byte	0xd0
    78db:	00          	.byte	0x00
		*elem = (PixelElement*)&Pixel_Mapping[mod->index] - 1;
    78dc:	f8d0 2001 	ldr.w	r2, [r0, #1]
    78e0:	4b7c      	ldr	r3, [pc, #496]	; (7ad4 <Pixel_fillPixelLookup+0x224>)
		if ( mod->index <= Pixel_TotalPixels_KLL )
    78e2:	2a26      	cmp	r2, #38	; 0x26
		*elem = (PixelElement*)&Pixel_Mapping[mod->index] - 1;
    78e4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    78e8:	6033      	str	r3, [r6, #0]
		if ( mod->index <= Pixel_TotalPixels_KLL )
    78ea:	dd27      	ble.n	793c <Pixel_fillPixelLookup+0x8c>
	return 0;
    78ec:	2400      	movs	r4, #0
    78ee:	e047      	b.n	7980 <Pixel_fillPixelLookup+0xd0>
		if ( mod->rect.col >= Pixel_DisplayMapping_Cols_KLL
    78f0:	f9b0 2001 	ldrsh.w	r2, [r0, #1]
    78f4:	f9b0 3003 	ldrsh.w	r3, [r0, #3]
    78f8:	2a10      	cmp	r2, #16
    78fa:	b219      	sxth	r1, r3
    78fc:	dd13      	ble.n	7926 <Pixel_fillPixelLookup+0x76>
			&& mod->rect.row >= Pixel_DisplayMapping_Rows_KLL )
    78fe:	2906      	cmp	r1, #6
    7900:	dd11      	ble.n	7926 <Pixel_fillPixelLookup+0x76>
			erro_msg("Invalid row,column index: ");
    7902:	4875      	ldr	r0, [pc, #468]	; (7ad8 <Pixel_fillPixelLookup+0x228>)
    7904:	f003 fd7c 	bl	b400 <_print>
			printInt16( mod->rect.row );
    7908:	f8b7 0003 	ldrh.w	r0, [r7, #3]
    790c:	f003 fdc8 	bl	b4a0 <printInt16>
			print(",");
    7910:	4872      	ldr	r0, [pc, #456]	; (7adc <Pixel_fillPixelLookup+0x22c>)
    7912:	f003 fd75 	bl	b400 <_print>
			printInt16( mod->rect.col );
    7916:	f8b7 0001 	ldrh.w	r0, [r7, #1]
			printInt16( position );
    791a:	f003 fdc1 	bl	b4a0 <printInt16>
			print( NL );
    791e:	4870      	ldr	r0, [pc, #448]	; (7ae0 <Pixel_fillPixelLookup+0x230>)
    7920:	f003 fd6e 	bl	b400 <_print>
    7924:	e7e2      	b.n	78ec <Pixel_fillPixelLookup+0x3c>
				mod->rect.row * Pixel_DisplayMapping_Cols_KLL + mod->rect.col
    7926:	2111      	movs	r1, #17
    7928:	fb13 2301 	smlabb	r3, r3, r1, r2
			Pixel_DisplayMapping[
    792c:	4a6d      	ldr	r2, [pc, #436]	; (7ae4 <Pixel_fillPixelLookup+0x234>)
    792e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
			] - 1
    7932:	1e5a      	subs	r2, r3, #1
		*elem = (PixelElement*)&Pixel_Mapping[
    7934:	4b6c      	ldr	r3, [pc, #432]	; (7ae8 <Pixel_fillPixelLookup+0x238>)
    7936:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    793a:	6033      	str	r3, [r6, #0]
		*valid = 1;
    793c:	2301      	movs	r3, #1
    793e:	f8a8 3000 	strh.w	r3, [r8]
    7942:	e7d3      	b.n	78ec <Pixel_fillPixelLookup+0x3c>
    7944:	f9b0 0001 	ldrsh.w	r0, [r0, #1]
    7948:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    794c:	4403      	add	r3, r0
    794e:	4865      	ldr	r0, [pc, #404]	; (7ae4 <Pixel_fillPixelLookup+0x234>)
			index = Pixel_DisplayMapping[ cur * Pixel_DisplayMapping_Cols_KLL + mod->rect.col ];
    7950:	2100      	movs	r1, #0
    7952:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    7956:	2222      	movs	r2, #34	; 0x22
    7958:	fb02 f301 	mul.w	r3, r2, r1
			if ( cur >= Pixel_DisplayMapping_Rows_KLL )
    795c:	2c06      	cmp	r4, #6
			index = Pixel_DisplayMapping[ cur * Pixel_DisplayMapping_Cols_KLL + mod->rect.col ];
    795e:	5ac3      	ldrh	r3, [r0, r3]
			if ( cur >= Pixel_DisplayMapping_Rows_KLL )
    7960:	d8c4      	bhi.n	78ec <Pixel_fillPixelLookup+0x3c>
			cur++;
    7962:	3401      	adds	r4, #1
    7964:	b2a4      	uxth	r4, r4
    7966:	3101      	adds	r1, #1
		} while ( index == 0 );
    7968:	2b00      	cmp	r3, #0
    796a:	d0f5      	beq.n	7958 <Pixel_fillPixelLookup+0xa8>
		if ( index <= Pixel_TotalPixels_KLL )
    796c:	2b26      	cmp	r3, #38	; 0x26
			*valid = 1;
    796e:	bf9c      	itt	ls
    7970:	2201      	movls	r2, #1
    7972:	f8a8 2000 	strhls.w	r2, [r8]
		*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    7976:	4a5c      	ldr	r2, [pc, #368]	; (7ae8 <Pixel_fillPixelLookup+0x238>)
    7978:	3b01      	subs	r3, #1
    797a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    797e:	6033      	str	r3, [r6, #0]
}
    7980:	4620      	mov	r0, r4
    7982:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			index = Pixel_DisplayMapping[ mod->rect.row * Pixel_DisplayMapping_Cols_KLL + cur ];
    7986:	f9b0 1003 	ldrsh.w	r1, [r0, #3]
    798a:	2311      	movs	r3, #17
    798c:	fb11 4303 	smlabb	r3, r1, r3, r4
    7990:	4956      	ldr	r1, [pc, #344]	; (7aec <Pixel_fillPixelLookup+0x23c>)
    7992:	eb01 0143 	add.w	r1, r1, r3, lsl #1
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    7996:	2c10      	cmp	r4, #16
			index = Pixel_DisplayMapping[ mod->rect.row * Pixel_DisplayMapping_Cols_KLL + cur ];
    7998:	f831 3f02 	ldrh.w	r3, [r1, #2]!
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    799c:	d8a6      	bhi.n	78ec <Pixel_fillPixelLookup+0x3c>
			cur++;
    799e:	3401      	adds	r4, #1
    79a0:	b2a4      	uxth	r4, r4
		} while ( index == 0 );
    79a2:	2b00      	cmp	r3, #0
    79a4:	d0f7      	beq.n	7996 <Pixel_fillPixelLookup+0xe6>
    79a6:	e7e1      	b.n	796c <Pixel_fillPixelLookup+0xbc>
		if ( mod->index > MaxScanCode_KLL )
    79a8:	f8d0 3001 	ldr.w	r3, [r0, #1]
    79ac:	2b5a      	cmp	r3, #90	; 0x5a
    79ae:	dd06      	ble.n	79be <Pixel_fillPixelLookup+0x10e>
			erro_msg("Invalid ScanCode: ");
    79b0:	484f      	ldr	r0, [pc, #316]	; (7af0 <Pixel_fillPixelLookup+0x240>)
    79b2:	f003 fd25 	bl	b400 <_print>
			printInt16( mod->index );
    79b6:	f8d7 0001 	ldr.w	r0, [r7, #1]
    79ba:	b280      	uxth	r0, r0
    79bc:	e7ad      	b.n	791a <Pixel_fillPixelLookup+0x6a>
		*valid = 1;
    79be:	2301      	movs	r3, #1
    79c0:	f8a8 3000 	strh.w	r3, [r8]
		uint16_t pixel = Pixel_ScanCodeToPixel[ mod->index - 1 ];
    79c4:	f8d0 3001 	ldr.w	r3, [r0, #1]
		*elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    79c8:	4a4a      	ldr	r2, [pc, #296]	; (7af4 <Pixel_fillPixelLookup+0x244>)
		uint16_t pixel = Pixel_ScanCodeToPixel[ mod->index - 1 ];
    79ca:	3b01      	subs	r3, #1
		*elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    79cc:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    79d0:	1e5a      	subs	r2, r3, #1
    79d2:	4b45      	ldr	r3, [pc, #276]	; (7ae8 <Pixel_fillPixelLookup+0x238>)
    79d4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
			*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    79d8:	6033      	str	r3, [r6, #0]
    79da:	e787      	b.n	78ec <Pixel_fillPixelLookup+0x3c>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    79dc:	6818      	ldr	r0, [r3, #0]
    79de:	f7ff ff55 	bl	788c <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    79e2:	4b45      	ldr	r3, [pc, #276]	; (7af8 <Pixel_fillPixelLookup+0x248>)
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    79e4:	f9b7 2003 	ldrsh.w	r2, [r7, #3]
    79e8:	f9b7 1001 	ldrsh.w	r1, [r7, #1]
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    79ec:	3801      	subs	r0, #1
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    79ee:	eb02 1202 	add.w	r2, r2, r2, lsl #4
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    79f2:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    79f6:	440a      	add	r2, r1
    79f8:	4413      	add	r3, r2
    79fa:	b29b      	uxth	r3, r3
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    79fc:	2b76      	cmp	r3, #118	; 0x76
    79fe:	f63f af75 	bhi.w	78ec <Pixel_fillPixelLookup+0x3c>
		index = Pixel_DisplayMapping[ position ];
    7a02:	4a38      	ldr	r2, [pc, #224]	; (7ae4 <Pixel_fillPixelLookup+0x234>)
    7a04:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
		if ( index <= Pixel_TotalPixels_KLL && index != 0 )
    7a08:	3b01      	subs	r3, #1
    7a0a:	b29a      	uxth	r2, r3
    7a0c:	2a25      	cmp	r2, #37	; 0x25
    7a0e:	f63f af6d 	bhi.w	78ec <Pixel_fillPixelLookup+0x3c>
			*valid = 1;
    7a12:	2201      	movs	r2, #1
    7a14:	f8a8 2000 	strh.w	r2, [r8]
			*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    7a18:	4a33      	ldr	r2, [pc, #204]	; (7ae8 <Pixel_fillPixelLookup+0x238>)
    7a1a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    7a1e:	e7db      	b.n	79d8 <Pixel_fillPixelLookup+0x128>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    7a20:	6818      	ldr	r0, [r3, #0]
    7a22:	f7ff ff33 	bl	788c <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    7a26:	4b34      	ldr	r3, [pc, #208]	; (7af8 <Pixel_fillPixelLookup+0x248>)
    7a28:	3801      	subs	r0, #1
    7a2a:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.col;
    7a2e:	f9b7 3001 	ldrsh.w	r3, [r7, #1]
    7a32:	441d      	add	r5, r3
    7a34:	b2ad      	uxth	r5, r5
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    7a36:	2d76      	cmp	r5, #118	; 0x76
    7a38:	d904      	bls.n	7a44 <Pixel_fillPixelLookup+0x194>
			erro_msg("Invalid position index (relcol): ");
    7a3a:	4830      	ldr	r0, [pc, #192]	; (7afc <Pixel_fillPixelLookup+0x24c>)
			erro_msg("Invalid position index (relrow): ");
    7a3c:	f003 fce0 	bl	b400 <_print>
			printInt16( position );
    7a40:	4628      	mov	r0, r5
    7a42:	e76a      	b.n	791a <Pixel_fillPixelLookup+0x6a>
		position %= Pixel_DisplayMapping_Cols_KLL;
    7a44:	2311      	movs	r3, #17
    7a46:	fbb5 f3f3 	udiv	r3, r5, r3
    7a4a:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    7a4e:	1aed      	subs	r5, r5, r3
    7a50:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    7a54:	441d      	add	r5, r3
			index = Pixel_DisplayMapping[ curpos ];
    7a56:	4923      	ldr	r1, [pc, #140]	; (7ae4 <Pixel_fillPixelLookup+0x234>)
    7a58:	b2ad      	uxth	r5, r5
			uint16_t curpos = cur++ * Pixel_DisplayMapping_Cols_KLL + position;
    7a5a:	3401      	adds	r4, #1
			if ( curpos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    7a5c:	2d76      	cmp	r5, #118	; 0x76
			uint16_t curpos = cur++ * Pixel_DisplayMapping_Cols_KLL + position;
    7a5e:	b2a4      	uxth	r4, r4
			if ( curpos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    7a60:	f63f af44 	bhi.w	78ec <Pixel_fillPixelLookup+0x3c>
			index = Pixel_DisplayMapping[ curpos ];
    7a64:	f831 3015 	ldrh.w	r3, [r1, r5, lsl #1]
    7a68:	3511      	adds	r5, #17
    7a6a:	b2ad      	uxth	r5, r5
		} while ( index == 0 );
    7a6c:	2b00      	cmp	r3, #0
    7a6e:	d0f4      	beq.n	7a5a <Pixel_fillPixelLookup+0x1aa>
    7a70:	e77c      	b.n	796c <Pixel_fillPixelLookup+0xbc>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    7a72:	6818      	ldr	r0, [r3, #0]
    7a74:	f7ff ff0a 	bl	788c <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    7a78:	4b1f      	ldr	r3, [pc, #124]	; (7af8 <Pixel_fillPixelLookup+0x248>)
    7a7a:	3801      	subs	r0, #1
    7a7c:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Rows_KLL;
    7a80:	f9b7 3003 	ldrsh.w	r3, [r7, #3]
    7a84:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    7a88:	441d      	add	r5, r3
    7a8a:	b2ad      	uxth	r5, r5
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    7a8c:	2d76      	cmp	r5, #118	; 0x76
    7a8e:	d901      	bls.n	7a94 <Pixel_fillPixelLookup+0x1e4>
			erro_msg("Invalid position index (relrow): ");
    7a90:	481b      	ldr	r0, [pc, #108]	; (7b00 <Pixel_fillPixelLookup+0x250>)
    7a92:	e7d3      	b.n	7a3c <Pixel_fillPixelLookup+0x18c>
		position /= Pixel_DisplayMapping_Cols_KLL;
    7a94:	2311      	movs	r3, #17
			index = Pixel_DisplayMapping[ curpos ];
    7a96:	4913      	ldr	r1, [pc, #76]	; (7ae4 <Pixel_fillPixelLookup+0x234>)
		position /= Pixel_DisplayMapping_Cols_KLL;
    7a98:	fbb5 f5f3 	udiv	r5, r5, r3
			uint16_t curpos = cur++ + Pixel_DisplayMapping_Cols_KLL * position;
    7a9c:	eb05 1505 	add.w	r5, r5, r5, lsl #4
    7aa0:	b2ad      	uxth	r5, r5
	uint16_t cur = prev;
    7aa2:	4623      	mov	r3, r4
			uint16_t curpos = cur++ + Pixel_DisplayMapping_Cols_KLL * position;
    7aa4:	3401      	adds	r4, #1
    7aa6:	b2a4      	uxth	r4, r4
    7aa8:	442b      	add	r3, r5
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    7aaa:	2c10      	cmp	r4, #16
    7aac:	b29b      	uxth	r3, r3
    7aae:	f63f af1d 	bhi.w	78ec <Pixel_fillPixelLookup+0x3c>
			index = Pixel_DisplayMapping[ curpos ];
    7ab2:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    7ab6:	4623      	mov	r3, r4
		} while ( index == 0 );
    7ab8:	2a00      	cmp	r2, #0
    7aba:	d0f3      	beq.n	7aa4 <Pixel_fillPixelLookup+0x1f4>
		if ( index <= Pixel_TotalPixels_KLL )
    7abc:	2a26      	cmp	r2, #38	; 0x26
			*valid = 1;
    7abe:	bf9c      	itt	ls
    7ac0:	2301      	movls	r3, #1
    7ac2:	f8a8 3000 	strhls.w	r3, [r8]
		*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    7ac6:	4b08      	ldr	r3, [pc, #32]	; (7ae8 <Pixel_fillPixelLookup+0x238>)
    7ac8:	3a01      	subs	r2, #1
    7aca:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    7ace:	6032      	str	r2, [r6, #0]
		return cur;
    7ad0:	e756      	b.n	7980 <Pixel_fillPixelLookup+0xd0>
    7ad2:	bf00      	nop
    7ad4:	0000ffe8 	.word	0x0000ffe8
    7ad8:	0000f5b4 	.word	0x0000f5b4
    7adc:	0000d322 	.word	0x0000d322
    7ae0:	00010d99 	.word	0x00010d99
    7ae4:	0000ff02 	.word	0x0000ff02
    7ae8:	0000fff0 	.word	0x0000fff0
    7aec:	0000ff00 	.word	0x0000ff00
    7af0:	0000f5e4 	.word	0x0000f5e4
    7af4:	0001017a 	.word	0x0001017a
    7af8:	00010120 	.word	0x00010120
    7afc:	0000f60c 	.word	0x0000f60c
    7b00:	0000f643 	.word	0x0000f643

00007b04 <Pixel_pixelTweenStandard>:
{
    7b04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint16_t pos = 0;
    7b08:	2400      	movs	r4, #0
{
    7b0a:	b085      	sub	sp, #20
    7b0c:	4607      	mov	r7, r0
    7b0e:	4689      	mov	r9, r1
	PixelModElement *mod = (PixelModElement*)&frame[pos];
    7b10:	4605      	mov	r5, r0
		uint16_t valid = 0;
    7b12:	46a0      	mov	r8, r4
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    7b14:	f10d 0a0a 	add.w	sl, sp, #10
	while ( mod->type != PixelAddressType_End )
    7b18:	782b      	ldrb	r3, [r5, #0]
    7b1a:	b913      	cbnz	r3, 7b22 <Pixel_pixelTweenStandard+0x1e>
}
    7b1c:	b005      	add	sp, #20
    7b1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t valid = 0;
    7b22:	f8ad 800a 	strh.w	r8, [sp, #10]
		PixelElement *elem = 0;
    7b26:	f8cd 800c 	str.w	r8, [sp, #12]
		uint16_t next = 0;
    7b2a:	2600      	movs	r6, #0
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    7b2c:	4632      	mov	r2, r6
    7b2e:	a903      	add	r1, sp, #12
    7b30:	f8cd a000 	str.w	sl, [sp]
    7b34:	464b      	mov	r3, r9
    7b36:	4628      	mov	r0, r5
			prev_pixel_elem = elem;
    7b38:	f8dd b00c 	ldr.w	fp, [sp, #12]
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    7b3c:	f7ff feb8 	bl	78b0 <Pixel_fillPixelLookup>
			Pixel_pixelEvaluation( mod, elem );
    7b40:	9903      	ldr	r1, [sp, #12]
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    7b42:	4606      	mov	r6, r0
			Pixel_pixelEvaluation( mod, elem );
    7b44:	4628      	mov	r0, r5
    7b46:	f7ff f9d3 	bl	6ef0 <Pixel_pixelEvaluation>
		} while ( next );
    7b4a:	2e00      	cmp	r6, #0
    7b4c:	d1ee      	bne.n	7b2c <Pixel_pixelTweenStandard+0x28>
		pos += Pixel_pixelTweenNextPos( elem, prev_pixel_elem );
    7b4e:	4659      	mov	r1, fp
    7b50:	9803      	ldr	r0, [sp, #12]
    7b52:	f7ff fb5d 	bl	7210 <Pixel_pixelTweenNextPos>
    7b56:	4404      	add	r4, r0
    7b58:	b2a4      	uxth	r4, r4
		mod = (PixelModElement*)&frame[pos];
    7b5a:	193d      	adds	r5, r7, r4
    7b5c:	e7dc      	b.n	7b18 <Pixel_pixelTweenStandard+0x14>

00007b5e <Pixel_pixelTweenInterpolation>:
{
    7b5e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7b62:	b093      	sub	sp, #76	; 0x4c
	PixelModElement *prev = 0;
    7b64:	2400      	movs	r4, #0
{
    7b66:	9006      	str	r0, [sp, #24]
    7b68:	9102      	str	r1, [sp, #8]
	PixelModElement *mod = (PixelModElement*)&frame[pos];
    7b6a:	4680      	mov	r8, r0
	uint16_t pos = 0;
    7b6c:	46a3      	mov	fp, r4
			Pixel_fillPixelLookup( prev, &prev_elem, 0, stack_elem, &valid );
    7b6e:	46a1      	mov	r9, r4
		PixelElement *prev_elem = 0;
    7b70:	46a2      	mov	sl, r4
	while ( mod->type != PixelAddressType_End )
    7b72:	f898 3000 	ldrb.w	r3, [r8]
    7b76:	b913      	cbnz	r3, 7b7e <Pixel_pixelTweenInterpolation+0x20>
}
    7b78:	b013      	add	sp, #76	; 0x4c
    7b7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch ( mod->type )
    7b7e:	3b01      	subs	r3, #1
		int32_t start = mod->index;
    7b80:	f8d8 6001 	ldr.w	r6, [r8, #1]
    7b84:	af09      	add	r7, sp, #36	; 0x24
		switch ( mod->type )
    7b86:	2b04      	cmp	r3, #4
    7b88:	d86f      	bhi.n	7c6a <Pixel_pixelTweenInterpolation+0x10c>
    7b8a:	e8df f003 	tbb	[pc, r3]
    7b8e:	1e37      	.short	0x1e37
    7b90:	1603      	.short	0x1603
    7b92:	37          	.byte	0x37
    7b93:	00          	.byte	0x00
    7b94:	f9b8 6001 	ldrsh.w	r6, [r8, #1]
			start = prev != 0 ? prev->rect.col : mod->rect.col;
    7b98:	2c00      	cmp	r4, #0
    7b9a:	f000 80cf 	beq.w	7d3c <Pixel_pixelTweenInterpolation+0x1de>
    7b9e:	f9b4 5001 	ldrsh.w	r5, [r4, #1]
		PixelElement *prev_elem = 0;
    7ba2:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
		uint16_t valid = 0;
    7ba6:	f8ad 9024 	strh.w	r9, [sp, #36]	; 0x24
			Pixel_fillPixelLookup( prev, &prev_elem, 0, stack_elem, &valid );
    7baa:	9700      	str	r7, [sp, #0]
    7bac:	9b02      	ldr	r3, [sp, #8]
    7bae:	2200      	movs	r2, #0
    7bb0:	a90a      	add	r1, sp, #40	; 0x28
    7bb2:	4620      	mov	r0, r4
    7bb4:	f7ff fe7c 	bl	78b0 <Pixel_fillPixelLookup>
    7bb8:	e02a      	b.n	7c10 <Pixel_pixelTweenInterpolation+0xb2>
    7bba:	f9b8 6003 	ldrsh.w	r6, [r8, #3]
			start = prev != 0 ? prev->rect.row : mod->rect.row;
    7bbe:	2c00      	cmp	r4, #0
    7bc0:	f000 80bc 	beq.w	7d3c <Pixel_pixelTweenInterpolation+0x1de>
    7bc4:	f9b4 5003 	ldrsh.w	r5, [r4, #3]
    7bc8:	e7eb      	b.n	7ba2 <Pixel_pixelTweenInterpolation+0x44>
    7bca:	f9b8 5001 	ldrsh.w	r5, [r8, #1]
			if ( prev != 0 )
    7bce:	2c00      	cmp	r4, #0
    7bd0:	f000 80b9 	beq.w	7d46 <Pixel_pixelTweenInterpolation+0x1e8>
				if ( prev->rect.col != mod->rect.col )
    7bd4:	f9b4 3001 	ldrsh.w	r3, [r4, #1]
				if ( prev->rect.row != mod->rect.row )
    7bd8:	f9b8 1003 	ldrsh.w	r1, [r8, #3]
					start = prev->rect.col;
    7bdc:	42ab      	cmp	r3, r5
    7bde:	bf18      	it	ne
    7be0:	461e      	movne	r6, r3
				if ( prev->rect.row != mod->rect.row )
    7be2:	f9b4 3003 	ldrsh.w	r3, [r4, #3]
		PixelElement *prev_elem = 0;
    7be6:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
		uint16_t valid = 0;
    7bea:	462a      	mov	r2, r5
    7bec:	f8ad 9024 	strh.w	r9, [sp, #36]	; 0x24
    7bf0:	4299      	cmp	r1, r3
    7bf2:	bf0c      	ite	eq
    7bf4:	4635      	moveq	r5, r6
    7bf6:	461d      	movne	r5, r3
			end = mod->rect.col;
    7bf8:	4616      	mov	r6, r2
    7bfa:	e7d6      	b.n	7baa <Pixel_pixelTweenInterpolation+0x4c>
			start = prev != 0 ? prev->index : mod->index;
    7bfc:	2c00      	cmp	r4, #0
    7bfe:	d034      	beq.n	7c6a <Pixel_pixelTweenInterpolation+0x10c>
    7c00:	f8d4 5001 	ldr.w	r5, [r4, #1]
		PixelElement *prev_elem = 0;
    7c04:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
		uint16_t valid = 0;
    7c08:	f8ad 9024 	strh.w	r9, [sp, #36]	; 0x24
		if ( prev != 0 )
    7c0c:	2c00      	cmp	r4, #0
    7c0e:	d1cc      	bne.n	7baa <Pixel_pixelTweenInterpolation+0x4c>
		PixelElement *mod_elem = 0;
    7c10:	a912      	add	r1, sp, #72	; 0x48
		Pixel_fillPixelLookup( mod, &mod_elem, 0, stack_elem, &valid );
    7c12:	9b02      	ldr	r3, [sp, #8]
		PixelElement *mod_elem = 0;
    7c14:	f841 ad1c 	str.w	sl, [r1, #-28]!
		Pixel_fillPixelLookup( mod, &mod_elem, 0, stack_elem, &valid );
    7c18:	2200      	movs	r2, #0
    7c1a:	9700      	str	r7, [sp, #0]
    7c1c:	4640      	mov	r0, r8
    7c1e:	f7ff fe47 	bl	78b0 <Pixel_fillPixelLookup>
		if ( mod_elem == 0 )
    7c22:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7c24:	b1ab      	cbz	r3, 7c52 <Pixel_pixelTweenInterpolation+0xf4>
		memcpy( interp_mod, mod, sizeof( interp_data ) );
    7c26:	2214      	movs	r2, #20
    7c28:	4641      	mov	r1, r8
    7c2a:	a80d      	add	r0, sp, #52	; 0x34
		PixelElement *elem = 0;
    7c2c:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
		memcpy( interp_mod, mod, sizeof( interp_data ) );
    7c30:	f7fa fd0e 	bl	2650 <memcpy>
    7c34:	1b73      	subs	r3, r6, r5
    7c36:	9305      	str	r3, [sp, #20]
		uint16_t slice = prev != 0 ? 256 / (end - start + 1) : 0;
    7c38:	b1cc      	cbz	r4, 7c6e <Pixel_pixelTweenInterpolation+0x110>
    7c3a:	1c5a      	adds	r2, r3, #1
    7c3c:	f44f 7380 	mov.w	r3, #256	; 0x100
    7c40:	fb93 f3f2 	sdiv	r3, r3, r2
    7c44:	b29b      	uxth	r3, r3
    7c46:	9304      	str	r3, [sp, #16]
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    7c48:	2600      	movs	r6, #0
		PixelElement *prev_pixel_elem = 0;
    7c4a:	9603      	str	r6, [sp, #12]
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    7c4c:	9b05      	ldr	r3, [sp, #20]
    7c4e:	429e      	cmp	r6, r3
    7c50:	dd0f      	ble.n	7c72 <Pixel_pixelTweenInterpolation+0x114>
		pos += Pixel_pixelTweenNextPos( elem, prev_pixel_elem );
    7c52:	9903      	ldr	r1, [sp, #12]
    7c54:	980c      	ldr	r0, [sp, #48]	; 0x30
    7c56:	f7ff fadb 	bl	7210 <Pixel_pixelTweenNextPos>
		mod = (PixelModElement*)&frame[pos];
    7c5a:	9b06      	ldr	r3, [sp, #24]
		pos += Pixel_pixelTweenNextPos( elem, prev_pixel_elem );
    7c5c:	4483      	add	fp, r0
    7c5e:	fa1f fb8b 	uxth.w	fp, fp
    7c62:	4644      	mov	r4, r8
		mod = (PixelModElement*)&frame[pos];
    7c64:	eb03 080b 	add.w	r8, r3, fp
    7c68:	e783      	b.n	7b72 <Pixel_pixelTweenInterpolation+0x14>
			start = prev != 0 ? prev->index : mod->index;
    7c6a:	4635      	mov	r5, r6
    7c6c:	e7ca      	b.n	7c04 <Pixel_pixelTweenInterpolation+0xa6>
		uint16_t slice = prev != 0 ? 256 / (end - start + 1) : 0;
    7c6e:	9404      	str	r4, [sp, #16]
    7c70:	e7ea      	b.n	7c48 <Pixel_pixelTweenInterpolation+0xea>
			switch ( mod->type )
    7c72:	f898 3000 	ldrb.w	r3, [r8]
    7c76:	3b01      	subs	r3, #1
    7c78:	2b04      	cmp	r3, #4
    7c7a:	d85c      	bhi.n	7d36 <Pixel_pixelTweenInterpolation+0x1d8>
    7c7c:	e8df f003 	tbb	[pc, r3]
    7c80:	0b031158 	.word	0x0b031158
    7c84:	58          	.byte	0x58
    7c85:	00          	.byte	0x00
				interp_mod->rect.col = start + cur;
    7c86:	19ab      	adds	r3, r5, r6
    7c88:	b29b      	uxth	r3, r3
    7c8a:	f8ad 3035 	strh.w	r3, [sp, #53]	; 0x35
				if ( interp_mod->rect.col >= Pixel_DisplayMapping_Cols_KLL || interp_mod->rect.col < 0 )
    7c8e:	2b10      	cmp	r3, #16
				if ( interp_mod->rect.row >= Pixel_DisplayMapping_Rows_KLL || interp_mod->rect.row < 0 )
    7c90:	d951      	bls.n	7d36 <Pixel_pixelTweenInterpolation+0x1d8>
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    7c92:	3601      	adds	r6, #1
    7c94:	e7da      	b.n	7c4c <Pixel_pixelTweenInterpolation+0xee>
				interp_mod->rect.row = start + cur;
    7c96:	19ab      	adds	r3, r5, r6
    7c98:	b29b      	uxth	r3, r3
    7c9a:	f8ad 3037 	strh.w	r3, [sp, #55]	; 0x37
				if ( interp_mod->rect.row >= Pixel_DisplayMapping_Rows_KLL || interp_mod->rect.row < 0 )
    7c9e:	2b06      	cmp	r3, #6
    7ca0:	e7f6      	b.n	7c90 <Pixel_pixelTweenInterpolation+0x132>
				interp_mod->rect.col = 0;
    7ca2:	f88d 9035 	strb.w	r9, [sp, #53]	; 0x35
    7ca6:	f88d 9036 	strb.w	r9, [sp, #54]	; 0x36
				interp_mod->rect.row = 0;
    7caa:	f88d 9037 	strb.w	r9, [sp, #55]	; 0x37
    7cae:	f88d 9038 	strb.w	r9, [sp, #56]	; 0x38
				if ( prev != 0 )
    7cb2:	b9cc      	cbnz	r4, 7ce8 <Pixel_pixelTweenInterpolation+0x18a>
			uint16_t valid = 0;
    7cb4:	f8ad 9026 	strh.w	r9, [sp, #38]	; 0x26
			uint16_t next = 0;
    7cb8:	2200      	movs	r2, #0
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    7cba:	f10d 0726 	add.w	r7, sp, #38	; 0x26
				prev_pixel_elem = elem;
    7cbe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    7cc0:	9303      	str	r3, [sp, #12]
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    7cc2:	9700      	str	r7, [sp, #0]
    7cc4:	9b02      	ldr	r3, [sp, #8]
    7cc6:	a90c      	add	r1, sp, #48	; 0x30
    7cc8:	a80d      	add	r0, sp, #52	; 0x34
    7cca:	f7ff fdf1 	bl	78b0 <Pixel_fillPixelLookup>
				if ( valid )
    7cce:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    7cd2:	4602      	mov	r2, r0
				if ( valid )
    7cd4:	b12b      	cbz	r3, 7ce2 <Pixel_pixelTweenInterpolation+0x184>
    7cd6:	9007      	str	r0, [sp, #28]
					Pixel_pixelEvaluation( interp_mod, elem );
    7cd8:	990c      	ldr	r1, [sp, #48]	; 0x30
    7cda:	a80d      	add	r0, sp, #52	; 0x34
    7cdc:	f7ff f908 	bl	6ef0 <Pixel_pixelEvaluation>
    7ce0:	9a07      	ldr	r2, [sp, #28]
			} while ( next );
    7ce2:	2a00      	cmp	r2, #0
    7ce4:	d1eb      	bne.n	7cbe <Pixel_pixelTweenInterpolation+0x160>
    7ce6:	e7d4      	b.n	7c92 <Pixel_pixelTweenInterpolation+0x134>
					interp_mod->rect.col = prev->rect.col + cur;
    7ce8:	f9b4 3001 	ldrsh.w	r3, [r4, #1]
    7cec:	4433      	add	r3, r6
    7cee:	f8ad 3035 	strh.w	r3, [sp, #53]	; 0x35
				int32_t distance = slice * cur;
    7cf2:	9b04      	ldr	r3, [sp, #16]
    7cf4:	fb06 f203 	mul.w	r2, r6, r3
				for ( uint8_t ch = 0; ch < mod_elem->channels; ch++ )
    7cf8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7cfa:	b2d2      	uxtb	r2, r2
    7cfc:	f893 e001 	ldrb.w	lr, [r3, #1]
    7d00:	2000      	movs	r0, #0
	return (start * (256 - dist) + end * dist) >> 8;
    7d02:	f5c2 7780 	rsb	r7, r2, #256	; 0x100
    7d06:	b2c3      	uxtb	r3, r0
				for ( uint8_t ch = 0; ch < mod_elem->channels; ch++ )
    7d08:	4573      	cmp	r3, lr
    7d0a:	d2d3      	bcs.n	7cb4 <Pixel_pixelTweenInterpolation+0x156>
					interp_mod->data[pos] = Pixel_8bitInterpolation(
    7d0c:	005b      	lsls	r3, r3, #1
    7d0e:	3301      	adds	r3, #1
    7d10:	b2db      	uxtb	r3, r3
    7d12:	a912      	add	r1, sp, #72	; 0x48
    7d14:	eb01 0c03 	add.w	ip, r1, r3
    7d18:	18e1      	adds	r1, r4, r3
    7d1a:	4443      	add	r3, r8
	return (start * (256 - dist) + end * dist) >> 8;
    7d1c:	7949      	ldrb	r1, [r1, #5]
    7d1e:	795b      	ldrb	r3, [r3, #5]
    7d20:	4353      	muls	r3, r2
    7d22:	fb07 3101 	mla	r1, r7, r1, r3
    7d26:	1209      	asrs	r1, r1, #8
    7d28:	f80c 1c0f 	strb.w	r1, [ip, #-15]
    7d2c:	3001      	adds	r0, #1
    7d2e:	e7ea      	b.n	7d06 <Pixel_pixelTweenInterpolation+0x1a8>
				interp_mod->index = start + cur;
    7d30:	1973      	adds	r3, r6, r5
    7d32:	f8cd 3035 	str.w	r3, [sp, #53]	; 0x35
			if ( prev != 0 )
    7d36:	2c00      	cmp	r4, #0
    7d38:	d1db      	bne.n	7cf2 <Pixel_pixelTweenInterpolation+0x194>
    7d3a:	e7bb      	b.n	7cb4 <Pixel_pixelTweenInterpolation+0x156>
		PixelElement *prev_elem = 0;
    7d3c:	940a      	str	r4, [sp, #40]	; 0x28
		uint16_t valid = 0;
    7d3e:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
			start = prev != 0 ? prev->rect.row : mod->rect.row;
    7d42:	4635      	mov	r5, r6
    7d44:	e764      	b.n	7c10 <Pixel_pixelTweenInterpolation+0xb2>
		PixelElement *prev_elem = 0;
    7d46:	940a      	str	r4, [sp, #40]	; 0x28
		uint16_t valid = 0;
    7d48:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
			end = mod->rect.col;
    7d4c:	462e      	mov	r6, r5
    7d4e:	e75f      	b.n	7c10 <Pixel_pixelTweenInterpolation+0xb2>

00007d50 <Pixel_frameTweenStandard>:
	if ( elem->subpos != 0 )
    7d50:	7a0b      	ldrb	r3, [r1, #8]
    7d52:	b113      	cbz	r3, 7d5a <Pixel_frameTweenStandard+0xa>
		if ( !( elem->frameoption & PixelFrameOption_FrameStretch ) )
    7d54:	7acb      	ldrb	r3, [r1, #11]
    7d56:	07db      	lsls	r3, r3, #31
    7d58:	d509      	bpl.n	7d6e <Pixel_frameTweenStandard+0x1e>
	switch ( elem->pfunc )
    7d5a:	7b4b      	ldrb	r3, [r1, #13]
    7d5c:	2b01      	cmp	r3, #1
    7d5e:	d004      	beq.n	7d6a <Pixel_frameTweenStandard+0x1a>
    7d60:	d301      	bcc.n	7d66 <Pixel_frameTweenStandard+0x16>
    7d62:	2b02      	cmp	r3, #2
    7d64:	d103      	bne.n	7d6e <Pixel_frameTweenStandard+0x1e>
		Pixel_pixelTweenStandard( data, elem );
    7d66:	f7ff becd 	b.w	7b04 <Pixel_pixelTweenStandard>
		Pixel_pixelTweenInterpolation( data, elem );
    7d6a:	f7ff bef8 	b.w	7b5e <Pixel_pixelTweenInterpolation>
}
    7d6e:	4770      	bx	lr

00007d70 <Pixel_animationProcess>:
{
    7d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ( elem->index == 0xFFFF )
    7d72:	8881      	ldrh	r1, [r0, #4]
	const uint8_t *data = Pixel_Animations[elem->index][elem->pos];
    7d74:	4e1a      	ldr	r6, [pc, #104]	; (7de0 <Pixel_animationProcess+0x70>)
{
    7d76:	4604      	mov	r4, r0
	if ( elem->index == 0xFFFF )
    7d78:	f64f 73ff 	movw	r3, #65535	; 0xffff
			elem->pos = 0;
    7d7c:	2700      	movs	r7, #0
	if ( elem->index == 0xFFFF )
    7d7e:	4299      	cmp	r1, r3
    7d80:	d005      	beq.n	7d8e <Pixel_animationProcess+0x1e>
	switch ( elem->state )
    7d82:	7be0      	ldrb	r0, [r4, #15]
    7d84:	2801      	cmp	r0, #1
    7d86:	d013      	beq.n	7db0 <Pixel_animationProcess+0x40>
    7d88:	2802      	cmp	r0, #2
    7d8a:	d102      	bne.n	7d92 <Pixel_animationProcess+0x22>
		elem->index = 0xFFFF;
    7d8c:	80a3      	strh	r3, [r4, #4]
		return 0;
    7d8e:	2000      	movs	r0, #0
    7d90:	e00e      	b.n	7db0 <Pixel_animationProcess+0x40>
	const uint8_t *data = Pixel_Animations[elem->index][elem->pos];
    7d92:	88e0      	ldrh	r0, [r4, #6]
    7d94:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
    7d98:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
	if ( data == 0 )
    7d9c:	b948      	cbnz	r0, 7db2 <Pixel_animationProcess+0x42>
		if ( elem->loops == 0 || elem->loops-- > 1 )
    7d9e:	7a62      	ldrb	r2, [r4, #9]
    7da0:	b90a      	cbnz	r2, 7da6 <Pixel_animationProcess+0x36>
			elem->pos = 0;
    7da2:	80e7      	strh	r7, [r4, #6]
			return Pixel_animationProcess( elem );
    7da4:	e7eb      	b.n	7d7e <Pixel_animationProcess+0xe>
		if ( elem->loops == 0 || elem->loops-- > 1 )
    7da6:	1e55      	subs	r5, r2, #1
    7da8:	2a01      	cmp	r2, #1
    7daa:	7265      	strb	r5, [r4, #9]
    7dac:	d8f9      	bhi.n	7da2 <Pixel_animationProcess+0x32>
			elem->index = 0xFFFF;
    7dae:	80a3      	strh	r3, [r4, #4]
}
    7db0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch ( elem->ffunc )
    7db2:	7b23      	ldrb	r3, [r4, #12]
    7db4:	b10b      	cbz	r3, 7dba <Pixel_animationProcess+0x4a>
    7db6:	2b02      	cmp	r3, #2
    7db8:	d102      	bne.n	7dc0 <Pixel_animationProcess+0x50>
		Pixel_frameTweenStandard( data, elem );
    7dba:	4621      	mov	r1, r4
    7dbc:	f7ff ffc8 	bl	7d50 <Pixel_frameTweenStandard>
	if ( elem->framedelay > 0 )
    7dc0:	7aa2      	ldrb	r2, [r4, #10]
    7dc2:	b122      	cbz	r2, 7dce <Pixel_animationProcess+0x5e>
		if ( elem->subpos == elem->framedelay )
    7dc4:	7a23      	ldrb	r3, [r4, #8]
    7dc6:	429a      	cmp	r2, r3
    7dc8:	d105      	bne.n	7dd6 <Pixel_animationProcess+0x66>
			elem->subpos = 0;
    7dca:	2300      	movs	r3, #0
    7dcc:	7223      	strb	r3, [r4, #8]
		elem->pos++;
    7dce:	88e3      	ldrh	r3, [r4, #6]
    7dd0:	3301      	adds	r3, #1
    7dd2:	80e3      	strh	r3, [r4, #6]
    7dd4:	e001      	b.n	7dda <Pixel_animationProcess+0x6a>
			elem->subpos++;
    7dd6:	3301      	adds	r3, #1
    7dd8:	7223      	strb	r3, [r4, #8]
	return 1;
    7dda:	2001      	movs	r0, #1
    7ddc:	e7e8      	b.n	7db0 <Pixel_animationProcess+0x40>
    7dde:	bf00      	nop
    7de0:	1fff93e4 	.word	0x1fff93e4

00007de4 <Pixel_stackProcess>:
{
    7de4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint16_t size = Pixel_AnimationStack.size;
    7de8:	4c0e      	ldr	r4, [pc, #56]	; (7e24 <Pixel_stackProcess+0x40>)
	Pixel_AnimationStack.size = 0;
    7dea:	2300      	movs	r3, #0
	uint16_t size = Pixel_AnimationStack.size;
    7dec:	8827      	ldrh	r7, [r4, #0]
	Pixel_AnimationStack.size = 0;
    7dee:	8023      	strh	r3, [r4, #0]
	for ( ; pos < size; pos++ )
    7df0:	2501      	movs	r5, #1
		if ( elem->index == 0xFFFF )
    7df2:	f64f 78ff 	movw	r8, #65535	; 0xffff
	for ( ; pos < size; pos++ )
    7df6:	1e6b      	subs	r3, r5, #1
    7df8:	b29b      	uxth	r3, r3
    7dfa:	429f      	cmp	r7, r3
    7dfc:	d801      	bhi.n	7e02 <Pixel_stackProcess+0x1e>
}
    7dfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    7e02:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
		if ( elem->index == 0xFFFF )
    7e06:	88b3      	ldrh	r3, [r6, #4]
    7e08:	4543      	cmp	r3, r8
    7e0a:	d009      	beq.n	7e20 <Pixel_stackProcess+0x3c>
		if ( Pixel_animationProcess( elem ) )
    7e0c:	4630      	mov	r0, r6
    7e0e:	f7ff ffaf 	bl	7d70 <Pixel_animationProcess>
    7e12:	b128      	cbz	r0, 7e20 <Pixel_stackProcess+0x3c>
			Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = elem;
    7e14:	8823      	ldrh	r3, [r4, #0]
    7e16:	1c5a      	adds	r2, r3, #1
    7e18:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    7e1c:	8022      	strh	r2, [r4, #0]
    7e1e:	605e      	str	r6, [r3, #4]
    7e20:	3501      	adds	r5, #1
    7e22:	e7e8      	b.n	7df6 <Pixel_stackProcess+0x12>
    7e24:	1fffa710 	.word	0x1fffa710

00007e28 <Pixel_updateUSBLEDs>:
	if ( !USBKeys_LEDs_Changed )
    7e28:	4b02      	ldr	r3, [pc, #8]	; (7e34 <Pixel_updateUSBLEDs+0xc>)
    7e2a:	781a      	ldrb	r2, [r3, #0]
    7e2c:	b10a      	cbz	r2, 7e32 <Pixel_updateUSBLEDs+0xa>
	USBKeys_LEDs_Changed = 0;
    7e2e:	2200      	movs	r2, #0
    7e30:	701a      	strb	r2, [r3, #0]
}
    7e32:	4770      	bx	lr
    7e34:	1fffadc0 	.word	0x1fffadc0

00007e38 <Pixel_setAnimationControl>:
	Pixel_animationControl = control;
    7e38:	4b01      	ldr	r3, [pc, #4]	; (7e40 <Pixel_setAnimationControl+0x8>)
    7e3a:	7018      	strb	r0, [r3, #0]
}
    7e3c:	4770      	bx	lr
    7e3e:	bf00      	nop
    7e40:	1fffa764 	.word	0x1fffa764

00007e44 <Pixel_process>:
{
    7e44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	Latency_start_time( pixelLatencyResource );
    7e48:	4d75      	ldr	r5, [pc, #468]	; (8020 <Pixel_process+0x1dc>)
	switch( Pixel_FrameState )
    7e4a:	4c76      	ldr	r4, [pc, #472]	; (8024 <Pixel_process+0x1e0>)
	Latency_start_time( pixelLatencyResource );
    7e4c:	7828      	ldrb	r0, [r5, #0]
    7e4e:	f003 fa4b 	bl	b2e8 <Latency_start_time>
	Pixel_updateUSBLEDs();
    7e52:	f7ff ffe9 	bl	7e28 <Pixel_updateUSBLEDs>
	switch( Pixel_FrameState )
    7e56:	7823      	ldrb	r3, [r4, #0]
    7e58:	3b02      	subs	r3, #2
    7e5a:	2b01      	cmp	r3, #1
    7e5c:	d828      	bhi.n	7eb0 <Pixel_process+0x6c>
	switch ( Pixel_animationControl )
    7e5e:	4e72      	ldr	r6, [pc, #456]	; (8028 <Pixel_process+0x1e4>)
    7e60:	7833      	ldrb	r3, [r6, #0]
    7e62:	2b05      	cmp	r3, #5
    7e64:	d822      	bhi.n	7eac <Pixel_process+0x68>
    7e66:	e8df f003 	tbb	[pc, r3]
    7e6a:	0303      	.short	0x0303
    7e6c:	1c131321 	.word	0x1c131321
		Pixel_FrameState = FrameState_Update;
    7e70:	2302      	movs	r3, #2
    7e72:	7023      	strb	r3, [r4, #0]
	switch ( Pixel_testMode )
    7e74:	4f6d      	ldr	r7, [pc, #436]	; (802c <Pixel_process+0x1e8>)
    7e76:	783b      	ldrb	r3, [r7, #0]
    7e78:	3b01      	subs	r3, #1
    7e7a:	2b0b      	cmp	r3, #11
    7e7c:	f200 80c8 	bhi.w	8010 <Pixel_process+0x1cc>
    7e80:	e8df f003 	tbb	[pc, r3]
    7e84:	3b321b2a 	.word	0x3b321b2a
    7e88:	6f604451 	.word	0x6f604451
    7e8c:	a7b07e92 	.word	0xa7b07e92
		Pixel_FrameState = FrameState_Update;
    7e90:	2302      	movs	r3, #2
    7e92:	7023      	strb	r3, [r4, #0]
		Pixel_clearAnimations();
    7e94:	f7fe ff60 	bl	6d58 <Pixel_clearAnimations>
		Pixel_clearPixels();
    7e98:	f7ff fac6 	bl	7428 <Pixel_clearPixels>
		Pixel_animationControl = AnimationControl_Forward;
    7e9c:	2300      	movs	r3, #0
    7e9e:	7033      	strb	r3, [r6, #0]
		break;
    7ea0:	e7e8      	b.n	7e74 <Pixel_process+0x30>
		Pixel_FrameState = FrameState_Pause;
    7ea2:	2303      	movs	r3, #3
    7ea4:	7023      	strb	r3, [r4, #0]
		Pixel_clearPixels();
    7ea6:	f7ff fabf 	bl	7428 <Pixel_clearPixels>
		break;
    7eaa:	e7e3      	b.n	7e74 <Pixel_process+0x30>
		Pixel_FrameState = FrameState_Pause;
    7eac:	2303      	movs	r3, #3
	Pixel_FrameState = FrameState_Ready;
    7eae:	7023      	strb	r3, [r4, #0]
	Latency_end_time( pixelLatencyResource );
    7eb0:	7828      	ldrb	r0, [r5, #0]
}
    7eb2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	Latency_end_time( pixelLatencyResource );
    7eb6:	f003 ba29 	b.w	b30c <Latency_end_time>
		Pixel_channelToggle( Pixel_testPos );
    7eba:	4e5d      	ldr	r6, [pc, #372]	; (8030 <Pixel_process+0x1ec>)
    7ebc:	8830      	ldrh	r0, [r6, #0]
    7ebe:	f7ff f9ed 	bl	729c <Pixel_channelToggle>
		Pixel_testPos++;
    7ec2:	8833      	ldrh	r3, [r6, #0]
    7ec4:	3301      	adds	r3, #1
    7ec6:	b29b      	uxth	r3, r3
    7ec8:	8033      	strh	r3, [r6, #0]
		if ( Pixel_testPos >= Pixel_TotalChannels_KLL )
    7eca:	2b8f      	cmp	r3, #143	; 0x8f
    7ecc:	d902      	bls.n	7ed4 <Pixel_process+0x90>
			Pixel_testPos = 0;
    7ece:	4b58      	ldr	r3, [pc, #352]	; (8030 <Pixel_process+0x1ec>)
    7ed0:	2200      	movs	r2, #0
    7ed2:	801a      	strh	r2, [r3, #0]
	Pixel_FrameState = FrameState_Ready;
    7ed4:	2300      	movs	r3, #0
    7ed6:	e7ea      	b.n	7eae <Pixel_process+0x6a>
	switch ( Pixel_testMode )
    7ed8:	2600      	movs	r6, #0
			Pixel_channelToggle( ch );
    7eda:	b2b0      	uxth	r0, r6
    7edc:	3601      	adds	r6, #1
    7ede:	f7ff f9dd 	bl	729c <Pixel_channelToggle>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    7ee2:	2e90      	cmp	r6, #144	; 0x90
    7ee4:	d1f9      	bne.n	7eda <Pixel_process+0x96>
    7ee6:	e7f5      	b.n	7ed4 <Pixel_process+0x90>
	switch ( Pixel_testMode )
    7ee8:	2600      	movs	r6, #0
			Pixel_channelSet( ch, 255 );
    7eea:	b2b0      	uxth	r0, r6
    7eec:	21ff      	movs	r1, #255	; 0xff
    7eee:	3601      	adds	r6, #1
    7ef0:	f7ff f9a4 	bl	723c <Pixel_channelSet>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    7ef4:	2e90      	cmp	r6, #144	; 0x90
    7ef6:	d1f8      	bne.n	7eea <Pixel_process+0xa6>
    7ef8:	e7ec      	b.n	7ed4 <Pixel_process+0x90>
	switch ( Pixel_testMode )
    7efa:	2600      	movs	r6, #0
			Pixel_channelSet( ch, 0 );
    7efc:	b2b0      	uxth	r0, r6
    7efe:	2100      	movs	r1, #0
    7f00:	3601      	adds	r6, #1
    7f02:	f7ff f99b 	bl	723c <Pixel_channelSet>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    7f06:	2e90      	cmp	r6, #144	; 0x90
    7f08:	d1f8      	bne.n	7efc <Pixel_process+0xb8>
    7f0a:	e7e3      	b.n	7ed4 <Pixel_process+0x90>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ Pixel_testPos ] );
    7f0c:	4e48      	ldr	r6, [pc, #288]	; (8030 <Pixel_process+0x1ec>)
    7f0e:	4b49      	ldr	r3, [pc, #292]	; (8034 <Pixel_process+0x1f0>)
    7f10:	8830      	ldrh	r0, [r6, #0]
    7f12:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    7f16:	f7ff fa95 	bl	7444 <Pixel_pixelToggle>
		Pixel_testPos++;
    7f1a:	8833      	ldrh	r3, [r6, #0]
    7f1c:	3301      	adds	r3, #1
    7f1e:	b29b      	uxth	r3, r3
    7f20:	8033      	strh	r3, [r6, #0]
		if ( Pixel_testPos >= Pixel_TotalPixels_KLL )
    7f22:	2b25      	cmp	r3, #37	; 0x25
    7f24:	e7d2      	b.n	7ecc <Pixel_process+0x88>
		for ( uint16_t px = Pixel_testPos; px < Pixel_TotalPixels_KLL; px++ )
    7f26:	4b42      	ldr	r3, [pc, #264]	; (8030 <Pixel_process+0x1ec>)
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ px ] );
    7f28:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8034 <Pixel_process+0x1f0>
		for ( uint16_t px = Pixel_testPos; px < Pixel_TotalPixels_KLL; px++ )
    7f2c:	881f      	ldrh	r7, [r3, #0]
    7f2e:	2600      	movs	r6, #0
    7f30:	19b8      	adds	r0, r7, r6
    7f32:	b283      	uxth	r3, r0
    7f34:	2b25      	cmp	r3, #37	; 0x25
    7f36:	d8cd      	bhi.n	7ed4 <Pixel_process+0x90>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ px ] );
    7f38:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
    7f3c:	f7ff fa82 	bl	7444 <Pixel_pixelToggle>
    7f40:	3601      	adds	r6, #1
    7f42:	e7f5      	b.n	7f30 <Pixel_process+0xec>
	switch ( Pixel_testMode )
    7f44:	2600      	movs	r6, #0
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 255 );
    7f46:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 8034 <Pixel_process+0x1f0>
			Pixel_testMode = PixelTest_Off;
    7f4a:	46b0      	mov	r8, r6
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 255 );
    7f4c:	eb09 00c6 	add.w	r0, r9, r6, lsl #3
    7f50:	21ff      	movs	r1, #255	; 0xff
    7f52:	3601      	adds	r6, #1
    7f54:	f7ff fa56 	bl	7404 <Pixel_pixelSet>
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    7f58:	2e26      	cmp	r6, #38	; 0x26
			Pixel_testMode = PixelTest_Off;
    7f5a:	f887 8000 	strb.w	r8, [r7]
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    7f5e:	d1f5      	bne.n	7f4c <Pixel_process+0x108>
    7f60:	e7b8      	b.n	7ed4 <Pixel_process+0x90>
	switch ( Pixel_testMode )
    7f62:	2600      	movs	r6, #0
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    7f64:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8034 <Pixel_process+0x1f0>
    7f68:	46b0      	mov	r8, r6
    7f6a:	eb09 00c6 	add.w	r0, r9, r6, lsl #3
    7f6e:	2100      	movs	r1, #0
    7f70:	3601      	adds	r6, #1
    7f72:	f7ff fa47 	bl	7404 <Pixel_pixelSet>
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    7f76:	2e26      	cmp	r6, #38	; 0x26
			Pixel_testMode = PixelTest_Off;
    7f78:	f887 8000 	strb.w	r8, [r7]
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    7f7c:	d1f5      	bne.n	7f6a <Pixel_process+0x126>
    7f7e:	e7a9      	b.n	7ed4 <Pixel_process+0x90>
		uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    7f80:	4a2b      	ldr	r2, [pc, #172]	; (8030 <Pixel_process+0x1ec>)
    7f82:	492d      	ldr	r1, [pc, #180]	; (8038 <Pixel_process+0x1f4>)
    7f84:	8813      	ldrh	r3, [r2, #0]
    7f86:	f831 0013 	ldrh.w	r0, [r1, r3, lsl #1]
		Pixel_testPos++;
    7f8a:	3301      	adds	r3, #1
    7f8c:	b29b      	uxth	r3, r3
		if ( Pixel_testPos >= MaxScanCode_KLL )
    7f8e:	2b59      	cmp	r3, #89	; 0x59
			Pixel_testPos = 0;
    7f90:	bf88      	it	hi
    7f92:	2300      	movhi	r3, #0
    7f94:	8013      	strh	r3, [r2, #0]
		if ( pixel == 0 )
    7f96:	2800      	cmp	r0, #0
    7f98:	d08a      	beq.n	7eb0 <Pixel_process+0x6c>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    7f9a:	4b26      	ldr	r3, [pc, #152]	; (8034 <Pixel_process+0x1f0>)
    7f9c:	3801      	subs	r0, #1
    7f9e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    7fa2:	f7ff fa4f 	bl	7444 <Pixel_pixelToggle>
		goto pixel_process_done;
    7fa6:	e795      	b.n	7ed4 <Pixel_process+0x90>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    7fa8:	4b21      	ldr	r3, [pc, #132]	; (8030 <Pixel_process+0x1ec>)
			uint16_t pixel = Pixel_ScanCodeToPixel[ px ];
    7faa:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8038 <Pixel_process+0x1f4>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    7fae:	881f      	ldrh	r7, [r3, #0]
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    7fb0:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8034 <Pixel_process+0x1f0>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    7fb4:	2600      	movs	r6, #0
    7fb6:	19bb      	adds	r3, r7, r6
    7fb8:	b29a      	uxth	r2, r3
    7fba:	2a59      	cmp	r2, #89	; 0x59
    7fbc:	d88a      	bhi.n	7ed4 <Pixel_process+0x90>
			uint16_t pixel = Pixel_ScanCodeToPixel[ px ];
    7fbe:	f838 0013 	ldrh.w	r0, [r8, r3, lsl #1]
			if ( pixel == 0 )
    7fc2:	b120      	cbz	r0, 7fce <Pixel_process+0x18a>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    7fc4:	3801      	subs	r0, #1
    7fc6:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    7fca:	f7ff fa3b 	bl	7444 <Pixel_pixelToggle>
    7fce:	3601      	adds	r6, #1
    7fd0:	e7f1      	b.n	7fb6 <Pixel_process+0x172>
		uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    7fd2:	4a17      	ldr	r2, [pc, #92]	; (8030 <Pixel_process+0x1ec>)
    7fd4:	4919      	ldr	r1, [pc, #100]	; (803c <Pixel_process+0x1f8>)
    7fd6:	8813      	ldrh	r3, [r2, #0]
    7fd8:	f831 0013 	ldrh.w	r0, [r1, r3, lsl #1]
		Pixel_testPos++;
    7fdc:	3301      	adds	r3, #1
    7fde:	b29b      	uxth	r3, r3
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    7fe0:	2b76      	cmp	r3, #118	; 0x76
    7fe2:	e7d5      	b.n	7f90 <Pixel_process+0x14c>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    7fe4:	4b12      	ldr	r3, [pc, #72]	; (8030 <Pixel_process+0x1ec>)
			uint16_t pixel = Pixel_DisplayMapping[ px ];
    7fe6:	f8df 8054 	ldr.w	r8, [pc, #84]	; 803c <Pixel_process+0x1f8>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    7fea:	881f      	ldrh	r7, [r3, #0]
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    7fec:	f8df 9044 	ldr.w	r9, [pc, #68]	; 8034 <Pixel_process+0x1f0>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    7ff0:	2600      	movs	r6, #0
    7ff2:	19bb      	adds	r3, r7, r6
    7ff4:	b29a      	uxth	r2, r3
    7ff6:	2a76      	cmp	r2, #118	; 0x76
    7ff8:	f63f af6c 	bhi.w	7ed4 <Pixel_process+0x90>
			uint16_t pixel = Pixel_DisplayMapping[ px ];
    7ffc:	f838 0013 	ldrh.w	r0, [r8, r3, lsl #1]
			if ( pixel == 0 )
    8000:	b120      	cbz	r0, 800c <Pixel_process+0x1c8>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    8002:	3801      	subs	r0, #1
    8004:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    8008:	f7ff fa1c 	bl	7444 <Pixel_pixelToggle>
    800c:	3601      	adds	r6, #1
    800e:	e7f0      	b.n	7ff2 <Pixel_process+0x1ae>
	Pixel_stackProcess();
    8010:	f7ff fee8 	bl	7de4 <Pixel_stackProcess>
	switch( Pixel_animationControl )
    8014:	7833      	ldrb	r3, [r6, #0]
    8016:	2b01      	cmp	r3, #1
		Pixel_animationControl = AnimationControl_Pause;
    8018:	bf04      	itt	eq
    801a:	2302      	moveq	r3, #2
    801c:	7033      	strbeq	r3, [r6, #0]
		break;
    801e:	e759      	b.n	7ed4 <Pixel_process+0x90>
    8020:	1fff93e2 	.word	0x1fff93e2
    8024:	1fffa765 	.word	0x1fffa765
    8028:	1fffa764 	.word	0x1fffa764
    802c:	1fffa8a8 	.word	0x1fffa8a8
    8030:	1fff93e0 	.word	0x1fff93e0
    8034:	0000fff0 	.word	0x0000fff0
    8038:	0001017a 	.word	0x0001017a
    803c:	0000ff02 	.word	0x0000ff02

00008040 <Pixel_setup>:
{
    8040:	b510      	push	{r4, lr}
	CLI_registerDictionary( pixelCLIDict, pixelCLIDictName );
    8042:	490a      	ldr	r1, [pc, #40]	; (806c <Pixel_setup+0x2c>)
    8044:	480a      	ldr	r0, [pc, #40]	; (8070 <Pixel_setup+0x30>)
    8046:	f002 fe6d 	bl	ad24 <CLI_registerDictionary>
	Pixel_FrameState = FrameState_Update;
    804a:	4b0a      	ldr	r3, [pc, #40]	; (8074 <Pixel_setup+0x34>)
    804c:	2202      	movs	r2, #2
    804e:	701a      	strb	r2, [r3, #0]
	Pixel_testMode = Pixel_Test_Mode_define;
    8050:	4b09      	ldr	r3, [pc, #36]	; (8078 <Pixel_setup+0x38>)
    8052:	2400      	movs	r4, #0
    8054:	701c      	strb	r4, [r3, #0]
	Pixel_clearAnimations();
    8056:	f7fe fe7f 	bl	6d58 <Pixel_clearAnimations>
	Pixel_animationControl = AnimationControl_Forward;
    805a:	4b08      	ldr	r3, [pc, #32]	; (807c <Pixel_setup+0x3c>)
	pixelLatencyResource = Latency_add_resource("PixelMap", LatencyOption_Ticks);
    805c:	4808      	ldr	r0, [pc, #32]	; (8080 <Pixel_setup+0x40>)
	Pixel_animationControl = AnimationControl_Forward;
    805e:	701c      	strb	r4, [r3, #0]
	pixelLatencyResource = Latency_add_resource("PixelMap", LatencyOption_Ticks);
    8060:	4621      	mov	r1, r4
    8062:	f003 f8f1 	bl	b248 <Latency_add_resource>
    8066:	4b07      	ldr	r3, [pc, #28]	; (8084 <Pixel_setup+0x44>)
    8068:	7018      	strb	r0, [r3, #0]
}
    806a:	bd10      	pop	{r4, pc}
    806c:	0000fd3c 	.word	0x0000fd3c
    8070:	0000fcc4 	.word	0x0000fcc4
    8074:	1fffa765 	.word	0x1fffa765
    8078:	1fffa8a8 	.word	0x1fffa8a8
    807c:	1fffa764 	.word	0x1fffa764
    8080:	0000f849 	.word	0x0000f849
    8084:	1fff93e2 	.word	0x1fff93e2

00008088 <Pixel_dispBuffer>:

void Pixel_dispBuffer()
{
    8088:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    808c:	2600      	movs	r6, #0

			PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_DisplayMapping[px] - 1 ];

			// Lookup channel data
			// TODO account for different channel size mappings
			print("\033[48;2");
    808e:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 8138 <Pixel_dispBuffer+0xb0>
			for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    8092:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 813c <Pixel_dispBuffer+0xb4>
	uint8_t col = 0;
    8096:	4635      	mov	r5, r6
		if ( Pixel_DisplayMapping[px] == 0 )
    8098:	4b20      	ldr	r3, [pc, #128]	; (811c <Pixel_dispBuffer+0x94>)
    809a:	f833 7016 	ldrh.w	r7, [r3, r6, lsl #1]
    809e:	b987      	cbnz	r7, 80c2 <Pixel_dispBuffer+0x3a>
			print("+");
    80a0:	481f      	ldr	r0, [pc, #124]	; (8120 <Pixel_dispBuffer+0x98>)
				PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
				printInt8( PixelBuf16( pixbuf, ch_pos ) );
			}
			print("m");
			print(" ");
			print("\033[0m");
    80a2:	f003 f9ad 	bl	b400 <_print>
		}

		// Determine what to increment next
		if ( col >= Pixel_DisplayMapping_Cols_KLL - 1 )
    80a6:	2d0f      	cmp	r5, #15
    80a8:	d935      	bls.n	8116 <Pixel_dispBuffer+0x8e>
		{
			col = 0;
			row++;
			print(" ");
    80aa:	481e      	ldr	r0, [pc, #120]	; (8124 <Pixel_dispBuffer+0x9c>)
    80ac:	f003 f9a8 	bl	b400 <_print>
			print(NL);
    80b0:	481d      	ldr	r0, [pc, #116]	; (8128 <Pixel_dispBuffer+0xa0>)
    80b2:	f003 f9a5 	bl	b400 <_print>
			col = 0;
    80b6:	2500      	movs	r5, #0
    80b8:	3601      	adds	r6, #1
	for ( uint16_t px = 0; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    80ba:	2e77      	cmp	r6, #119	; 0x77
    80bc:	d1ec      	bne.n	8098 <Pixel_dispBuffer+0x10>
		else
		{
			col++;
		}
	}
}
    80be:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_DisplayMapping[px] - 1 ];
    80c2:	3f01      	subs	r7, #1
			print("\033[48;2");
    80c4:	4650      	mov	r0, sl
    80c6:	f003 f99b 	bl	b400 <_print>
			for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    80ca:	eb08 02c7 	add.w	r2, r8, r7, lsl #3
    80ce:	2300      	movs	r3, #0
    80d0:	f892 b001 	ldrb.w	fp, [r2, #1]
    80d4:	b2dc      	uxtb	r4, r3
    80d6:	45a3      	cmp	fp, r4
    80d8:	f103 0901 	add.w	r9, r3, #1
    80dc:	d807      	bhi.n	80ee <Pixel_dispBuffer+0x66>
			print("m");
    80de:	4813      	ldr	r0, [pc, #76]	; (812c <Pixel_dispBuffer+0xa4>)
    80e0:	f003 f98e 	bl	b400 <_print>
			print(" ");
    80e4:	480f      	ldr	r0, [pc, #60]	; (8124 <Pixel_dispBuffer+0x9c>)
    80e6:	f003 f98b 	bl	b400 <_print>
			print("\033[0m");
    80ea:	4811      	ldr	r0, [pc, #68]	; (8130 <Pixel_dispBuffer+0xa8>)
    80ec:	e7d9      	b.n	80a2 <Pixel_dispBuffer+0x1a>
				print(";");
    80ee:	4811      	ldr	r0, [pc, #68]	; (8134 <Pixel_dispBuffer+0xac>)
    80f0:	f003 f986 	bl	b400 <_print>
				uint16_t ch_pos = elem->indices[ch];
    80f4:	eb04 0387 	add.w	r3, r4, r7, lsl #2
    80f8:	eb08 0343 	add.w	r3, r8, r3, lsl #1
    80fc:	885c      	ldrh	r4, [r3, #2]
				PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
    80fe:	4620      	mov	r0, r4
    8100:	f7fe fec8 	bl	6e94 <Pixel_bufferMap>
				printInt8( PixelBuf16( pixbuf, ch_pos ) );
    8104:	8843      	ldrh	r3, [r0, #2]
    8106:	1ae4      	subs	r4, r4, r3
    8108:	6843      	ldr	r3, [r0, #4]
    810a:	f813 0014 	ldrb.w	r0, [r3, r4, lsl #1]
    810e:	f003 f9a9 	bl	b464 <printInt8>
    8112:	464b      	mov	r3, r9
    8114:	e7de      	b.n	80d4 <Pixel_dispBuffer+0x4c>
			col++;
    8116:	3501      	adds	r5, #1
    8118:	b2ed      	uxtb	r5, r5
    811a:	e7cd      	b.n	80b8 <Pixel_dispBuffer+0x30>
    811c:	0000ff02 	.word	0x0000ff02
    8120:	0000c85a 	.word	0x0000c85a
    8124:	00011f77 	.word	0x00011f77
    8128:	00010d99 	.word	0x00010d99
    812c:	0000de79 	.word	0x0000de79
    8130:	0000de76 	.word	0x0000de76
    8134:	0000ece9 	.word	0x0000ece9
    8138:	0000f5ad 	.word	0x0000f5ad
    813c:	0000fff0 	.word	0x0000fff0

00008140 <cliFunc_rectDisp>:

void cliFunc_rectDisp( char* args )
{
    8140:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    8142:	4803      	ldr	r0, [pc, #12]	; (8150 <cliFunc_rectDisp+0x10>)
    8144:	f003 f95c 	bl	b400 <_print>

	// TODO move to own function, use this func to control startup/args
	Pixel_dispBuffer();
}
    8148:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	Pixel_dispBuffer();
    814c:	f7ff bf9c 	b.w	8088 <Pixel_dispBuffer>
    8150:	00010d99 	.word	0x00010d99

00008154 <HIDIO_supported_0_call>:
// Supported Ids call
HIDIO_Return HIDIO_supported_0_call( uint16_t buf_pos, uint8_t irq )
{
	// TODO
	return HIDIO_Return__Ok;
}
    8154:	2000      	movs	r0, #0
    8156:	4770      	bx	lr

00008158 <HIDIO_supported_0_reply>:
// Supported Ids reply
HIDIO_Return HIDIO_supported_0_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
	// TODO
	return HIDIO_Return__Ok;
}
    8158:	2000      	movs	r0, #0
    815a:	4770      	bx	lr

0000815c <HIDIO_test_2_reply>:
	return HIDIO_Return__Ok;
}

// Test reply
HIDIO_Return HIDIO_test_2_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
    815c:	b510      	push	{r4, lr}
	// TODO (HaaTa) - Add option to process optionally inside irqs
	if ( irq )
    815e:	b9a9      	cbnz	r1, 818c <HIDIO_test_2_reply+0x30>
	{
		return HIDIO_Return__Delay;
	}

	// Make sure entry is ready
	if ( !buf->done )
    8160:	7983      	ldrb	r3, [r0, #6]
    8162:	b19b      	cbz	r3, 818c <HIDIO_test_2_reply+0x30>
    8164:	8882      	ldrh	r2, [r0, #4]
    8166:	f100 0308 	add.w	r3, r0, #8
    816a:	441a      	add	r2, r3
	{
		return HIDIO_Return__Delay;
	}

	// Get size and iterate through payload, start after id
	uint16_t transitions = 0;
    816c:	4608      	mov	r0, r1
	uint8_t last_byte = 0;
	for ( uint16_t pos = 0; pos < buf->size; pos++ )
    816e:	4293      	cmp	r3, r2
    8170:	d104      	bne.n	817c <HIDIO_test_2_reply+0x20>
		return HIDIO_Return__Delay;
    8172:	2801      	cmp	r0, #1
    8174:	bf94      	ite	ls
    8176:	2000      	movls	r0, #0
    8178:	2001      	movhi	r0, #1
		return HIDIO_Return__InBuffer_Fail;
	}

	// Buffer is automatically released for us
	return HIDIO_Return__Ok;
}
    817a:	bd10      	pop	{r4, pc}
		uint8_t byte = buf->data[ pos ];
    817c:	f813 4b01 	ldrb.w	r4, [r3], #1
		if ( byte != last_byte )
    8180:	428c      	cmp	r4, r1
			transitions++;
    8182:	bf1c      	itt	ne
    8184:	3001      	addne	r0, #1
    8186:	b280      	uxthne	r0, r0
		uint8_t byte = buf->data[ pos ];
    8188:	4621      	mov	r1, r4
    818a:	e7f0      	b.n	816e <HIDIO_test_2_reply+0x12>
		return HIDIO_Return__Delay;
    818c:	2003      	movs	r0, #3
    818e:	e7f4      	b.n	817a <HIDIO_test_2_reply+0x1e>

00008190 <HIDIO_info_1_reply>:
    8190:	2000      	movs	r0, #0
    8192:	4770      	bx	lr

00008194 <HIDIO_info_1_call>:
    8194:	2000      	movs	r0, #0
    8196:	4770      	bx	lr

00008198 <HIDIO_buffer_munch>:
{
    8198:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ( buf_pos + len < buffer->len )
    819a:	8904      	ldrh	r4, [r0, #8]
{
    819c:	461f      	mov	r7, r3
	if ( buf_pos + len < buffer->len )
    819e:	18d3      	adds	r3, r2, r3
    81a0:	42a3      	cmp	r3, r4
{
    81a2:	4606      	mov	r6, r0
    81a4:	460d      	mov	r5, r1
    81a6:	68c0      	ldr	r0, [r0, #12]
    81a8:	4611      	mov	r1, r2
	if ( buf_pos + len < buffer->len )
    81aa:	da01      	bge.n	81b0 <HIDIO_buffer_munch+0x18>
		return &(buffer->data[ buf_pos ]);
    81ac:	4410      	add	r0, r2
}
    81ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ( len == 1 )
    81b0:	2f01      	cmp	r7, #1
    81b2:	d0fc      	beq.n	81ae <HIDIO_buffer_munch+0x16>
	uint16_t cur_len = buffer->len - buf_pos;
    81b4:	1aa4      	subs	r4, r4, r2
    81b6:	b2a4      	uxth	r4, r4
	memcpy( buf, &(buffer->data[ buf_pos ]), cur_len );
    81b8:	4401      	add	r1, r0
    81ba:	4622      	mov	r2, r4
    81bc:	4628      	mov	r0, r5
    81be:	f7fa fa47 	bl	2650 <memcpy>
	memcpy( &buf[ cur_len ], buffer->data, len - cur_len );
    81c2:	1b3a      	subs	r2, r7, r4
    81c4:	68f1      	ldr	r1, [r6, #12]
    81c6:	1928      	adds	r0, r5, r4
    81c8:	f7fa fa42 	bl	2650 <memcpy>
	return buf;
    81cc:	4628      	mov	r0, r5
    81ce:	e7ee      	b.n	81ae <HIDIO_buffer_munch+0x16>

000081d0 <HIDIO_buffer_push_byte>:
	if ( buffer->tail == buffer->len )
    81d0:	8842      	ldrh	r2, [r0, #2]
    81d2:	8903      	ldrh	r3, [r0, #8]
    81d4:	429a      	cmp	r2, r3
		buffer->tail = 0;
    81d6:	bf04      	itt	eq
    81d8:	2300      	moveq	r3, #0
    81da:	8043      	strheq	r3, [r0, #2]
	buffer->data[ buffer->tail++ ] = byte;
    81dc:	8843      	ldrh	r3, [r0, #2]
    81de:	68c2      	ldr	r2, [r0, #12]
{
    81e0:	b510      	push	{r4, lr}
	buffer->data[ buffer->tail++ ] = byte;
    81e2:	1c5c      	adds	r4, r3, #1
    81e4:	8044      	strh	r4, [r0, #2]
    81e6:	54d1      	strb	r1, [r2, r3]
}
    81e8:	bd10      	pop	{r4, pc}

000081ea <HIDIO_modify_buffer>:
{
    81ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    81ec:	b296      	uxth	r6, r2
    81ee:	1b89      	subs	r1, r1, r6
    81f0:	b294      	uxth	r4, r2
	for ( uint16_t c = 0; c < len; c++ )
    81f2:	1ba5      	subs	r5, r4, r6
    81f4:	b2ad      	uxth	r5, r5
    81f6:	42ab      	cmp	r3, r5
    81f8:	d800      	bhi.n	81fc <HIDIO_modify_buffer+0x12>
}
    81fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if ( pos >= buffer->len )
    81fc:	8905      	ldrh	r5, [r0, #8]
		buffer->data[pos] = data[c];
    81fe:	f812 7b01 	ldrb.w	r7, [r2], #1
    8202:	440c      	add	r4, r1
    8204:	b2a4      	uxth	r4, r4
		if ( pos >= buffer->len )
    8206:	42a5      	cmp	r5, r4
			pos -= buffer->len;
    8208:	bf9c      	itt	ls
    820a:	1b64      	subls	r4, r4, r5
    820c:	b2a4      	uxthls	r4, r4
		buffer->data[pos] = data[c];
    820e:	68c5      	ldr	r5, [r0, #12]
    8210:	552f      	strb	r7, [r5, r4]
    8212:	e7ed      	b.n	81f0 <HIDIO_modify_buffer+0x6>

00008214 <HIDIO_buffer_pop_bytes>:
{
    8214:	b538      	push	{r3, r4, r5, lr}
    8216:	4604      	mov	r4, r0
	if ( len > buffer->len )
    8218:	8900      	ldrh	r0, [r0, #8]
    821a:	4288      	cmp	r0, r1
{
    821c:	460d      	mov	r5, r1
	if ( len > buffer->len )
    821e:	d210      	bcs.n	8242 <HIDIO_buffer_pop_bytes+0x2e>
		erro_msg("Requested HIDIO buffer pop larger than entire buffer: ");
    8220:	480c      	ldr	r0, [pc, #48]	; (8254 <HIDIO_buffer_pop_bytes+0x40>)
    8222:	f003 f8ed 	bl	b400 <_print>
		printInt16( len );
    8226:	4628      	mov	r0, r5
    8228:	f003 f93a 	bl	b4a0 <printInt16>
		print(":");
    822c:	480a      	ldr	r0, [pc, #40]	; (8258 <HIDIO_buffer_pop_bytes+0x44>)
    822e:	f003 f8e7 	bl	b400 <_print>
		printInt16( buffer->len );
    8232:	8920      	ldrh	r0, [r4, #8]
    8234:	f003 f934 	bl	b4a0 <printInt16>
		print(NL);
    8238:	4808      	ldr	r0, [pc, #32]	; (825c <HIDIO_buffer_pop_bytes+0x48>)
    823a:	f003 f8e1 	bl	b400 <_print>
    823e:	2000      	movs	r0, #0
}
    8240:	bd38      	pop	{r3, r4, r5, pc}
	if ( len + buffer->head > buffer->len )
    8242:	8822      	ldrh	r2, [r4, #0]
    8244:	1851      	adds	r1, r2, r1
    8246:	b28b      	uxth	r3, r1
    8248:	4281      	cmp	r1, r0
		buffer->head = len + buffer->head - buffer->len;
    824a:	bfc8      	it	gt
    824c:	1a1b      	subgt	r3, r3, r0
		buffer->head += len;
    824e:	8023      	strh	r3, [r4, #0]
	return 1;
    8250:	2001      	movs	r0, #1
    8252:	e7f5      	b.n	8240 <HIDIO_buffer_pop_bytes+0x2c>
    8254:	00010239 	.word	0x00010239
    8258:	0000f857 	.word	0x0000f857
    825c:	00010d99 	.word	0x00010d99

00008260 <HIDIO_buffer_free_bytes>:
	if ( buffer->head <= buffer->tail )
    8260:	8803      	ldrh	r3, [r0, #0]
    8262:	8842      	ldrh	r2, [r0, #2]
    8264:	4293      	cmp	r3, r2
		return buffer->len - (buffer->tail - buffer->head);
    8266:	bf9d      	ittte	ls
    8268:	8900      	ldrhls	r0, [r0, #8]
    826a:	18c0      	addls	r0, r0, r3
    826c:	1a80      	subls	r0, r0, r2
		return buffer->head - buffer->tail;
    826e:	1a98      	subhi	r0, r3, r2
    8270:	b280      	uxth	r0, r0
}
    8272:	4770      	bx	lr

00008274 <HIDIO_buffer_position>:
	if ( cur_pos + distance >= buffer->len )
    8274:	8903      	ldrh	r3, [r0, #8]
    8276:	1888      	adds	r0, r1, r2
    8278:	4298      	cmp	r0, r3
		return buffer->len - (cur_pos + distance);
    827a:	bfa3      	ittte	ge
    827c:	1a9b      	subge	r3, r3, r2
    827e:	1a59      	subge	r1, r3, r1
    8280:	b288      	uxthge	r0, r1
		return cur_pos + distance;
    8282:	b280      	uxthlt	r0, r0
}
    8284:	4770      	bx	lr

00008286 <HIDIO_buffer_id>:
	if ( packet->id_width == 0 )
    8286:	7803      	ldrb	r3, [r0, #0]
    8288:	06db      	lsls	r3, r3, #27
		id = pkt->id;
    828a:	bf54      	ite	pl
    828c:	8840      	ldrhpl	r0, [r0, #2]
		id = pkt->id;
    828e:	f8d0 0002 	ldrmi.w	r0, [r0, #2]
}
    8292:	4770      	bx	lr

00008294 <HIDIO_payload_start>:
	if ( packet->id_width == 0 )
    8294:	7803      	ldrb	r3, [r0, #0]
    8296:	06db      	lsls	r3, r3, #27
		data = pkt->data;
    8298:	bf54      	ite	pl
    829a:	3004      	addpl	r0, #4
		data = pkt->data;
    829c:	3006      	addmi	r0, #6
}
    829e:	4770      	bx	lr

000082a0 <HIDIO_buffer_generate_packet>:
{
    82a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    82a4:	b08b      	sub	sp, #44	; 0x2c
    82a6:	460c      	mov	r4, r1
    82a8:	9301      	str	r3, [sp, #4]
    82aa:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    82ae:	9302      	str	r3, [sp, #8]
    82b0:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
    82b4:	9303      	str	r3, [sp, #12]
		width = 2;
    82b6:	9b16      	ldr	r3, [sp, #88]	; 0x58
    82b8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    82bc:	4b68      	ldr	r3, [pc, #416]	; (8460 <HIDIO_buffer_generate_packet+0x1c0>)
    82be:	f8b3 b000 	ldrh.w	fp, [r3]
    82c2:	bf2c      	ite	cs
    82c4:	2104      	movcs	r1, #4
    82c6:	2102      	movcc	r1, #2
    82c8:	ebab 0b01 	sub.w	fp, fp, r1
    82cc:	fa1f fb8b 	uxth.w	fp, fp
    82d0:	f1ab 0902 	sub.w	r9, fp, #2
{
    82d4:	4607      	mov	r7, r0
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    82d6:	fa1f f989 	uxth.w	r9, r9
	if ( payload_len != 0 )
    82da:	4690      	mov	r8, r2
    82dc:	2a00      	cmp	r2, #0
    82de:	d031      	beq.n	8344 <HIDIO_buffer_generate_packet+0xa4>
		packet_count = payload_len / max_payload;
    82e0:	fbb2 faf9 	udiv	sl, r2, r9
		cur_packet = pos / max_payload;
    82e4:	fbb4 f6f9 	udiv	r6, r4, r9
		packet_count += payload_len % max_payload != 0 ? 1 : 0;
    82e8:	fb09 231a 	mls	r3, r9, sl, r2
    82ec:	b29b      	uxth	r3, r3
    82ee:	2b00      	cmp	r3, #0
    82f0:	bf18      	it	ne
    82f2:	f10a 0a01 	addne.w	sl, sl, #1
		cur_packet += pos % max_payload != 0 ? 1 : 0;
    82f6:	fb09 4316 	mls	r3, r9, r6, r4
    82fa:	b29b      	uxth	r3, r3
    82fc:	2b00      	cmp	r3, #0
    82fe:	bf18      	it	ne
    8300:	3601      	addne	r6, #1
		packet_count += payload_len % max_payload != 0 ? 1 : 0;
    8302:	fa1f fa8a 	uxth.w	sl, sl
		cur_packet += pos % max_payload != 0 ? 1 : 0;
    8306:	b2b6      	uxth	r6, r6
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    8308:	eba8 0304 	sub.w	r3, r8, r4
    830c:	ebaa 0506 	sub.w	r5, sl, r6
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    8310:	4638      	mov	r0, r7
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    8312:	eb03 0545 	add.w	r5, r3, r5, lsl #1
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    8316:	f7ff ffa3 	bl	8260 <HIDIO_buffer_free_bytes>
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    831a:	b2ad      	uxth	r5, r5
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    831c:	42a8      	cmp	r0, r5
    831e:	d315      	bcc.n	834c <HIDIO_buffer_generate_packet+0xac>
			uint16_t packet_len = bytes_left + width;
    8320:	eb09 0301 	add.w	r3, r9, r1
    8324:	b29b      	uxth	r3, r3
    8326:	9304      	str	r3, [sp, #16]
			uint16_t cur_payload_len = payload_len - pos + width;
    8328:	eb08 0301 	add.w	r3, r8, r1
    832c:	9305      	str	r3, [sp, #20]
	for ( ; pos < payload_len || payload_len == 0; pos++ )
    832e:	4544      	cmp	r4, r8
    8330:	d32b      	bcc.n	838a <HIDIO_buffer_generate_packet+0xea>
    8332:	f1b8 0f00 	cmp.w	r8, #0
    8336:	d028      	beq.n	838a <HIDIO_buffer_generate_packet+0xea>
	if ( pos == payload_len )
    8338:	4544      	cmp	r4, r8
		buf->packets_ready++;
    833a:	bf02      	ittt	eq
    833c:	897b      	ldrheq	r3, [r7, #10]
    833e:	3301      	addeq	r3, #1
    8340:	817b      	strheq	r3, [r7, #10]
    8342:	e01e      	b.n	8382 <HIDIO_buffer_generate_packet+0xe2>
	uint16_t cur_packet = 0;
    8344:	4616      	mov	r6, r2
	uint16_t packet_count = 1;
    8346:	f04f 0a01 	mov.w	sl, #1
    834a:	e7dd      	b.n	8308 <HIDIO_buffer_generate_packet+0x68>
		erro_msg("Not enough bytes in HIDIO buffer: ");
    834c:	4845      	ldr	r0, [pc, #276]	; (8464 <HIDIO_buffer_generate_packet+0x1c4>)
    834e:	f003 f857 	bl	b400 <_print>
		printInt16( HIDIO_buffer_free_bytes( buf ) );
    8352:	4638      	mov	r0, r7
    8354:	f7ff ff84 	bl	8260 <HIDIO_buffer_free_bytes>
    8358:	f003 f8a2 	bl	b4a0 <printInt16>
		print(" bytes left, ");
    835c:	4842      	ldr	r0, [pc, #264]	; (8468 <HIDIO_buffer_generate_packet+0x1c8>)
    835e:	f003 f84f 	bl	b400 <_print>
		printInt16( buf->len );
    8362:	8938      	ldrh	r0, [r7, #8]
    8364:	f003 f89c 	bl	b4a0 <printInt16>
		print(" bytes total ");
    8368:	4840      	ldr	r0, [pc, #256]	; (846c <HIDIO_buffer_generate_packet+0x1cc>)
    836a:	f003 f849 	bl	b400 <_print>
		printInt16( requested );
    836e:	4628      	mov	r0, r5
    8370:	f003 f896 	bl	b4a0 <printInt16>
		print(" bytes requested");
    8374:	483e      	ldr	r0, [pc, #248]	; (8470 <HIDIO_buffer_generate_packet+0x1d0>)
    8376:	f003 f843 	bl	b400 <_print>
		print(NL);
    837a:	483e      	ldr	r0, [pc, #248]	; (8474 <HIDIO_buffer_generate_packet+0x1d4>)
    837c:	f003 f840 	bl	b400 <_print>
		return payload_len;
    8380:	4644      	mov	r4, r8
}
    8382:	4620      	mov	r0, r4
    8384:	b00b      	add	sp, #44	; 0x2c
    8386:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t bytes_left = pos % max_payload;
    838a:	fbb4 f5f9 	udiv	r5, r4, r9
    838e:	fb09 4515 	mls	r5, r9, r5, r4
    8392:	b2ad      	uxth	r5, r5
		if ( bytes_left == 0 )
    8394:	2d00      	cmp	r5, #0
    8396:	d135      	bne.n	8404 <HIDIO_buffer_generate_packet+0x164>
			if ( pos != 0 )
    8398:	b114      	cbz	r4, 83a0 <HIDIO_buffer_generate_packet+0x100>
				buf->packets_ready++;
    839a:	897b      	ldrh	r3, [r7, #10]
    839c:	3301      	adds	r3, #1
    839e:	817b      	strh	r3, [r7, #10]
			uint16_t cur_payload_len = payload_len - pos + width;
    83a0:	9b05      	ldr	r3, [sp, #20]
			if ( id <= 0xFFFF )
    83a2:	9d16      	ldr	r5, [sp, #88]	; 0x58
			uint16_t cur_payload_len = payload_len - pos + width;
    83a4:	1b1a      	subs	r2, r3, r4
    83a6:	9b04      	ldr	r3, [sp, #16]
    83a8:	b292      	uxth	r2, r2
			cur_packet++;
    83aa:	3601      	adds	r6, #1
    83ac:	429a      	cmp	r2, r3
    83ae:	b2b6      	uxth	r6, r6
    83b0:	bf28      	it	cs
    83b2:	461a      	movcs	r2, r3
			uint8_t p_type = cur_packet == 1 ? type : HIDIO_Packet_Type__Continued;
    83b4:	2e01      	cmp	r6, #1
    83b6:	9b03      	ldr	r3, [sp, #12]
    83b8:	bf18      	it	ne
    83ba:	2304      	movne	r3, #4
			uint8_t p_cont = cur_packet == packet_count ? 0 : 1;
    83bc:	ebba 0006 	subs.w	r0, sl, r6
    83c0:	bf18      	it	ne
    83c2:	2001      	movne	r0, #1
    83c4:	f003 0307 	and.w	r3, r3, #7
			if ( id <= 0xFFFF )
    83c8:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
    83cc:	f3c2 2101 	ubfx	r1, r2, #8, #2
				HIDIO_Packet16 packet = {
    83d0:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
    83d4:	b2d2      	uxtb	r2, r2
    83d6:	f04f 0500 	mov.w	r5, #0
			if ( id <= 0xFFFF )
    83da:	d22a      	bcs.n	8432 <HIDIO_buffer_generate_packet+0x192>
				HIDIO_Packet16 packet = {
    83dc:	f361 1387 	bfi	r3, r1, #6, #2
    83e0:	f88d 3020 	strb.w	r3, [sp, #32]
					.id = (uint16_t)id,
    83e4:	9b16      	ldr	r3, [sp, #88]	; 0x58
				HIDIO_Packet16 packet = {
    83e6:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
					.id = (uint16_t)id,
    83ea:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    83ee:	ab08      	add	r3, sp, #32
    83f0:	4638      	mov	r0, r7
    83f2:	5d59      	ldrb	r1, [r3, r5]
    83f4:	3501      	adds	r5, #1
    83f6:	f7ff feeb 	bl	81d0 <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet16); byte++ )
    83fa:	2d04      	cmp	r5, #4
    83fc:	d1f7      	bne.n	83ee <HIDIO_buffer_generate_packet+0x14e>
				bytes_left -= sizeof(HIDIO_Packet16);
    83fe:	f1ab 0506 	sub.w	r5, fp, #6
				bytes_left -= sizeof(HIDIO_Packet32);
    8402:	b2ad      	uxth	r5, r5
    8404:	9b02      	ldr	r3, [sp, #8]
    8406:	18e2      	adds	r2, r4, r3
		for ( ; byte < data_len && bytes_left > 0; byte++, pos++, bytes_left-- )
    8408:	9b01      	ldr	r3, [sp, #4]
    840a:	441d      	add	r5, r3
    840c:	b292      	uxth	r2, r2
    840e:	b2ad      	uxth	r5, r5
    8410:	42a2      	cmp	r2, r4
    8412:	d091      	beq.n	8338 <HIDIO_buffer_generate_packet+0x98>
    8414:	b299      	uxth	r1, r3
    8416:	3401      	adds	r4, #1
    8418:	428d      	cmp	r5, r1
    841a:	b2a4      	uxth	r4, r4
    841c:	d087      	beq.n	832e <HIDIO_buffer_generate_packet+0x8e>
			HIDIO_buffer_push_byte( buf, data[ byte ] );
    841e:	f813 1b01 	ldrb.w	r1, [r3], #1
    8422:	9207      	str	r2, [sp, #28]
    8424:	4638      	mov	r0, r7
    8426:	9306      	str	r3, [sp, #24]
    8428:	f7ff fed2 	bl	81d0 <HIDIO_buffer_push_byte>
    842c:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
    8430:	e7ee      	b.n	8410 <HIDIO_buffer_generate_packet+0x170>
				HIDIO_Packet32 packet = {
    8432:	f043 0310 	orr.w	r3, r3, #16
    8436:	f361 1387 	bfi	r3, r1, #6, #2
    843a:	f88d 3020 	strb.w	r3, [sp, #32]
    843e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    8440:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
    8444:	f8cd 3022 	str.w	r3, [sp, #34]	; 0x22
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    8448:	ab08      	add	r3, sp, #32
    844a:	4638      	mov	r0, r7
    844c:	5d59      	ldrb	r1, [r3, r5]
    844e:	3501      	adds	r5, #1
    8450:	f7ff febe 	bl	81d0 <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet32); byte++ )
    8454:	2d06      	cmp	r5, #6
    8456:	d1f7      	bne.n	8448 <HIDIO_buffer_generate_packet+0x1a8>
				bytes_left -= sizeof(HIDIO_Packet32);
    8458:	f1ab 0508 	sub.w	r5, fp, #8
    845c:	e7d1      	b.n	8402 <HIDIO_buffer_generate_packet+0x162>
    845e:	bf00      	nop
    8460:	1fffaa24 	.word	0x1fffaa24
    8464:	000101d4 	.word	0x000101d4
    8468:	0001020c 	.word	0x0001020c
    846c:	0001021a 	.word	0x0001021a
    8470:	00010228 	.word	0x00010228
    8474:	00010d99 	.word	0x00010d99

00008478 <HIDIO_test_2_call>:
{
    8478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    847c:	4605      	mov	r5, r0
    847e:	b089      	sub	sp, #36	; 0x24
	if ( irq )
    8480:	460c      	mov	r4, r1
    8482:	2900      	cmp	r1, #0
    8484:	d146      	bne.n	8514 <HIDIO_test_2_call+0x9c>
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    8486:	4e24      	ldr	r6, [pc, #144]	; (8518 <HIDIO_test_2_call+0xa0>)
    8488:	2308      	movs	r3, #8
    848a:	4602      	mov	r2, r0
    848c:	a906      	add	r1, sp, #24
    848e:	4630      	mov	r0, r6
    8490:	f7ff fe82 	bl	8198 <HIDIO_buffer_munch>
	if ( !entry->done )
    8494:	7983      	ldrb	r3, [r0, #6]
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    8496:	4680      	mov	r8, r0
	if ( !entry->done )
    8498:	2b00      	cmp	r3, #0
    849a:	d03b      	beq.n	8514 <HIDIO_test_2_call+0x9c>
	uint8_t last_byte = 0;
    849c:	f88d 4017 	strb.w	r4, [sp, #23]
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    84a0:	3508      	adds	r5, #8
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    84a2:	f8b0 a004 	ldrh.w	sl, [r0, #4]
	if ( buf_pos + len < buffer->len )
    84a6:	f8b6 b008 	ldrh.w	fp, [r6, #8]
		return &(buffer->data[0]);
    84aa:	f8d6 900c 	ldr.w	r9, [r6, #12]
	uint16_t transitions = 0;
    84ae:	4627      	mov	r7, r4
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    84b0:	b2ad      	uxth	r5, r5
    84b2:	b2a2      	uxth	r2, r4
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    84b4:	4552      	cmp	r2, sl
    84b6:	d30c      	bcc.n	84d2 <HIDIO_test_2_call+0x5a>
	if ( transitions > 1 )
    84b8:	2f01      	cmp	r7, #1
    84ba:	d829      	bhi.n	8510 <HIDIO_test_2_call+0x98>
		pos = HIDIO_buffer_generate_packet(
    84bc:	4d17      	ldr	r5, [pc, #92]	; (851c <HIDIO_test_2_call+0xa4>)
	uint16_t pos = 0;
    84be:	2100      	movs	r1, #0
		pos = HIDIO_buffer_generate_packet(
    84c0:	2402      	movs	r4, #2
	while ( pos < entry->size )
    84c2:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    84c6:	4291      	cmp	r1, r2
    84c8:	d317      	bcc.n	84fa <HIDIO_test_2_call+0x82>
	return HIDIO_Return__Ok;
    84ca:	2000      	movs	r0, #0
}
    84cc:	b009      	add	sp, #36	; 0x24
    84ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    84d2:	4629      	mov	r1, r5
    84d4:	4630      	mov	r0, r6
    84d6:	f7ff fecd 	bl	8274 <HIDIO_buffer_position>
	if ( buf_pos + len < buffer->len )
    84da:	1c43      	adds	r3, r0, #1
    84dc:	455b      	cmp	r3, fp
		return &(buffer->data[ buf_pos ]);
    84de:	bfb4      	ite	lt
    84e0:	4448      	addlt	r0, r9
		return &(buffer->data[0]);
    84e2:	4648      	movge	r0, r9
		if ( *byte != last_byte )
    84e4:	f89d 2017 	ldrb.w	r2, [sp, #23]
    84e8:	7803      	ldrb	r3, [r0, #0]
    84ea:	429a      	cmp	r2, r3
			transitions++;
    84ec:	bf1e      	ittt	ne
    84ee:	3701      	addne	r7, #1
    84f0:	b2bf      	uxthne	r7, r7
			last_byte = *byte;
    84f2:	f88d 3017 	strbne.w	r3, [sp, #23]
    84f6:	3401      	adds	r4, #1
    84f8:	e7db      	b.n	84b2 <HIDIO_test_2_call+0x3a>
		pos = HIDIO_buffer_generate_packet(
    84fa:	2301      	movs	r3, #1
    84fc:	e9cd 3300 	strd	r3, r3, [sp]
    8500:	9402      	str	r4, [sp, #8]
    8502:	f10d 0317 	add.w	r3, sp, #23
    8506:	4628      	mov	r0, r5
    8508:	f7ff feca 	bl	82a0 <HIDIO_buffer_generate_packet>
    850c:	4601      	mov	r1, r0
    850e:	e7d8      	b.n	84c2 <HIDIO_test_2_call+0x4a>
		return HIDIO_Return__InBuffer_Fail;
    8510:	2001      	movs	r0, #1
    8512:	e7db      	b.n	84cc <HIDIO_test_2_call+0x54>
		return HIDIO_Return__Delay;
    8514:	2003      	movs	r0, #3
    8516:	e7d9      	b.n	84cc <HIDIO_test_2_call+0x54>
    8518:	1fffaccc 	.word	0x1fffaccc
    851c:	1fffabcc 	.word	0x1fffabcc

00008520 <HIDIO_nopayload_ack>:
{
    8520:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	HIDIO_buffer_generate_packet(
    8522:	2300      	movs	r3, #0
    8524:	2201      	movs	r2, #1
    8526:	9002      	str	r0, [sp, #8]
    8528:	e9cd 3200 	strd	r3, r2, [sp]
    852c:	4619      	mov	r1, r3
    852e:	461a      	mov	r2, r3
    8530:	4802      	ldr	r0, [pc, #8]	; (853c <HIDIO_nopayload_ack+0x1c>)
    8532:	f7ff feb5 	bl	82a0 <HIDIO_buffer_generate_packet>
}
    8536:	b005      	add	sp, #20
    8538:	f85d fb04 	ldr.w	pc, [sp], #4
    853c:	1fffabcc 	.word	0x1fffabcc

00008540 <HIDIO_register_id>:
// ----- Functions -----

// Register HID-IO callbacks
// If an Id is not registered, it is ignored and automatically NAK'd
void HIDIO_register_id( uint32_t id, void* incoming_call_func, void* incoming_reply_func )
{
    8540:	b538      	push	{r3, r4, r5, lr}
	// Check if there is any room left in the list
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    8542:	4b0d      	ldr	r3, [pc, #52]	; (8578 <HIDIO_register_id+0x38>)
{
    8544:	4605      	mov	r5, r0
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    8546:	6818      	ldr	r0, [r3, #0]
    8548:	2813      	cmp	r0, #19
    854a:	d90a      	bls.n	8562 <HIDIO_register_id+0x22>
	{
		erro_msg("HIDIO_Id_List is full, cannot register Id: ");
    854c:	480b      	ldr	r0, [pc, #44]	; (857c <HIDIO_register_id+0x3c>)
    854e:	f002 ff57 	bl	b400 <_print>
		printInt32( id );
    8552:	4628      	mov	r0, r5
    8554:	f002 ffc3 	bl	b4de <printInt32>
		print( NL );
    8558:	4809      	ldr	r0, [pc, #36]	; (8580 <HIDIO_register_id+0x40>)
	// Add id to unsorted list (no reason to sort, as Ids may not be contiguous)
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
	entry->id = id;
	entry->call_func = incoming_call_func;
	entry->reply_func = incoming_reply_func;
}
    855a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print( NL );
    855e:	f002 bf4f 	b.w	b400 <_print>
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
    8562:	1c44      	adds	r4, r0, #1
    8564:	601c      	str	r4, [r3, #0]
	entry->id = id;
    8566:	4c07      	ldr	r4, [pc, #28]	; (8584 <HIDIO_register_id+0x44>)
    8568:	230c      	movs	r3, #12
    856a:	4343      	muls	r3, r0
    856c:	18e0      	adds	r0, r4, r3
    856e:	50e5      	str	r5, [r4, r3]
	entry->reply_func = incoming_reply_func;
    8570:	e9c0 1201 	strd	r1, r2, [r0, #4]
}
    8574:	bd38      	pop	{r3, r4, r5, pc}
    8576:	bf00      	nop
    8578:	1fffaa20 	.word	0x1fffaa20
    857c:	00010354 	.word	0x00010354
    8580:	00010d99 	.word	0x00010d99
    8584:	1fffabdc 	.word	0x1fffabdc

00008588 <HIDIO_call_id>:
// Initiate registered call function
// id - Function id
// buf_pos - Index in ring buffer
// irq - Set to 1 if called from an IRQ
HIDIO_Return HIDIO_call_id( uint32_t id, uint16_t buf_pos, uint8_t irq )
{
    8588:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	HIDIO_Return retval = HIDIO_Return__Unknown;

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    858c:	4f1e      	ldr	r7, [pc, #120]	; (8608 <HIDIO_call_id+0x80>)
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    858e:	4e1f      	ldr	r6, [pc, #124]	; (860c <HIDIO_call_id+0x84>)
{
    8590:	4680      	mov	r8, r0
    8592:	4689      	mov	r9, r1
    8594:	4692      	mov	sl, r2
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    8596:	2400      	movs	r4, #0
	HIDIO_Return retval = HIDIO_Return__Unknown;
    8598:	2504      	movs	r5, #4
		if ( HIDIO_Id_List[ pos ].id == id )
    859a:	f04f 0b0c 	mov.w	fp, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    859e:	683a      	ldr	r2, [r7, #0]
    85a0:	b2a3      	uxth	r3, r4
    85a2:	429a      	cmp	r2, r3
    85a4:	d806      	bhi.n	85b4 <HIDIO_call_id+0x2c>
	// Enough space to store header
	uint8_t tmpdata[sizeof(HIDIO_Buffer_Entry)];
	uint16_t datasize;
	HIDIO_Buffer_Entry *entry;

	switch ( retval )
    85a6:	b195      	cbz	r5, 85ce <HIDIO_call_id+0x46>
    85a8:	2d01      	cmp	r5, #1
    85aa:	d028      	beq.n	85fe <HIDIO_call_id+0x76>
	default:
		break;
	}

	return retval;
}
    85ac:	4628      	mov	r0, r5
    85ae:	b003      	add	sp, #12
    85b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ( HIDIO_Id_List[ pos ].id == id )
    85b4:	fb0b f303 	mul.w	r3, fp, r3
    85b8:	18f2      	adds	r2, r6, r3
    85ba:	58f3      	ldr	r3, [r6, r3]
    85bc:	4543      	cmp	r3, r8
    85be:	d104      	bne.n	85ca <HIDIO_call_id+0x42>
			retval = func( buf_pos, irq );
    85c0:	6853      	ldr	r3, [r2, #4]
    85c2:	4651      	mov	r1, sl
    85c4:	4648      	mov	r0, r9
    85c6:	4798      	blx	r3
    85c8:	4605      	mov	r5, r0
    85ca:	3401      	adds	r4, #1
    85cc:	e7e7      	b.n	859e <HIDIO_call_id+0x16>
		entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch( &HIDIO_assembly_buf, tmpdata, HIDIO_assembly_buf.head, sizeof(tmpdata) );
    85ce:	4c10      	ldr	r4, [pc, #64]	; (8610 <HIDIO_call_id+0x88>)
    85d0:	2308      	movs	r3, #8
    85d2:	8822      	ldrh	r2, [r4, #0]
    85d4:	4669      	mov	r1, sp
    85d6:	4620      	mov	r0, r4
    85d8:	f7ff fdde 	bl	8198 <HIDIO_buffer_munch>
		datasize = sizeof(HIDIO_Buffer_Entry) + entry->size;
    85dc:	8881      	ldrh	r1, [r0, #4]
    85de:	3108      	adds	r1, #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_assembly_buf, datasize ) )
    85e0:	b289      	uxth	r1, r1
    85e2:	4620      	mov	r0, r4
    85e4:	f7ff fe16 	bl	8214 <HIDIO_buffer_pop_bytes>
    85e8:	4623      	mov	r3, r4
    85ea:	b128      	cbz	r0, 85f8 <HIDIO_call_id+0x70>
			HIDIO_assembly_buf.packets_ready--;
    85ec:	8962      	ldrh	r2, [r4, #10]
    85ee:	3a01      	subs	r2, #1
    85f0:	8162      	strh	r2, [r4, #10]
		HIDIO_assembly_buf.waiting = 0;
    85f2:	2200      	movs	r2, #0
    85f4:	719a      	strb	r2, [r3, #6]
    85f6:	e7d9      	b.n	85ac <HIDIO_call_id+0x24>
			HIDIO_assembly_buf.packets_ready = 0;
    85f8:	8165      	strh	r5, [r4, #10]
			HIDIO_assembly_buf.head = 0;
    85fa:	6025      	str	r5, [r4, #0]
    85fc:	e7f9      	b.n	85f2 <HIDIO_call_id+0x6a>
		print("FAIL"NL);
    85fe:	4805      	ldr	r0, [pc, #20]	; (8614 <HIDIO_call_id+0x8c>)
    8600:	f002 fefe 	bl	b400 <_print>
		break;
    8604:	e7d2      	b.n	85ac <HIDIO_call_id+0x24>
    8606:	bf00      	nop
    8608:	1fffaa20 	.word	0x1fffaa20
    860c:	1fffabdc 	.word	0x1fffabdc
    8610:	1fffaccc 	.word	0x1fffaccc
    8614:	00010285 	.word	0x00010285

00008618 <HIDIO_reply_id>:
HIDIO_Return HIDIO_reply_id( uint32_t id, uint8_t *buf, uint8_t irq )
{
	HIDIO_Return retval = HIDIO_Return__Unknown;

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    8618:	4b1f      	ldr	r3, [pc, #124]	; (8698 <HIDIO_reply_id+0x80>)
{
    861a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    861c:	681e      	ldr	r6, [r3, #0]
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    861e:	4d1f      	ldr	r5, [pc, #124]	; (869c <HIDIO_reply_id+0x84>)
{
    8620:	460f      	mov	r7, r1
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    8622:	2400      	movs	r4, #0
		if ( HIDIO_Id_List[ pos ].id == id )
    8624:	210c      	movs	r1, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    8626:	b2a3      	uxth	r3, r4
    8628:	429e      	cmp	r6, r3
    862a:	d801      	bhi.n	8630 <HIDIO_reply_id+0x18>
	HIDIO_Return retval = HIDIO_Return__Unknown;
    862c:	2504      	movs	r5, #4
    862e:	e010      	b.n	8652 <HIDIO_reply_id+0x3a>
		if ( HIDIO_Id_List[ pos ].id == id )
    8630:	434b      	muls	r3, r1
    8632:	eb05 0c03 	add.w	ip, r5, r3
    8636:	58eb      	ldr	r3, [r5, r3]
    8638:	4283      	cmp	r3, r0
    863a:	f104 0401 	add.w	r4, r4, #1
    863e:	d1f2      	bne.n	8626 <HIDIO_reply_id+0xe>
			// Map function pointer
			HIDIO_Return (*func)(HIDIO_Buffer_Entry*, uint8_t) = \
				(HIDIO_Return(*)(HIDIO_Buffer_Entry*, uint8_t))(HIDIO_Id_List[ pos ].reply_func);

			// Call function
			retval = func( (HIDIO_Buffer_Entry*)buf, irq );
    8640:	f8dc 3008 	ldr.w	r3, [ip, #8]
    8644:	4611      	mov	r1, r2
    8646:	4638      	mov	r0, r7
    8648:	4798      	blx	r3
	// Enough space to store header
	uint8_t tmpdata[6];
	uint16_t datasize;
	HIDIO_Packet *packet;

	switch ( retval )
    864a:	4605      	mov	r5, r0
    864c:	b120      	cbz	r0, 8658 <HIDIO_reply_id+0x40>
    864e:	2801      	cmp	r0, #1
    8650:	d01d      	beq.n	868e <HIDIO_reply_id+0x76>
	default:
		break;
	}

	return retval;
}
    8652:	4628      	mov	r0, r5
    8654:	b003      	add	sp, #12
    8656:	bdf0      	pop	{r4, r5, r6, r7, pc}
		packet = (HIDIO_Packet*)HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, sizeof(tmpdata) );
    8658:	4c11      	ldr	r4, [pc, #68]	; (86a0 <HIDIO_reply_id+0x88>)
    865a:	2306      	movs	r3, #6
    865c:	8822      	ldrh	r2, [r4, #0]
    865e:	4669      	mov	r1, sp
    8660:	4620      	mov	r0, r4
    8662:	f7ff fd99 	bl	8198 <HIDIO_buffer_munch>
		datasize = (packet->upper_len << 8) | packet->len;
    8666:	7801      	ldrb	r1, [r0, #0]
    8668:	098b      	lsrs	r3, r1, #6
    866a:	7841      	ldrb	r1, [r0, #1]
    866c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_tx_buf, datasize + 2 ) )
    8670:	3102      	adds	r1, #2
    8672:	4620      	mov	r0, r4
    8674:	f7ff fdce 	bl	8214 <HIDIO_buffer_pop_bytes>
    8678:	4623      	mov	r3, r4
    867a:	b128      	cbz	r0, 8688 <HIDIO_reply_id+0x70>
			HIDIO_tx_buf.packets_ready--;
    867c:	8962      	ldrh	r2, [r4, #10]
    867e:	3a01      	subs	r2, #1
    8680:	8162      	strh	r2, [r4, #10]
		HIDIO_tx_buf.waiting = 0;
    8682:	2200      	movs	r2, #0
    8684:	719a      	strb	r2, [r3, #6]
    8686:	e7e4      	b.n	8652 <HIDIO_reply_id+0x3a>
			HIDIO_tx_buf.packets_ready = 0;
    8688:	8165      	strh	r5, [r4, #10]
			HIDIO_tx_buf.head = 0;
    868a:	6025      	str	r5, [r4, #0]
    868c:	e7f9      	b.n	8682 <HIDIO_reply_id+0x6a>
		print("FAIL"NL);
    868e:	4805      	ldr	r0, [pc, #20]	; (86a4 <HIDIO_reply_id+0x8c>)
    8690:	f002 feb6 	bl	b400 <_print>
		break;
    8694:	e7dd      	b.n	8652 <HIDIO_reply_id+0x3a>
    8696:	bf00      	nop
    8698:	1fffaa20 	.word	0x1fffaa20
    869c:	1fffabdc 	.word	0x1fffabdc
    86a0:	1fffacdc 	.word	0x1fffacdc
    86a4:	00010285 	.word	0x00010285

000086a8 <HIDIO_setup>:

// HID-IO Module Setup
inline void HIDIO_setup()
{
	// Default packet size (i.e. lowest supported)
	HIDIO_Packet_Size = 8;
    86a8:	4b21      	ldr	r3, [pc, #132]	; (8730 <HIDIO_setup+0x88>)
	HIDIO_assembly_buf.tail = 0;
	HIDIO_assembly_buf.cur_buf_head = 0;
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
	HIDIO_assembly_buf.packets_ready = 0;
	HIDIO_assembly_buf.waiting = 0;
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    86aa:	4922      	ldr	r1, [pc, #136]	; (8734 <HIDIO_setup+0x8c>)
	HIDIO_tx_buf.packets_ready = 0;
	HIDIO_tx_buf.waiting = 0;
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;

	// Register Output CLI dictionary
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    86ac:	4822      	ldr	r0, [pc, #136]	; (8738 <HIDIO_setup+0x90>)
	HIDIO_Packet_Size = 8;
    86ae:	2208      	movs	r2, #8
{
    86b0:	b510      	push	{r4, lr}
	HIDIO_Packet_Size = 8;
    86b2:	801a      	strh	r2, [r3, #0]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    86b4:	4b21      	ldr	r3, [pc, #132]	; (873c <HIDIO_setup+0x94>)
	HIDIO_assembly_buf.head = 0;
    86b6:	2400      	movs	r4, #0
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    86b8:	22d0      	movs	r2, #208	; 0xd0
	HIDIO_assembly_buf.head = 0;
    86ba:	601c      	str	r4, [r3, #0]
	HIDIO_assembly_buf.tail = 0;
    86bc:	809c      	strh	r4, [r3, #4]
	HIDIO_assembly_buf.cur_buf_head = 0;
    86be:	719c      	strb	r4, [r3, #6]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    86c0:	609a      	str	r2, [r3, #8]
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    86c2:	60d9      	str	r1, [r3, #12]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    86c4:	4b1e      	ldr	r3, [pc, #120]	; (8740 <HIDIO_setup+0x98>)
    86c6:	491f      	ldr	r1, [pc, #124]	; (8744 <HIDIO_setup+0x9c>)
	HIDIO_ack_buf->id = 0;
    86c8:	701c      	strb	r4, [r3, #0]
    86ca:	705c      	strb	r4, [r3, #1]
    86cc:	709c      	strb	r4, [r3, #2]
    86ce:	70dc      	strb	r4, [r3, #3]
	HIDIO_ack_buf->size = 0;
    86d0:	711c      	strb	r4, [r3, #4]
    86d2:	715c      	strb	r4, [r3, #5]
	HIDIO_ack_buf->done = 0;
    86d4:	719c      	strb	r4, [r3, #6]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    86d6:	600b      	str	r3, [r1, #0]
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    86d8:	4b1b      	ldr	r3, [pc, #108]	; (8748 <HIDIO_setup+0xa0>)
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    86da:	491c      	ldr	r1, [pc, #112]	; (874c <HIDIO_setup+0xa4>)
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    86dc:	609a      	str	r2, [r3, #8]
	HIDIO_ack_send_buf.data = HIDIO_ack_send_data;
    86de:	4a1c      	ldr	r2, [pc, #112]	; (8750 <HIDIO_setup+0xa8>)
	HIDIO_ack_send_buf.head = 0;
    86e0:	601c      	str	r4, [r3, #0]
	HIDIO_ack_send_buf.tail = 0;
    86e2:	809c      	strh	r4, [r3, #4]
	HIDIO_ack_send_buf.cur_buf_head = 0;
    86e4:	719c      	strb	r4, [r3, #6]
	HIDIO_ack_send_buf.data = HIDIO_ack_send_data;
    86e6:	60da      	str	r2, [r3, #12]
	HIDIO_tx_buf.len = sizeof(HIDIO_tx_buf_data);
    86e8:	4b1a      	ldr	r3, [pc, #104]	; (8754 <HIDIO_setup+0xac>)
    86ea:	22ca      	movs	r2, #202	; 0xca
    86ec:	609a      	str	r2, [r3, #8]
	HIDIO_tx_buf.head = 0;
    86ee:	601c      	str	r4, [r3, #0]
	HIDIO_tx_buf.tail = 0;
    86f0:	809c      	strh	r4, [r3, #4]
	HIDIO_tx_buf.cur_buf_head = 0;
    86f2:	719c      	strb	r4, [r3, #6]
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;
    86f4:	4a18      	ldr	r2, [pc, #96]	; (8758 <HIDIO_setup+0xb0>)
    86f6:	60da      	str	r2, [r3, #12]
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    86f8:	f002 fb14 	bl	ad24 <CLI_registerDictionary>

	// Allocate latency resource
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    86fc:	4621      	mov	r1, r4
    86fe:	4817      	ldr	r0, [pc, #92]	; (875c <HIDIO_setup+0xb4>)
    8700:	f002 fda2 	bl	b248 <Latency_add_resource>
    8704:	4b16      	ldr	r3, [pc, #88]	; (8760 <HIDIO_setup+0xb8>)

	// Reset internal id list
	HIDIO_Id_List_Size = 0;

	// Register internal Ids
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    8706:	4a17      	ldr	r2, [pc, #92]	; (8764 <HIDIO_setup+0xbc>)
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    8708:	7018      	strb	r0, [r3, #0]
	HIDIO_Id_List_Size = 0;
    870a:	4b17      	ldr	r3, [pc, #92]	; (8768 <HIDIO_setup+0xc0>)
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    870c:	4917      	ldr	r1, [pc, #92]	; (876c <HIDIO_setup+0xc4>)
	HIDIO_Id_List_Size = 0;
    870e:	601c      	str	r4, [r3, #0]
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    8710:	4620      	mov	r0, r4
    8712:	f7ff ff15 	bl	8540 <HIDIO_register_id>
	HIDIO_register_id( 1, (void*)HIDIO_info_1_call, (void*)HIDIO_info_1_reply );
    8716:	4a16      	ldr	r2, [pc, #88]	; (8770 <HIDIO_setup+0xc8>)
    8718:	4916      	ldr	r1, [pc, #88]	; (8774 <HIDIO_setup+0xcc>)
    871a:	2001      	movs	r0, #1
    871c:	f7ff ff10 	bl	8540 <HIDIO_register_id>
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    8720:	4a15      	ldr	r2, [pc, #84]	; (8778 <HIDIO_setup+0xd0>)
    8722:	4916      	ldr	r1, [pc, #88]	; (877c <HIDIO_setup+0xd4>)
    8724:	2002      	movs	r0, #2
}
    8726:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    872a:	f7ff bf09 	b.w	8540 <HIDIO_register_id>
    872e:	bf00      	nop
    8730:	1fffaa24 	.word	0x1fffaa24
    8734:	1fffaa26 	.word	0x1fffaa26
    8738:	0001039c 	.word	0x0001039c
    873c:	1fffaccc 	.word	0x1fffaccc
    8740:	1fffa9d0 	.word	0x1fffa9d0
    8744:	1fffaaf8 	.word	0x1fffaaf8
    8748:	1fffabcc 	.word	0x1fffabcc
    874c:	000103a8 	.word	0x000103a8
    8750:	1fffaafc 	.word	0x1fffaafc
    8754:	1fffacdc 	.word	0x1fffacdc
    8758:	1fffacec 	.word	0x1fffacec
    875c:	00010395 	.word	0x00010395
    8760:	1fff93e4 	.word	0x1fff93e4
    8764:	00008159 	.word	0x00008159
    8768:	1fffaa20 	.word	0x1fffaa20
    876c:	00008155 	.word	0x00008155
    8770:	00008191 	.word	0x00008191
    8774:	00008195 	.word	0x00008195
    8778:	0000815d 	.word	0x0000815d
    877c:	00008479 	.word	0x00008479

00008780 <HIDIO_process_incoming_packet>:

// HID-IO Process Packet
void HIDIO_process_incoming_packet( uint8_t *buf, uint8_t irq )
{
    8780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Map structure to packet data
	HIDIO_Packet *packet = (HIDIO_Packet*)buf;

	// Check header packet type to see if a valid packet
	if ( packet->type > HIDIO_Packet_Type__Continued )
    8784:	f890 b000 	ldrb.w	fp, [r0]
{
    8788:	b089      	sub	sp, #36	; 0x24
	if ( packet->type > HIDIO_Packet_Type__Continued )
    878a:	f3cb 0a02 	ubfx	sl, fp, #0, #3
{
    878e:	9105      	str	r1, [sp, #20]
	if ( packet->type > HIDIO_Packet_Type__Continued )
    8790:	fa5f f18a 	uxtb.w	r1, sl
    8794:	2904      	cmp	r1, #4
{
    8796:	4607      	mov	r7, r0
	if ( packet->type > HIDIO_Packet_Type__Continued )
    8798:	f200 80c5 	bhi.w	8926 <HIDIO_process_incoming_packet+0x1a6>
		return;

	// Check if the length is valid
	uint16_t packet_len = (packet->upper_len << 8) | packet->len;
    879c:	7842      	ldrb	r2, [r0, #1]
    879e:	ea4f 159b 	mov.w	r5, fp, lsr #6
    87a2:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
	if ( packet_len > HIDIO_Packet_Size )
    87a6:	4a73      	ldr	r2, [pc, #460]	; (8974 <HIDIO_process_incoming_packet+0x1f4>)
    87a8:	8812      	ldrh	r2, [r2, #0]
    87aa:	42aa      	cmp	r2, r5
    87ac:	f0c0 80bb 	bcc.w	8926 <HIDIO_process_incoming_packet+0x1a6>
	return id_width ? 4 : 2;
    87b0:	f01b 0f10 	tst.w	fp, #16
    87b4:	bf14      	ite	ne
    87b6:	2204      	movne	r2, #4
    87b8:	2202      	moveq	r2, #2
	uint16_t payload_len = packet_len - id_width_len;

	// Check if valid Id
	uint32_t id = 0;
	uint8_t *data = 0;
	switch ( type )
    87ba:	2903      	cmp	r1, #3
    87bc:	d029      	beq.n	8812 <HIDIO_process_incoming_packet+0x92>
    87be:	2904      	cmp	r1, #4
    87c0:	d02c      	beq.n	881c <HIDIO_process_incoming_packet+0x9c>
		// Modify type so we know what to do with the payload
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;

	// Most packet types
	default:
		id = HIDIO_buffer_id( packet );
    87c2:	4638      	mov	r0, r7
	uint16_t payload_len = packet_len - id_width_len;
    87c4:	1aad      	subs	r5, r5, r2
		id = HIDIO_buffer_id( packet );
    87c6:	f7ff fd5e 	bl	8286 <HIDIO_buffer_id>
    87ca:	4606      	mov	r6, r0

		// Data start
		data = HIDIO_payload_start( packet );
    87cc:	4638      	mov	r0, r7
    87ce:	f7ff fd61 	bl	8294 <HIDIO_payload_start>
	uint16_t payload_len = packet_len - id_width_len;
    87d2:	b2ad      	uxth	r5, r5
		data = HIDIO_payload_start( packet );
    87d4:	4681      	mov	r9, r0
		break;
	}

	// Process packet
	switch ( type )
    87d6:	b341      	cbz	r1, 882a <HIDIO_process_incoming_packet+0xaa>
    87d8:	2902      	cmp	r1, #2
    87da:	d81d      	bhi.n	8818 <HIDIO_process_incoming_packet+0x98>

	case HIDIO_Packet_Type__ACK:
	case HIDIO_Packet_Type__NAK:
		// ACK/NAK packets have their own assembly buffer
		// Setup entry
		HIDIO_ack_buf->id = id;
    87dc:	4c66      	ldr	r4, [pc, #408]	; (8978 <HIDIO_process_incoming_packet+0x1f8>)
		HIDIO_ack_buf->size = payload_len;
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    87de:	f08b 0b08 	eor.w	fp, fp, #8
		HIDIO_ack_buf->id = id;
    87e2:	6820      	ldr	r0, [r4, #0]
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    87e4:	f3cb 0bc0 	ubfx	fp, fp, #3, #1
		HIDIO_ack_buf->id = id;
    87e8:	6006      	str	r6, [r0, #0]
		HIDIO_ack_buf->size = payload_len;
    87ea:	8085      	strh	r5, [r0, #4]
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    87ec:	f880 b006 	strb.w	fp, [r0, #6]
		HIDIO_ack_buf->type = packet->type;
    87f0:	f880 a007 	strb.w	sl, [r0, #7]

		// Copy to buffer
		memcpy( &(HIDIO_ack_buf->data[0]), data, payload_len );
    87f4:	4649      	mov	r1, r9
    87f6:	462a      	mov	r2, r5
    87f8:	3008      	adds	r0, #8
    87fa:	f7f9 ff29 	bl	2650 <memcpy>

		// If finished, send to appropriate registered callback
		if ( HIDIO_ack_buf->done )
    87fe:	6821      	ldr	r1, [r4, #0]
    8800:	798b      	ldrb	r3, [r1, #6]
    8802:	2b00      	cmp	r3, #0
    8804:	f000 808f 	beq.w	8926 <HIDIO_process_incoming_packet+0x1a6>
		{
			HIDIO_reply_id( id, (uint8_t*)HIDIO_ack_buf, irq );
    8808:	9a05      	ldr	r2, [sp, #20]
    880a:	4630      	mov	r0, r6
    880c:	f7ff ff04 	bl	8618 <HIDIO_reply_id>
    8810:	e089      	b.n	8926 <HIDIO_process_incoming_packet+0x1a6>
		print("SYNC");
    8812:	485a      	ldr	r0, [pc, #360]	; (897c <HIDIO_process_incoming_packet+0x1fc>)
    8814:	f002 fdf4 	bl	b400 <_print>
		break;
		break;

	default:
		// TODO (HaaTa)
		print("TODO!"NL);
    8818:	4859      	ldr	r0, [pc, #356]	; (8980 <HIDIO_process_incoming_packet+0x200>)
    881a:	e012      	b.n	8842 <HIDIO_process_incoming_packet+0xc2>
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;
    881c:	4956      	ldr	r1, [pc, #344]	; (8978 <HIDIO_process_incoming_packet+0x1f8>)
    881e:	6809      	ldr	r1, [r1, #0]
    8820:	7989      	ldrb	r1, [r1, #6]
    8822:	fab1 f181 	clz	r1, r1
    8826:	0949      	lsrs	r1, r1, #5
    8828:	e7cb      	b.n	87c2 <HIDIO_process_incoming_packet+0x42>
		if ( !HIDIO_assembly_buf.waiting )
    882a:	f8df 8178 	ldr.w	r8, [pc, #376]	; 89a4 <HIDIO_process_incoming_packet+0x224>
    882e:	f898 2006 	ldrb.w	r2, [r8, #6]
    8832:	4644      	mov	r4, r8
    8834:	2a00      	cmp	r2, #0
    8836:	d179      	bne.n	892c <HIDIO_process_incoming_packet+0x1ac>
			if ( packet->type == HIDIO_Packet_Type__Continued )
    8838:	f00b 0207 	and.w	r2, fp, #7
    883c:	2a04      	cmp	r2, #4
    883e:	d103      	bne.n	8848 <HIDIO_process_incoming_packet+0xc8>
				warn_print("Dropping incoming Continued Data packet...");
    8840:	4850      	ldr	r0, [pc, #320]	; (8984 <HIDIO_process_incoming_packet+0x204>)
		print("TODO!"NL);
    8842:	f002 fddd 	bl	b400 <_print>
    8846:	e06e      	b.n	8926 <HIDIO_process_incoming_packet+0x1a6>
			if ( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) < sizeof(HIDIO_Buffer_Entry) + payload_len )
    8848:	4640      	mov	r0, r8
    884a:	f7ff fd09 	bl	8260 <HIDIO_buffer_free_bytes>
    884e:	f105 0208 	add.w	r2, r5, #8
    8852:	4290      	cmp	r0, r2
    8854:	d222      	bcs.n	889c <HIDIO_process_incoming_packet+0x11c>
				warn_print("Dropping incoming Data packet, not enough buffer space...");
    8856:	484c      	ldr	r0, [pc, #304]	; (8988 <HIDIO_process_incoming_packet+0x208>)
    8858:	9205      	str	r2, [sp, #20]
    885a:	f002 fdd1 	bl	b400 <_print>
				print("head: ");
    885e:	484b      	ldr	r0, [pc, #300]	; (898c <HIDIO_process_incoming_packet+0x20c>)
    8860:	f002 fdce 	bl	b400 <_print>
				printInt16( HIDIO_assembly_buf.head );
    8864:	f8b8 0000 	ldrh.w	r0, [r8]
    8868:	f002 fe1a 	bl	b4a0 <printInt16>
				print(" tail: ");
    886c:	4848      	ldr	r0, [pc, #288]	; (8990 <HIDIO_process_incoming_packet+0x210>)
    886e:	f002 fdc7 	bl	b400 <_print>
				printInt16( HIDIO_assembly_buf.tail );
    8872:	f8b8 0002 	ldrh.w	r0, [r8, #2]
    8876:	f002 fe13 	bl	b4a0 <printInt16>
				print(" bytes_left: ");
    887a:	4846      	ldr	r0, [pc, #280]	; (8994 <HIDIO_process_incoming_packet+0x214>)
    887c:	f002 fdc0 	bl	b400 <_print>
				printInt16( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) );
    8880:	4640      	mov	r0, r8
    8882:	f7ff fced 	bl	8260 <HIDIO_buffer_free_bytes>
    8886:	f002 fe0b 	bl	b4a0 <printInt16>
				print(" request: ");
    888a:	4843      	ldr	r0, [pc, #268]	; (8998 <HIDIO_process_incoming_packet+0x218>)
    888c:	f002 fdb8 	bl	b400 <_print>
				printInt16( sizeof(HIDIO_Buffer_Entry) + payload_len );
    8890:	9a05      	ldr	r2, [sp, #20]
    8892:	b290      	uxth	r0, r2
    8894:	f002 fe04 	bl	b4a0 <printInt16>
				print(NL);
    8898:	4840      	ldr	r0, [pc, #256]	; (899c <HIDIO_process_incoming_packet+0x21c>)
    889a:	e7d2      	b.n	8842 <HIDIO_process_incoming_packet+0xc2>
			entry.done = packet->cont ? 0 : 1;
    889c:	f08b 0b08 	eor.w	fp, fp, #8
    88a0:	f3cb 0bc0 	ubfx	fp, fp, #3, #1
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    88a4:	f8b8 3002 	ldrh.w	r3, [r8, #2]
			entry.done = packet->cont ? 0 : 1;
    88a8:	f88d b01e 	strb.w	fp, [sp, #30]
			entry.type = packet->type;
    88ac:	f88d a01f 	strb.w	sl, [sp, #31]
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    88b0:	f8a8 3004 	strh.w	r3, [r8, #4]
			entry.id = id;
    88b4:	9606      	str	r6, [sp, #24]
			entry.size = payload_len;
    88b6:	f8ad 501c 	strh.w	r5, [sp, #28]
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    88ba:	4688      	mov	r8, r1
				HIDIO_buffer_push_byte( &HIDIO_assembly_buf, ((uint8_t*)&entry)[c] );
    88bc:	f10d 0a18 	add.w	sl, sp, #24
    88c0:	46a3      	mov	fp, r4
    88c2:	f81a 1008 	ldrb.w	r1, [sl, r8]
    88c6:	4658      	mov	r0, fp
    88c8:	f108 0801 	add.w	r8, r8, #1
    88cc:	f7ff fc80 	bl	81d0 <HIDIO_buffer_push_byte>
			for ( uint8_t c = 0; c < sizeof(HIDIO_Buffer_Entry); c++ )
    88d0:	f1b8 0f08 	cmp.w	r8, #8
    88d4:	d1f5      	bne.n	88c2 <HIDIO_process_incoming_packet+0x142>
		HIDIO_assembly_buf.waiting = packet->cont;
    88d6:	783b      	ldrb	r3, [r7, #0]
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    88d8:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 89a4 <HIDIO_process_incoming_packet+0x224>
		HIDIO_assembly_buf.waiting = packet->cont;
    88dc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    88e0:	71a3      	strb	r3, [r4, #6]
		for ( uint16_t c = 0; c < payload_len; c++ )
    88e2:	464f      	mov	r7, r9
    88e4:	eba7 0309 	sub.w	r3, r7, r9
    88e8:	b29b      	uxth	r3, r3
    88ea:	42ab      	cmp	r3, r5
    88ec:	d338      	bcc.n	8960 <HIDIO_process_incoming_packet+0x1e0>
		HIDIO_assembly_buf.packets_ready++;
    88ee:	8963      	ldrh	r3, [r4, #10]
		if ( !HIDIO_assembly_buf.waiting )
    88f0:	79a5      	ldrb	r5, [r4, #6]
		HIDIO_assembly_buf.packets_ready++;
    88f2:	3301      	adds	r3, #1
    88f4:	8163      	strh	r3, [r4, #10]
		if ( !HIDIO_assembly_buf.waiting )
    88f6:	2d00      	cmp	r5, #0
    88f8:	d138      	bne.n	896c <HIDIO_process_incoming_packet+0x1ec>
			HIDIO_Return retval = HIDIO_call_id( id, HIDIO_assembly_buf.cur_buf_head, irq );
    88fa:	9a05      	ldr	r2, [sp, #20]
    88fc:	88a1      	ldrh	r1, [r4, #4]
    88fe:	4630      	mov	r0, r6
    8900:	f7ff fe42 	bl	8588 <HIDIO_call_id>
			switch ( retval )
    8904:	2804      	cmp	r0, #4
    8906:	d10e      	bne.n	8926 <HIDIO_process_incoming_packet+0x1a6>
				HIDIO_assembly_buf.packets_ready--;
    8908:	8963      	ldrh	r3, [r4, #10]
				HIDIO_buffer_generate_packet(
    890a:	4825      	ldr	r0, [pc, #148]	; (89a0 <HIDIO_process_incoming_packet+0x220>)
				HIDIO_assembly_buf.packets_ready--;
    890c:	3b01      	subs	r3, #1
    890e:	8163      	strh	r3, [r4, #10]
				HIDIO_assembly_buf.head = HIDIO_assembly_buf.tail;
    8910:	8863      	ldrh	r3, [r4, #2]
    8912:	8023      	strh	r3, [r4, #0]
				HIDIO_buffer_generate_packet(
    8914:	2302      	movs	r3, #2
    8916:	e9cd 5300 	strd	r5, r3, [sp]
    891a:	9602      	str	r6, [sp, #8]
    891c:	462b      	mov	r3, r5
    891e:	462a      	mov	r2, r5
    8920:	4629      	mov	r1, r5
    8922:	f7ff fcbd 	bl	82a0 <HIDIO_buffer_generate_packet>
	{
		printChar( (char)(data[ pos ]) );
	}
	print( NL );
	*/
}
    8926:	b009      	add	sp, #36	; 0x24
    8928:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    892c:	f10d 0818 	add.w	r8, sp, #24
    8930:	2308      	movs	r3, #8
    8932:	88a2      	ldrh	r2, [r4, #4]
    8934:	4641      	mov	r1, r8
    8936:	4620      	mov	r0, r4
    8938:	f7ff fc2e 	bl	8198 <HIDIO_buffer_munch>
			entry->size += payload_len;
    893c:	8883      	ldrh	r3, [r0, #4]
    893e:	442b      	add	r3, r5
    8940:	8083      	strh	r3, [r0, #4]
			entry->done = packet->cont ? 0 : 1;
    8942:	783b      	ldrb	r3, [r7, #0]
    8944:	f083 0308 	eor.w	r3, r3, #8
    8948:	f3c3 03c0 	ubfx	r3, r3, #3, #1
			if ( tmpbuf == (uint8_t*)entry )
    894c:	4540      	cmp	r0, r8
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    894e:	4602      	mov	r2, r0
			entry->done = packet->cont ? 0 : 1;
    8950:	7183      	strb	r3, [r0, #6]
			if ( tmpbuf == (uint8_t*)entry )
    8952:	d1c0      	bne.n	88d6 <HIDIO_process_incoming_packet+0x156>
				HIDIO_modify_buffer(
    8954:	2308      	movs	r3, #8
    8956:	88a1      	ldrh	r1, [r4, #4]
    8958:	4620      	mov	r0, r4
    895a:	f7ff fc46 	bl	81ea <HIDIO_modify_buffer>
    895e:	e7ba      	b.n	88d6 <HIDIO_process_incoming_packet+0x156>
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    8960:	f817 1b01 	ldrb.w	r1, [r7], #1
    8964:	4640      	mov	r0, r8
    8966:	f7ff fc33 	bl	81d0 <HIDIO_buffer_push_byte>
    896a:	e7bb      	b.n	88e4 <HIDIO_process_incoming_packet+0x164>
			HIDIO_nopayload_ack( id );
    896c:	4630      	mov	r0, r6
    896e:	f7ff fdd7 	bl	8520 <HIDIO_nopayload_ack>
    8972:	e7d8      	b.n	8926 <HIDIO_process_incoming_packet+0x1a6>
    8974:	1fffaa24 	.word	0x1fffaa24
    8978:	1fffaaf8 	.word	0x1fffaaf8
    897c:	0001028c 	.word	0x0001028c
    8980:	0001034c 	.word	0x0001034c
    8984:	00010291 	.word	0x00010291
    8988:	000102d3 	.word	0x000102d3
    898c:	00010324 	.word	0x00010324
    8990:	0001032b 	.word	0x0001032b
    8994:	00010333 	.word	0x00010333
    8998:	00010341 	.word	0x00010341
    899c:	00010d99 	.word	0x00010d99
    89a0:	1fffabcc 	.word	0x1fffabcc
    89a4:	1fffaccc 	.word	0x1fffaccc

000089a8 <HIDIO_process>:

// HID-IO Processing Loop
inline void HIDIO_process()
{
    89a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Start latency measurement
	Latency_start_time( hidioLatencyResource );
    89aa:	4d22      	ldr	r5, [pc, #136]	; (8a34 <HIDIO_process+0x8c>)
{
    89ac:	b091      	sub	sp, #68	; 0x44
	Latency_start_time( hidioLatencyResource );
    89ae:	7828      	ldrb	r0, [r5, #0]
    89b0:	f002 fc9a 	bl	b2e8 <Latency_start_time>

	// TODO (HaaTa): Handle timeouts and lost packets

	// Retrieve incoming packets
	while ( Output_rawio_availablechar() )
    89b4:	f000 f8ed 	bl	8b92 <Output_rawio_availablechar>
    89b8:	b9c0      	cbnz	r0, 89ec <HIDIO_process+0x44>
		// Process Packet, regular process (no interrupt)
		HIDIO_process_incoming_packet( tmpdata, 0 );
	}

	// Send all ACK packets
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    89ba:	4c1f      	ldr	r4, [pc, #124]	; (8a38 <HIDIO_process+0x90>)
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    89bc:	4e1f      	ldr	r6, [pc, #124]	; (8a3c <HIDIO_process+0x94>)
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    89be:	8963      	ldrh	r3, [r4, #10]
    89c0:	b9e3      	cbnz	r3, 89fc <HIDIO_process+0x54>
		}
	}

	// Send outgoing packet, we can only send one at a time
	// and the next one can only be sent after an ACK is recieved
	if ( HIDIO_tx_buf.packets_ready > 0 && HIDIO_tx_buf.waiting == 0 )
    89c2:	4c1f      	ldr	r4, [pc, #124]	; (8a40 <HIDIO_process+0x98>)
    89c4:	8963      	ldrh	r3, [r4, #10]
    89c6:	b163      	cbz	r3, 89e2 <HIDIO_process+0x3a>
    89c8:	79a3      	ldrb	r3, [r4, #6]
    89ca:	b953      	cbnz	r3, 89e2 <HIDIO_process+0x3a>
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, HIDIO_Packet_Size );
    89cc:	4b1b      	ldr	r3, [pc, #108]	; (8a3c <HIDIO_process+0x94>)
    89ce:	8822      	ldrh	r2, [r4, #0]
    89d0:	881b      	ldrh	r3, [r3, #0]
    89d2:	4669      	mov	r1, sp
    89d4:	4620      	mov	r0, r4
    89d6:	f7ff fbdf 	bl	8198 <HIDIO_buffer_munch>
		HIDIO_Packet *packet = (HIDIO_Packet*)buf;

		// Send packet
		// TODO (HaaTa): Check error?
		Output_rawio_sendbuffer( (char*)packet );
    89da:	f000 f8de 	bl	8b9a <Output_rawio_sendbuffer>

		// Indicate waiting for ACK packet
		// Once ACK has been received (or NAK) the packet will be released
		HIDIO_tx_buf.waiting = 1;
    89de:	2301      	movs	r3, #1
    89e0:	71a3      	strb	r3, [r4, #6]
	}

	// End latency measurement
	Latency_end_time( hidioLatencyResource );
    89e2:	7828      	ldrb	r0, [r5, #0]
    89e4:	f002 fc92 	bl	b30c <Latency_end_time>
}
    89e8:	b011      	add	sp, #68	; 0x44
    89ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
		Output_rawio_getbuffer( (char*)&tmpdata );
    89ec:	4668      	mov	r0, sp
    89ee:	f000 f8d2 	bl	8b96 <Output_rawio_getbuffer>
		HIDIO_process_incoming_packet( tmpdata, 0 );
    89f2:	2100      	movs	r1, #0
    89f4:	4668      	mov	r0, sp
    89f6:	f7ff fec3 	bl	8780 <HIDIO_process_incoming_packet>
    89fa:	e7db      	b.n	89b4 <HIDIO_process+0xc>
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    89fc:	8833      	ldrh	r3, [r6, #0]
    89fe:	8822      	ldrh	r2, [r4, #0]
    8a00:	4669      	mov	r1, sp
    8a02:	4620      	mov	r0, r4
    8a04:	f7ff fbc8 	bl	8198 <HIDIO_buffer_munch>
    8a08:	4607      	mov	r7, r0
		Output_rawio_sendbuffer( (char*)buf );
    8a0a:	f000 f8c6 	bl	8b9a <Output_rawio_sendbuffer>
		HIDIO_ack_send_buf.waiting = 1;
    8a0e:	2301      	movs	r3, #1
    8a10:	71a3      	strb	r3, [r4, #6]
		uint16_t datasize = (packet->upper_len << 8) | packet->len;
    8a12:	7839      	ldrb	r1, [r7, #0]
    8a14:	098b      	lsrs	r3, r1, #6
    8a16:	7879      	ldrb	r1, [r7, #1]
    8a18:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_ack_send_buf, datasize + 2 ) )
    8a1c:	3102      	adds	r1, #2
    8a1e:	4620      	mov	r0, r4
    8a20:	f7ff fbf8 	bl	8214 <HIDIO_buffer_pop_bytes>
    8a24:	b118      	cbz	r0, 8a2e <HIDIO_process+0x86>
			HIDIO_ack_send_buf.packets_ready--;
    8a26:	8963      	ldrh	r3, [r4, #10]
    8a28:	3b01      	subs	r3, #1
    8a2a:	8163      	strh	r3, [r4, #10]
    8a2c:	e7c7      	b.n	89be <HIDIO_process+0x16>
			HIDIO_ack_send_buf.packets_ready = 0;
    8a2e:	8160      	strh	r0, [r4, #10]
			HIDIO_ack_send_buf.head = 0;
    8a30:	6020      	str	r0, [r4, #0]
    8a32:	e7c4      	b.n	89be <HIDIO_process+0x16>
    8a34:	1fff93e4 	.word	0x1fff93e4
    8a38:	1fffabcc 	.word	0x1fffabcc
    8a3c:	1fffaa24 	.word	0x1fffaa24
    8a40:	1fffacdc 	.word	0x1fffacdc

00008a44 <cliFunc_outputDebug>:
	print(" mA");
}


void cliFunc_outputDebug( char* args )
{
    8a44:	b513      	push	{r0, r1, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    8a46:	4c09      	ldr	r4, [pc, #36]	; (8a6c <cliFunc_outputDebug+0x28>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    8a48:	aa01      	add	r2, sp, #4
    8a4a:	4669      	mov	r1, sp
    8a4c:	f002 f8d0 	bl	abf0 <CLI_argumentIsolation>
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    8a50:	7823      	ldrb	r3, [r4, #0]

	if ( arg1Ptr[0] != '\0' )
    8a52:	9800      	ldr	r0, [sp, #0]
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    8a54:	fab3 f383 	clz	r3, r3
    8a58:	095b      	lsrs	r3, r3, #5
    8a5a:	7023      	strb	r3, [r4, #0]
	if ( arg1Ptr[0] != '\0' )
    8a5c:	7803      	ldrb	r3, [r0, #0]
    8a5e:	b113      	cbz	r3, 8a66 <cliFunc_outputDebug+0x22>
	{
		Output_DebugMode = (uint16_t)numToInt( arg1Ptr );
    8a60:	f002 fde1 	bl	b626 <numToInt>
    8a64:	7020      	strb	r0, [r4, #0]
	}
}
    8a66:	b002      	add	sp, #8
    8a68:	bd10      	pop	{r4, pc}
    8a6a:	bf00      	nop
    8a6c:	1fffadb6 	.word	0x1fffadb6

00008a70 <Output_flashMode_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8a70:	2aff      	cmp	r2, #255	; 0xff
    8a72:	d104      	bne.n	8a7e <Output_flashMode_capability+0xe>
    8a74:	29ff      	cmp	r1, #255	; 0xff
    8a76:	d102      	bne.n	8a7e <Output_flashMode_capability+0xe>
		print("Output_flashMode()");
    8a78:	4802      	ldr	r0, [pc, #8]	; (8a84 <Output_flashMode_capability+0x14>)
    8a7a:	f002 bcc1 	b.w	b400 <_print>
	Output_firmwareReload();
    8a7e:	f000 b87e 	b.w	8b7e <Output_firmwareReload>
    8a82:	bf00      	nop
    8a84:	000103bf 	.word	0x000103bf

00008a88 <OutputGen_setup>:
{
    8a88:	b508      	push	{r3, lr}
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    8a8a:	4907      	ldr	r1, [pc, #28]	; (8aa8 <OutputGen_setup+0x20>)
    8a8c:	4807      	ldr	r0, [pc, #28]	; (8aac <OutputGen_setup+0x24>)
    8a8e:	f002 f949 	bl	ad24 <CLI_registerDictionary>
	Output_Available = 0;
    8a92:	4a07      	ldr	r2, [pc, #28]	; (8ab0 <OutputGen_setup+0x28>)
    8a94:	2300      	movs	r3, #0
    8a96:	7013      	strb	r3, [r2, #0]
	Output_DebugMode = 0;
    8a98:	4a06      	ldr	r2, [pc, #24]	; (8ab4 <OutputGen_setup+0x2c>)
    8a9a:	7013      	strb	r3, [r2, #0]
	Output_ExtCurrent_Available = 0;
    8a9c:	4a06      	ldr	r2, [pc, #24]	; (8ab8 <OutputGen_setup+0x30>)
    8a9e:	8013      	strh	r3, [r2, #0]
	Output_USBCurrent_Available = 0;
    8aa0:	4a06      	ldr	r2, [pc, #24]	; (8abc <OutputGen_setup+0x34>)
    8aa2:	8013      	strh	r3, [r2, #0]
}
    8aa4:	bd08      	pop	{r3, pc}
    8aa6:	bf00      	nop
    8aa8:	00010494 	.word	0x00010494
    8aac:	00010470 	.word	0x00010470
    8ab0:	1fffadba 	.word	0x1fffadba
    8ab4:	1fffadb6 	.word	0x1fffadb6
    8ab8:	1fffadb8 	.word	0x1fffadb8
    8abc:	1fffadbc 	.word	0x1fffadbc

00008ac0 <Output_current_available>:
	total_current += Output_USBCurrent_Available;
    8ac0:	4b03      	ldr	r3, [pc, #12]	; (8ad0 <Output_current_available+0x10>)
    8ac2:	8818      	ldrh	r0, [r3, #0]
	total_current += Output_ExtCurrent_Available;
    8ac4:	4b03      	ldr	r3, [pc, #12]	; (8ad4 <Output_current_available+0x14>)
    8ac6:	881b      	ldrh	r3, [r3, #0]
	if ( total_current == 0 )
    8ac8:	18c0      	adds	r0, r0, r3
}
    8aca:	bf08      	it	eq
    8acc:	2064      	moveq	r0, #100	; 0x64
    8ace:	4770      	bx	lr
    8ad0:	1fffadbc 	.word	0x1fffadbc
    8ad4:	1fffadb8 	.word	0x1fffadb8

00008ad8 <Output_update_usb_current>:
{
    8ad8:	b508      	push	{r3, lr}
	if ( current == Output_USBCurrent_Available )
    8ada:	4b06      	ldr	r3, [pc, #24]	; (8af4 <Output_update_usb_current+0x1c>)
    8adc:	881a      	ldrh	r2, [r3, #0]
    8ade:	4282      	cmp	r2, r0
    8ae0:	d006      	beq.n	8af0 <Output_update_usb_current+0x18>
	Output_USBCurrent_Available = current;
    8ae2:	8018      	strh	r0, [r3, #0]
	Scan_currentChange( Output_current_available() );
    8ae4:	f7ff ffec 	bl	8ac0 <Output_current_available>
}
    8ae8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	Scan_currentChange( Output_current_available() );
    8aec:	f7fc bc44 	b.w	5378 <Scan_currentChange>
}
    8af0:	bd08      	pop	{r3, pc}
    8af2:	bf00      	nop
    8af4:	1fffadbc 	.word	0x1fffadbc

00008af8 <Output_update_external_current>:
	if ( current == Output_ExtCurrent_Available )
    8af8:	4b0c      	ldr	r3, [pc, #48]	; (8b2c <Output_update_external_current+0x34>)
    8afa:	881a      	ldrh	r2, [r3, #0]
    8afc:	4282      	cmp	r2, r0
{
    8afe:	b510      	push	{r4, lr}
	if ( current == Output_ExtCurrent_Available )
    8b00:	d012      	beq.n	8b28 <Output_update_external_current+0x30>
	Output_ExtCurrent_Available = current;
    8b02:	8018      	strh	r0, [r3, #0]
	unsigned int total_current = Output_current_available();
    8b04:	f7ff ffdc 	bl	8ac0 <Output_current_available>
    8b08:	4604      	mov	r4, r0
	info_msg("External Available Current Changed. Total Available: ");
    8b0a:	4809      	ldr	r0, [pc, #36]	; (8b30 <Output_update_external_current+0x38>)
    8b0c:	f002 fc78 	bl	b400 <_print>
	printInt32( total_current );
    8b10:	4620      	mov	r0, r4
    8b12:	f002 fce4 	bl	b4de <printInt32>
	print(" mA" NL);
    8b16:	4807      	ldr	r0, [pc, #28]	; (8b34 <Output_update_external_current+0x3c>)
    8b18:	f002 fc72 	bl	b400 <_print>
	Scan_currentChange( Output_current_available() );
    8b1c:	f7ff ffd0 	bl	8ac0 <Output_current_available>
}
    8b20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Scan_currentChange( Output_current_available() );
    8b24:	f7fc bc28 	b.w	5378 <Scan_currentChange>
}
    8b28:	bd10      	pop	{r4, pc}
    8b2a:	bf00      	nop
    8b2c:	1fffadb8 	.word	0x1fffadb8
    8b30:	000103d2 	.word	0x000103d2
    8b34:	0001041a 	.word	0x0001041a

00008b38 <cliFunc_current>:
{
    8b38:	b508      	push	{r3, lr}
	print( NL );
    8b3a:	4808      	ldr	r0, [pc, #32]	; (8b5c <cliFunc_current+0x24>)
    8b3c:	f002 fc60 	bl	b400 <_print>
	info_msg("Current available: ");
    8b40:	4807      	ldr	r0, [pc, #28]	; (8b60 <cliFunc_current+0x28>)
    8b42:	f002 fc5d 	bl	b400 <_print>
	printInt16( Output_current_available() );
    8b46:	f7ff ffbb 	bl	8ac0 <Output_current_available>
    8b4a:	b280      	uxth	r0, r0
    8b4c:	f002 fca8 	bl	b4a0 <printInt16>
	print(" mA");
    8b50:	4804      	ldr	r0, [pc, #16]	; (8b64 <cliFunc_current+0x2c>)
}
    8b52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print(" mA");
    8b56:	f002 bc53 	b.w	b400 <_print>
    8b5a:	bf00      	nop
    8b5c:	00010d99 	.word	0x00010d99
    8b60:	00010420 	.word	0x00010420
    8b64:	00010446 	.word	0x00010446

00008b68 <Output_setup>:

// ----- Functions -----

// Output Module Setup
inline void Output_setup()
{
    8b68:	b508      	push	{r3, lr}
	// Initialize Interface module
	OutputGen_setup();
    8b6a:	f7ff ff8d 	bl	8a88 <OutputGen_setup>

	// Initialize the USB module
	USB_setup();
}
    8b6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USB_setup();
    8b72:	f000 bac7 	b.w	9104 <USB_setup>

00008b76 <Output_poll>:


// Output Module Data Poll
inline void Output_poll()
{
	USB_poll();
    8b76:	f000 baf3 	b.w	9160 <USB_poll>

00008b7a <Output_periodic>:


// Output Module Data Periodic
inline void Output_periodic()
{
	USB_periodic();
    8b7a:	f000 bb03 	b.w	9184 <USB_periodic>

00008b7e <Output_firmwareReload>:


// Sets the device into firmware reload mode
inline void Output_firmwareReload()
{
	USB_firmwareReload();
    8b7e:	f000 bb57 	b.w	9230 <USB_firmwareReload>

00008b82 <Output_softReset>:


// Soft Chip Reset
inline void Output_softReset()
{
	USB_softReset();
    8b82:	f000 bb57 	b.w	9234 <USB_softReset>

00008b86 <Output_availablechar>:


// USB Input buffer available
inline unsigned int Output_availablechar()
{
	return USB_availablechar();
    8b86:	f000 bb5d 	b.w	9244 <USB_availablechar>

00008b8a <Output_getchar>:


// USB Get Character from input buffer
inline int Output_getchar()
{
	return USB_getchar();
    8b8a:	f000 bb5d 	b.w	9248 <USB_getchar>

00008b8e <Output_putstr>:


// USB Send String to output buffer, null terminated
inline int Output_putstr( char* str )
{
	return USB_putstr( str );
    8b8e:	f000 bb5d 	b.w	924c <USB_putstr>

00008b92 <Output_rawio_availablechar>:


// USB RawIO buffer available
unsigned int Output_rawio_availablechar()
{
	return USB_rawio_availablechar();
    8b92:	f000 bb63 	b.w	925c <USB_rawio_availablechar>

00008b96 <Output_rawio_getbuffer>:


// USB RawIO get buffer
int Output_rawio_getbuffer( char* buffer )
{
	return USB_rawio_getbuffer( buffer );
    8b96:	f000 bb63 	b.w	9260 <USB_rawio_getbuffer>

00008b9a <Output_rawio_sendbuffer>:


// USB RawIO send buffer
int Output_rawio_sendbuffer( char* buffer )
{
	return USB_rawio_sendbuffer( buffer );
    8b9a:	f000 bb64 	b.w	9266 <USB_rawio_sendbuffer>
    8b9e:	0000      	movs	r0, r0

00008ba0 <cliFunc_idle>:


// ----- CLI Command Functions -----

void cliFunc_idle( char* args )
{
    8ba0:	b513      	push	{r0, r1, r4, lr}
    8ba2:	4604      	mov	r4, r0
	print( NL );
    8ba4:	480f      	ldr	r0, [pc, #60]	; (8be4 <cliFunc_idle+0x44>)
    8ba6:	f002 fc2b 	bl	b400 <_print>

	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    8baa:	4620      	mov	r0, r4
    8bac:	aa01      	add	r2, sp, #4
    8bae:	4669      	mov	r1, sp
    8bb0:	f002 f81e 	bl	abf0 <CLI_argumentIsolation>

	// Set Idle count
	if ( arg1Ptr[0] != '\0' )
    8bb4:	9800      	ldr	r0, [sp, #0]
    8bb6:	4c0c      	ldr	r4, [pc, #48]	; (8be8 <cliFunc_idle+0x48>)
    8bb8:	7803      	ldrb	r3, [r0, #0]
    8bba:	b11b      	cbz	r3, 8bc4 <cliFunc_idle+0x24>
	{
		uint8_t idle = (uint8_t)numToInt( arg1Ptr );
    8bbc:	f002 fd33 	bl	b626 <numToInt>
    8bc0:	b2c0      	uxtb	r0, r0
		USBKeys_Idle_Config = idle;
    8bc2:	7020      	strb	r0, [r4, #0]
	}

	// Show Idle count
	info_msg("USB Idle Config: ");
    8bc4:	4809      	ldr	r0, [pc, #36]	; (8bec <cliFunc_idle+0x4c>)
    8bc6:	f002 fc1b 	bl	b400 <_print>
	printInt16( 4 * USBKeys_Idle_Config );
    8bca:	7820      	ldrb	r0, [r4, #0]
    8bcc:	0080      	lsls	r0, r0, #2
    8bce:	f002 fc67 	bl	b4a0 <printInt16>
	print(" ms - ");
    8bd2:	4807      	ldr	r0, [pc, #28]	; (8bf0 <cliFunc_idle+0x50>)
    8bd4:	f002 fc14 	bl	b400 <_print>
	printInt8( USBKeys_Idle_Config );
    8bd8:	7820      	ldrb	r0, [r4, #0]
    8bda:	f002 fc43 	bl	b464 <printInt8>
}
    8bde:	b002      	add	sp, #8
    8be0:	bd10      	pop	{r4, pc}
    8be2:	bf00      	nop
    8be4:	00010d99 	.word	0x00010d99
    8be8:	1fff93e5 	.word	0x1fff93e5
    8bec:	0001083e 	.word	0x0001083e
    8bf0:	00010862 	.word	0x00010862

00008bf4 <cliFunc_readLEDs>:
	}
}


void cliFunc_readLEDs( char* args )
{
    8bf4:	b508      	push	{r3, lr}
	print( NL );
    8bf6:	4806      	ldr	r0, [pc, #24]	; (8c10 <cliFunc_readLEDs+0x1c>)
    8bf8:	f002 fc02 	bl	b400 <_print>
	info_msg("LED State: ");
    8bfc:	4805      	ldr	r0, [pc, #20]	; (8c14 <cliFunc_readLEDs+0x20>)
    8bfe:	f002 fbff 	bl	b400 <_print>
	printInt8( USBKeys_LEDs );
    8c02:	4b05      	ldr	r3, [pc, #20]	; (8c18 <cliFunc_readLEDs+0x24>)
    8c04:	7818      	ldrb	r0, [r3, #0]
}
    8c06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	printInt8( USBKeys_LEDs );
    8c0a:	f002 bc2b 	b.w	b464 <printInt8>
    8c0e:	bf00      	nop
    8c10:	00010d99 	.word	0x00010d99
    8c14:	000108c0 	.word	0x000108c0
    8c18:	1fff93ec 	.word	0x1fff93ec

00008c1c <cliFunc_usbInitTime>:


void cliFunc_usbInitTime( char* args )
{
    8c1c:	b508      	push	{r3, lr}
	// Calculate overall USB initialization time
	// XXX A protocol analyzer will be more accurate, however, this is built-in and easier to collect data
	print(NL);
    8c1e:	480c      	ldr	r0, [pc, #48]	; (8c50 <cliFunc_usbInitTime+0x34>)
    8c20:	f002 fbee 	bl	b400 <_print>
	info_msg("USB Init Time: ");
    8c24:	480b      	ldr	r0, [pc, #44]	; (8c54 <cliFunc_usbInitTime+0x38>)
    8c26:	f002 fbeb 	bl	b400 <_print>
	printInt32( USBInit_TimeEnd - USBInit_TimeStart );
    8c2a:	4b0b      	ldr	r3, [pc, #44]	; (8c58 <cliFunc_usbInitTime+0x3c>)
    8c2c:	6818      	ldr	r0, [r3, #0]
    8c2e:	4b0b      	ldr	r3, [pc, #44]	; (8c5c <cliFunc_usbInitTime+0x40>)
    8c30:	681b      	ldr	r3, [r3, #0]
    8c32:	1ac0      	subs	r0, r0, r3
    8c34:	f002 fc53 	bl	b4de <printInt32>
	print(" ms - ");
    8c38:	4809      	ldr	r0, [pc, #36]	; (8c60 <cliFunc_usbInitTime+0x44>)
    8c3a:	f002 fbe1 	bl	b400 <_print>
	printInt16( USBInit_Ticks );
    8c3e:	4b09      	ldr	r3, [pc, #36]	; (8c64 <cliFunc_usbInitTime+0x48>)
    8c40:	8818      	ldrh	r0, [r3, #0]
    8c42:	f002 fc2d 	bl	b4a0 <printInt16>
	print(" ticks");
    8c46:	4808      	ldr	r0, [pc, #32]	; (8c68 <cliFunc_usbInitTime+0x4c>)
}
    8c48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print(" ticks");
    8c4c:	f002 bbd8 	b.w	b400 <_print>
    8c50:	00010d99 	.word	0x00010d99
    8c54:	000108de 	.word	0x000108de
    8c58:	1fffadc4 	.word	0x1fffadc4
    8c5c:	1fffae14 	.word	0x1fffae14
    8c60:	00010862 	.word	0x00010862
    8c64:	1fffadc8 	.word	0x1fffadc8
    8c68:	0000b85f 	.word	0x0000b85f

00008c6c <cliFunc_kbdProtocol>:
{
    8c6c:	b513      	push	{r0, r1, r4, lr}
    8c6e:	4604      	mov	r4, r0
	print( NL );
    8c70:	480f      	ldr	r0, [pc, #60]	; (8cb0 <cliFunc_kbdProtocol+0x44>)
    8c72:	f002 fbc5 	bl	b400 <_print>
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    8c76:	4620      	mov	r0, r4
    8c78:	aa01      	add	r2, sp, #4
    8c7a:	4669      	mov	r1, sp
    8c7c:	f001 ffb8 	bl	abf0 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    8c80:	9800      	ldr	r0, [sp, #0]
    8c82:	7803      	ldrb	r3, [r0, #0]
    8c84:	b193      	cbz	r3, 8cac <cliFunc_kbdProtocol+0x40>
		uint8_t mode = (uint8_t)numToInt( arg1Ptr );
    8c86:	f002 fcce 	bl	b626 <numToInt>
    8c8a:	b2c0      	uxtb	r0, r0
		if ( mode == 0 || mode == 1 )
    8c8c:	2801      	cmp	r0, #1
    8c8e:	d80b      	bhi.n	8ca8 <cliFunc_kbdProtocol+0x3c>
			USBKeys_Protocol_New = mode;
    8c90:	4b08      	ldr	r3, [pc, #32]	; (8cb4 <cliFunc_kbdProtocol+0x48>)
    8c92:	7018      	strb	r0, [r3, #0]
			USBKeys_Protocol_Change = 1;
    8c94:	4b08      	ldr	r3, [pc, #32]	; (8cb8 <cliFunc_kbdProtocol+0x4c>)
			info_msg("Setting Keyboard Protocol to: ");
    8c96:	4809      	ldr	r0, [pc, #36]	; (8cbc <cliFunc_kbdProtocol+0x50>)
			USBKeys_Protocol_Change = 1;
    8c98:	2201      	movs	r2, #1
    8c9a:	701a      	strb	r2, [r3, #0]
		info_msg("Keyboard Protocol: ");
    8c9c:	f002 fbb0 	bl	b400 <_print>
		printInt8( USBKeys_Protocol );
    8ca0:	4b07      	ldr	r3, [pc, #28]	; (8cc0 <cliFunc_kbdProtocol+0x54>)
    8ca2:	7818      	ldrb	r0, [r3, #0]
    8ca4:	f002 fbde 	bl	b464 <printInt8>
}
    8ca8:	b002      	add	sp, #8
    8caa:	bd10      	pop	{r4, pc}
		info_msg("Keyboard Protocol: ");
    8cac:	4805      	ldr	r0, [pc, #20]	; (8cc4 <cliFunc_kbdProtocol+0x58>)
    8cae:	e7f5      	b.n	8c9c <cliFunc_kbdProtocol+0x30>
    8cb0:	00010d99 	.word	0x00010d99
    8cb4:	1fff8ce9 	.word	0x1fff8ce9
    8cb8:	1fffae10 	.word	0x1fffae10
    8cbc:	00010869 	.word	0x00010869
    8cc0:	1fff8ce8 	.word	0x1fff8ce8
    8cc4:	0001089a 	.word	0x0001089a

00008cc8 <Output_consCtrlSend_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8cc8:	2aff      	cmp	r2, #255	; 0xff
{
    8cca:	b410      	push	{r4}
	if ( stateType == 0xFF && state == 0xFF )
    8ccc:	d105      	bne.n	8cda <Output_consCtrlSend_capability+0x12>
    8cce:	29ff      	cmp	r1, #255	; 0xff
    8cd0:	d103      	bne.n	8cda <Output_consCtrlSend_capability+0x12>
		print("Output_consCtrlSend(consCode)");
    8cd2:	480c      	ldr	r0, [pc, #48]	; (8d04 <Output_consCtrlSend_capability+0x3c>)
}
    8cd4:	bc10      	pop	{r4}
		print("Output_consCtrlSend(consCode)");
    8cd6:	f002 bb93 	b.w	b400 <_print>
	if ( state == 0x01 || state == 0x03 )
    8cda:	f001 00fd 	and.w	r0, r1, #253	; 0xfd
    8cde:	2801      	cmp	r0, #1
    8ce0:	4809      	ldr	r0, [pc, #36]	; (8d08 <Output_consCtrlSend_capability+0x40>)
    8ce2:	d10b      	bne.n	8cfc <Output_consCtrlSend_capability+0x34>
		USBKeys_primary.changed |= USBKeyChangeState_Consumer;
    8ce4:	f890 4020 	ldrb.w	r4, [r0, #32]
    8ce8:	f044 0440 	orr.w	r4, r4, #64	; 0x40
    8cec:	f880 4020 	strb.w	r4, [r0, #32]
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    8cf0:	b922      	cbnz	r2, 8cfc <Output_consCtrlSend_capability+0x34>
    8cf2:	2903      	cmp	r1, #3
    8cf4:	d102      	bne.n	8cfc <Output_consCtrlSend_capability+0x34>
		USBKeys_primary.cons_ctrl = 0;
    8cf6:	83c2      	strh	r2, [r0, #30]
}
    8cf8:	bc10      	pop	{r4}
    8cfa:	4770      	bx	lr
	USBKeys_primary.cons_ctrl = *(uint16_t*)(&args[0]);
    8cfc:	881b      	ldrh	r3, [r3, #0]
    8cfe:	83c3      	strh	r3, [r0, #30]
    8d00:	e7fa      	b.n	8cf8 <Output_consCtrlSend_capability+0x30>
    8d02:	bf00      	nop
    8d04:	0001067f 	.word	0x0001067f
    8d08:	1fffadee 	.word	0x1fffadee

00008d0c <Output_noneSend_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8d0c:	2aff      	cmp	r2, #255	; 0xff
    8d0e:	d104      	bne.n	8d1a <Output_noneSend_capability+0xe>
    8d10:	29ff      	cmp	r1, #255	; 0xff
    8d12:	d102      	bne.n	8d1a <Output_noneSend_capability+0xe>
		print("Output_noneSend()");
    8d14:	4801      	ldr	r0, [pc, #4]	; (8d1c <Output_noneSend_capability+0x10>)
    8d16:	f002 bb73 	b.w	b400 <_print>
}
    8d1a:	4770      	bx	lr
    8d1c:	000106cf 	.word	0x000106cf

00008d20 <Output_sysCtrlSend_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8d20:	2aff      	cmp	r2, #255	; 0xff
{
    8d22:	b410      	push	{r4}
	if ( stateType == 0xFF && state == 0xFF )
    8d24:	d105      	bne.n	8d32 <Output_sysCtrlSend_capability+0x12>
    8d26:	29ff      	cmp	r1, #255	; 0xff
    8d28:	d103      	bne.n	8d32 <Output_sysCtrlSend_capability+0x12>
		print("Output_sysCtrlSend(sysCode)");
    8d2a:	480c      	ldr	r0, [pc, #48]	; (8d5c <Output_sysCtrlSend_capability+0x3c>)
}
    8d2c:	bc10      	pop	{r4}
		print("Output_sysCtrlSend(sysCode)");
    8d2e:	f002 bb67 	b.w	b400 <_print>
	if ( state == 0x01 || state == 0x03 )
    8d32:	f001 00fd 	and.w	r0, r1, #253	; 0xfd
    8d36:	2801      	cmp	r0, #1
    8d38:	4809      	ldr	r0, [pc, #36]	; (8d60 <Output_sysCtrlSend_capability+0x40>)
    8d3a:	d10b      	bne.n	8d54 <Output_sysCtrlSend_capability+0x34>
		USBKeys_primary.changed |= USBKeyChangeState_System;
    8d3c:	f890 4020 	ldrb.w	r4, [r0, #32]
    8d40:	f044 0420 	orr.w	r4, r4, #32
    8d44:	f880 4020 	strb.w	r4, [r0, #32]
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    8d48:	b922      	cbnz	r2, 8d54 <Output_sysCtrlSend_capability+0x34>
    8d4a:	2903      	cmp	r1, #3
    8d4c:	d102      	bne.n	8d54 <Output_sysCtrlSend_capability+0x34>
		USBKeys_primary.sys_ctrl = 0;
    8d4e:	7702      	strb	r2, [r0, #28]
}
    8d50:	bc10      	pop	{r4}
    8d52:	4770      	bx	lr
	USBKeys_primary.sys_ctrl = args[0];
    8d54:	781b      	ldrb	r3, [r3, #0]
    8d56:	7703      	strb	r3, [r0, #28]
    8d58:	e7fa      	b.n	8d50 <Output_sysCtrlSend_capability+0x30>
    8d5a:	bf00      	nop
    8d5c:	000106e1 	.word	0x000106e1
    8d60:	1fffadee 	.word	0x1fffadee

00008d64 <Output_usbMouse_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8d64:	2aff      	cmp	r2, #255	; 0xff
{
    8d66:	b470      	push	{r4, r5, r6}
	if ( stateType == 0xFF && state == 0xFF )
    8d68:	d105      	bne.n	8d76 <Output_usbMouse_capability+0x12>
    8d6a:	29ff      	cmp	r1, #255	; 0xff
    8d6c:	d103      	bne.n	8d76 <Output_usbMouse_capability+0x12>
		print("Output_usbMouse(mouseButton,relX,relY)");
    8d6e:	4819      	ldr	r0, [pc, #100]	; (8dd4 <Output_usbMouse_capability+0x70>)
}
    8d70:	bc70      	pop	{r4, r5, r6}
		print("Output_usbMouse(mouseButton,relX,relY)");
    8d72:	f002 bb45 	b.w	b400 <_print>
	uint16_t mouse_button = *(uint16_t*)(&args[0]);
    8d76:	8818      	ldrh	r0, [r3, #0]
	uint16_t mouse_x = *(uint16_t*)(&args[2]);
    8d78:	885e      	ldrh	r6, [r3, #2]
	uint16_t mouse_y = *(uint16_t*)(&args[4]);
    8d7a:	889d      	ldrh	r5, [r3, #4]
	uint16_t mouse_button_shift = mouse_button - 1;
    8d7c:	1e43      	subs	r3, r0, #1
    8d7e:	b29c      	uxth	r4, r3
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    8d80:	b97a      	cbnz	r2, 8da2 <Output_usbMouse_capability+0x3e>
    8d82:	2903      	cmp	r1, #3
    8d84:	d10d      	bne.n	8da2 <Output_usbMouse_capability+0x3e>
		if ( mouse_button )
    8d86:	b1e0      	cbz	r0, 8dc2 <Output_usbMouse_capability+0x5e>
			USBMouse_Buttons &= ~(1 << mouse_button_shift);
    8d88:	4913      	ldr	r1, [pc, #76]	; (8dd8 <Output_usbMouse_capability+0x74>)
    8d8a:	2301      	movs	r3, #1
    8d8c:	880a      	ldrh	r2, [r1, #0]
    8d8e:	40a3      	lsls	r3, r4
    8d90:	ea22 0303 	bic.w	r3, r2, r3
    8d94:	800b      	strh	r3, [r1, #0]
		USBMouse_Changed |= USBMouseChangeState_Buttons;
    8d96:	4a11      	ldr	r2, [pc, #68]	; (8ddc <Output_usbMouse_capability+0x78>)
    8d98:	7813      	ldrb	r3, [r2, #0]
    8d9a:	f043 0301 	orr.w	r3, r3, #1
    8d9e:	7013      	strb	r3, [r2, #0]
    8da0:	e00f      	b.n	8dc2 <Output_usbMouse_capability+0x5e>
		if ( mouse_button )
    8da2:	b130      	cbz	r0, 8db2 <Output_usbMouse_capability+0x4e>
			USBMouse_Buttons |= (1 << mouse_button_shift);
    8da4:	4a0c      	ldr	r2, [pc, #48]	; (8dd8 <Output_usbMouse_capability+0x74>)
    8da6:	2301      	movs	r3, #1
    8da8:	8811      	ldrh	r1, [r2, #0]
    8daa:	40a3      	lsls	r3, r4
    8dac:	430b      	orrs	r3, r1
    8dae:	b29b      	uxth	r3, r3
    8db0:	8013      	strh	r3, [r2, #0]
		if ( mouse_x )
    8db2:	b10e      	cbz	r6, 8db8 <Output_usbMouse_capability+0x54>
			USBMouse_Relative_x = mouse_x;
    8db4:	4b0a      	ldr	r3, [pc, #40]	; (8de0 <Output_usbMouse_capability+0x7c>)
    8db6:	801e      	strh	r6, [r3, #0]
		if ( mouse_y )
    8db8:	b10d      	cbz	r5, 8dbe <Output_usbMouse_capability+0x5a>
			USBMouse_Relative_y = mouse_y;
    8dba:	4b0a      	ldr	r3, [pc, #40]	; (8de4 <Output_usbMouse_capability+0x80>)
    8dbc:	801d      	strh	r5, [r3, #0]
	if ( mouse_button )
    8dbe:	2800      	cmp	r0, #0
    8dc0:	d1e9      	bne.n	8d96 <Output_usbMouse_capability+0x32>
	if ( mouse_x || mouse_y )
    8dc2:	b906      	cbnz	r6, 8dc6 <Output_usbMouse_capability+0x62>
    8dc4:	b125      	cbz	r5, 8dd0 <Output_usbMouse_capability+0x6c>
		USBMouse_Changed |= USBMouseChangeState_Relative;
    8dc6:	4a05      	ldr	r2, [pc, #20]	; (8ddc <Output_usbMouse_capability+0x78>)
    8dc8:	7813      	ldrb	r3, [r2, #0]
    8dca:	f043 0302 	orr.w	r3, r3, #2
    8dce:	7013      	strb	r3, [r2, #0]
}
    8dd0:	bc70      	pop	{r4, r5, r6}
    8dd2:	4770      	bx	lr
    8dd4:	000107fb 	.word	0x000107fb
    8dd8:	1fff93ee 	.word	0x1fff93ee
    8ddc:	1fff93f0 	.word	0x1fff93f0
    8de0:	1fff93f2 	.word	0x1fff93f2
    8de4:	1fff93f4 	.word	0x1fff93f4

00008de8 <USB_flushBuffers>:
{
    8de8:	b508      	push	{r3, lr}
	memset( (void*)&USBKeys_primary, 0, sizeof( USBKeys ) );
    8dea:	2222      	movs	r2, #34	; 0x22
    8dec:	2100      	movs	r1, #0
    8dee:	4807      	ldr	r0, [pc, #28]	; (8e0c <USB_flushBuffers+0x24>)
    8df0:	f7f9 fc26 	bl	2640 <memset>
	memset( (void*)&USBKeys_idle, 0, sizeof( USBKeys ) );
    8df4:	2222      	movs	r2, #34	; 0x22
    8df6:	2100      	movs	r1, #0
    8df8:	4805      	ldr	r0, [pc, #20]	; (8e10 <USB_flushBuffers+0x28>)
    8dfa:	f7f9 fc21 	bl	2640 <memset>
	USBKeys_Sent = 0;
    8dfe:	4b05      	ldr	r3, [pc, #20]	; (8e14 <USB_flushBuffers+0x2c>)
    8e00:	2200      	movs	r2, #0
    8e02:	701a      	strb	r2, [r3, #0]
	USBKeys_LEDs_Changed = 1;
    8e04:	4b04      	ldr	r3, [pc, #16]	; (8e18 <USB_flushBuffers+0x30>)
    8e06:	2201      	movs	r2, #1
    8e08:	701a      	strb	r2, [r3, #0]
}
    8e0a:	bd08      	pop	{r3, pc}
    8e0c:	1fffadee 	.word	0x1fffadee
    8e10:	1fffadca 	.word	0x1fffadca
    8e14:	1fffadec 	.word	0x1fffadec
    8e18:	1fffadc0 	.word	0x1fffadc0

00008e1c <Output_kbdProtocolBoot_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8e1c:	2aff      	cmp	r2, #255	; 0xff
{
    8e1e:	b510      	push	{r4, lr}
    8e20:	4614      	mov	r4, r2
	if ( stateType == 0xFF && state == 0xFF )
    8e22:	d106      	bne.n	8e32 <Output_kbdProtocolBoot_capability+0x16>
    8e24:	29ff      	cmp	r1, #255	; 0xff
    8e26:	d104      	bne.n	8e32 <Output_kbdProtocolBoot_capability+0x16>
		print("Output_kbdProtocolBoot()");
    8e28:	4808      	ldr	r0, [pc, #32]	; (8e4c <Output_kbdProtocolBoot_capability+0x30>)
}
    8e2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Output_kbdProtocolBoot()");
    8e2e:	f002 bae7 	b.w	b400 <_print>
	if ( USBKeys_Protocol == 0 )
    8e32:	4b07      	ldr	r3, [pc, #28]	; (8e50 <Output_kbdProtocolBoot_capability+0x34>)
    8e34:	781b      	ldrb	r3, [r3, #0]
    8e36:	b143      	cbz	r3, 8e4a <Output_kbdProtocolBoot_capability+0x2e>
	if ( stateType != 0x01 )
    8e38:	2c01      	cmp	r4, #1
    8e3a:	d106      	bne.n	8e4a <Output_kbdProtocolBoot_capability+0x2e>
	USB_flushBuffers();
    8e3c:	f7ff ffd4 	bl	8de8 <USB_flushBuffers>
	USBKeys_Protocol_New = 0;
    8e40:	4b04      	ldr	r3, [pc, #16]	; (8e54 <Output_kbdProtocolBoot_capability+0x38>)
    8e42:	2200      	movs	r2, #0
    8e44:	701a      	strb	r2, [r3, #0]
	USBKeys_Protocol_Change = 1;
    8e46:	4b04      	ldr	r3, [pc, #16]	; (8e58 <Output_kbdProtocolBoot_capability+0x3c>)
    8e48:	701c      	strb	r4, [r3, #0]
}
    8e4a:	bd10      	pop	{r4, pc}
    8e4c:	0001069d 	.word	0x0001069d
    8e50:	1fff8ce8 	.word	0x1fff8ce8
    8e54:	1fff8ce9 	.word	0x1fff8ce9
    8e58:	1fffae10 	.word	0x1fffae10

00008e5c <Output_kbdProtocolNKRO_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8e5c:	2aff      	cmp	r2, #255	; 0xff
{
    8e5e:	b510      	push	{r4, lr}
    8e60:	4614      	mov	r4, r2
	if ( stateType == 0xFF && state == 0xFF )
    8e62:	d106      	bne.n	8e72 <Output_kbdProtocolNKRO_capability+0x16>
    8e64:	29ff      	cmp	r1, #255	; 0xff
    8e66:	d104      	bne.n	8e72 <Output_kbdProtocolNKRO_capability+0x16>
		print("Output_kbdProtocolNKRO()");
    8e68:	4808      	ldr	r0, [pc, #32]	; (8e8c <Output_kbdProtocolNKRO_capability+0x30>)
}
    8e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Output_kbdProtocolNKRO()");
    8e6e:	f002 bac7 	b.w	b400 <_print>
	if ( USBKeys_Protocol == 1 )
    8e72:	4b07      	ldr	r3, [pc, #28]	; (8e90 <Output_kbdProtocolNKRO_capability+0x34>)
    8e74:	781b      	ldrb	r3, [r3, #0]
    8e76:	2b01      	cmp	r3, #1
    8e78:	d007      	beq.n	8e8a <Output_kbdProtocolNKRO_capability+0x2e>
	if ( stateType != 0x01 )
    8e7a:	2c01      	cmp	r4, #1
    8e7c:	d105      	bne.n	8e8a <Output_kbdProtocolNKRO_capability+0x2e>
	USB_flushBuffers();
    8e7e:	f7ff ffb3 	bl	8de8 <USB_flushBuffers>
	USBKeys_Protocol_New = 1;
    8e82:	4b04      	ldr	r3, [pc, #16]	; (8e94 <Output_kbdProtocolNKRO_capability+0x38>)
    8e84:	701c      	strb	r4, [r3, #0]
	USBKeys_Protocol_Change = 1;
    8e86:	4b04      	ldr	r3, [pc, #16]	; (8e98 <Output_kbdProtocolNKRO_capability+0x3c>)
    8e88:	701c      	strb	r4, [r3, #0]
}
    8e8a:	bd10      	pop	{r4, pc}
    8e8c:	000106b6 	.word	0x000106b6
    8e90:	1fff8ce8 	.word	0x1fff8ce8
    8e94:	1fff8ce9 	.word	0x1fff8ce9
    8e98:	1fffae10 	.word	0x1fffae10

00008e9c <Output_toggleKbdProtocol_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8e9c:	2aff      	cmp	r2, #255	; 0xff
{
    8e9e:	b508      	push	{r3, lr}
	if ( stateType == 0xFF && state == 0xFF )
    8ea0:	d106      	bne.n	8eb0 <Output_toggleKbdProtocol_capability+0x14>
    8ea2:	29ff      	cmp	r1, #255	; 0xff
    8ea4:	d113      	bne.n	8ece <Output_toggleKbdProtocol_capability+0x32>
		print("Output_toggleKbdProtocol()");
    8ea6:	480a      	ldr	r0, [pc, #40]	; (8ed0 <Output_toggleKbdProtocol_capability+0x34>)
}
    8ea8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		print("Output_toggleKbdProtocol()");
    8eac:	f002 baa8 	b.w	b400 <_print>
	if ( stateType == 0x00 && state == 0x03 )
    8eb0:	b96a      	cbnz	r2, 8ece <Output_toggleKbdProtocol_capability+0x32>
    8eb2:	2903      	cmp	r1, #3
    8eb4:	d10b      	bne.n	8ece <Output_toggleKbdProtocol_capability+0x32>
		USB_flushBuffers();
    8eb6:	f7ff ff97 	bl	8de8 <USB_flushBuffers>
		USBKeys_Protocol_New = !USBKeys_Protocol;
    8eba:	4b06      	ldr	r3, [pc, #24]	; (8ed4 <Output_toggleKbdProtocol_capability+0x38>)
    8ebc:	4a06      	ldr	r2, [pc, #24]	; (8ed8 <Output_toggleKbdProtocol_capability+0x3c>)
    8ebe:	781b      	ldrb	r3, [r3, #0]
    8ec0:	fab3 f383 	clz	r3, r3
    8ec4:	095b      	lsrs	r3, r3, #5
    8ec6:	7013      	strb	r3, [r2, #0]
		USBKeys_Protocol_Change = 1;
    8ec8:	4b04      	ldr	r3, [pc, #16]	; (8edc <Output_toggleKbdProtocol_capability+0x40>)
    8eca:	2201      	movs	r2, #1
    8ecc:	701a      	strb	r2, [r3, #0]
}
    8ece:	bd08      	pop	{r3, pc}
    8ed0:	000106fd 	.word	0x000106fd
    8ed4:	1fff8ce8 	.word	0x1fff8ce8
    8ed8:	1fff8ce9 	.word	0x1fff8ce9
    8edc:	1fffae10 	.word	0x1fffae10

00008ee0 <Output_usbCodeSend_capability>:
	if ( stateType == 0xFF && state == 0xFF )
    8ee0:	2aff      	cmp	r2, #255	; 0xff
{
    8ee2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ( stateType == 0xFF && state == 0xFF )
    8ee4:	d106      	bne.n	8ef4 <Output_usbCodeSend_capability+0x14>
    8ee6:	29ff      	cmp	r1, #255	; 0xff
    8ee8:	d113      	bne.n	8f12 <Output_usbCodeSend_capability+0x32>
		print("Output_usbCodeSend(usbCode)");
    8eea:	4878      	ldr	r0, [pc, #480]	; (90cc <Output_usbCodeSend_capability+0x1ec>)
}
    8eec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			print( NL );
    8ef0:	f002 ba86 	b.w	b400 <_print>
	if ( stateType == 0x00 && state == 0x02 ) // Hold state
    8ef4:	b96a      	cbnz	r2, 8f12 <Output_usbCodeSend_capability+0x32>
    8ef6:	2902      	cmp	r1, #2
    8ef8:	d00a      	beq.n	8f10 <Output_usbCodeSend_capability+0x30>
	uint8_t keyPress = 0; // Default to key release
    8efa:	3901      	subs	r1, #1
    8efc:	424a      	negs	r2, r1
    8efe:	414a      	adcs	r2, r1
	uint8_t key = args[0];
    8f00:	781c      	ldrb	r4, [r3, #0]
	switch ( USBKeys_Protocol )
    8f02:	4b73      	ldr	r3, [pc, #460]	; (90d0 <Output_usbCodeSend_capability+0x1f0>)
    8f04:	781b      	ldrb	r3, [r3, #0]
    8f06:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    8f0a:	b123      	cbz	r3, 8f16 <Output_usbCodeSend_capability+0x36>
    8f0c:	2d01      	cmp	r5, #1
    8f0e:	d05b      	beq.n	8fc8 <Output_usbCodeSend_capability+0xe8>
}
    8f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint8_t keyPress = 0; // Default to key release
    8f12:	2200      	movs	r2, #0
    8f14:	e7f4      	b.n	8f00 <Output_usbCodeSend_capability+0x20>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    8f16:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    8f1a:	2be0      	cmp	r3, #224	; 0xe0
    8f1c:	d140      	bne.n	8fa0 <Output_usbCodeSend_capability+0xc0>
    8f1e:	f084 01e0 	eor.w	r1, r4, #224	; 0xe0
    8f22:	2401      	movs	r4, #1
    8f24:	408c      	lsls	r4, r1
    8f26:	b264      	sxtb	r4, r4
    8f28:	4b6a      	ldr	r3, [pc, #424]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
			if ( keyPress )
    8f2a:	b11a      	cbz	r2, 8f34 <Output_usbCodeSend_capability+0x54>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    8f2c:	781a      	ldrb	r2, [r3, #0]
    8f2e:	4314      	orrs	r4, r2
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    8f30:	b2e4      	uxtb	r4, r4
    8f32:	e002      	b.n	8f3a <Output_usbCodeSend_capability+0x5a>
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    8f34:	781a      	ldrb	r2, [r3, #0]
    8f36:	ea22 0404 	bic.w	r4, r2, r4
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    8f3a:	701c      	strb	r4, [r3, #0]
			USBKeys_primary.changed |= USBKeyChangeState_Modifiers;
    8f3c:	f893 2020 	ldrb.w	r2, [r3, #32]
    8f40:	f042 0201 	orr.w	r2, r2, #1
    8f44:	f883 2020 	strb.w	r2, [r3, #32]
			break;
    8f48:	e7e2      	b.n	8f10 <Output_usbCodeSend_capability+0x30>
				if ( keyPress && USBKeys_primary.keys[newkey] == key )
    8f4a:	b12a      	cbz	r2, 8f58 <Output_usbCodeSend_capability+0x78>
    8f4c:	4403      	add	r3, r0
    8f4e:	785b      	ldrb	r3, [r3, #1]
    8f50:	42a3      	cmp	r3, r4
    8f52:	d11e      	bne.n	8f92 <Output_usbCodeSend_capability+0xb2>
					keyFound = 1;
    8f54:	4613      	mov	r3, r2
    8f56:	e00f      	b.n	8f78 <Output_usbCodeSend_capability+0x98>
				if ( !keyPress && USBKeys_primary.keys[newkey] == key )
    8f58:	18c7      	adds	r7, r0, r3
    8f5a:	787f      	ldrb	r7, [r7, #1]
    8f5c:	42a7      	cmp	r7, r4
    8f5e:	d118      	bne.n	8f92 <Output_usbCodeSend_capability+0xb2>
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    8f60:	780d      	ldrb	r5, [r1, #0]
    8f62:	3d01      	subs	r5, #1
    8f64:	42ab      	cmp	r3, r5
    8f66:	db0c      	blt.n	8f82 <Output_usbCodeSend_capability+0xa2>
					USBKeys_Sent--;
    8f68:	780b      	ldrb	r3, [r1, #0]
    8f6a:	3b01      	subs	r3, #1
    8f6c:	b2db      	uxtb	r3, r3
    8f6e:	700b      	strb	r3, [r1, #0]
					USBKeys_primary.changed = USBKeyChangeState_MainKeys;
    8f70:	2302      	movs	r3, #2
    8f72:	f880 3020 	strb.w	r3, [r0, #32]
					keyFound = 1;
    8f76:	2301      	movs	r3, #1
			if ( USBKeys_Sent >= USB_BOOT_MAX_KEYS )
    8f78:	7808      	ldrb	r0, [r1, #0]
    8f7a:	2805      	cmp	r0, #5
    8f7c:	d914      	bls.n	8fa8 <Output_usbCodeSend_capability+0xc8>
				warn_print("USB Key limit reached");
    8f7e:	4856      	ldr	r0, [pc, #344]	; (90d8 <Output_usbCodeSend_capability+0x1f8>)
    8f80:	e7b4      	b.n	8eec <Output_usbCodeSend_capability+0xc>
						USBKeys_primary.keys[pos] = USBKeys_primary.keys[pos + 1];
    8f82:	1c5e      	adds	r6, r3, #1
    8f84:	1985      	adds	r5, r0, r6
    8f86:	4403      	add	r3, r0
    8f88:	786d      	ldrb	r5, [r5, #1]
    8f8a:	b2ed      	uxtb	r5, r5
    8f8c:	705d      	strb	r5, [r3, #1]
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    8f8e:	b2f3      	uxtb	r3, r6
    8f90:	e7e6      	b.n	8f60 <Output_usbCodeSend_capability+0x80>
    8f92:	3501      	adds	r5, #1
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    8f94:	7837      	ldrb	r7, [r6, #0]
    8f96:	b2eb      	uxtb	r3, r5
    8f98:	429f      	cmp	r7, r3
    8f9a:	d8d6      	bhi.n	8f4a <Output_usbCodeSend_capability+0x6a>
			uint8_t keyFound = 0;
    8f9c:	2300      	movs	r3, #0
    8f9e:	e7eb      	b.n	8f78 <Output_usbCodeSend_capability+0x98>
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    8fa0:	4e4e      	ldr	r6, [pc, #312]	; (90dc <Output_usbCodeSend_capability+0x1fc>)
    8fa2:	484c      	ldr	r0, [pc, #304]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    8fa4:	4631      	mov	r1, r6
    8fa6:	e7f5      	b.n	8f94 <Output_usbCodeSend_capability+0xb4>
			if ( keyPress && !keyFound )
    8fa8:	2a00      	cmp	r2, #0
    8faa:	d0b1      	beq.n	8f10 <Output_usbCodeSend_capability+0x30>
    8fac:	2b00      	cmp	r3, #0
    8fae:	d1af      	bne.n	8f10 <Output_usbCodeSend_capability+0x30>
				USBKeys_primary.keys[USBKeys_Sent++] = key;
    8fb0:	780b      	ldrb	r3, [r1, #0]
    8fb2:	b2db      	uxtb	r3, r3
    8fb4:	1c5a      	adds	r2, r3, #1
    8fb6:	b2d2      	uxtb	r2, r2
    8fb8:	700a      	strb	r2, [r1, #0]
    8fba:	4a46      	ldr	r2, [pc, #280]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    8fbc:	4413      	add	r3, r2
    8fbe:	705c      	strb	r4, [r3, #1]
				USBKeys_primary.changed = USBKeyChangeState_MainKeys;
    8fc0:	2302      	movs	r3, #2
    8fc2:	f882 3020 	strb.w	r3, [r2, #32]
    8fc6:	e7a3      	b.n	8f10 <Output_usbCodeSend_capability+0x30>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    8fc8:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    8fcc:	2be0      	cmp	r3, #224	; 0xe0
    8fce:	d10c      	bne.n	8fea <Output_usbCodeSend_capability+0x10a>
    8fd0:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
    8fd4:	4b3f      	ldr	r3, [pc, #252]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    8fd6:	fa05 f404 	lsl.w	r4, r5, r4
    8fda:	b264      	sxtb	r4, r4
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    8fdc:	7819      	ldrb	r1, [r3, #0]
			if ( keyPress )
    8fde:	b10a      	cbz	r2, 8fe4 <Output_usbCodeSend_capability+0x104>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    8fe0:	430c      	orrs	r4, r1
    8fe2:	e7a5      	b.n	8f30 <Output_usbCodeSend_capability+0x50>
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    8fe4:	ea21 0404 	bic.w	r4, r1, r4
    8fe8:	e7a7      	b.n	8f3a <Output_usbCodeSend_capability+0x5a>
		else if ( key >= 4 && key <= 49 )
    8fea:	1f23      	subs	r3, r4, #4
    8fec:	2b2d      	cmp	r3, #45	; 0x2d
    8fee:	d822      	bhi.n	9036 <Output_usbCodeSend_capability+0x156>
    8ff0:	3c05      	subs	r4, #5
    8ff2:	b2e4      	uxtb	r4, r4
    8ff4:	2c2e      	cmp	r4, #46	; 0x2e
    8ff6:	bf9f      	itttt	ls
    8ff8:	4b39      	ldrls	r3, [pc, #228]	; (90e0 <Output_usbCodeSend_capability+0x200>)
    8ffa:	5d18      	ldrbls	r0, [r3, r4]
    8ffc:	4b39      	ldrls	r3, [pc, #228]	; (90e4 <Output_usbCodeSend_capability+0x204>)
    8ffe:	5d1c      	ldrbls	r4, [r3, r4]
			USBKeys_primary.changed |= USBKeyChangeState_MainKeys;
    9000:	4b34      	ldr	r3, [pc, #208]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    9002:	f893 1020 	ldrb.w	r1, [r3, #32]
		else if ( key >= 4 && key <= 49 )
    9006:	bf84      	itt	hi
    9008:	2400      	movhi	r4, #0
    900a:	4620      	movhi	r0, r4
			USBKeys_primary.changed |= USBKeyChangeState_MainKeys;
    900c:	f041 0102 	orr.w	r1, r1, #2
			USBKeys_primary.changed |= USBKeyChangeState_SecondaryKeys;
    9010:	f883 1020 	strb.w	r1, [r3, #32]
    9014:	2301      	movs	r3, #1
    9016:	40a3      	lsls	r3, r4
    9018:	b25b      	sxtb	r3, r3
    901a:	492e      	ldr	r1, [pc, #184]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    901c:	4c2f      	ldr	r4, [pc, #188]	; (90dc <Output_usbCodeSend_capability+0x1fc>)
		if ( keyPress )
    901e:	2a00      	cmp	r2, #0
    9020:	d04c      	beq.n	90bc <Output_usbCodeSend_capability+0x1dc>
			USBKeys_primary.keys[bytePosition] |= (1 << byteShift);
    9022:	180a      	adds	r2, r1, r0
    9024:	7851      	ldrb	r1, [r2, #1]
    9026:	430b      	orrs	r3, r1
    9028:	b2db      	uxtb	r3, r3
    902a:	7053      	strb	r3, [r2, #1]
			USBKeys_Sent--;
    902c:	7823      	ldrb	r3, [r4, #0]
    902e:	3b01      	subs	r3, #1
			USBKeys_Sent++;
    9030:	b2db      	uxtb	r3, r3
    9032:	7023      	strb	r3, [r4, #0]
    9034:	e76c      	b.n	8f10 <Output_usbCodeSend_capability+0x30>
		else if ( key >= 51 && key <= 155 )
    9036:	f1a4 0333 	sub.w	r3, r4, #51	; 0x33
    903a:	b2db      	uxtb	r3, r3
    903c:	2b68      	cmp	r3, #104	; 0x68
    903e:	d809      	bhi.n	9054 <Output_usbCodeSend_capability+0x174>
    9040:	4929      	ldr	r1, [pc, #164]	; (90e8 <Output_usbCodeSend_capability+0x208>)
    9042:	5cc8      	ldrb	r0, [r1, r3]
    9044:	4929      	ldr	r1, [pc, #164]	; (90ec <Output_usbCodeSend_capability+0x20c>)
    9046:	5ccc      	ldrb	r4, [r1, r3]
			USBKeys_primary.changed |= USBKeyChangeState_SecondaryKeys;
    9048:	4b22      	ldr	r3, [pc, #136]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    904a:	f893 1020 	ldrb.w	r1, [r3, #32]
    904e:	f041 0104 	orr.w	r1, r1, #4
    9052:	e7dd      	b.n	9010 <Output_usbCodeSend_capability+0x130>
		else if ( key >= 157 && key <= 164 )
    9054:	f104 0363 	add.w	r3, r4, #99	; 0x63
    9058:	b2db      	uxtb	r3, r3
    905a:	2b07      	cmp	r3, #7
    905c:	d80a      	bhi.n	9074 <Output_usbCodeSend_capability+0x194>
    905e:	4924      	ldr	r1, [pc, #144]	; (90f0 <Output_usbCodeSend_capability+0x210>)
    9060:	5ccc      	ldrb	r4, [r1, r3]
			USBKeys_primary.changed |= USBKeyChangeState_TertiaryKeys;
    9062:	4b1c      	ldr	r3, [pc, #112]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    9064:	f893 1020 	ldrb.w	r1, [r3, #32]
    9068:	f041 0108 	orr.w	r1, r1, #8
    906c:	f883 1020 	strb.w	r1, [r3, #32]
    9070:	2014      	movs	r0, #20
    9072:	e7cf      	b.n	9014 <Output_usbCodeSend_capability+0x134>
		else if ( key >= 176 && key <= 221 )
    9074:	f104 0350 	add.w	r3, r4, #80	; 0x50
    9078:	b2db      	uxtb	r3, r3
    907a:	2b2d      	cmp	r3, #45	; 0x2d
    907c:	d809      	bhi.n	9092 <Output_usbCodeSend_capability+0x1b2>
    907e:	491d      	ldr	r1, [pc, #116]	; (90f4 <Output_usbCodeSend_capability+0x214>)
    9080:	5cc8      	ldrb	r0, [r1, r3]
    9082:	491d      	ldr	r1, [pc, #116]	; (90f8 <Output_usbCodeSend_capability+0x218>)
    9084:	5ccc      	ldrb	r4, [r1, r3]
			USBKeys_primary.changed |= USBKeyChangeState_QuartiaryKeys;
    9086:	4b13      	ldr	r3, [pc, #76]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    9088:	f893 1020 	ldrb.w	r1, [r3, #32]
    908c:	f041 0110 	orr.w	r1, r1, #16
    9090:	e7be      	b.n	9010 <Output_usbCodeSend_capability+0x130>
		else if ( key == 0x00 )
    9092:	b954      	cbnz	r4, 90aa <Output_usbCodeSend_capability+0x1ca>
			USBKeys_primary.changed |= USBKeyChangeState_MainKeys;
    9094:	4a0f      	ldr	r2, [pc, #60]	; (90d4 <Output_usbCodeSend_capability+0x1f4>)
    9096:	f892 3020 	ldrb.w	r3, [r2, #32]
    909a:	f043 0302 	orr.w	r3, r3, #2
    909e:	f882 3020 	strb.w	r3, [r2, #32]
}
    90a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			USB_flushBuffers();
    90a6:	f7ff be9f 	b.w	8de8 <USB_flushBuffers>
			warn_msg("USB Code not within 4-49 (0x4-0x31), 51-155 (0x33-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
    90aa:	4814      	ldr	r0, [pc, #80]	; (90fc <Output_usbCodeSend_capability+0x21c>)
    90ac:	f002 f9a8 	bl	b400 <_print>
			printHex( key );
    90b0:	4620      	mov	r0, r4
    90b2:	4629      	mov	r1, r5
    90b4:	f002 fa4c 	bl	b550 <printHex_op>
			print( NL );
    90b8:	4811      	ldr	r0, [pc, #68]	; (9100 <Output_usbCodeSend_capability+0x220>)
    90ba:	e717      	b.n	8eec <Output_usbCodeSend_capability+0xc>
			USBKeys_primary.keys[bytePosition] &= ~(1 << byteShift);
    90bc:	180a      	adds	r2, r1, r0
    90be:	7851      	ldrb	r1, [r2, #1]
    90c0:	ea21 0303 	bic.w	r3, r1, r3
    90c4:	7053      	strb	r3, [r2, #1]
			USBKeys_Sent++;
    90c6:	7823      	ldrb	r3, [r4, #0]
    90c8:	3301      	adds	r3, #1
    90ca:	e7b1      	b.n	9030 <Output_usbCodeSend_capability+0x150>
    90cc:	00010718 	.word	0x00010718
    90d0:	1fff8ce8 	.word	0x1fff8ce8
    90d4:	1fffadee 	.word	0x1fffadee
    90d8:	00010734 	.word	0x00010734
    90dc:	1fffadec 	.word	0x1fffadec
    90e0:	000104d9 	.word	0x000104d9
    90e4:	00010508 	.word	0x00010508
    90e8:	00010537 	.word	0x00010537
    90ec:	000105a7 	.word	0x000105a7
    90f0:	00010617 	.word	0x00010617
    90f4:	0001061f 	.word	0x0001061f
    90f8:	0001064f 	.word	0x0001064f
    90fc:	00010761 	.word	0x00010761
    9100:	00010d99 	.word	0x00010d99

00009104 <USB_setup>:
{
    9104:	b510      	push	{r4, lr}
	usb_init();
    9106:	f000 fe31 	bl	9d6c <usb_init>
	CLI_registerDictionary( usbCLIDict, usbCLIDictName );
    910a:	490d      	ldr	r1, [pc, #52]	; (9140 <USB_setup+0x3c>)
    910c:	480d      	ldr	r0, [pc, #52]	; (9144 <USB_setup+0x40>)
    910e:	f001 fe09 	bl	ad24 <CLI_registerDictionary>
	USBKeys_Protocol_Change = 0;
    9112:	4b0d      	ldr	r3, [pc, #52]	; (9148 <USB_setup+0x44>)
    9114:	2400      	movs	r4, #0
    9116:	701c      	strb	r4, [r3, #0]
	USB_flushBuffers();
    9118:	f7ff fe66 	bl	8de8 <USB_flushBuffers>
	VBAT_SECURE1 = 0;
    911c:	4b0b      	ldr	r3, [pc, #44]	; (914c <USB_setup+0x48>)
    911e:	601c      	str	r4, [r3, #0]
	VBAT_SECURE2 = 0;
    9120:	605c      	str	r4, [r3, #4]
	HIDIO_setup();
    9122:	f7ff fac1 	bl	86a8 <HIDIO_setup>
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    9126:	4621      	mov	r1, r4
    9128:	4809      	ldr	r0, [pc, #36]	; (9150 <USB_setup+0x4c>)
    912a:	f002 f88d 	bl	b248 <Latency_add_resource>
    912e:	4b09      	ldr	r3, [pc, #36]	; (9154 <USB_setup+0x50>)
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    9130:	4621      	mov	r1, r4
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    9132:	7018      	strb	r0, [r3, #0]
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    9134:	4808      	ldr	r0, [pc, #32]	; (9158 <USB_setup+0x54>)
    9136:	f002 f887 	bl	b248 <Latency_add_resource>
    913a:	4b08      	ldr	r3, [pc, #32]	; (915c <USB_setup+0x58>)
    913c:	7018      	strb	r0, [r3, #0]
}
    913e:	bd10      	pop	{r4, pc}
    9140:	00010a08 	.word	0x00010a08
    9144:	000109cc 	.word	0x000109cc
    9148:	1fffae10 	.word	0x1fffae10
    914c:	4003e018 	.word	0x4003e018
    9150:	00010822 	.word	0x00010822
    9154:	1fff93f6 	.word	0x1fff93f6
    9158:	00010830 	.word	0x00010830
    915c:	1fff93f7 	.word	0x1fff93f7

00009160 <USB_poll>:
{
    9160:	b510      	push	{r4, lr}
	Latency_start_time( outputPollLatencyResource );
    9162:	4c07      	ldr	r4, [pc, #28]	; (9180 <USB_poll+0x20>)
    9164:	7820      	ldrb	r0, [r4, #0]
    9166:	f002 f8bf 	bl	b2e8 <Latency_start_time>
	usb_device_check();
    916a:	f000 f8a7 	bl	92bc <usb_device_check>
	usb_keyboard_idle_update();
    916e:	f001 f807 	bl	a180 <usb_keyboard_idle_update>
	HIDIO_process();
    9172:	f7ff fc19 	bl	89a8 <HIDIO_process>
	Latency_end_time( outputPollLatencyResource );
    9176:	7820      	ldrb	r0, [r4, #0]
}
    9178:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Latency_end_time( outputPollLatencyResource );
    917c:	f002 b8c6 	b.w	b30c <Latency_end_time>
    9180:	1fff93f7 	.word	0x1fff93f7

00009184 <USB_periodic>:
{
    9184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	Latency_start_time( outputPeriodicLatencyResource );
    9186:	4d23      	ldr	r5, [pc, #140]	; (9214 <USB_periodic+0x90>)
	while ( USBMouse_Changed )
    9188:	4c23      	ldr	r4, [pc, #140]	; (9218 <USB_periodic+0x94>)
	Latency_start_time( outputPeriodicLatencyResource );
    918a:	7828      	ldrb	r0, [r5, #0]
    918c:	f002 f8ac 	bl	b2e8 <Latency_start_time>
	while ( USBMouse_Changed )
    9190:	7827      	ldrb	r7, [r4, #0]
    9192:	b9ff      	cbnz	r7, 91d4 <USB_periodic+0x50>
	if ( USBKeys_Protocol_Change )
    9194:	4e21      	ldr	r6, [pc, #132]	; (921c <USB_periodic+0x98>)
    9196:	4c22      	ldr	r4, [pc, #136]	; (9220 <USB_periodic+0x9c>)
    9198:	7833      	ldrb	r3, [r6, #0]
    919a:	b13b      	cbz	r3, 91ac <USB_periodic+0x28>
		usb_keyboard_clear( USBKeys_Protocol );
    919c:	7820      	ldrb	r0, [r4, #0]
    919e:	f001 f815 	bl	a1cc <usb_keyboard_clear>
		USBKeys_Protocol = USBKeys_Protocol_New;
    91a2:	4b20      	ldr	r3, [pc, #128]	; (9224 <USB_periodic+0xa0>)
    91a4:	781b      	ldrb	r3, [r3, #0]
    91a6:	b2db      	uxtb	r3, r3
    91a8:	7023      	strb	r3, [r4, #0]
		USBKeys_Protocol_Change = 0;
    91aa:	7037      	strb	r7, [r6, #0]
	if ( USBKeys_Protocol == 0 )
    91ac:	7823      	ldrb	r3, [r4, #0]
    91ae:	4e1e      	ldr	r6, [pc, #120]	; (9228 <USB_periodic+0xa4>)
    91b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    91b4:	b18b      	cbz	r3, 91da <USB_periodic+0x56>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    91b6:	4f1c      	ldr	r7, [pc, #112]	; (9228 <USB_periodic+0xa4>)
	while ( USBKeys_primary.changed )
    91b8:	f896 3020 	ldrb.w	r3, [r6, #32]
    91bc:	b9bb      	cbnz	r3, 91ee <USB_periodic+0x6a>
	switch ( USBKeys_Protocol )
    91be:	7823      	ldrb	r3, [r4, #0]
    91c0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    91c4:	b1c3      	cbz	r3, 91f8 <USB_periodic+0x74>
    91c6:	2a01      	cmp	r2, #1
    91c8:	d020      	beq.n	920c <USB_periodic+0x88>
	Latency_end_time( outputPeriodicLatencyResource );
    91ca:	7828      	ldrb	r0, [r5, #0]
}
    91cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	Latency_end_time( outputPeriodicLatencyResource );
    91d0:	f002 b89c 	b.w	b30c <Latency_end_time>
		usb_mouse_send();
    91d4:	f001 f84c 	bl	a270 <usb_mouse_send>
    91d8:	e7da      	b.n	9190 <USB_periodic+0xc>
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    91da:	4b14      	ldr	r3, [pc, #80]	; (922c <USB_periodic+0xa8>)
    91dc:	781b      	ldrb	r3, [r3, #0]
    91de:	b2db      	uxtb	r3, r3
    91e0:	b2d9      	uxtb	r1, r3
    91e2:	2905      	cmp	r1, #5
    91e4:	d8e7      	bhi.n	91b6 <USB_periodic+0x32>
			USBKeys_primary.keys[c] = 0;
    91e6:	18f1      	adds	r1, r6, r3
    91e8:	3301      	adds	r3, #1
    91ea:	704a      	strb	r2, [r1, #1]
    91ec:	e7f8      	b.n	91e0 <USB_periodic+0x5c>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    91ee:	7821      	ldrb	r1, [r4, #0]
    91f0:	4638      	mov	r0, r7
    91f2:	f000 fe4b 	bl	9e8c <usb_keyboard_send>
    91f6:	e7df      	b.n	91b8 <USB_periodic+0x34>
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
    91f8:	4b0c      	ldr	r3, [pc, #48]	; (922c <USB_periodic+0xa8>)
    91fa:	781a      	ldrb	r2, [r3, #0]
    91fc:	2a06      	cmp	r2, #6
    91fe:	bf96      	itet	ls
    9200:	7818      	ldrbls	r0, [r3, #0]
    9202:	2006      	movhi	r0, #6
    9204:	b2c0      	uxtbls	r0, r0
		Scan_finishedWithOutput( USBKeys_Sent );
    9206:	f7fc f8b6 	bl	5376 <Scan_finishedWithOutput>
		break;
    920a:	e7de      	b.n	91ca <USB_periodic+0x46>
		Scan_finishedWithOutput( USBKeys_Sent );
    920c:	4b07      	ldr	r3, [pc, #28]	; (922c <USB_periodic+0xa8>)
    920e:	7818      	ldrb	r0, [r3, #0]
    9210:	e7f9      	b.n	9206 <USB_periodic+0x82>
    9212:	bf00      	nop
    9214:	1fff93f6 	.word	0x1fff93f6
    9218:	1fff93f0 	.word	0x1fff93f0
    921c:	1fffae10 	.word	0x1fffae10
    9220:	1fff8ce8 	.word	0x1fff8ce8
    9224:	1fff8ce9 	.word	0x1fff8ce9
    9228:	1fffadee 	.word	0x1fffadee
    922c:	1fffadec 	.word	0x1fffadec

00009230 <USB_firmwareReload>:
	usb_device_reload();
    9230:	f000 b93a 	b.w	94a8 <usb_device_reload>

00009234 <USB_softReset>:
	usb_device_software_reset();
    9234:	4b01      	ldr	r3, [pc, #4]	; (923c <USB_softReset+0x8>)
    9236:	4a02      	ldr	r2, [pc, #8]	; (9240 <USB_softReset+0xc>)
    9238:	601a      	str	r2, [r3, #0]
}
    923a:	4770      	bx	lr
    923c:	e000ed0c 	.word	0xe000ed0c
    9240:	05fa0004 	.word	0x05fa0004

00009244 <USB_availablechar>:
	return usb_serial_available();
    9244:	f001 b916 	b.w	a474 <usb_serial_available>

00009248 <USB_getchar>:
	return (int)usb_serial_getchar();
    9248:	f001 b8ee 	b.w	a428 <usb_serial_getchar>

0000924c <USB_putstr>:
	while ( str[count] != '\0' )
    924c:	4603      	mov	r3, r0
    924e:	1a19      	subs	r1, r3, r0
    9250:	f813 2b01 	ldrb.w	r2, [r3], #1
    9254:	2a00      	cmp	r2, #0
    9256:	d1fa      	bne.n	924e <USB_putstr+0x2>
	return usb_serial_write( str, count );
    9258:	f001 b91a 	b.w	a490 <usb_serial_write>

0000925c <USB_rawio_availablechar>:
	return usb_rawio_available();
    925c:	f001 b864 	b.w	a328 <usb_rawio_available>

00009260 <USB_rawio_getbuffer>:
	return usb_rawio_rx( (void*)buffer, 0 );
    9260:	2100      	movs	r1, #0
    9262:	f001 b86d 	b.w	a340 <usb_rawio_rx>

00009266 <USB_rawio_sendbuffer>:
	return usb_rawio_tx( (void*)buffer, 0 );
    9266:	2100      	movs	r1, #0
    9268:	f001 b8a0 	b.w	a3ac <usb_rawio_tx>

0000926c <usb_set_config_descriptor_size>:
};

// Simplifies defines for USB descriptors
void usb_set_config_descriptor_size()
{
	config_descriptor[2] = LSB( sizeof( config_descriptor ) );
    926c:	4b02      	ldr	r3, [pc, #8]	; (9278 <usb_set_config_descriptor_size+0xc>)
    926e:	22cf      	movs	r2, #207	; 0xcf
    9270:	709a      	strb	r2, [r3, #2]
	config_descriptor[3] = MSB( sizeof( config_descriptor ) );
    9272:	2200      	movs	r2, #0
    9274:	70da      	strb	r2, [r3, #3]
}
    9276:	4770      	bx	lr
    9278:	1fff8cea 	.word	0x1fff8cea

0000927c <endpoint0_transmit>:
	#endif
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
    927c:	b5f0      	push	{r4, r5, r6, r7, lr}
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    927e:	4c0c      	ldr	r4, [pc, #48]	; (92b0 <endpoint0_transmit+0x34>)
    9280:	4e0c      	ldr	r6, [pc, #48]	; (92b4 <endpoint0_transmit+0x38>)
    9282:	7823      	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9284:	4d0c      	ldr	r5, [pc, #48]	; (92b8 <endpoint0_transmit+0x3c>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9286:	f043 0702 	orr.w	r7, r3, #2
    928a:	eb06 02c7 	add.w	r2, r6, r7, lsl #3
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    928e:	f083 0301 	eor.w	r3, r3, #1
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9292:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9294:	782a      	ldrb	r2, [r5, #0]
	ep0_tx_bdt_bank ^= 1;
    9296:	7023      	strb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9298:	2a00      	cmp	r2, #0
    929a:	bf14      	ite	ne
    929c:	20c8      	movne	r0, #200	; 0xc8
    929e:	2088      	moveq	r0, #136	; 0x88
    92a0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    92a4:	f082 0201 	eor.w	r2, r2, #1
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    92a8:	f846 1037 	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
    92ac:	702a      	strb	r2, [r5, #0]
}
    92ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    92b0:	1fff947c 	.word	0x1fff947c
    92b4:	1fff8000 	.word	0x1fff8000
    92b8:	1fff947d 	.word	0x1fff947d

000092bc <usb_device_check>:
// Called once per scan loop, should take minimal processing time or it may affect other modules
void usb_device_check()
{
	// Check to see if we're still waiting for the next USB request after Get Configuration Descriptor
	// If still waiting, restart the USB initialization with a lower power requirement
	if ( power_neg_delay )
    92bc:	4a07      	ldr	r2, [pc, #28]	; (92dc <usb_device_check+0x20>)
    92be:	7813      	ldrb	r3, [r2, #0]
    92c0:	b15b      	cbz	r3, 92da <usb_device_check+0x1e>
	{
		// Check if 100 ms has elapsed
		if ( systick_millis_count - power_neg_time > 100 )
    92c2:	4b07      	ldr	r3, [pc, #28]	; (92e0 <usb_device_check+0x24>)
    92c4:	4907      	ldr	r1, [pc, #28]	; (92e4 <usb_device_check+0x28>)
    92c6:	681b      	ldr	r3, [r3, #0]
    92c8:	6809      	ldr	r1, [r1, #0]
    92ca:	1a5b      	subs	r3, r3, r1
    92cc:	2b64      	cmp	r3, #100	; 0x64
    92ce:	d904      	bls.n	92da <usb_device_check+0x1e>
		{
			power_neg_delay = 0;
    92d0:	2300      	movs	r3, #0
			*usb_bMaxPower = 50;

			// Re-initialize USB
			usb_reinit();
#else
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    92d2:	4805      	ldr	r0, [pc, #20]	; (92e8 <usb_device_check+0x2c>)
			power_neg_delay = 0;
    92d4:	7013      	strb	r3, [r2, #0]
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    92d6:	f002 b893 	b.w	b400 <_print>
#endif
		}
	}
}
    92da:	4770      	bx	lr
    92dc:	1fff9484 	.word	0x1fff9484
    92e0:	1fff9158 	.word	0x1fff9158
    92e4:	1fff9488 	.word	0x1fff9488
    92e8:	00010bae 	.word	0x00010bae

000092ec <usb_rx>:

usb_packet_t *usb_rx( uint32_t endpoint )
{
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
    92ec:	1e43      	subs	r3, r0, #1

	// Make sure this is a valid endpoint
	if ( endpoint >= NUM_ENDPOINTS )
    92ee:	2b09      	cmp	r3, #9
{
    92f0:	b510      	push	{r4, lr}
	if ( endpoint >= NUM_ENDPOINTS )
    92f2:	d810      	bhi.n	9316 <usb_rx+0x2a>
	{
		return NULL;
	}

	__disable_irq();
    92f4:	b672      	cpsid	i

	// Receive packet, check pointer
	ret = rx_first[endpoint];
    92f6:	4a09      	ldr	r2, [pc, #36]	; (931c <usb_rx+0x30>)
    92f8:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
	if ( ret )
    92fc:	b148      	cbz	r0, 9312 <usb_rx+0x26>
	{
		rx_first[ endpoint ] = ret->next;
    92fe:	6841      	ldr	r1, [r0, #4]
    9300:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[ endpoint ] -= ret->len;
    9304:	4906      	ldr	r1, [pc, #24]	; (9320 <usb_rx+0x34>)
    9306:	8804      	ldrh	r4, [r0, #0]
    9308:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    930c:	1b12      	subs	r2, r2, r4
    930e:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	}

	__enable_irq();
    9312:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9314:	bd10      	pop	{r4, pc}
		return NULL;
    9316:	2000      	movs	r0, #0
    9318:	e7fc      	b.n	9314 <usb_rx+0x28>
    931a:	bf00      	nop
    931c:	1fff9494 	.word	0x1fff9494
    9320:	1fffae18 	.word	0x1fffae18

00009324 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count( uint32_t endpoint )
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9324:	3801      	subs	r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    9326:	2809      	cmp	r0, #9
    9328:	d80a      	bhi.n	9340 <usb_tx_packet_count+0x1c>
		return 0;
	__disable_irq();
    932a:	b672      	cpsid	i
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    932c:	4b05      	ldr	r3, [pc, #20]	; (9344 <usb_tx_packet_count+0x20>)
    932e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
	uint32_t count=0;
    9332:	2000      	movs	r0, #0
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    9334:	b90b      	cbnz	r3, 933a <usb_tx_packet_count+0x16>
		count++;
	__enable_irq();
    9336:	b662      	cpsie	i
	return count;
    9338:	4770      	bx	lr
		count++;
    933a:	3001      	adds	r0, #1
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    933c:	685b      	ldr	r3, [r3, #4]
    933e:	e7f9      	b.n	9334 <usb_tx_packet_count+0x10>
		return 0;
    9340:	2000      	movs	r0, #0
}
    9342:	4770      	bx	lr
    9344:	1fff94ec 	.word	0x1fff94ec

00009348 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory( usb_packet_t *packet )
{
    9348:	b430      	push	{r4, r5}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    934a:	b672      	cpsid	i
    934c:	4c17      	ldr	r4, [pc, #92]	; (93ac <usb_rx_memory+0x64>)
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
	{
		if ( *cfg++ & USB_ENDPT_EPRXEN )
		{
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    934e:	4a18      	ldr	r2, [pc, #96]	; (93b0 <usb_rx_memory+0x68>)
	__disable_irq();
    9350:	2304      	movs	r3, #4
		if ( *cfg++ & USB_ENDPT_EPRXEN )
    9352:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    9356:	0709      	lsls	r1, r1, #28
    9358:	d51d      	bpl.n	9396 <usb_rx_memory+0x4e>
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    935a:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
    935e:	00d9      	lsls	r1, r3, #3
    9360:	b965      	cbnz	r5, 937c <usb_rx_memory+0x34>
			{
				table[ index( i, RX, EVEN ) ].addr = packet->buf;
    9362:	4411      	add	r1, r2
    9364:	3008      	adds	r0, #8
    9366:	6048      	str	r0, [r1, #4]
				table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    9368:	4912      	ldr	r1, [pc, #72]	; (93b4 <usb_rx_memory+0x6c>)
    936a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
			}
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
			{
				table[ index( i, RX, ODD ) ].addr = packet->buf;
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
				usb_rx_memory_needed--;
    936e:	4a12      	ldr	r2, [pc, #72]	; (93b8 <usb_rx_memory+0x70>)
    9370:	7813      	ldrb	r3, [r2, #0]
    9372:	3b01      	subs	r3, #1
    9374:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    9376:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free( packet );
	return;
}
    9378:	bc30      	pop	{r4, r5}
    937a:	4770      	bx	lr
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
    937c:	f043 0101 	orr.w	r1, r3, #1
    9380:	f852 5031 	ldr.w	r5, [r2, r1, lsl #3]
    9384:	b93d      	cbnz	r5, 9396 <usb_rx_memory+0x4e>
				table[ index( i, RX, ODD ) ].addr = packet->buf;
    9386:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
    938a:	3008      	adds	r0, #8
    938c:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    938e:	4b0b      	ldr	r3, [pc, #44]	; (93bc <usb_rx_memory+0x74>)
    9390:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
    9394:	e7eb      	b.n	936e <usb_rx_memory+0x26>
    9396:	3304      	adds	r3, #4
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    9398:	2b2c      	cmp	r3, #44	; 0x2c
    939a:	d1da      	bne.n	9352 <usb_rx_memory+0xa>
	__enable_irq();
    939c:	b662      	cpsie	i
	usb_rx_memory_needed = 0;
    939e:	4b06      	ldr	r3, [pc, #24]	; (93b8 <usb_rx_memory+0x70>)
    93a0:	2200      	movs	r2, #0
    93a2:	701a      	strb	r2, [r3, #0]
}
    93a4:	bc30      	pop	{r4, r5}
	usb_free( packet );
    93a6:	f000 bf41 	b.w	a22c <usb_free>
    93aa:	bf00      	nop
    93ac:	00010ba3 	.word	0x00010ba3
    93b0:	1fff8000 	.word	0x1fff8000
    93b4:	00400088 	.word	0x00400088
    93b8:	1fff9549 	.word	0x1fff9549
    93bc:	004000c8 	.word	0x004000c8

000093c0 <usb_resume>:

// Call whenever there's an action that may wake the host device
uint8_t usb_resume()
{
    93c0:	b538      	push	{r3, r4, r5, lr}
	// If we have been sleeping, try to wake up host
	if ( usb_dev_sleep && usb_configured() )
    93c2:	4d0d      	ldr	r5, [pc, #52]	; (93f8 <usb_resume+0x38>)
    93c4:	7828      	ldrb	r0, [r5, #0]
    93c6:	b1b0      	cbz	r0, 93f6 <usb_resume+0x36>

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured()
{
	return usb_configuration;
    93c8:	4b0c      	ldr	r3, [pc, #48]	; (93fc <usb_resume+0x3c>)
    93ca:	781b      	ldrb	r3, [r3, #0]
	if ( usb_dev_sleep && usb_configured() )
    93cc:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    93d0:	b18b      	cbz	r3, 93f6 <usb_resume+0x36>
		USB0_CTL |= USB_CTL_RESUME;
    93d2:	4c0b      	ldr	r4, [pc, #44]	; (9400 <usb_resume+0x40>)
    93d4:	7823      	ldrb	r3, [r4, #0]
    93d6:	f043 0304 	orr.w	r3, r3, #4
    93da:	7023      	strb	r3, [r4, #0]
		delay_ms(10);
    93dc:	200a      	movs	r0, #10
    93de:	f7f9 f975 	bl	26cc <delay_ms>
		USB0_CTL &= ~(USB_CTL_RESUME);
    93e2:	7823      	ldrb	r3, [r4, #0]
    93e4:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    93e8:	7023      	strb	r3, [r4, #0]
		delay_ms(50); // Wait for at least 50 ms to make sure the bus is clear
    93ea:	2032      	movs	r0, #50	; 0x32
    93ec:	f7f9 f96e 	bl	26cc <delay_ms>
		usb_dev_sleep = 0; // Make sure we don't call this again, may crash system
    93f0:	2300      	movs	r3, #0
    93f2:	702b      	strb	r3, [r5, #0]
		return 1;
    93f4:	2001      	movs	r0, #1
}
    93f6:	bd38      	pop	{r3, r4, r5, pc}
    93f8:	1fff9547 	.word	0x1fff9547
    93fc:	1fff9546 	.word	0x1fff9546
    9400:	40072094 	.word	0x40072094

00009404 <usb_tx>:
{
    9404:	b538      	push	{r3, r4, r5, lr}
	USBKeys_Idle_Expiry = systick_millis_count;
    9406:	4b21      	ldr	r3, [pc, #132]	; (948c <usb_tx+0x88>)
    9408:	681a      	ldr	r2, [r3, #0]
    940a:	4b21      	ldr	r3, [pc, #132]	; (9490 <usb_tx+0x8c>)
    940c:	601a      	str	r2, [r3, #0]
	Output_update_usb_current( *usb_bMaxPower * 2 );
    940e:	4b21      	ldr	r3, [pc, #132]	; (9494 <usb_tx+0x90>)
    9410:	681b      	ldr	r3, [r3, #0]
{
    9412:	4604      	mov	r4, r0
	Output_update_usb_current( *usb_bMaxPower * 2 );
    9414:	7818      	ldrb	r0, [r3, #0]
    9416:	0040      	lsls	r0, r0, #1
{
    9418:	460d      	mov	r5, r1
	Output_update_usb_current( *usb_bMaxPower * 2 );
    941a:	f7ff fb5d 	bl	8ad8 <Output_update_usb_current>
	endpoint--;
    941e:	1e63      	subs	r3, r4, #1
	if ( endpoint >= NUM_ENDPOINTS )
    9420:	2b09      	cmp	r3, #9
    9422:	d82c      	bhi.n	947e <usb_tx+0x7a>
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
    9424:	0164      	lsls	r4, r4, #5
    9426:	481c      	ldr	r0, [pc, #112]	; (9498 <usb_tx+0x94>)
    9428:	f044 0410 	orr.w	r4, r4, #16
    942c:	4420      	add	r0, r4
	__disable_irq();
    942e:	b672      	cpsid	i
	switch ( tx_state[ endpoint ] )
    9430:	4a1a      	ldr	r2, [pc, #104]	; (949c <usb_tx+0x98>)
    9432:	5cd1      	ldrb	r1, [r2, r3]
    9434:	2903      	cmp	r1, #3
    9436:	d818      	bhi.n	946a <usb_tx+0x66>
    9438:	e8df f001 	tbb	[pc, r1]
    943c:	14021126 	.word	0x14021126
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9440:	2105      	movs	r1, #5
	tx_state[ endpoint ] = next;
    9442:	54d1      	strb	r1, [r2, r3]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    9444:	f010 0f08 	tst.w	r0, #8
	b->addr = packet->buf;
    9448:	f105 0308 	add.w	r3, r5, #8
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    944c:	882a      	ldrh	r2, [r5, #0]
	b->addr = packet->buf;
    944e:	6043      	str	r3, [r0, #4]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    9450:	bf14      	ite	ne
    9452:	23c8      	movne	r3, #200	; 0xc8
    9454:	2388      	moveq	r3, #136	; 0x88
    9456:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    945a:	6003      	str	r3, [r0, #0]
    945c:	e00e      	b.n	947c <usb_tx+0x78>
		b++;
    945e:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9460:	2102      	movs	r1, #2
		break;
    9462:	e7ee      	b.n	9442 <usb_tx+0x3e>
		b++;
    9464:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9466:	2104      	movs	r1, #4
		break;
    9468:	e7eb      	b.n	9442 <usb_tx+0x3e>
		if (tx_first[ endpoint ] == NULL)
    946a:	490d      	ldr	r1, [pc, #52]	; (94a0 <usb_tx+0x9c>)
    946c:	4a0d      	ldr	r2, [pc, #52]	; (94a4 <usb_tx+0xa0>)
    946e:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    9472:	b928      	cbnz	r0, 9480 <usb_tx+0x7c>
			tx_first[ endpoint ] = packet;
    9474:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
		tx_last[ endpoint ] = packet;
    9478:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
	__enable_irq();
    947c:	b662      	cpsie	i
}
    947e:	bd38      	pop	{r3, r4, r5, pc}
			tx_last[ endpoint ]->next = packet;
    9480:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    9484:	604d      	str	r5, [r1, #4]
    9486:	e7f7      	b.n	9478 <usb_tx+0x74>
		next = TX_STATE_ODD_FREE;
    9488:	2103      	movs	r1, #3
    948a:	e7da      	b.n	9442 <usb_tx+0x3e>
    948c:	1fff9158 	.word	0x1fff9158
    9490:	1fff93e8 	.word	0x1fff93e8
    9494:	1fff8f10 	.word	0x1fff8f10
    9498:	1fff8000 	.word	0x1fff8000
    949c:	1fff953c 	.word	0x1fff953c
    94a0:	1fff94ec 	.word	0x1fff94ec
    94a4:	1fff9514 	.word	0x1fff9514

000094a8 <usb_device_reload>:
{
    94a8:	4b07      	ldr	r3, [pc, #28]	; (94c8 <usb_device_reload+0x20>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    94aa:	4808      	ldr	r0, [pc, #32]	; (94cc <usb_device_reload+0x24>)
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    94ac:	4908      	ldr	r1, [pc, #32]	; (94d0 <usb_device_reload+0x28>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    94ae:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
    94b2:	f5a2 3278 	sub.w	r2, r2, #253952	; 0x3e000
    94b6:	5c12      	ldrb	r2, [r2, r0]
    94b8:	f803 2b01 	strb.w	r2, [r3], #1
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    94bc:	428b      	cmp	r3, r1
    94be:	d1f6      	bne.n	94ae <usb_device_reload+0x6>
	SOFTWARE_RESET();
    94c0:	4b04      	ldr	r3, [pc, #16]	; (94d4 <usb_device_reload+0x2c>)
    94c2:	4a05      	ldr	r2, [pc, #20]	; (94d8 <usb_device_reload+0x30>)
    94c4:	601a      	str	r2, [r3, #0]
}
    94c6:	4770      	bx	lr
    94c8:	4003e000 	.word	0x4003e000
    94cc:	0000b715 	.word	0x0000b715
    94d0:	4003e016 	.word	0x4003e016
    94d4:	e000ed0c 	.word	0xe000ed0c
    94d8:	05fa0004 	.word	0x05fa0004

000094dc <usb_isr>:
{
    94dc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    94e0:	4eac      	ldr	r6, [pc, #688]	; (9794 <usb_isr+0x2b8>)
	status = USB0_ISTAT;
    94e2:	4bac      	ldr	r3, [pc, #688]	; (9794 <usb_isr+0x2b8>)
    94e4:	781c      	ldrb	r4, [r3, #0]
    94e6:	b2e4      	uxtb	r4, r4
	if ( (status & USB_INTEN_SOFTOKEN /* 04 */ ) )
    94e8:	0765      	lsls	r5, r4, #29
    94ea:	d525      	bpl.n	9538 <usb_isr+0x5c>
		if ( usb_configuration )
    94ec:	4baa      	ldr	r3, [pc, #680]	; (9798 <usb_isr+0x2bc>)
    94ee:	781b      	ldrb	r3, [r3, #0]
    94f0:	b1ab      	cbz	r3, 951e <usb_isr+0x42>
			t = usb_reboot_timer;
    94f2:	4aaa      	ldr	r2, [pc, #680]	; (979c <usb_isr+0x2c0>)
    94f4:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    94f6:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    94fa:	b129      	cbz	r1, 9508 <usb_isr+0x2c>
				usb_reboot_timer = --t;
    94fc:	3b01      	subs	r3, #1
    94fe:	b2db      	uxtb	r3, r3
    9500:	7013      	strb	r3, [r2, #0]
				if ( !t )
    9502:	b90b      	cbnz	r3, 9508 <usb_isr+0x2c>
					usb_device_reload();
    9504:	f7ff ffd0 	bl	94a8 <usb_device_reload>
			t = usb_cdc_transmit_flush_timer;
    9508:	4aa5      	ldr	r2, [pc, #660]	; (97a0 <usb_isr+0x2c4>)
    950a:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    950c:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    9510:	b129      	cbz	r1, 951e <usb_isr+0x42>
				usb_cdc_transmit_flush_timer = --t;
    9512:	3b01      	subs	r3, #1
    9514:	b2db      	uxtb	r3, r3
    9516:	7013      	strb	r3, [r2, #0]
				if ( t == 0 )
    9518:	b90b      	cbnz	r3, 951e <usb_isr+0x42>
					usb_serial_flush_callback();
    951a:	f001 f827 	bl	a56c <usb_serial_flush_callback>
		if ( usb_dev_sleep )
    951e:	4da1      	ldr	r5, [pc, #644]	; (97a4 <usb_isr+0x2c8>)
    9520:	782b      	ldrb	r3, [r5, #0]
    9522:	b13b      	cbz	r3, 9534 <usb_isr+0x58>
			Output_update_usb_current( *usb_bMaxPower * 2 );
    9524:	4ba0      	ldr	r3, [pc, #640]	; (97a8 <usb_isr+0x2cc>)
    9526:	681b      	ldr	r3, [r3, #0]
    9528:	7818      	ldrb	r0, [r3, #0]
    952a:	0040      	lsls	r0, r0, #1
    952c:	f7ff fad4 	bl	8ad8 <Output_update_usb_current>
			usb_dev_sleep = 0;
    9530:	2300      	movs	r3, #0
    9532:	702b      	strb	r3, [r5, #0]
		USB0_ISTAT = USB_INTEN_SOFTOKEN;
    9534:	2304      	movs	r3, #4
    9536:	7033      	strb	r3, [r6, #0]
	if ( (status & USB_ISTAT_TOKDNE /* 08 */ ) )
    9538:	f014 0208 	ands.w	r2, r4, #8
    953c:	f000 8399 	beq.w	9c72 <usb_isr+0x796>
		stat = USB0_STAT;
    9540:	4b9a      	ldr	r3, [pc, #616]	; (97ac <usb_isr+0x2d0>)
    9542:	4c9b      	ldr	r4, [pc, #620]	; (97b0 <usb_isr+0x2d4>)
    9544:	781b      	ldrb	r3, [r3, #0]
    9546:	b2db      	uxtb	r3, r3
		if ( endpoint == 0 )
    9548:	091d      	lsrs	r5, r3, #4
    954a:	ea4f 0893 	mov.w	r8, r3, lsr #2
    954e:	f040 8313 	bne.w	9b78 <usb_isr+0x69c>
	b = stat2bufferdescriptor( stat );
    9552:	eb04 03c8 	add.w	r3, r4, r8, lsl #3
	buf = b->addr;
    9556:	685f      	ldr	r7, [r3, #4]
	pid = BDT_PID( b->desc );
    9558:	f854 3038 	ldr.w	r3, [r4, r8, lsl #3]
    955c:	f3c3 0383 	ubfx	r3, r3, #2, #4
	switch ( pid )
    9560:	3b01      	subs	r3, #1
    9562:	2b0c      	cmp	r3, #12
    9564:	f200 829d 	bhi.w	9aa2 <usb_isr+0x5c6>
    9568:	e8df f013 	tbh	[pc, r3, lsl #1]
    956c:	02700270 	.word	0x02700270
    9570:	029b029b 	.word	0x029b029b
    9574:	029b029b 	.word	0x029b029b
    9578:	029b029b 	.word	0x029b029b
    957c:	029b02e0 	.word	0x029b02e0
    9580:	029b029b 	.word	0x029b029b
    9584:	000d      	.short	0x000d
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    9586:	4a8b      	ldr	r2, [pc, #556]	; (97b4 <usb_isr+0x2d8>)
		setup.word1 = *(uint32_t *)(buf);
    9588:	683b      	ldr	r3, [r7, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    958a:	6879      	ldr	r1, [r7, #4]
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    958c:	f844 2038 	str.w	r2, [r4, r8, lsl #3]
		ep0_tx_data_toggle = 1;
    9590:	4a89      	ldr	r2, [pc, #548]	; (97b8 <usb_isr+0x2dc>)
		setup.word1 = *(uint32_t *)(buf);
    9592:	4d8a      	ldr	r5, [pc, #552]	; (97bc <usb_isr+0x2e0>)
		ep0_tx_ptr = NULL;
    9594:	f8df 8268 	ldr.w	r8, [pc, #616]	; 9800 <usb_isr+0x324>
		setup.word1 = *(uint32_t *)(buf);
    9598:	602b      	str	r3, [r5, #0]
		ep0_tx_data_toggle = 1;
    959a:	2001      	movs	r0, #1
    959c:	7010      	strb	r0, [r2, #0]
	USBInit_TimeEnd = systick_millis_count;
    959e:	4888      	ldr	r0, [pc, #544]	; (97c0 <usb_isr+0x2e4>)
    95a0:	4a88      	ldr	r2, [pc, #544]	; (97c4 <usb_isr+0x2e8>)
    95a2:	6807      	ldr	r7, [r0, #0]
    95a4:	6017      	str	r7, [r2, #0]
	USBInit_Ticks++;
    95a6:	4f88      	ldr	r7, [pc, #544]	; (97c8 <usb_isr+0x2ec>)
		setup.word2 = *(uint32_t *)(buf + 4);
    95a8:	6069      	str	r1, [r5, #4]
	USBInit_Ticks++;
    95aa:	883a      	ldrh	r2, [r7, #0]
    95ac:	3201      	adds	r2, #1
    95ae:	b292      	uxth	r2, r2
    95b0:	803a      	strh	r2, [r7, #0]
	if ( power_neg_delay )
    95b2:	4f86      	ldr	r7, [pc, #536]	; (97cc <usb_isr+0x2f0>)
    95b4:	783a      	ldrb	r2, [r7, #0]
		ep0_tx_ptr = NULL;
    95b6:	f04f 0c00 	mov.w	ip, #0
    95ba:	f8c8 c000 	str.w	ip, [r8]
		table[index(0, TX, EVEN)].desc = 0;
    95be:	f8c4 c010 	str.w	ip, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    95c2:	f8c4 c018 	str.w	ip, [r4, #24]
	if ( power_neg_delay )
    95c6:	b10a      	cbz	r2, 95cc <usb_isr+0xf0>
		power_neg_delay = 0;
    95c8:	f887 c000 	strb.w	ip, [r7]
	switch ( setup.wRequestAndType )
    95cc:	b29a      	uxth	r2, r3
    95ce:	f240 3ca1 	movw	ip, #929	; 0x3a1
    95d2:	4562      	cmp	r2, ip
    95d4:	f000 8222 	beq.w	9a1c <usb_isr+0x540>
    95d8:	d84c      	bhi.n	9674 <usb_isr+0x198>
    95da:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
    95de:	f000 818b 	beq.w	98f8 <usb_isr+0x41c>
    95e2:	d81d      	bhi.n	9620 <usb_isr+0x144>
    95e4:	2a82      	cmp	r2, #130	; 0x82
    95e6:	f000 8171 	beq.w	98cc <usb_isr+0x3f0>
    95ea:	d804      	bhi.n	95f6 <usb_isr+0x11a>
    95ec:	2a80      	cmp	r2, #128	; 0x80
    95ee:	f000 8167 	beq.w	98c0 <usb_isr+0x3e4>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    95f2:	4b77      	ldr	r3, [pc, #476]	; (97d0 <usb_isr+0x2f4>)
    95f4:	e16e      	b.n	98d4 <usb_isr+0x3f8>
	switch ( setup.wRequestAndType )
    95f6:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    95fa:	f000 8190 	beq.w	991e <usb_isr+0x442>
    95fe:	f240 1301 	movw	r3, #257	; 0x101
    9602:	429a      	cmp	r2, r3
    9604:	d1f5      	bne.n	95f2 <usb_isr+0x116>
		warn_msg("CLEAR_FEATURE - Interface wValue(");
    9606:	4873      	ldr	r0, [pc, #460]	; (97d4 <usb_isr+0x2f8>)
    9608:	f001 fefa 	bl	b400 <_print>
		printHex( setup.wValue );
    960c:	2101      	movs	r1, #1
    960e:	8868      	ldrh	r0, [r5, #2]
    9610:	f001 ff9e 	bl	b550 <printHex_op>
		print(") wIndex(");
    9614:	4870      	ldr	r0, [pc, #448]	; (97d8 <usb_isr+0x2fc>)
    9616:	f001 fef3 	bl	b400 <_print>
		printHex( setup.wIndex );
    961a:	2101      	movs	r1, #1
    961c:	88a8      	ldrh	r0, [r5, #4]
    961e:	e187      	b.n	9930 <usb_isr+0x454>
	switch ( setup.wRequestAndType )
    9620:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
    9624:	f000 817b 	beq.w	991e <usb_isr+0x442>
    9628:	d80a      	bhi.n	9640 <usb_isr+0x164>
    962a:	f240 13a1 	movw	r3, #417	; 0x1a1
    962e:	429a      	cmp	r2, r3
    9630:	f000 81db 	beq.w	99ea <usb_isr+0x50e>
    9634:	f240 23a1 	movw	r3, #673	; 0x2a1
    9638:	429a      	cmp	r2, r3
    963a:	d1da      	bne.n	95f2 <usb_isr+0x116>
		reply_buffer[0] = USBKeys_Idle_Config;
    963c:	4b67      	ldr	r3, [pc, #412]	; (97dc <usb_isr+0x300>)
    963e:	e13a      	b.n	98b6 <usb_isr+0x3da>
	switch ( setup.wRequestAndType )
    9640:	f240 3001 	movw	r0, #769	; 0x301
    9644:	4282      	cmp	r2, r0
    9646:	4c62      	ldr	r4, [pc, #392]	; (97d0 <usb_isr+0x2f4>)
    9648:	f000 8178 	beq.w	993c <usb_isr+0x460>
    964c:	f240 3002 	movw	r0, #770	; 0x302
    9650:	4282      	cmp	r2, r0
    9652:	d1ce      	bne.n	95f2 <usb_isr+0x116>
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    9654:	f001 027f 	and.w	r2, r1, #127	; 0x7f
    9658:	2a0a      	cmp	r2, #10
    965a:	f200 8180 	bhi.w	995e <usb_isr+0x482>
    965e:	0c1b      	lsrs	r3, r3, #16
    9660:	f040 817d 	bne.w	995e <usb_isr+0x482>
		i = setup.wIndex & 0x7F;
    9664:	b289      	uxth	r1, r1
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) |= 0x02;
    9666:	f814 3021 	ldrb.w	r3, [r4, r1, lsl #2]
    966a:	f043 0302 	orr.w	r3, r3, #2
    966e:	f804 3021 	strb.w	r3, [r4, r1, lsl #2]
    9672:	e010      	b.n	9696 <usb_isr+0x1ba>
	switch ( setup.wRequestAndType )
    9674:	f640 1c21 	movw	ip, #2337	; 0x921
    9678:	4562      	cmp	r2, ip
    967a:	f000 81a9 	beq.w	99d0 <usb_isr+0x4f4>
    967e:	d855      	bhi.n	972c <usb_isr+0x250>
    9680:	f240 6c81 	movw	ip, #1665	; 0x681
    9684:	4562      	cmp	r2, ip
    9686:	d808      	bhi.n	969a <usb_isr+0x1be>
    9688:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
    968c:	f080 816a 	bcs.w	9964 <usb_isr+0x488>
    9690:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    9694:	d1ad      	bne.n	95f2 <usb_isr+0x116>
	uint32_t datalen = 0;
    9696:	2300      	movs	r3, #0
    9698:	e13f      	b.n	991a <usb_isr+0x43e>
	switch ( setup.wRequestAndType )
    969a:	f5b2 6f08 	cmp.w	r2, #2176	; 0x880
    969e:	f000 8109 	beq.w	98b4 <usb_isr+0x3d8>
    96a2:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    96a6:	d1a4      	bne.n	95f2 <usb_isr+0x116>
		usb_configuration = setup.wValue;
    96a8:	4a3b      	ldr	r2, [pc, #236]	; (9798 <usb_isr+0x2bc>)
    96aa:	f3c3 4307 	ubfx	r3, r3, #16, #8
    96ae:	7013      	strb	r3, [r2, #0]
		Output_Available = usb_configuration;
    96b0:	7813      	ldrb	r3, [r2, #0]
    96b2:	4a4b      	ldr	r2, [pc, #300]	; (97e0 <usb_isr+0x304>)
    96b4:	b2db      	uxtb	r3, r3
    96b6:	7013      	strb	r3, [r2, #0]
		Output_update_usb_current( *usb_bMaxPower * 2 );
    96b8:	4b3b      	ldr	r3, [pc, #236]	; (97a8 <usb_isr+0x2cc>)
    96ba:	681b      	ldr	r3, [r3, #0]
    96bc:	7818      	ldrb	r0, [r3, #0]
    96be:	0040      	lsls	r0, r0, #1
    96c0:	f7ff fa0a 	bl	8ad8 <Output_update_usb_current>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    96c4:	2704      	movs	r7, #4
			if ( table[i].desc & BDT_OWN )
    96c6:	f854 2037 	ldr.w	r2, [r4, r7, lsl #3]
    96ca:	0610      	lsls	r0, r2, #24
    96cc:	ea4f 03c7 	mov.w	r3, r7, lsl #3
    96d0:	d504      	bpl.n	96dc <usb_isr+0x200>
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
    96d2:	4423      	add	r3, r4
    96d4:	6858      	ldr	r0, [r3, #4]
    96d6:	3808      	subs	r0, #8
    96d8:	f000 fda8 	bl	a22c <usb_free>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    96dc:	3701      	adds	r7, #1
    96de:	2f2c      	cmp	r7, #44	; 0x2c
    96e0:	d1f1      	bne.n	96c6 <usb_isr+0x1ea>
			p = rx_first[i];
    96e2:	f8df 9120 	ldr.w	r9, [pc, #288]	; 9804 <usb_isr+0x328>
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    96e6:	2700      	movs	r7, #0
    96e8:	46cb      	mov	fp, r9
			p = rx_first[i];
    96ea:	f859 0027 	ldr.w	r0, [r9, r7, lsl #2]
    96ee:	ea4f 0a87 	mov.w	sl, r7, lsl #2
			while ( p )
    96f2:	2800      	cmp	r0, #0
    96f4:	d13e      	bne.n	9774 <usb_isr+0x298>
			rx_last[ i ] = NULL;
    96f6:	4b3b      	ldr	r3, [pc, #236]	; (97e4 <usb_isr+0x308>)
			p = tx_first[i];
    96f8:	4a3b      	ldr	r2, [pc, #236]	; (97e8 <usb_isr+0x30c>)
			rx_first[ i ] = NULL;
    96fa:	f84b 000a 	str.w	r0, [fp, sl]
			rx_last[ i ] = NULL;
    96fe:	f84a 0003 	str.w	r0, [sl, r3]
			p = tx_first[i];
    9702:	f85a 0002 	ldr.w	r0, [sl, r2]
			while (p)
    9706:	2800      	cmp	r0, #0
    9708:	d13b      	bne.n	9782 <usb_isr+0x2a6>
			tx_first[ i ] = NULL;
    970a:	f842 000a 	str.w	r0, [r2, sl]
			tx_last[ i ] = NULL;
    970e:	4a37      	ldr	r2, [pc, #220]	; (97ec <usb_isr+0x310>)
			usb_rx_byte_count_data[i] = 0;
    9710:	4b37      	ldr	r3, [pc, #220]	; (97f0 <usb_isr+0x314>)
			tx_last[ i ] = NULL;
    9712:	f84a 0002 	str.w	r0, [sl, r2]
			switch ( tx_state[ i ] )
    9716:	4a37      	ldr	r2, [pc, #220]	; (97f4 <usb_isr+0x318>)
			usb_rx_byte_count_data[i] = 0;
    9718:	f823 0017 	strh.w	r0, [r3, r7, lsl #1]
			switch ( tx_state[ i ] )
    971c:	5dd3      	ldrb	r3, [r2, r7]
    971e:	3b02      	subs	r3, #2
    9720:	2b03      	cmp	r3, #3
    9722:	d873      	bhi.n	980c <usb_isr+0x330>
    9724:	e8df f003 	tbb	[pc, r3]
    9728:	b170b170 	.word	0xb170b170
	switch ( setup.wRequestAndType )
    972c:	f242 0121 	movw	r1, #8225	; 0x2021
    9730:	428a      	cmp	r2, r1
    9732:	d0b0      	beq.n	9696 <usb_isr+0x1ba>
    9734:	d80f      	bhi.n	9756 <usb_isr+0x27a>
    9736:	f640 2121 	movw	r1, #2593	; 0xa21
    973a:	428a      	cmp	r2, r1
    973c:	f000 8166 	beq.w	9a0c <usb_isr+0x530>
    9740:	f640 3121 	movw	r1, #2849	; 0xb21
    9744:	428a      	cmp	r2, r1
    9746:	f47f af54 	bne.w	95f2 <usb_isr+0x116>
		USBKeys_Protocol_New = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    974a:	4a2b      	ldr	r2, [pc, #172]	; (97f8 <usb_isr+0x31c>)
    974c:	f3c3 4307 	ubfx	r3, r3, #16, #8
    9750:	7013      	strb	r3, [r2, #0]
		USBKeys_Protocol_New = 1;
    9752:	2301      	movs	r3, #1
    9754:	e00c      	b.n	9770 <usb_isr+0x294>
	switch ( setup.wRequestAndType )
    9756:	f242 11a1 	movw	r1, #8609	; 0x21a1
    975a:	428a      	cmp	r2, r1
    975c:	f000 8160 	beq.w	9a20 <usb_isr+0x544>
    9760:	f242 2121 	movw	r1, #8737	; 0x2221
    9764:	428a      	cmp	r2, r1
    9766:	f47f af44 	bne.w	95f2 <usb_isr+0x116>
		usb_cdc_line_rtsdtr = setup.wValue;
    976a:	4a24      	ldr	r2, [pc, #144]	; (97fc <usb_isr+0x320>)
    976c:	f3c3 4307 	ubfx	r3, r3, #16, #8
		USBKeys_Protocol_New = 1;
    9770:	7013      	strb	r3, [r2, #0]
    9772:	e790      	b.n	9696 <usb_isr+0x1ba>
				n = p->next;
    9774:	6842      	ldr	r2, [r0, #4]
    9776:	9200      	str	r2, [sp, #0]
				usb_free(p);
    9778:	f000 fd58 	bl	a22c <usb_free>
				p = n;
    977c:	9a00      	ldr	r2, [sp, #0]
    977e:	4610      	mov	r0, r2
    9780:	e7b7      	b.n	96f2 <usb_isr+0x216>
				n = p->next;
    9782:	6841      	ldr	r1, [r0, #4]
    9784:	9201      	str	r2, [sp, #4]
    9786:	9100      	str	r1, [sp, #0]
				usb_free(p);
    9788:	f000 fd50 	bl	a22c <usb_free>
				p = n;
    978c:	9900      	ldr	r1, [sp, #0]
    978e:	9a01      	ldr	r2, [sp, #4]
    9790:	4608      	mov	r0, r1
    9792:	e7b8      	b.n	9706 <usb_isr+0x22a>
    9794:	40072080 	.word	0x40072080
    9798:	1fff9546 	.word	0x1fff9546
    979c:	1fff9548 	.word	0x1fff9548
    97a0:	1fff9559 	.word	0x1fff9559
    97a4:	1fff9547 	.word	0x1fff9547
    97a8:	1fff8f10 	.word	0x1fff8f10
    97ac:	40072090 	.word	0x40072090
    97b0:	1fff8000 	.word	0x1fff8000
    97b4:	004000c8 	.word	0x004000c8
    97b8:	1fff947d 	.word	0x1fff947d
    97bc:	1fff94e4 	.word	0x1fff94e4
    97c0:	1fff9158 	.word	0x1fff9158
    97c4:	1fffadc4 	.word	0x1fffadc4
    97c8:	1fffadc8 	.word	0x1fffadc8
    97cc:	1fff9484 	.word	0x1fff9484
    97d0:	400720c0 	.word	0x400720c0
    97d4:	00010c2c 	.word	0x00010c2c
    97d8:	00010c63 	.word	0x00010c63
    97dc:	1fff93e5 	.word	0x1fff93e5
    97e0:	1fffadba 	.word	0x1fffadba
    97e4:	1fff94bc 	.word	0x1fff94bc
    97e8:	1fff94ec 	.word	0x1fff94ec
    97ec:	1fff9514 	.word	0x1fff9514
    97f0:	1fffae18 	.word	0x1fffae18
    97f4:	1fff953c 	.word	0x1fff953c
    97f8:	1fff8ce9 	.word	0x1fff8ce9
    97fc:	1fff9558 	.word	0x1fff9558
    9800:	1fff9480 	.word	0x1fff9480
    9804:	1fff9494 	.word	0x1fff9494
				tx_state[ i ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9808:	2300      	movs	r3, #0
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    980a:	55d3      	strb	r3, [r2, r7]
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    980c:	3701      	adds	r7, #1
    980e:	2f0a      	cmp	r7, #10
    9810:	f47f af6b 	bne.w	96ea <usb_isr+0x20e>
		usb_rx_memory_needed = 0;
    9814:	4aa9      	ldr	r2, [pc, #676]	; (9abc <usb_isr+0x5e0>)
    9816:	4faa      	ldr	r7, [pc, #680]	; (9ac0 <usb_isr+0x5e4>)
		reg = &USB0_ENDPT1;
    9818:	f8df 9308 	ldr.w	r9, [pc, #776]	; 9b24 <usb_isr+0x648>
		usb_rx_memory_needed = 0;
    981c:	2300      	movs	r3, #0
    981e:	7013      	strb	r3, [r2, #0]
    9820:	4693      	mov	fp, r2
			epconf = *cfg++;
    9822:	f817 1f01 	ldrb.w	r1, [r7, #1]!
			*reg = epconf;
    9826:	f809 1b04 	strb.w	r1, [r9], #4
    982a:	f8df a2fc 	ldr.w	sl, [pc, #764]	; 9b28 <usb_isr+0x64c>
			if ( epconf & USB_ENDPT_EPRXEN )
    982e:	0709      	lsls	r1, r1, #28
    9830:	44ca      	add	sl, r9
    9832:	d51d      	bpl.n	9870 <usb_isr+0x394>
				p = usb_malloc();
    9834:	f000 fcdc 	bl	a1f0 <usb_malloc>
    9838:	ea4f 01c9 	mov.w	r1, r9, lsl #3
				if ( p )
    983c:	b338      	cbz	r0, 988e <usb_isr+0x3b2>
    983e:	4421      	add	r1, r4
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    9840:	f5a1 1164 	sub.w	r1, r1, #3735552	; 0x390000
    9844:	f2a1 6c1c 	subw	ip, r1, #1564	; 0x61c
    9848:	3008      	adds	r0, #8
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    984a:	f5a1 61c4 	sub.w	r1, r1, #1568	; 0x620
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    984e:	f8cc 0000 	str.w	r0, [ip]
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    9852:	489c      	ldr	r0, [pc, #624]	; (9ac4 <usb_isr+0x5e8>)
    9854:	6008      	str	r0, [r1, #0]
				p = usb_malloc();
    9856:	f000 fccb 	bl	a1f0 <usb_malloc>
    985a:	f04a 0101 	orr.w	r1, sl, #1
				if ( p )
    985e:	b308      	cbz	r0, 98a4 <usb_isr+0x3c8>
					table[ index( i, RX, ODD ) ].addr = p->buf;
    9860:	eb04 0cc1 	add.w	ip, r4, r1, lsl #3
					table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    9864:	4b98      	ldr	r3, [pc, #608]	; (9ac8 <usb_isr+0x5ec>)
    9866:	f844 3031 	str.w	r3, [r4, r1, lsl #3]
					table[ index( i, RX, ODD ) ].addr = p->buf;
    986a:	3008      	adds	r0, #8
    986c:	f8cc 0004 	str.w	r0, [ip, #4]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    9870:	4b96      	ldr	r3, [pc, #600]	; (9acc <usb_isr+0x5f0>)
			table[ index( i, TX, EVEN ) ].desc = 0;
    9872:	f04a 0002 	orr.w	r0, sl, #2
			table[ index( i, TX, ODD ) ].desc = 0;
    9876:	f04a 0203 	orr.w	r2, sl, #3
			table[ index( i, TX, EVEN ) ].desc = 0;
    987a:	2100      	movs	r1, #0
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    987c:	4599      	cmp	r9, r3
			table[ index( i, TX, EVEN ) ].desc = 0;
    987e:	f844 1030 	str.w	r1, [r4, r0, lsl #3]
			table[ index( i, TX, ODD ) ].desc = 0;
    9882:	f844 1032 	str.w	r1, [r4, r2, lsl #3]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    9886:	d1cc      	bne.n	9822 <usb_isr+0x346>
    9888:	e705      	b.n	9696 <usb_isr+0x1ba>
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    988a:	2301      	movs	r3, #1
    988c:	e7bd      	b.n	980a <usb_isr+0x32e>
					table[ index( i, RX, EVEN ) ].desc = 0;
    988e:	f5a1 1164 	sub.w	r1, r1, #3735552	; 0x390000
    9892:	f5a1 61c4 	sub.w	r1, r1, #1568	; 0x620
    9896:	5060      	str	r0, [r4, r1]
					usb_rx_memory_needed++;
    9898:	f89b 1000 	ldrb.w	r1, [fp]
    989c:	3101      	adds	r1, #1
    989e:	f88b 1000 	strb.w	r1, [fp]
    98a2:	e7d8      	b.n	9856 <usb_isr+0x37a>
					table[ index( i, RX, ODD ) ].desc = 0;
    98a4:	f844 0031 	str.w	r0, [r4, r1, lsl #3]
					usb_rx_memory_needed++;
    98a8:	f89b 1000 	ldrb.w	r1, [fp]
    98ac:	3101      	adds	r1, #1
    98ae:	f88b 1000 	strb.w	r1, [fp]
    98b2:	e7dd      	b.n	9870 <usb_isr+0x394>
		reply_buffer[0] = usb_configuration;
    98b4:	4b86      	ldr	r3, [pc, #536]	; (9ad0 <usb_isr+0x5f4>)
		reply_buffer[0] = USBKeys_Protocol;
    98b6:	4c87      	ldr	r4, [pc, #540]	; (9ad4 <usb_isr+0x5f8>)
    98b8:	781b      	ldrb	r3, [r3, #0]
    98ba:	7023      	strb	r3, [r4, #0]
		datalen = 1;
    98bc:	2301      	movs	r3, #1
    98be:	e066      	b.n	998e <usb_isr+0x4b2>
		reply_buffer[0] = 0;
    98c0:	4c84      	ldr	r4, [pc, #528]	; (9ad4 <usb_isr+0x5f8>)
    98c2:	2300      	movs	r3, #0
    98c4:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    98c6:	7063      	strb	r3, [r4, #1]
		datalen = 2;
    98c8:	2302      	movs	r3, #2
    98ca:	e060      	b.n	998e <usb_isr+0x4b2>
		if ( setup.wIndex > NUM_ENDPOINTS )
    98cc:	b28b      	uxth	r3, r1
    98ce:	2b0a      	cmp	r3, #10
    98d0:	4b81      	ldr	r3, [pc, #516]	; (9ad8 <usb_isr+0x5fc>)
    98d2:	d905      	bls.n	98e0 <usb_isr+0x404>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    98d4:	220f      	movs	r2, #15
    98d6:	701a      	strb	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    98d8:	4b80      	ldr	r3, [pc, #512]	; (9adc <usb_isr+0x600>)
    98da:	2201      	movs	r2, #1
			USB0_ADDR = setup.wValue;
    98dc:	701a      	strb	r2, [r3, #0]
    98de:	e0e0      	b.n	9aa2 <usb_isr+0x5c6>
		reply_buffer[0] = 0;
    98e0:	4c7c      	ldr	r4, [pc, #496]	; (9ad4 <usb_isr+0x5f8>)
    98e2:	2200      	movs	r2, #0
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    98e4:	b289      	uxth	r1, r1
		reply_buffer[0] = 0;
    98e6:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    98e8:	7062      	strb	r2, [r4, #1]
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    98ea:	f813 3021 	ldrb.w	r3, [r3, r1, lsl #2]
    98ee:	079a      	lsls	r2, r3, #30
    98f0:	d5ea      	bpl.n	98c8 <usb_isr+0x3ec>
			reply_buffer[0] = 1;
    98f2:	2301      	movs	r3, #1
    98f4:	7023      	strb	r3, [r4, #0]
    98f6:	e7e7      	b.n	98c8 <usb_isr+0x3ec>
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    98f8:	f001 027f 	and.w	r2, r1, #127	; 0x7f
    98fc:	2a0a      	cmp	r2, #10
    98fe:	4a76      	ldr	r2, [pc, #472]	; (9ad8 <usb_isr+0x5fc>)
    9900:	d801      	bhi.n	9906 <usb_isr+0x42a>
    9902:	0c1b      	lsrs	r3, r3, #16
    9904:	d002      	beq.n	990c <usb_isr+0x430>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9906:	230f      	movs	r3, #15
    9908:	7013      	strb	r3, [r2, #0]
    990a:	e7e5      	b.n	98d8 <usb_isr+0x3fc>
		i = setup.wIndex & 0x7F;
    990c:	b289      	uxth	r1, r1
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) &= ~0x02;
    990e:	f812 0021 	ldrb.w	r0, [r2, r1, lsl #2]
    9912:	f020 0002 	bic.w	r0, r0, #2
    9916:	f802 0021 	strb.w	r0, [r2, r1, lsl #2]
	const uint8_t *data = NULL;
    991a:	461c      	mov	r4, r3
    991c:	e037      	b.n	998e <usb_isr+0x4b2>
		switch ( setup.wValue )
    991e:	0c1b      	lsrs	r3, r3, #16
    9920:	2b01      	cmp	r3, #1
    9922:	f43f aeb8 	beq.w	9696 <usb_isr+0x1ba>
		warn_msg("SET_FEATURE - Device wValue(");
    9926:	486e      	ldr	r0, [pc, #440]	; (9ae0 <usb_isr+0x604>)
    9928:	f001 fd6a 	bl	b400 <_print>
		printHex( setup.wValue );
    992c:	8868      	ldrh	r0, [r5, #2]
    992e:	2101      	movs	r1, #1
    9930:	f001 fe0e 	bl	b550 <printHex_op>
		print( ")" NL );
    9934:	486b      	ldr	r0, [pc, #428]	; (9ae4 <usb_isr+0x608>)
    9936:	f001 fd63 	bl	b400 <_print>
    993a:	e65a      	b.n	95f2 <usb_isr+0x116>
		warn_msg("SET_FEATURE - Interface wValue(");
    993c:	486a      	ldr	r0, [pc, #424]	; (9ae8 <usb_isr+0x60c>)
    993e:	f001 fd5f 	bl	b400 <_print>
		printHex( setup.wValue );
    9942:	2101      	movs	r1, #1
    9944:	8868      	ldrh	r0, [r5, #2]
    9946:	f001 fe03 	bl	b550 <printHex_op>
		print(") wIndex(");
    994a:	4868      	ldr	r0, [pc, #416]	; (9aec <usb_isr+0x610>)
    994c:	f001 fd58 	bl	b400 <_print>
		printHex( setup.wIndex );
    9950:	88a8      	ldrh	r0, [r5, #4]
    9952:	2101      	movs	r1, #1
    9954:	f001 fdfc 	bl	b550 <printHex_op>
		print( ")" NL );
    9958:	4862      	ldr	r0, [pc, #392]	; (9ae4 <usb_isr+0x608>)
    995a:	f001 fd51 	bl	b400 <_print>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    995e:	230f      	movs	r3, #15
    9960:	7023      	strb	r3, [r4, #0]
    9962:	e7b9      	b.n	98d8 <usb_isr+0x3fc>
		for ( list = usb_descriptor_list; 1; list++ )
    9964:	4a62      	ldr	r2, [pc, #392]	; (9af0 <usb_isr+0x614>)
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    9966:	f3c3 430f 	ubfx	r3, r3, #16, #16
    996a:	b289      	uxth	r1, r1
			if ( list->addr == NULL )
    996c:	6854      	ldr	r4, [r2, #4]
    996e:	2c00      	cmp	r4, #0
    9970:	f43f ae3f 	beq.w	95f2 <usb_isr+0x116>
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    9974:	f8b2 e000 	ldrh.w	lr, [r2]
    9978:	4573      	cmp	r3, lr
    997a:	469c      	mov	ip, r3
    997c:	d126      	bne.n	99cc <usb_isr+0x4f0>
    997e:	f8b2 e002 	ldrh.w	lr, [r2, #2]
    9982:	458e      	cmp	lr, r1
    9984:	d122      	bne.n	99cc <usb_isr+0x4f0>
				if ( (setup.wValue >> 8) == 3 )
    9986:	0a1b      	lsrs	r3, r3, #8
    9988:	2b03      	cmp	r3, #3
    998a:	d113      	bne.n	99b4 <usb_isr+0x4d8>
					datalen = *(list->addr);
    998c:	7823      	ldrb	r3, [r4, #0]
	if ( datalen > setup.wLength )
    998e:	88ef      	ldrh	r7, [r5, #6]
    9990:	429f      	cmp	r7, r3
    9992:	bf28      	it	cs
    9994:	461f      	movcs	r7, r3
    9996:	2f40      	cmp	r7, #64	; 0x40
    9998:	463d      	mov	r5, r7
    999a:	bf28      	it	cs
    999c:	2540      	movcs	r5, #64	; 0x40
	endpoint0_transmit( data, size );
    999e:	4629      	mov	r1, r5
    99a0:	4620      	mov	r0, r4
    99a2:	f7ff fc6b 	bl	927c <endpoint0_transmit>
	data += size;
    99a6:	442c      	add	r4, r5
	if ( datalen == 0 && size < EP0_SIZE )
    99a8:	1b7d      	subs	r5, r7, r5
    99aa:	d13c      	bne.n	9a26 <usb_isr+0x54a>
    99ac:	2f3f      	cmp	r7, #63	; 0x3f
    99ae:	d993      	bls.n	98d8 <usb_isr+0x3fc>
    99b0:	462f      	mov	r7, r5
    99b2:	e03c      	b.n	9a2e <usb_isr+0x552>
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    99b4:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
					datalen = list->length;
    99b8:	8913      	ldrh	r3, [r2, #8]
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    99ba:	d1e8      	bne.n	998e <usb_isr+0x4b2>
    99bc:	2900      	cmp	r1, #0
    99be:	d1e6      	bne.n	998e <usb_isr+0x4b2>
					power_neg_delay = 1;
    99c0:	2201      	movs	r2, #1
    99c2:	703a      	strb	r2, [r7, #0]
					power_neg_time = systick_millis_count;
    99c4:	4a4b      	ldr	r2, [pc, #300]	; (9af4 <usb_isr+0x618>)
    99c6:	6801      	ldr	r1, [r0, #0]
    99c8:	6011      	str	r1, [r2, #0]
    99ca:	e7e0      	b.n	998e <usb_isr+0x4b2>
		for ( list = usb_descriptor_list; 1; list++ )
    99cc:	320c      	adds	r2, #12
    99ce:	e7cd      	b.n	996c <usb_isr+0x490>
		switch ( setup.wIndex & 0xFF )
    99d0:	b2c9      	uxtb	r1, r1
    99d2:	2901      	cmp	r1, #1
    99d4:	f67f ae5f 	bls.w	9696 <usb_isr+0x1ba>
			warn_msg("(SET_REPORT, SETUP) Unknown interface - ");
    99d8:	4847      	ldr	r0, [pc, #284]	; (9af8 <usb_isr+0x61c>)
    99da:	f001 fd11 	bl	b400 <_print>
			printHex( setup.wIndex );
    99de:	88a8      	ldrh	r0, [r5, #4]
    99e0:	2101      	movs	r1, #1
    99e2:	f001 fdb5 	bl	b550 <printHex_op>
			print( NL );
    99e6:	4845      	ldr	r0, [pc, #276]	; (9afc <usb_isr+0x620>)
    99e8:	e7a5      	b.n	9936 <usb_isr+0x45a>
		for ( list = usb_descriptor_list; 1; list++ )
    99ea:	4b41      	ldr	r3, [pc, #260]	; (9af0 <usb_isr+0x614>)
			if ( setup.wIndex == list->wIndex )
    99ec:	b289      	uxth	r1, r1
			if ( list->addr == NULL )
    99ee:	685c      	ldr	r4, [r3, #4]
    99f0:	2c00      	cmp	r4, #0
    99f2:	f43f adfe 	beq.w	95f2 <usb_isr+0x116>
			if ( list->wValue != 0x2200 )
    99f6:	881a      	ldrh	r2, [r3, #0]
    99f8:	f5b2 5f08 	cmp.w	r2, #8704	; 0x2200
    99fc:	d104      	bne.n	9a08 <usb_isr+0x52c>
			if ( setup.wIndex == list->wIndex )
    99fe:	885a      	ldrh	r2, [r3, #2]
    9a00:	428a      	cmp	r2, r1
    9a02:	d101      	bne.n	9a08 <usb_isr+0x52c>
				datalen = list->length;
    9a04:	891b      	ldrh	r3, [r3, #8]
    9a06:	e7c2      	b.n	998e <usb_isr+0x4b2>
		for ( list = usb_descriptor_list; 1; list++ )
    9a08:	330c      	adds	r3, #12
    9a0a:	e7f0      	b.n	99ee <usb_isr+0x512>
		USBKeys_Idle_Config = (setup.wValue >> 8);
    9a0c:	4a3c      	ldr	r2, [pc, #240]	; (9b00 <usb_isr+0x624>)
		USBKeys_Idle_Expiry = 0;
    9a0e:	493d      	ldr	r1, [pc, #244]	; (9b04 <usb_isr+0x628>)
		USBKeys_Idle_Config = (setup.wValue >> 8);
    9a10:	0e1b      	lsrs	r3, r3, #24
    9a12:	7013      	strb	r3, [r2, #0]
		USBKeys_Idle_Expiry = 0;
    9a14:	2300      	movs	r3, #0
    9a16:	600b      	str	r3, [r1, #0]
			USBKeys_Idle_Config = USBIdle_define;
    9a18:	7013      	strb	r3, [r2, #0]
    9a1a:	e77e      	b.n	991a <usb_isr+0x43e>
		reply_buffer[0] = USBKeys_Protocol;
    9a1c:	4b3a      	ldr	r3, [pc, #232]	; (9b08 <usb_isr+0x62c>)
    9a1e:	e74a      	b.n	98b6 <usb_isr+0x3da>
		datalen = sizeof( usb_cdc_line_coding );
    9a20:	2308      	movs	r3, #8
		data = (uint8_t*)&usb_cdc_line_coding;
    9a22:	4c3a      	ldr	r4, [pc, #232]	; (9b0c <usb_isr+0x630>)
    9a24:	e7b3      	b.n	998e <usb_isr+0x4b2>
    9a26:	2d40      	cmp	r5, #64	; 0x40
    9a28:	462f      	mov	r7, r5
    9a2a:	bf28      	it	cs
    9a2c:	2740      	movcs	r7, #64	; 0x40
	endpoint0_transmit( data, size );
    9a2e:	4620      	mov	r0, r4
    9a30:	4639      	mov	r1, r7
    9a32:	f7ff fc23 	bl	927c <endpoint0_transmit>
	if ( datalen == 0 && size < EP0_SIZE )
    9a36:	1bed      	subs	r5, r5, r7
	data += size;
    9a38:	443c      	add	r4, r7
	if ( datalen == 0 && size < EP0_SIZE )
    9a3a:	d102      	bne.n	9a42 <usb_isr+0x566>
    9a3c:	2f40      	cmp	r7, #64	; 0x40
    9a3e:	f47f af4b 	bne.w	98d8 <usb_isr+0x3fc>
	ep0_tx_len = datalen;
    9a42:	4b33      	ldr	r3, [pc, #204]	; (9b10 <usb_isr+0x634>)
	ep0_tx_ptr = data;
    9a44:	f8c8 4000 	str.w	r4, [r8]
	ep0_tx_len = datalen;
    9a48:	801d      	strh	r5, [r3, #0]
    9a4a:	e745      	b.n	98d8 <usb_isr+0x3fc>
		if ( setup.wRequestAndType == 0x2021 )
    9a4c:	4d31      	ldr	r5, [pc, #196]	; (9b14 <usb_isr+0x638>)
    9a4e:	882a      	ldrh	r2, [r5, #0]
    9a50:	f242 0321 	movw	r3, #8225	; 0x2021
    9a54:	429a      	cmp	r2, r3
    9a56:	d104      	bne.n	9a62 <usb_isr+0x586>
			memcpy( (void*)&usb_cdc_line_coding, buf, 7 );
    9a58:	2207      	movs	r2, #7
    9a5a:	4639      	mov	r1, r7
    9a5c:	482b      	ldr	r0, [pc, #172]	; (9b0c <usb_isr+0x630>)
    9a5e:	f7f8 fdf7 	bl	2650 <memcpy>
		if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    9a62:	882a      	ldrh	r2, [r5, #0]
    9a64:	f640 1321 	movw	r3, #2337	; 0x921
    9a68:	429a      	cmp	r2, r3
    9a6a:	d117      	bne.n	9a9c <usb_isr+0x5c0>
    9a6c:	886b      	ldrh	r3, [r5, #2]
    9a6e:	059b      	lsls	r3, r3, #22
    9a70:	d514      	bpl.n	9a9c <usb_isr+0x5c0>
			switch ( setup.wIndex & 0xFF )
    9a72:	792b      	ldrb	r3, [r5, #4]
    9a74:	b163      	cbz	r3, 9a90 <usb_isr+0x5b4>
    9a76:	2b01      	cmp	r3, #1
    9a78:	d019      	beq.n	9aae <usb_isr+0x5d2>
				warn_msg("(SET_REPORT, BULK) Unknown interface - ");
    9a7a:	4827      	ldr	r0, [pc, #156]	; (9b18 <usb_isr+0x63c>)
    9a7c:	f001 fcc0 	bl	b400 <_print>
				printHex( setup.wIndex );
    9a80:	88a8      	ldrh	r0, [r5, #4]
    9a82:	2101      	movs	r1, #1
    9a84:	f001 fd64 	bl	b550 <printHex_op>
				print( NL );
    9a88:	481c      	ldr	r0, [pc, #112]	; (9afc <usb_isr+0x620>)
    9a8a:	f001 fcb9 	bl	b400 <_print>
    9a8e:	e005      	b.n	9a9c <usb_isr+0x5c0>
				USBKeys_LEDs = buf[0];
    9a90:	4b22      	ldr	r3, [pc, #136]	; (9b1c <usb_isr+0x640>)
    9a92:	783a      	ldrb	r2, [r7, #0]
    9a94:	701a      	strb	r2, [r3, #0]
				USBKeys_LEDs_Changed = 1;
    9a96:	4b22      	ldr	r3, [pc, #136]	; (9b20 <usb_isr+0x644>)
    9a98:	2201      	movs	r2, #1
    9a9a:	701a      	strb	r2, [r3, #0]
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    9a9c:	4b0a      	ldr	r3, [pc, #40]	; (9ac8 <usb_isr+0x5ec>)
    9a9e:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9aa2:	4b0e      	ldr	r3, [pc, #56]	; (9adc <usb_isr+0x600>)
    9aa4:	2201      	movs	r2, #1
    9aa6:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9aa8:	2308      	movs	r3, #8
    9aaa:	7033      	strb	r3, [r6, #0]
		goto restart;
    9aac:	e519      	b.n	94e2 <usb_isr+0x6>
				USBKeys_LEDs = buf[1];
    9aae:	4a1b      	ldr	r2, [pc, #108]	; (9b1c <usb_isr+0x640>)
    9ab0:	7879      	ldrb	r1, [r7, #1]
    9ab2:	7011      	strb	r1, [r2, #0]
				USBKeys_LEDs_Changed = 1;
    9ab4:	4a1a      	ldr	r2, [pc, #104]	; (9b20 <usb_isr+0x644>)
    9ab6:	7013      	strb	r3, [r2, #0]
    9ab8:	e7f0      	b.n	9a9c <usb_isr+0x5c0>
    9aba:	bf00      	nop
    9abc:	1fff9549 	.word	0x1fff9549
    9ac0:	00010ba3 	.word	0x00010ba3
    9ac4:	00400088 	.word	0x00400088
    9ac8:	004000c8 	.word	0x004000c8
    9acc:	400720ec 	.word	0x400720ec
    9ad0:	1fff9546 	.word	0x1fff9546
    9ad4:	1fff948c 	.word	0x1fff948c
    9ad8:	400720c0 	.word	0x400720c0
    9adc:	40072094 	.word	0x40072094
    9ae0:	00010bfa 	.word	0x00010bfa
    9ae4:	000113bd 	.word	0x000113bd
    9ae8:	00010c6d 	.word	0x00010c6d
    9aec:	00010c63 	.word	0x00010c63
    9af0:	00010a60 	.word	0x00010a60
    9af4:	1fff9488 	.word	0x1fff9488
    9af8:	00010ca2 	.word	0x00010ca2
    9afc:	00010d99 	.word	0x00010d99
    9b00:	1fff93e5 	.word	0x1fff93e5
    9b04:	1fff93e8 	.word	0x1fff93e8
    9b08:	1fff8ce8 	.word	0x1fff8ce8
    9b0c:	1fff90ec 	.word	0x1fff90ec
    9b10:	1fff947e 	.word	0x1fff947e
    9b14:	1fff94e4 	.word	0x1fff94e4
    9b18:	00010ce0 	.word	0x00010ce0
    9b1c:	1fff93ec 	.word	0x1fff93ec
    9b20:	1fffadc0 	.word	0x1fffadc0
    9b24:	400720c4 	.word	0x400720c4
    9b28:	bff8df3c 	.word	0xbff8df3c
		data = ep0_tx_ptr;
    9b2c:	f8df 8234 	ldr.w	r8, [pc, #564]	; 9d64 <usb_isr+0x888>
    9b30:	f8d8 5000 	ldr.w	r5, [r8]
		if ( data )
    9b34:	b1b5      	cbz	r5, 9b64 <usb_isr+0x688>
			size = ep0_tx_len;
    9b36:	f8df 9230 	ldr.w	r9, [pc, #560]	; 9d68 <usb_isr+0x88c>
    9b3a:	f8b9 7000 	ldrh.w	r7, [r9]
    9b3e:	2f40      	cmp	r7, #64	; 0x40
    9b40:	463c      	mov	r4, r7
    9b42:	bf28      	it	cs
    9b44:	2440      	movcs	r4, #64	; 0x40
			endpoint0_transmit( data, size );
    9b46:	4621      	mov	r1, r4
    9b48:	4628      	mov	r0, r5
			data += size;
    9b4a:	4425      	add	r5, r4
			ep0_tx_len -= size;
    9b4c:	1b3c      	subs	r4, r7, r4
    9b4e:	b2a4      	uxth	r4, r4
			endpoint0_transmit( data, size );
    9b50:	f7ff fb94 	bl	927c <endpoint0_transmit>
			ep0_tx_len -= size;
    9b54:	f8a9 4000 	strh.w	r4, [r9]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9b58:	b914      	cbnz	r4, 9b60 <usb_isr+0x684>
    9b5a:	2f3f      	cmp	r7, #63	; 0x3f
    9b5c:	bf98      	it	ls
    9b5e:	2500      	movls	r5, #0
    9b60:	f8c8 5000 	str.w	r5, [r8]
		if ( setup.bRequest == 5 && setup.bmRequestType == 0 )
    9b64:	4b6a      	ldr	r3, [pc, #424]	; (9d10 <usb_isr+0x834>)
    9b66:	881a      	ldrh	r2, [r3, #0]
    9b68:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    9b6c:	d199      	bne.n	9aa2 <usb_isr+0x5c6>
			setup.bRequest = 0;
    9b6e:	2200      	movs	r2, #0
    9b70:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    9b72:	789a      	ldrb	r2, [r3, #2]
    9b74:	4b67      	ldr	r3, [pc, #412]	; (9d14 <usb_isr+0x838>)
    9b76:	e6b1      	b.n	98dc <usb_isr+0x400>
			bdt_t *b = stat2bufferdescriptor(stat);
    9b78:	eb04 07c8 	add.w	r7, r4, r8, lsl #3
			endpoint--;     // endpoint is index to zero-based arrays
    9b7c:	3d01      	subs	r5, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9b7e:	6879      	ldr	r1, [r7, #4]
			if ( stat & 0x08 )
    9b80:	f013 0308 	ands.w	r3, r3, #8
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9b84:	f1a1 0008 	sub.w	r0, r1, #8
			endpoint--;     // endpoint is index to zero-based arrays
    9b88:	b2ed      	uxtb	r5, r5
			if ( stat & 0x08 )
    9b8a:	d040      	beq.n	9c0e <usb_isr+0x732>
				usb_free( packet );
    9b8c:	f000 fb4e 	bl	a22c <usb_free>
				packet = tx_first[ endpoint ];
    9b90:	4861      	ldr	r0, [pc, #388]	; (9d18 <usb_isr+0x83c>)
    9b92:	4a62      	ldr	r2, [pc, #392]	; (9d1c <usb_isr+0x840>)
    9b94:	f850 1025 	ldr.w	r1, [r0, r5, lsl #2]
				if ( packet )
    9b98:	b1f9      	cbz	r1, 9bda <usb_isr+0x6fe>
					tx_first[endpoint] = packet->next;
    9b9a:	684b      	ldr	r3, [r1, #4]
    9b9c:	f840 3025 	str.w	r3, [r0, r5, lsl #2]
					b->addr = packet->buf;
    9ba0:	f101 0308 	add.w	r3, r1, #8
    9ba4:	607b      	str	r3, [r7, #4]
					switch ( tx_state[ endpoint ] )
    9ba6:	5d53      	ldrb	r3, [r2, r5]
    9ba8:	2b03      	cmp	r3, #3
    9baa:	d805      	bhi.n	9bb8 <usb_isr+0x6dc>
    9bac:	e8df f003 	tbb	[pc, r3]
    9bb0:	13110f02 	.word	0x13110f02
						tx_state[ endpoint ] = TX_STATE_ODD_FREE;
    9bb4:	2303      	movs	r3, #3
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9bb6:	5553      	strb	r3, [r2, r5]
					b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    9bb8:	f017 0f08 	tst.w	r7, #8
    9bbc:	880a      	ldrh	r2, [r1, #0]
    9bbe:	bf0c      	ite	eq
    9bc0:	2388      	moveq	r3, #136	; 0x88
    9bc2:	23c8      	movne	r3, #200	; 0xc8
    9bc4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    9bc8:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
    9bcc:	e76c      	b.n	9aa8 <usb_isr+0x5cc>
						tx_state[ endpoint ] = TX_STATE_EVEN_FREE;
    9bce:	2302      	movs	r3, #2
    9bd0:	e7f1      	b.n	9bb6 <usb_isr+0x6da>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_ODD_FIRST;
    9bd2:	2305      	movs	r3, #5
    9bd4:	e7ef      	b.n	9bb6 <usb_isr+0x6da>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9bd6:	2304      	movs	r3, #4
    9bd8:	e7ed      	b.n	9bb6 <usb_isr+0x6da>
					switch ( tx_state[ endpoint ] )
    9bda:	5d53      	ldrb	r3, [r2, r5]
    9bdc:	2b03      	cmp	r3, #3
    9bde:	d810      	bhi.n	9c02 <usb_isr+0x726>
    9be0:	a101      	add	r1, pc, #4	; (adr r1, 9be8 <usb_isr+0x70c>)
    9be2:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    9be6:	bf00      	nop
    9be8:	00009aa9 	.word	0x00009aa9
    9bec:	00009aa9 	.word	0x00009aa9
    9bf0:	00009bf9 	.word	0x00009bf9
    9bf4:	00009bff 	.word	0x00009bff
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9bf8:	2300      	movs	r3, #0
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    9bfa:	5553      	strb	r3, [r2, r5]
						break;
    9bfc:	e754      	b.n	9aa8 <usb_isr+0x5cc>
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9bfe:	2301      	movs	r3, #1
    9c00:	e7fb      	b.n	9bfa <usb_isr+0x71e>
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    9c02:	f017 0f08 	tst.w	r7, #8
    9c06:	bf0c      	ite	eq
    9c08:	2302      	moveq	r3, #2
    9c0a:	2303      	movne	r3, #3
    9c0c:	e7f5      	b.n	9bfa <usb_isr+0x71e>
				packet->len = b->desc >> 16;
    9c0e:	f854 2038 	ldr.w	r2, [r4, r8, lsl #3]
    9c12:	0c12      	lsrs	r2, r2, #16
    9c14:	fa1f fc82 	uxth.w	ip, r2
    9c18:	f821 cc08 	strh.w	ip, [r1, #-8]
				if ( packet->len > 0 )
    9c1c:	b1ba      	cbz	r2, 9c4e <usb_isr+0x772>
					packet->index = 0;
    9c1e:	f821 3c06 	strh.w	r3, [r1, #-6]
					packet->next = NULL;
    9c22:	f841 3c04 	str.w	r3, [r1, #-4]
					if ( rx_first[ endpoint ] == NULL )
    9c26:	493e      	ldr	r1, [pc, #248]	; (9d20 <usb_isr+0x844>)
    9c28:	4b3e      	ldr	r3, [pc, #248]	; (9d24 <usb_isr+0x848>)
    9c2a:	f851 2025 	ldr.w	r2, [r1, r5, lsl #2]
    9c2e:	b9aa      	cbnz	r2, 9c5c <usb_isr+0x780>
						rx_first[ endpoint ] = packet;
    9c30:	f841 0025 	str.w	r0, [r1, r5, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    9c34:	4a3c      	ldr	r2, [pc, #240]	; (9d28 <usb_isr+0x84c>)
					rx_last[ endpoint ] = packet;
    9c36:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    9c3a:	f832 3015 	ldrh.w	r3, [r2, r5, lsl #1]
    9c3e:	4463      	add	r3, ip
    9c40:	f822 3015 	strh.w	r3, [r2, r5, lsl #1]
					packet = usb_malloc();
    9c44:	f000 fad4 	bl	a1f0 <usb_malloc>
					if ( packet )
    9c48:	b160      	cbz	r0, 9c64 <usb_isr+0x788>
						b->addr = packet->buf;
    9c4a:	3008      	adds	r0, #8
    9c4c:	6078      	str	r0, [r7, #4]
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    9c4e:	4a37      	ldr	r2, [pc, #220]	; (9d2c <usb_isr+0x850>)
    9c50:	4b37      	ldr	r3, [pc, #220]	; (9d30 <usb_isr+0x854>)
    9c52:	f017 0f08 	tst.w	r7, #8
    9c56:	bf18      	it	ne
    9c58:	4613      	movne	r3, r2
    9c5a:	e7b5      	b.n	9bc8 <usb_isr+0x6ec>
						rx_last[ endpoint ]->next = packet;
    9c5c:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
    9c60:	6050      	str	r0, [r2, #4]
    9c62:	e7e7      	b.n	9c34 <usb_isr+0x758>
						usb_rx_memory_needed++;
    9c64:	4a33      	ldr	r2, [pc, #204]	; (9d34 <usb_isr+0x858>)
						b->desc = 0;
    9c66:	f844 0038 	str.w	r0, [r4, r8, lsl #3]
						usb_rx_memory_needed++;
    9c6a:	7813      	ldrb	r3, [r2, #0]
    9c6c:	3301      	adds	r3, #1
    9c6e:	7013      	strb	r3, [r2, #0]
    9c70:	e71a      	b.n	9aa8 <usb_isr+0x5cc>
	if ( status & USB_ISTAT_USBRST /* 01 */ )
    9c72:	07e5      	lsls	r5, r4, #31
    9c74:	d520      	bpl.n	9cb8 <usb_isr+0x7dc>
		USB0_CTL = USB_CTL_ODDRST;
    9c76:	4930      	ldr	r1, [pc, #192]	; (9d38 <usb_isr+0x85c>)
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    9c78:	482d      	ldr	r0, [pc, #180]	; (9d30 <usb_isr+0x854>)
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    9c7a:	4c30      	ldr	r4, [pc, #192]	; (9d3c <usb_isr+0x860>)
		USB0_CTL = USB_CTL_ODDRST;
    9c7c:	2302      	movs	r3, #2
    9c7e:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9c80:	4b2f      	ldr	r3, [pc, #188]	; (9d40 <usb_isr+0x864>)
    9c82:	701a      	strb	r2, [r3, #0]
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    9c84:	4b2f      	ldr	r3, [pc, #188]	; (9d44 <usb_isr+0x868>)
    9c86:	6018      	str	r0, [r3, #0]
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    9c88:	e9c3 4001 	strd	r4, r0, [r3, #4]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    9c8c:	482e      	ldr	r0, [pc, #184]	; (9d48 <usb_isr+0x86c>)
		table[index( 0, TX, ODD ) ].desc = 0;
    9c8e:	619a      	str	r2, [r3, #24]
		table[index( 0, TX, EVEN ) ].desc = 0;
    9c90:	e9c3 0203 	strd	r0, r2, [r3, #12]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9c94:	4b2d      	ldr	r3, [pc, #180]	; (9d4c <usb_isr+0x870>)
    9c96:	200d      	movs	r0, #13
    9c98:	7018      	strb	r0, [r3, #0]
		USB0_ERRSTAT = 0xFF;
    9c9a:	482d      	ldr	r0, [pc, #180]	; (9d50 <usb_isr+0x874>)
    9c9c:	23ff      	movs	r3, #255	; 0xff
    9c9e:	7003      	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9ca0:	7033      	strb	r3, [r6, #0]
		USB0_ADDR = 0;
    9ca2:	7402      	strb	r2, [r0, #16]
		USB0_ERREN = 0xFF;
    9ca4:	4a2b      	ldr	r2, [pc, #172]	; (9d54 <usb_isr+0x878>)
    9ca6:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9ca8:	4b2b      	ldr	r3, [pc, #172]	; (9d58 <usb_isr+0x87c>)
    9caa:	22bf      	movs	r2, #191	; 0xbf
    9cac:	701a      	strb	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN;
    9cae:	2301      	movs	r3, #1
    9cb0:	700b      	strb	r3, [r1, #0]
}
    9cb2:	b003      	add	sp, #12
    9cb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ( (status & USB_ISTAT_STALL /* 80 */ ) )
    9cb8:	0620      	lsls	r0, r4, #24
    9cba:	d504      	bpl.n	9cc6 <usb_isr+0x7ea>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9cbc:	4b23      	ldr	r3, [pc, #140]	; (9d4c <usb_isr+0x870>)
    9cbe:	220d      	movs	r2, #13
    9cc0:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9cc2:	2380      	movs	r3, #128	; 0x80
    9cc4:	7033      	strb	r3, [r6, #0]
	if ( (status & USB_ISTAT_ERROR /* 02 */ ) )
    9cc6:	07a1      	lsls	r1, r4, #30
    9cc8:	d505      	bpl.n	9cd6 <usb_isr+0x7fa>
		uint8_t err = USB0_ERRSTAT;
    9cca:	4a21      	ldr	r2, [pc, #132]	; (9d50 <usb_isr+0x874>)
    9ccc:	7813      	ldrb	r3, [r2, #0]
    9cce:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9cd0:	7013      	strb	r3, [r2, #0]
		USB0_ISTAT = USB_ISTAT_ERROR;
    9cd2:	2302      	movs	r3, #2
    9cd4:	7033      	strb	r3, [r6, #0]
	if ( (status & USB_ISTAT_SLEEP /* 10 */ ) )
    9cd6:	06e2      	lsls	r2, r4, #27
    9cd8:	d509      	bpl.n	9cee <usb_isr+0x812>
		Output_update_usb_current( 100 ); // Set to 100 mA
    9cda:	2064      	movs	r0, #100	; 0x64
    9cdc:	f7fe fefc 	bl	8ad8 <Output_update_usb_current>
		usb_dev_sleep = 1;
    9ce0:	4b1e      	ldr	r3, [pc, #120]	; (9d5c <usb_isr+0x880>)
    9ce2:	2201      	movs	r2, #1
    9ce4:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_SLEEP;
    9ce6:	7833      	ldrb	r3, [r6, #0]
    9ce8:	f043 0310 	orr.w	r3, r3, #16
    9cec:	7033      	strb	r3, [r6, #0]
	if ( (status & USB_ISTAT_RESUME /* 20 */ ) )
    9cee:	06a3      	lsls	r3, r4, #26
    9cf0:	d5df      	bpl.n	9cb2 <usb_isr+0x7d6>
		Output_update_usb_current( *usb_bMaxPower * 2 );
    9cf2:	4b1b      	ldr	r3, [pc, #108]	; (9d60 <usb_isr+0x884>)
    9cf4:	681b      	ldr	r3, [r3, #0]
    9cf6:	7818      	ldrb	r0, [r3, #0]
    9cf8:	0040      	lsls	r0, r0, #1
    9cfa:	f7fe feed 	bl	8ad8 <Output_update_usb_current>
		usb_dev_sleep = 0;
    9cfe:	4b17      	ldr	r3, [pc, #92]	; (9d5c <usb_isr+0x880>)
    9d00:	2200      	movs	r2, #0
    9d02:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_RESUME;
    9d04:	7833      	ldrb	r3, [r6, #0]
    9d06:	f043 0320 	orr.w	r3, r3, #32
    9d0a:	7033      	strb	r3, [r6, #0]
    9d0c:	e7d1      	b.n	9cb2 <usb_isr+0x7d6>
    9d0e:	bf00      	nop
    9d10:	1fff94e4 	.word	0x1fff94e4
    9d14:	40072098 	.word	0x40072098
    9d18:	1fff94ec 	.word	0x1fff94ec
    9d1c:	1fff953c 	.word	0x1fff953c
    9d20:	1fff9494 	.word	0x1fff9494
    9d24:	1fff94bc 	.word	0x1fff94bc
    9d28:	1fffae18 	.word	0x1fffae18
    9d2c:	004000c8 	.word	0x004000c8
    9d30:	00400088 	.word	0x00400088
    9d34:	1fff9549 	.word	0x1fff9549
    9d38:	40072094 	.word	0x40072094
    9d3c:	1fff93fc 	.word	0x1fff93fc
    9d40:	1fff947c 	.word	0x1fff947c
    9d44:	1fff8000 	.word	0x1fff8000
    9d48:	1fff943c 	.word	0x1fff943c
    9d4c:	400720c0 	.word	0x400720c0
    9d50:	40072088 	.word	0x40072088
    9d54:	4007208c 	.word	0x4007208c
    9d58:	40072084 	.word	0x40072084
    9d5c:	1fff9547 	.word	0x1fff9547
    9d60:	1fff8f10 	.word	0x1fff8f10
    9d64:	1fff9480 	.word	0x1fff9480
    9d68:	1fff947e 	.word	0x1fff947e

00009d6c <usb_init>:
	USBInit_TimeStart = systick_millis_count;
    9d6c:	4b33      	ldr	r3, [pc, #204]	; (9e3c <usb_init+0xd0>)
    9d6e:	681a      	ldr	r2, [r3, #0]
    9d70:	4b33      	ldr	r3, [pc, #204]	; (9e40 <usb_init+0xd4>)
{
    9d72:	b510      	push	{r4, lr}
	USBInit_TimeStart = systick_millis_count;
    9d74:	601a      	str	r2, [r3, #0]
	USBInit_Ticks = 0;
    9d76:	4b33      	ldr	r3, [pc, #204]	; (9e44 <usb_init+0xd8>)
    9d78:	2400      	movs	r4, #0
    9d7a:	801c      	strh	r4, [r3, #0]
	usb_set_config_descriptor_size();
    9d7c:	f7ff fa76 	bl	926c <usb_set_config_descriptor_size>
	hex32ToStr16( SIM_UIDH,  &(usb_string_serial_number_default.wString[0]), 8 );
    9d80:	4b31      	ldr	r3, [pc, #196]	; (9e48 <usb_init+0xdc>)
    9d82:	4932      	ldr	r1, [pc, #200]	; (9e4c <usb_init+0xe0>)
    9d84:	6818      	ldr	r0, [r3, #0]
    9d86:	2208      	movs	r2, #8
    9d88:	f001 fc25 	bl	b5d6 <hex32ToStr16>
	hex32ToStr16( SIM_UIDMH, &(usb_string_serial_number_default.wString[8]), 8 );
    9d8c:	4b30      	ldr	r3, [pc, #192]	; (9e50 <usb_init+0xe4>)
    9d8e:	4931      	ldr	r1, [pc, #196]	; (9e54 <usb_init+0xe8>)
    9d90:	6818      	ldr	r0, [r3, #0]
    9d92:	2208      	movs	r2, #8
    9d94:	f001 fc1f 	bl	b5d6 <hex32ToStr16>
	hex32ToStr16( SIM_UIDML, &(usb_string_serial_number_default.wString[16]), 8 );
    9d98:	4b2f      	ldr	r3, [pc, #188]	; (9e58 <usb_init+0xec>)
    9d9a:	4930      	ldr	r1, [pc, #192]	; (9e5c <usb_init+0xf0>)
    9d9c:	6818      	ldr	r0, [r3, #0]
    9d9e:	2208      	movs	r2, #8
    9da0:	f001 fc19 	bl	b5d6 <hex32ToStr16>
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    9da4:	4b2e      	ldr	r3, [pc, #184]	; (9e60 <usb_init+0xf4>)
    9da6:	492f      	ldr	r1, [pc, #188]	; (9e64 <usb_init+0xf8>)
    9da8:	6818      	ldr	r0, [r3, #0]
    9daa:	2208      	movs	r2, #8
    9dac:	f001 fc13 	bl	b5d6 <hex32ToStr16>
		table[i].desc = 0;
    9db0:	492d      	ldr	r1, [pc, #180]	; (9e68 <usb_init+0xfc>)
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    9db2:	4623      	mov	r3, r4
		table[i].desc = 0;
    9db4:	4620      	mov	r0, r4
    9db6:	460a      	mov	r2, r1
    9db8:	5058      	str	r0, [r3, r1]
		table[i].addr = 0;
    9dba:	18cc      	adds	r4, r1, r3
    9dbc:	3308      	adds	r3, #8
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    9dbe:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
		table[i].addr = 0;
    9dc2:	6060      	str	r0, [r4, #4]
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    9dc4:	d1f8      	bne.n	9db8 <usb_init+0x4c>
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9dc6:	4929      	ldr	r1, [pc, #164]	; (9e6c <usb_init+0x100>)
    9dc8:	680b      	ldr	r3, [r1, #0]
    9dca:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    9dce:	600b      	str	r3, [r1, #0]
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
    9dd0:	4b27      	ldr	r3, [pc, #156]	; (9e70 <usb_init+0x104>)
    9dd2:	2180      	movs	r1, #128	; 0x80
    9dd4:	7019      	strb	r1, [r3, #0]
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end
    9dd6:	7819      	ldrb	r1, [r3, #0]
    9dd8:	0608      	lsls	r0, r1, #24
    9dda:	d4fc      	bmi.n	9dd6 <usb_init+0x6a>
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9ddc:	4925      	ldr	r1, [pc, #148]	; (9e74 <usb_init+0x108>)
    9dde:	f3c2 2007 	ubfx	r0, r2, #8, #8
    9de2:	7008      	strb	r0, [r1, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9de4:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9de8:	0e12      	lsrs	r2, r2, #24
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9dea:	7508      	strb	r0, [r1, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9dec:	760a      	strb	r2, [r1, #24]
	USB0_ISTAT = 0xFF;
    9dee:	22ff      	movs	r2, #255	; 0xff
    9df0:	f801 2c1c 	strb.w	r2, [r1, #-28]
	USB0_ERRSTAT = 0xFF;
    9df4:	f801 2c14 	strb.w	r2, [r1, #-20]
	USB0_OTGISTAT = 0xFF;
    9df8:	f801 2c8c 	strb.w	r2, [r1, #-140]
	USB0_USBTRC0 |= 0x40; // undocumented bit
    9dfc:	781a      	ldrb	r2, [r3, #0]
    9dfe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    9e02:	701a      	strb	r2, [r3, #0]
	USB0_CTL = USB_CTL_USBENSOFEN;
    9e04:	4b1c      	ldr	r3, [pc, #112]	; (9e78 <usb_init+0x10c>)
	USB0_USBCTRL = 0;
    9e06:	4a1d      	ldr	r2, [pc, #116]	; (9e7c <usb_init+0x110>)
	USB0_CTL = USB_CTL_USBENSOFEN;
    9e08:	2001      	movs	r0, #1
    9e0a:	7018      	strb	r0, [r3, #0]
	USB0_USBCTRL = 0;
    9e0c:	2300      	movs	r3, #0
    9e0e:	7013      	strb	r3, [r2, #0]
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9e10:	f802 0c7c 	strb.w	r0, [r2, #-124]
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    9e14:	4a1a      	ldr	r2, [pc, #104]	; (9e80 <usb_init+0x114>)
    9e16:	2170      	movs	r1, #112	; 0x70
    9e18:	7011      	strb	r1, [r2, #0]
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    9e1a:	f46f 7150 	mvn.w	r1, #832	; 0x340
    9e1e:	440a      	add	r2, r1
    9e20:	f44f 7100 	mov.w	r1, #512	; 0x200
    9e24:	6011      	str	r1, [r2, #0]
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9e26:	f102 42c0 	add.w	r2, r2, #1610612736	; 0x60000000
    9e2a:	f502 22c8 	add.w	r2, r2, #409600	; 0x64000
    9e2e:	2110      	movs	r1, #16
    9e30:	7011      	strb	r1, [r2, #0]
	power_neg_delay = 0;
    9e32:	4a14      	ldr	r2, [pc, #80]	; (9e84 <usb_init+0x118>)
    9e34:	7013      	strb	r3, [r2, #0]
	usb_dev_sleep = 0;
    9e36:	4a14      	ldr	r2, [pc, #80]	; (9e88 <usb_init+0x11c>)
    9e38:	7013      	strb	r3, [r2, #0]
}
    9e3a:	bd10      	pop	{r4, pc}
    9e3c:	1fff9158 	.word	0x1fff9158
    9e40:	1fffae14 	.word	0x1fffae14
    9e44:	1fffadc8 	.word	0x1fffadc8
    9e48:	40048054 	.word	0x40048054
    9e4c:	1fff9076 	.word	0x1fff9076
    9e50:	40048058 	.word	0x40048058
    9e54:	1fff9086 	.word	0x1fff9086
    9e58:	4004805c 	.word	0x4004805c
    9e5c:	1fff9096 	.word	0x1fff9096
    9e60:	40048060 	.word	0x40048060
    9e64:	1fff90a6 	.word	0x1fff90a6
    9e68:	1fff8000 	.word	0x1fff8000
    9e6c:	40048034 	.word	0x40048034
    9e70:	4007210c 	.word	0x4007210c
    9e74:	4007209c 	.word	0x4007209c
    9e78:	40072094 	.word	0x40072094
    9e7c:	40072100 	.word	0x40072100
    9e80:	e000e449 	.word	0xe000e449
    9e84:	1fff9484 	.word	0x1fff9484
    9e88:	1fff9547 	.word	0x1fff9547

00009e8c <usb_keyboard_send>:
}


// Send the contents of keyboard_keys and keyboard_modifier_keys
void usb_keyboard_send( USBKeys *buffer, uint8_t protocol )
{
    9e8c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	Time start = Time_now();
    9e90:	46e8      	mov	r8, sp
{
    9e92:	4604      	mov	r4, r0
	Time start = Time_now();
    9e94:	4640      	mov	r0, r8
{
    9e96:	460e      	mov	r6, r1
	Time start = Time_now();
    9e98:	f7f8 fd62 	bl	2960 <Time_now>
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    9e9c:	f8df 92dc 	ldr.w	r9, [pc, #732]	; a17c <usb_keyboard_send+0x2f0>
    9ea0:	4fa9      	ldr	r7, [pc, #676]	; (a148 <usb_keyboard_send+0x2bc>)
    9ea2:	f899 3000 	ldrb.w	r3, [r9]
    9ea6:	b92b      	cbnz	r3, 9eb4 <usb_keyboard_send+0x28>
		{
			erro_print("USB not configured...");
    9ea8:	48a8      	ldr	r0, [pc, #672]	; (a14c <usb_keyboard_send+0x2c0>)

		break;
	}

	return;
}
    9eaa:	b002      	add	sp, #8
    9eac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			warn_print("USB Transmit Timeout...auto-restart disabled");
    9eb0:	f001 baa6 	b.w	b400 <_print>
		if ( usb_resume() )
    9eb4:	f7ff fa84 	bl	93c0 <usb_resume>
    9eb8:	b108      	cbz	r0, 9ebe <usb_keyboard_send+0x32>
			buffer->changed = USBKeyChangeState_None; // Mark sent
    9eba:	2300      	movs	r3, #0
    9ebc:	e045      	b.n	9f4a <usb_keyboard_send+0xbe>
		if ( protocol == 0 ) // Boot Mode
    9ebe:	b98e      	cbnz	r6, 9ee4 <usb_keyboard_send+0x58>
			if ( usb_tx_packet_count( KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    9ec0:	2001      	movs	r0, #1
    9ec2:	f7ff fa2f 	bl	9324 <usb_tx_packet_count>
    9ec6:	2803      	cmp	r0, #3
    9ec8:	d917      	bls.n	9efa <usb_keyboard_send+0x6e>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    9eca:	e898 0003 	ldmia.w	r8, {r0, r1}
    9ece:	f7f8 fdb1 	bl	2a34 <Time_duration_ms>
    9ed2:	2832      	cmp	r0, #50	; 0x32
    9ed4:	d93c      	bls.n	9f50 <usb_keyboard_send+0xc4>
			transmit_previous_timeout = 1;
    9ed6:	2301      	movs	r3, #1
    9ed8:	703b      	strb	r3, [r7, #0]
			buffer->changed = USBKeyChangeState_None; // Indicate packet lost
    9eda:	2300      	movs	r3, #0
    9edc:	f884 3020 	strb.w	r3, [r4, #32]
			warn_print("USB Transmit Timeout...auto-restart disabled");
    9ee0:	489b      	ldr	r0, [pc, #620]	; (a150 <usb_keyboard_send+0x2c4>)
    9ee2:	e7e2      	b.n	9eaa <usb_keyboard_send+0x1e>
		else if ( protocol == 1 ) // NKRO Mode
    9ee4:	2e01      	cmp	r6, #1
    9ee6:	d101      	bne.n	9eec <usb_keyboard_send+0x60>
			if ( usb_tx_packet_count( NKRO_KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    9ee8:	2002      	movs	r0, #2
    9eea:	e7ea      	b.n	9ec2 <usb_keyboard_send+0x36>
		else if ( buffer->changed &
    9eec:	f894 3020 	ldrb.w	r3, [r4, #32]
    9ef0:	f013 0f60 	tst.w	r3, #96	; 0x60
    9ef4:	d0e9      	beq.n	9eca <usb_keyboard_send+0x3e>
			if ( usb_tx_packet_count( SYS_CTRL_ENDPOINT ) < TX_PACKET_LIMIT )
    9ef6:	2003      	movs	r0, #3
    9ef8:	e7e3      	b.n	9ec2 <usb_keyboard_send+0x36>
				tx_packet = usb_malloc();
    9efa:	f000 f979 	bl	a1f0 <usb_malloc>
				if ( tx_packet )
    9efe:	4605      	mov	r5, r0
    9f00:	2800      	cmp	r0, #0
    9f02:	d0e2      	beq.n	9eca <usb_keyboard_send+0x3e>
	transmit_previous_timeout = 0;
    9f04:	2300      	movs	r3, #0
    9f06:	703b      	strb	r3, [r7, #0]
	if ( buffer->changed & USBKeyChangeState_System )
    9f08:	f894 3020 	ldrb.w	r3, [r4, #32]
    9f0c:	069a      	lsls	r2, r3, #26
    9f0e:	d525      	bpl.n	9f5c <usb_keyboard_send+0xd0>
		if ( Output_DebugMode )
    9f10:	4b90      	ldr	r3, [pc, #576]	; (a154 <usb_keyboard_send+0x2c8>)
    9f12:	781b      	ldrb	r3, [r3, #0]
    9f14:	b14b      	cbz	r3, 9f2a <usb_keyboard_send+0x9e>
			print("SysCtrl[");
    9f16:	4890      	ldr	r0, [pc, #576]	; (a158 <usb_keyboard_send+0x2cc>)
    9f18:	f001 fa72 	bl	b400 <_print>
			printHex_op( buffer->sys_ctrl, 2 );
    9f1c:	7f20      	ldrb	r0, [r4, #28]
    9f1e:	2102      	movs	r1, #2
    9f20:	f001 fb16 	bl	b550 <printHex_op>
			print( "] " NL );
    9f24:	488d      	ldr	r0, [pc, #564]	; (a15c <usb_keyboard_send+0x2d0>)
    9f26:	f001 fa6b 	bl	b400 <_print>
		USBKeys_idle.sys_ctrl = buffer->sys_ctrl;
    9f2a:	4b8d      	ldr	r3, [pc, #564]	; (a160 <usb_keyboard_send+0x2d4>)
    9f2c:	7f22      	ldrb	r2, [r4, #28]
    9f2e:	771a      	strb	r2, [r3, #28]
		*tx_buf++ = 0x02; // ID
    9f30:	2302      	movs	r3, #2
    9f32:	722b      	strb	r3, [r5, #8]
		*tx_buf   = buffer->sys_ctrl;
    9f34:	7f22      	ldrb	r2, [r4, #28]
    9f36:	726a      	strb	r2, [r5, #9]
		tx_packet->len = 2;
    9f38:	802b      	strh	r3, [r5, #0]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    9f3a:	4629      	mov	r1, r5
    9f3c:	2003      	movs	r0, #3
    9f3e:	f7ff fa61 	bl	9404 <usb_tx>
		buffer->changed &= ~USBKeyChangeState_System; // Mark sent
    9f42:	f894 3020 	ldrb.w	r3, [r4, #32]
    9f46:	f023 0320 	bic.w	r3, r3, #32
			buffer->changed = USBKeyChangeState_None; // Mark sent
    9f4a:	f884 3020 	strb.w	r3, [r4, #32]
    9f4e:	e02a      	b.n	9fa6 <usb_keyboard_send+0x11a>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    9f50:	783b      	ldrb	r3, [r7, #0]
    9f52:	2b00      	cmp	r3, #0
    9f54:	d1bf      	bne.n	9ed6 <usb_keyboard_send+0x4a>
		yield();
    9f56:	f7f8 fba9 	bl	26ac <yield>
		if ( !usb_configuration )
    9f5a:	e7a2      	b.n	9ea2 <usb_keyboard_send+0x16>
	if ( buffer->changed & USBKeyChangeState_Consumer )
    9f5c:	065b      	lsls	r3, r3, #25
    9f5e:	d51f      	bpl.n	9fa0 <usb_keyboard_send+0x114>
		if ( Output_DebugMode )
    9f60:	4b7c      	ldr	r3, [pc, #496]	; (a154 <usb_keyboard_send+0x2c8>)
    9f62:	781b      	ldrb	r3, [r3, #0]
    9f64:	b14b      	cbz	r3, 9f7a <usb_keyboard_send+0xee>
			print("ConsCtrl[");
    9f66:	487f      	ldr	r0, [pc, #508]	; (a164 <usb_keyboard_send+0x2d8>)
    9f68:	f001 fa4a 	bl	b400 <_print>
			printHex_op( buffer->cons_ctrl, 2 );
    9f6c:	8be0      	ldrh	r0, [r4, #30]
    9f6e:	2102      	movs	r1, #2
    9f70:	f001 faee 	bl	b550 <printHex_op>
			print( "] " NL );
    9f74:	4879      	ldr	r0, [pc, #484]	; (a15c <usb_keyboard_send+0x2d0>)
    9f76:	f001 fa43 	bl	b400 <_print>
		USBKeys_idle.cons_ctrl = buffer->cons_ctrl;
    9f7a:	4b79      	ldr	r3, [pc, #484]	; (a160 <usb_keyboard_send+0x2d4>)
    9f7c:	8be2      	ldrh	r2, [r4, #30]
    9f7e:	83da      	strh	r2, [r3, #30]
		*tx_buf++ = 0x03; // ID
    9f80:	2003      	movs	r0, #3
    9f82:	7228      	strb	r0, [r5, #8]
		*tx_buf++ = (uint8_t)(buffer->cons_ctrl & 0x00FF);
    9f84:	8be3      	ldrh	r3, [r4, #30]
    9f86:	726b      	strb	r3, [r5, #9]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    9f88:	8be3      	ldrh	r3, [r4, #30]
		tx_packet->len = 3;
    9f8a:	8028      	strh	r0, [r5, #0]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    9f8c:	0a1b      	lsrs	r3, r3, #8
    9f8e:	72ab      	strb	r3, [r5, #10]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    9f90:	4629      	mov	r1, r5
    9f92:	f7ff fa37 	bl	9404 <usb_tx>
		buffer->changed &= ~USBKeyChangeState_Consumer; // Mark sent
    9f96:	f894 3020 	ldrb.w	r3, [r4, #32]
    9f9a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    9f9e:	e7d4      	b.n	9f4a <usb_keyboard_send+0xbe>
	switch ( protocol )
    9fa0:	b126      	cbz	r6, 9fac <usb_keyboard_send+0x120>
    9fa2:	2e01      	cmp	r6, #1
    9fa4:	d04e      	beq.n	a044 <usb_keyboard_send+0x1b8>
}
    9fa6:	b002      	add	sp, #8
    9fa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ( Output_DebugMode )
    9fac:	4b69      	ldr	r3, [pc, #420]	; (a154 <usb_keyboard_send+0x2c8>)
    9fae:	781b      	ldrb	r3, [r3, #0]
    9fb0:	b35b      	cbz	r3, a00a <usb_keyboard_send+0x17e>
			dbug_msg("Boot USB: ");
    9fb2:	486d      	ldr	r0, [pc, #436]	; (a168 <usb_keyboard_send+0x2dc>)
    9fb4:	f001 fa24 	bl	b400 <_print>
			printHex_op( buffer->modifiers, 2 );
    9fb8:	2102      	movs	r1, #2
    9fba:	7820      	ldrb	r0, [r4, #0]
    9fbc:	f001 fac8 	bl	b550 <printHex_op>
			print(" ");
    9fc0:	486a      	ldr	r0, [pc, #424]	; (a16c <usb_keyboard_send+0x2e0>)
    9fc2:	f001 fa1d 	bl	b400 <_print>
			printHex( 0 );
    9fc6:	2101      	movs	r1, #1
    9fc8:	4630      	mov	r0, r6
    9fca:	f001 fac1 	bl	b550 <printHex_op>
			print(" ");
    9fce:	4867      	ldr	r0, [pc, #412]	; (a16c <usb_keyboard_send+0x2e0>)
    9fd0:	f001 fa16 	bl	b400 <_print>
			printHex_op( buffer->keys[0], 2 );
    9fd4:	2102      	movs	r1, #2
    9fd6:	7860      	ldrb	r0, [r4, #1]
    9fd8:	f001 faba 	bl	b550 <printHex_op>
			printHex_op( buffer->keys[1], 2 );
    9fdc:	2102      	movs	r1, #2
    9fde:	78a0      	ldrb	r0, [r4, #2]
    9fe0:	f001 fab6 	bl	b550 <printHex_op>
			printHex_op( buffer->keys[2], 2 );
    9fe4:	2102      	movs	r1, #2
    9fe6:	78e0      	ldrb	r0, [r4, #3]
    9fe8:	f001 fab2 	bl	b550 <printHex_op>
			printHex_op( buffer->keys[3], 2 );
    9fec:	2102      	movs	r1, #2
    9fee:	7920      	ldrb	r0, [r4, #4]
    9ff0:	f001 faae 	bl	b550 <printHex_op>
			printHex_op( buffer->keys[4], 2 );
    9ff4:	2102      	movs	r1, #2
    9ff6:	7960      	ldrb	r0, [r4, #5]
    9ff8:	f001 faaa 	bl	b550 <printHex_op>
			printHex_op( buffer->keys[5], 2 );
    9ffc:	79a0      	ldrb	r0, [r4, #6]
    9ffe:	2102      	movs	r1, #2
    a000:	f001 faa6 	bl	b550 <printHex_op>
			print( NL );
    a004:	485a      	ldr	r0, [pc, #360]	; (a170 <usb_keyboard_send+0x2e4>)
    a006:	f001 f9fb 	bl	b400 <_print>
		memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_BOOT_MAX_KEYS );
    a00a:	4e5a      	ldr	r6, [pc, #360]	; (a174 <usb_keyboard_send+0x2e8>)
    a00c:	1c67      	adds	r7, r4, #1
    a00e:	2206      	movs	r2, #6
    a010:	4639      	mov	r1, r7
    a012:	4630      	mov	r0, r6
    a014:	f7f8 fb1c 	bl	2650 <memcpy>
		USBKeys_idle.modifiers = buffer->modifiers;
    a018:	7823      	ldrb	r3, [r4, #0]
    a01a:	f806 3c01 	strb.w	r3, [r6, #-1]
		*tx_buf++ = buffer->modifiers;
    a01e:	7823      	ldrb	r3, [r4, #0]
    a020:	722b      	strb	r3, [r5, #8]
		*tx_buf++ = 0;
    a022:	2600      	movs	r6, #0
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    a024:	2206      	movs	r2, #6
    a026:	4639      	mov	r1, r7
		*tx_buf++ = 0;
    a028:	726e      	strb	r6, [r5, #9]
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    a02a:	f105 000a 	add.w	r0, r5, #10
    a02e:	f7f8 fb0f 	bl	2650 <memcpy>
		tx_packet->len = 8;
    a032:	2308      	movs	r3, #8
    a034:	802b      	strh	r3, [r5, #0]
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    a036:	4629      	mov	r1, r5
    a038:	2001      	movs	r0, #1
    a03a:	f7ff f9e3 	bl	9404 <usb_tx>
		buffer->changed = USBKeyChangeState_None;
    a03e:	f884 6020 	strb.w	r6, [r4, #32]
		break;
    a042:	e7b0      	b.n	9fa6 <usb_keyboard_send+0x11a>
		if ( Output_DebugMode )
    a044:	4e43      	ldr	r6, [pc, #268]	; (a154 <usb_keyboard_send+0x2c8>)
    a046:	7832      	ldrb	r2, [r6, #0]
    a048:	b112      	cbz	r2, a050 <usb_keyboard_send+0x1c4>
			dbug_msg("NKRO USB: ");
    a04a:	484b      	ldr	r0, [pc, #300]	; (a178 <usb_keyboard_send+0x2ec>)
    a04c:	f001 f9d8 	bl	b400 <_print>
		if ( buffer->changed )
    a050:	f894 3020 	ldrb.w	r3, [r4, #32]
    a054:	2b00      	cmp	r3, #0
    a056:	d0a6      	beq.n	9fa6 <usb_keyboard_send+0x11a>
			if ( Output_DebugMode )
    a058:	7833      	ldrb	r3, [r6, #0]
    a05a:	f104 0a01 	add.w	sl, r4, #1
    a05e:	f104 0907 	add.w	r9, r4, #7
    a062:	b39b      	cbz	r3, a0cc <usb_keyboard_send+0x240>
				printHex_op( buffer->modifiers, 2 );
    a064:	2102      	movs	r1, #2
    a066:	7820      	ldrb	r0, [r4, #0]
    a068:	f001 fa72 	bl	b550 <printHex_op>
				print(" ");
    a06c:	483f      	ldr	r0, [pc, #252]	; (a16c <usb_keyboard_send+0x2e0>)
    a06e:	f001 f9c7 	bl	b400 <_print>
    a072:	4656      	mov	r6, sl
					printHex_op( buffer->keys[ c ], 2 );
    a074:	f816 0b01 	ldrb.w	r0, [r6], #1
    a078:	2102      	movs	r1, #2
    a07a:	f001 fa69 	bl	b550 <printHex_op>
				for ( uint8_t c = 0; c < 6; c++ )
    a07e:	454e      	cmp	r6, r9
    a080:	d1f8      	bne.n	a074 <usb_keyboard_send+0x1e8>
				print(" ");
    a082:	483a      	ldr	r0, [pc, #232]	; (a16c <usb_keyboard_send+0x2e0>)
    a084:	f001 f9bc 	bl	b400 <_print>
    a088:	464e      	mov	r6, r9
    a08a:	f104 0715 	add.w	r7, r4, #21
					printHex_op( buffer->keys[ c ], 2 );
    a08e:	f816 0b01 	ldrb.w	r0, [r6], #1
    a092:	2102      	movs	r1, #2
    a094:	f001 fa5c 	bl	b550 <printHex_op>
				for ( uint8_t c = 6; c < 20; c++ )
    a098:	42be      	cmp	r6, r7
    a09a:	d1f8      	bne.n	a08e <usb_keyboard_send+0x202>
				print(" ");
    a09c:	4833      	ldr	r0, [pc, #204]	; (a16c <usb_keyboard_send+0x2e0>)
    a09e:	f001 f9af 	bl	b400 <_print>
				printHex_op( buffer->keys[20], 2 );
    a0a2:	2102      	movs	r1, #2
    a0a4:	7d60      	ldrb	r0, [r4, #21]
    a0a6:	f001 fa53 	bl	b550 <printHex_op>
				print(" ");
    a0aa:	4830      	ldr	r0, [pc, #192]	; (a16c <usb_keyboard_send+0x2e0>)
    a0ac:	f001 f9a8 	bl	b400 <_print>
    a0b0:	f104 0616 	add.w	r6, r4, #22
    a0b4:	f104 071c 	add.w	r7, r4, #28
					printHex_op( buffer->keys[ c ], 2 );
    a0b8:	f816 0b01 	ldrb.w	r0, [r6], #1
    a0bc:	2102      	movs	r1, #2
    a0be:	f001 fa47 	bl	b550 <printHex_op>
				for ( uint8_t c = 21; c < 27; c++ )
    a0c2:	42b7      	cmp	r7, r6
    a0c4:	d1f8      	bne.n	a0b8 <usb_keyboard_send+0x22c>
				print( NL );
    a0c6:	482a      	ldr	r0, [pc, #168]	; (a170 <usb_keyboard_send+0x2e4>)
    a0c8:	f001 f99a 	bl	b400 <_print>
			memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_NKRO_BITFIELD_SIZE_KEYS );
    a0cc:	4e29      	ldr	r6, [pc, #164]	; (a174 <usb_keyboard_send+0x2e8>)
    a0ce:	4651      	mov	r1, sl
    a0d0:	221b      	movs	r2, #27
    a0d2:	4630      	mov	r0, r6
    a0d4:	f7f8 fabc 	bl	2650 <memcpy>
			*tx_buf++ = 0x01; // ID
    a0d8:	f04f 0801 	mov.w	r8, #1
			USBKeys_idle.modifiers = buffer->modifiers;
    a0dc:	7823      	ldrb	r3, [r4, #0]
    a0de:	f806 3c01 	strb.w	r3, [r6, #-1]
			*tx_buf++ = buffer->modifiers;
    a0e2:	4627      	mov	r7, r4
			*tx_buf++ = 0x01; // ID
    a0e4:	f885 8008 	strb.w	r8, [r5, #8]
			tx_packet->len += 2;
    a0e8:	4628      	mov	r0, r5
			*tx_buf++ = buffer->modifiers;
    a0ea:	f817 3b15 	ldrb.w	r3, [r7], #21
    a0ee:	726b      	strb	r3, [r5, #9]
			tx_packet->len += 2;
    a0f0:	2602      	movs	r6, #2
			memcpy( tx_buf, buffer->keys, 6 );
    a0f2:	4651      	mov	r1, sl
			tx_packet->len += 2;
    a0f4:	f820 6b0a 	strh.w	r6, [r0], #10
			memcpy( tx_buf, buffer->keys, 6 );
    a0f8:	2206      	movs	r2, #6
    a0fa:	f7f8 faa9 	bl	2650 <memcpy>
			tx_packet->len += 6;
    a0fe:	882b      	ldrh	r3, [r5, #0]
    a100:	4628      	mov	r0, r5
    a102:	3306      	adds	r3, #6
			memcpy( tx_buf, buffer->keys + 6, 14 );
    a104:	4649      	mov	r1, r9
			tx_packet->len += 6;
    a106:	f820 3b10 	strh.w	r3, [r0], #16
			memcpy( tx_buf, buffer->keys + 6, 14 );
    a10a:	220e      	movs	r2, #14
    a10c:	f7f8 faa0 	bl	2650 <memcpy>
			tx_packet->len += 14;
    a110:	882b      	ldrh	r3, [r5, #0]
    a112:	4628      	mov	r0, r5
    a114:	330e      	adds	r3, #14
			memcpy( tx_buf, buffer->keys + 20, 1 );
    a116:	4642      	mov	r2, r8
    a118:	4639      	mov	r1, r7
			tx_packet->len += 14;
    a11a:	f820 3b1e 	strh.w	r3, [r0], #30
			memcpy( tx_buf, buffer->keys + 20, 1 );
    a11e:	f7f8 fa97 	bl	2650 <memcpy>
			tx_packet->len += 1;
    a122:	882b      	ldrh	r3, [r5, #0]
    a124:	4628      	mov	r0, r5
    a126:	4443      	add	r3, r8
			memcpy( tx_buf, buffer->keys + 21, 6 );
    a128:	f104 0116 	add.w	r1, r4, #22
			tx_packet->len += 1;
    a12c:	f820 3b1f 	strh.w	r3, [r0], #31
			memcpy( tx_buf, buffer->keys + 21, 6 );
    a130:	2206      	movs	r2, #6
    a132:	f7f8 fa8d 	bl	2650 <memcpy>
			tx_packet->len += 6;
    a136:	882b      	ldrh	r3, [r5, #0]
    a138:	3306      	adds	r3, #6
    a13a:	802b      	strh	r3, [r5, #0]
			usb_tx( NKRO_KEYBOARD_ENDPOINT, tx_packet );
    a13c:	4629      	mov	r1, r5
    a13e:	4630      	mov	r0, r6
    a140:	f7ff f960 	bl	9404 <usb_tx>
    a144:	e6b9      	b.n	9eba <usb_keyboard_send+0x2e>
    a146:	bf00      	nop
    a148:	1fff954a 	.word	0x1fff954a
    a14c:	00010d1d 	.word	0x00010d1d
    a150:	00010d4a 	.word	0x00010d4a
    a154:	1fffadb6 	.word	0x1fffadb6
    a158:	00010d8e 	.word	0x00010d8e
    a15c:	00010d97 	.word	0x00010d97
    a160:	1fffadca 	.word	0x1fffadca
    a164:	00010d9c 	.word	0x00010d9c
    a168:	00010da6 	.word	0x00010da6
    a16c:	00011f77 	.word	0x00011f77
    a170:	00010d99 	.word	0x00010d99
    a174:	1fffadcb 	.word	0x1fffadcb
    a178:	00010dc4 	.word	0x00010dc4
    a17c:	1fff9546 	.word	0x1fff9546

0000a180 <usb_keyboard_idle_update>:
{
    a180:	b570      	push	{r4, r5, r6, lr}
	if ( USBKeys_Idle_Config != 0 )
    a182:	4b0d      	ldr	r3, [pc, #52]	; (a1b8 <usb_keyboard_idle_update+0x38>)
    a184:	781a      	ldrb	r2, [r3, #0]
    a186:	b18a      	cbz	r2, a1ac <usb_keyboard_idle_update+0x2c>
		if ( USBKeys_Idle_Expiry + USBKeys_Idle_Config * 4 >= systick_millis_count )
    a188:	7819      	ldrb	r1, [r3, #0]
    a18a:	4b0c      	ldr	r3, [pc, #48]	; (a1bc <usb_keyboard_idle_update+0x3c>)
    a18c:	4a0c      	ldr	r2, [pc, #48]	; (a1c0 <usb_keyboard_idle_update+0x40>)
    a18e:	681b      	ldr	r3, [r3, #0]
    a190:	6812      	ldr	r2, [r2, #0]
    a192:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    a196:	4293      	cmp	r3, r2
    a198:	d308      	bcc.n	a1ac <usb_keyboard_idle_update+0x2c>
			USBKeys_idle.changed = USBKeyChangeState_All;
    a19a:	4c0a      	ldr	r4, [pc, #40]	; (a1c4 <usb_keyboard_idle_update+0x44>)
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    a19c:	4d0a      	ldr	r5, [pc, #40]	; (a1c8 <usb_keyboard_idle_update+0x48>)
			USBKeys_idle.changed = USBKeyChangeState_All;
    a19e:	237f      	movs	r3, #127	; 0x7f
    a1a0:	f884 3020 	strb.w	r3, [r4, #32]
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    a1a4:	4626      	mov	r6, r4
			while ( USBKeys_idle.changed )
    a1a6:	f894 3020 	ldrb.w	r3, [r4, #32]
    a1aa:	b903      	cbnz	r3, a1ae <usb_keyboard_idle_update+0x2e>
}
    a1ac:	bd70      	pop	{r4, r5, r6, pc}
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    a1ae:	7829      	ldrb	r1, [r5, #0]
    a1b0:	4630      	mov	r0, r6
    a1b2:	f7ff fe6b 	bl	9e8c <usb_keyboard_send>
    a1b6:	e7f6      	b.n	a1a6 <usb_keyboard_idle_update+0x26>
    a1b8:	1fff93e5 	.word	0x1fff93e5
    a1bc:	1fff93e8 	.word	0x1fff93e8
    a1c0:	1fff9158 	.word	0x1fff9158
    a1c4:	1fffadca 	.word	0x1fffadca
    a1c8:	1fff8ce8 	.word	0x1fff8ce8

0000a1cc <usb_keyboard_clear>:
{
    a1cc:	b510      	push	{r4, lr}
    a1ce:	b08a      	sub	sp, #40	; 0x28
    a1d0:	4604      	mov	r4, r0
	USBKeys buffer = {
    a1d2:	2222      	movs	r2, #34	; 0x22
    a1d4:	2100      	movs	r1, #0
    a1d6:	a801      	add	r0, sp, #4
    a1d8:	f7f8 fa32 	bl	2640 <memset>
    a1dc:	237f      	movs	r3, #127	; 0x7f
	usb_keyboard_send( &buffer, protocol );
    a1de:	4621      	mov	r1, r4
    a1e0:	a801      	add	r0, sp, #4
	USBKeys buffer = {
    a1e2:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	usb_keyboard_send( &buffer, protocol );
    a1e6:	f7ff fe51 	bl	9e8c <usb_keyboard_send>
}
    a1ea:	b00a      	add	sp, #40	; 0x28
    a1ec:	bd10      	pop	{r4, pc}
    a1ee:	0000      	movs	r0, r0

0000a1f0 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t *usb_malloc()
{
    a1f0:	b510      	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    a1f2:	b672      	cpsid	i
	avail = usb_buffer_available;
    a1f4:	480b      	ldr	r0, [pc, #44]	; (a224 <usb_malloc+0x34>)
    a1f6:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz( avail ); // clz = count leading zeros
    a1f8:	fab2 f182 	clz	r1, r2
	if ( n >= NUM_USB_BUFFERS )
    a1fc:	291d      	cmp	r1, #29
    a1fe:	dd02      	ble.n	a206 <usb_malloc+0x16>
	{
		__enable_irq();
    a200:	b662      	cpsie	i
		return NULL;
    a202:	2000      	movs	r0, #0
	__enable_irq();
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
}
    a204:	bd10      	pop	{r4, pc}
	usb_buffer_available = avail & ~(0x80000000 >> n);
    a206:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    a20a:	40cb      	lsrs	r3, r1
    a20c:	ea22 0203 	bic.w	r2, r2, r3
    a210:	6002      	str	r2, [r0, #0]
	__enable_irq();
    a212:	b662      	cpsie	i
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
    a214:	4c04      	ldr	r4, [pc, #16]	; (a228 <usb_malloc+0x38>)
    a216:	2348      	movs	r3, #72	; 0x48
    a218:	434b      	muls	r3, r1
    a21a:	18e0      	adds	r0, r4, r3
	*(uint32_t *)p = 0;
    a21c:	2200      	movs	r2, #0
    a21e:	50e2      	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    a220:	6042      	str	r2, [r0, #4]
	return (usb_packet_t *)p;
    a222:	e7ef      	b.n	a204 <usb_malloc+0x14>
    a224:	1fff90e8 	.word	0x1fff90e8
    a228:	1fff8160 	.word	0x1fff8160

0000a22c <usb_free>:

void usb_free( usb_packet_t *p )
{
	unsigned int n, mask;

	n = ( (uint8_t *)p - usb_buffer_memory ) / sizeof(usb_packet_t);
    a22c:	4b0c      	ldr	r3, [pc, #48]	; (a260 <usb_free+0x34>)
    a22e:	2248      	movs	r2, #72	; 0x48
    a230:	1ac3      	subs	r3, r0, r3
    a232:	fbb3 f3f2 	udiv	r3, r3, r2
	if ( n >= NUM_USB_BUFFERS )
    a236:	2b1d      	cmp	r3, #29
    a238:	d811      	bhi.n	a25e <usb_free+0x32>
		return;

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if ( usb_rx_memory_needed && usb_configuration )
    a23a:	4a0a      	ldr	r2, [pc, #40]	; (a264 <usb_free+0x38>)
    a23c:	7812      	ldrb	r2, [r2, #0]
    a23e:	b122      	cbz	r2, a24a <usb_free+0x1e>
    a240:	4a09      	ldr	r2, [pc, #36]	; (a268 <usb_free+0x3c>)
    a242:	7812      	ldrb	r2, [r2, #0]
    a244:	b10a      	cbz	r2, a24a <usb_free+0x1e>
	{
		usb_rx_memory( p );
    a246:	f7ff b87f 	b.w	9348 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    a24a:	b672      	cpsid	i
	usb_buffer_available |= mask;
    a24c:	4907      	ldr	r1, [pc, #28]	; (a26c <usb_free+0x40>)
	mask = (0x80000000 >> n);
    a24e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    a252:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
    a256:	680a      	ldr	r2, [r1, #0]
    a258:	431a      	orrs	r2, r3
    a25a:	600a      	str	r2, [r1, #0]
	__enable_irq();
    a25c:	b662      	cpsie	i
}
    a25e:	4770      	bx	lr
    a260:	1fff8160 	.word	0x1fff8160
    a264:	1fff9549 	.word	0x1fff9549
    a268:	1fff9546 	.word	0x1fff9546
    a26c:	1fff90e8 	.word	0x1fff90e8

0000a270 <usb_mouse_send>:
// Process pending mouse commands
// XXX Missing mouse movement and wheels
//     Proper support will require KLL generation of the USB descriptors
//     Similar support will be required for joystick control
void usb_mouse_send()
{
    a270:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	Time start = Time_now();
    a272:	466c      	mov	r4, sp
    a274:	4620      	mov	r0, r4
    a276:	f7f8 fb73 	bl	2960 <Time_now>
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    a27a:	4e23      	ldr	r6, [pc, #140]	; (a308 <usb_mouse_send+0x98>)
    a27c:	4d23      	ldr	r5, [pc, #140]	; (a30c <usb_mouse_send+0x9c>)
    a27e:	7833      	ldrb	r3, [r6, #0]
    a280:	b92b      	cbnz	r3, a28e <usb_mouse_send+0x1e>
		{
			erro_print("USB not configured...");
    a282:	4823      	ldr	r0, [pc, #140]	; (a310 <usb_mouse_send+0xa0>)
	// Clear status and state
	USBMouse_Buttons = 0;
	USBMouse_Relative_x = 0;
	USBMouse_Relative_y = 0;
	USBMouse_Changed = 0;
}
    a284:	b003      	add	sp, #12
    a286:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			erro_print("USB not configured...");
    a28a:	f001 b8b9 	b.w	b400 <_print>
		if ( usb_tx_packet_count( MOUSE_ENDPOINT ) < TX_PACKET_LIMIT )
    a28e:	2009      	movs	r0, #9
    a290:	f7ff f848 	bl	9324 <usb_tx_packet_count>
    a294:	2802      	cmp	r0, #2
    a296:	d915      	bls.n	a2c4 <usb_mouse_send+0x54>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    a298:	e894 0003 	ldmia.w	r4, {r0, r1}
    a29c:	f7f8 fbca 	bl	2a34 <Time_duration_ms>
    a2a0:	281e      	cmp	r0, #30
    a2a2:	d92a      	bls.n	a2fa <usb_mouse_send+0x8a>
			transmit_previous_timeout = 1;
    a2a4:	2301      	movs	r3, #1
			warn_print("USB Transmit Timeout...");
    a2a6:	481b      	ldr	r0, [pc, #108]	; (a314 <usb_mouse_send+0xa4>)
			transmit_previous_timeout = 1;
    a2a8:	702b      	strb	r3, [r5, #0]
			warn_print("USB Transmit Timeout...");
    a2aa:	f001 f8a9 	bl	b400 <_print>
			USBMouse_Buttons = 0;
    a2ae:	4a1a      	ldr	r2, [pc, #104]	; (a318 <usb_mouse_send+0xa8>)
    a2b0:	2300      	movs	r3, #0
    a2b2:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_x = 0;
    a2b4:	4a19      	ldr	r2, [pc, #100]	; (a31c <usb_mouse_send+0xac>)
    a2b6:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_y = 0;
    a2b8:	4a19      	ldr	r2, [pc, #100]	; (a320 <usb_mouse_send+0xb0>)
    a2ba:	8013      	strh	r3, [r2, #0]
			USBMouse_Changed = 0;
    a2bc:	4a19      	ldr	r2, [pc, #100]	; (a324 <usb_mouse_send+0xb4>)
    a2be:	7013      	strb	r3, [r2, #0]
}
    a2c0:	b003      	add	sp, #12
    a2c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
			tx_packet = usb_malloc();
    a2c4:	f7ff ff94 	bl	a1f0 <usb_malloc>
			if ( tx_packet )
    a2c8:	4601      	mov	r1, r0
    a2ca:	2800      	cmp	r0, #0
    a2cc:	d0e4      	beq.n	a298 <usb_mouse_send+0x28>
	packet_data[0] = USBMouse_Buttons;
    a2ce:	4f12      	ldr	r7, [pc, #72]	; (a318 <usb_mouse_send+0xa8>)
	packet_data[1] = USBMouse_Relative_x;
    a2d0:	4e12      	ldr	r6, [pc, #72]	; (a31c <usb_mouse_send+0xac>)
	packet_data[0] = USBMouse_Buttons;
    a2d2:	883b      	ldrh	r3, [r7, #0]
    a2d4:	8103      	strh	r3, [r0, #8]
	transmit_previous_timeout = 0;
    a2d6:	2400      	movs	r4, #0
    a2d8:	702c      	strb	r4, [r5, #0]
	packet_data[2] = USBMouse_Relative_y;
    a2da:	4d11      	ldr	r5, [pc, #68]	; (a320 <usb_mouse_send+0xb0>)
	packet_data[1] = USBMouse_Relative_x;
    a2dc:	8833      	ldrh	r3, [r6, #0]
    a2de:	8143      	strh	r3, [r0, #10]
	packet_data[2] = USBMouse_Relative_y;
    a2e0:	882b      	ldrh	r3, [r5, #0]
    a2e2:	8183      	strh	r3, [r0, #12]
	tx_packet->len = 6;
    a2e4:	2306      	movs	r3, #6
    a2e6:	8003      	strh	r3, [r0, #0]
	usb_tx( MOUSE_ENDPOINT, tx_packet );
    a2e8:	2009      	movs	r0, #9
    a2ea:	f7ff f88b 	bl	9404 <usb_tx>
	USBMouse_Changed = 0;
    a2ee:	4b0d      	ldr	r3, [pc, #52]	; (a324 <usb_mouse_send+0xb4>)
	USBMouse_Buttons = 0;
    a2f0:	803c      	strh	r4, [r7, #0]
	USBMouse_Changed = 0;
    a2f2:	701c      	strb	r4, [r3, #0]
	USBMouse_Relative_x = 0;
    a2f4:	8034      	strh	r4, [r6, #0]
	USBMouse_Relative_y = 0;
    a2f6:	802c      	strh	r4, [r5, #0]
    a2f8:	e7e2      	b.n	a2c0 <usb_mouse_send+0x50>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    a2fa:	782b      	ldrb	r3, [r5, #0]
    a2fc:	2b00      	cmp	r3, #0
    a2fe:	d1d1      	bne.n	a2a4 <usb_mouse_send+0x34>
		yield();
    a300:	f7f8 f9d4 	bl	26ac <yield>
		if ( !usb_configuration )
    a304:	e7bb      	b.n	a27e <usb_mouse_send+0xe>
    a306:	bf00      	nop
    a308:	1fff9546 	.word	0x1fff9546
    a30c:	1fff954b 	.word	0x1fff954b
    a310:	00010d1d 	.word	0x00010d1d
    a314:	00010de2 	.word	0x00010de2
    a318:	1fff93ee 	.word	0x1fff93ee
    a31c:	1fff93f2 	.word	0x1fff93f2
    a320:	1fff93f4 	.word	0x1fff93f4
    a324:	1fff93f0 	.word	0x1fff93f0

0000a328 <usb_rawio_available>:

// Check for packets available from host
uint32_t usb_rawio_available()
{
	// Error if USB isn't configured
	if ( !usb_configuration )
    a328:	4b03      	ldr	r3, [pc, #12]	; (a338 <usb_rawio_available+0x10>)
    a32a:	781b      	ldrb	r3, [r3, #0]
    a32c:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    a330:	b10b      	cbz	r3, a336 <usb_rawio_available+0xe>
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	return usb_rx_byte_count_data[ endpoint ];
    a332:	4b02      	ldr	r3, [pc, #8]	; (a33c <usb_rawio_available+0x14>)
    a334:	89d8      	ldrh	r0, [r3, #14]
		return 0;

	// Query number of bytes available from the endpoint
	return usb_rx_byte_count( RAWIO_RX_ENDPOINT );
}
    a336:	4770      	bx	lr
    a338:	1fff9546 	.word	0x1fff9546
    a33c:	1fffae18 	.word	0x1fffae18

0000a340 <usb_rawio_rx>:

// Retrieve packets from host
// Always returns RAWIO_RX_SIZE
int32_t usb_rawio_rx( void *buf, uint32_t timeout )
{
    a340:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	usb_packet_t *rx_packet;
	Time start = Time_now();
    a344:	466d      	mov	r5, sp
{
    a346:	4607      	mov	r7, r0
	Time start = Time_now();
    a348:	4628      	mov	r0, r5
{
    a34a:	460e      	mov	r6, r1
	Time start = Time_now();
    a34c:	f7f8 fb08 	bl	2960 <Time_now>

	// Read
	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    a350:	f8df 8054 	ldr.w	r8, [pc, #84]	; a3a8 <usb_rawio_rx+0x68>
    a354:	f898 3000 	ldrb.w	r3, [r8]
    a358:	b303      	cbz	r3, a39c <usb_rawio_rx+0x5c>
			return -1;

		// Retrieve packet
		rx_packet = usb_rx( RAWIO_RX_ENDPOINT );
    a35a:	2008      	movs	r0, #8
    a35c:	f7fe ffc6 	bl	92ec <usb_rx>
		if ( rx_packet )
    a360:	4604      	mov	r4, r0
    a362:	b980      	cbnz	r0, a386 <usb_rawio_rx+0x46>
			break;

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    a364:	e895 0003 	ldmia.w	r5, {r0, r1}
    a368:	f7f8 fb64 	bl	2a34 <Time_duration_ms>
    a36c:	42b0      	cmp	r0, r6
    a36e:	d800      	bhi.n	a372 <usb_rawio_rx+0x32>
    a370:	b936      	cbnz	r6, a380 <usb_rawio_rx+0x40>
		{
			warn_msg("RAWIO Rx - Timeout, dropping packet.");
    a372:	480c      	ldr	r0, [pc, #48]	; (a3a4 <usb_rawio_rx+0x64>)
    a374:	f001 f844 	bl	b400 <_print>
			return 0;
    a378:	2000      	movs	r0, #0
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
	usb_free( rx_packet );

	// Data sent in full packet chunks
	return RAWIO_RX_SIZE;
}
    a37a:	b002      	add	sp, #8
    a37c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		yield();
    a380:	f7f8 f994 	bl	26ac <yield>
		if ( !usb_configuration )
    a384:	e7e6      	b.n	a354 <usb_rawio_rx+0x14>
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
    a386:	f100 0108 	add.w	r1, r0, #8
    a38a:	2240      	movs	r2, #64	; 0x40
    a38c:	4638      	mov	r0, r7
    a38e:	f7f8 f95f 	bl	2650 <memcpy>
	usb_free( rx_packet );
    a392:	4620      	mov	r0, r4
    a394:	f7ff ff4a 	bl	a22c <usb_free>
	return RAWIO_RX_SIZE;
    a398:	2040      	movs	r0, #64	; 0x40
    a39a:	e7ee      	b.n	a37a <usb_rawio_rx+0x3a>
			return -1;
    a39c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a3a0:	e7eb      	b.n	a37a <usb_rawio_rx+0x3a>
    a3a2:	bf00      	nop
    a3a4:	00010e11 	.word	0x00010e11
    a3a8:	1fff9546 	.word	0x1fff9546

0000a3ac <usb_rawio_tx>:

// Send packet to host
// XXX Only transfers RAWIO_TX_SIZE on each call (likely 64 bytes)
// Always returns RAWIO_TX_SIZE
int32_t usb_rawio_tx( const void *buf, uint32_t timeout )
{
    a3ac:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	usb_packet_t *tx_packet;
	Time start = Time_now();
    a3b0:	466c      	mov	r4, sp
{
    a3b2:	4607      	mov	r7, r0
	Time start = Time_now();
    a3b4:	4620      	mov	r0, r4
{
    a3b6:	460e      	mov	r6, r1
	Time start = Time_now();
    a3b8:	f7f8 fad2 	bl	2960 <Time_now>

	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    a3bc:	f8df 8064 	ldr.w	r8, [pc, #100]	; a424 <usb_rawio_tx+0x78>
    a3c0:	f898 3000 	ldrb.w	r3, [r8]
    a3c4:	b343      	cbz	r3, a418 <usb_rawio_tx+0x6c>
			return -1;

		// Make sure we haven't exceeded the outgoing packet limit
		if ( usb_tx_packet_count( RAWIO_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    a3c6:	2007      	movs	r0, #7
    a3c8:	f7fe ffac 	bl	9324 <usb_tx_packet_count>
    a3cc:	2804      	cmp	r0, #4
    a3ce:	d90c      	bls.n	a3ea <usb_rawio_tx+0x3e>
			if ( tx_packet )
				break;
		}

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    a3d0:	e894 0003 	ldmia.w	r4, {r0, r1}
    a3d4:	f7f8 fb2e 	bl	2a34 <Time_duration_ms>
    a3d8:	42b0      	cmp	r0, r6
    a3da:	d918      	bls.n	a40e <usb_rawio_tx+0x62>
		{
			warn_msg("RAWIO Tx - Timeout, dropping packet.");
    a3dc:	4810      	ldr	r0, [pc, #64]	; (a420 <usb_rawio_tx+0x74>)
    a3de:	f001 f80f 	bl	b400 <_print>
			return 0;
    a3e2:	2000      	movs	r0, #0

	// Send USB packet
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );

	return RAWIO_TX_SIZE;
}
    a3e4:	b002      	add	sp, #8
    a3e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			tx_packet = usb_malloc();
    a3ea:	f7ff ff01 	bl	a1f0 <usb_malloc>
			if ( tx_packet )
    a3ee:	4605      	mov	r5, r0
    a3f0:	2800      	cmp	r0, #0
    a3f2:	d0ed      	beq.n	a3d0 <usb_rawio_tx+0x24>
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    a3f4:	2240      	movs	r2, #64	; 0x40
    a3f6:	4639      	mov	r1, r7
	tx_packet->len = RAWIO_TX_SIZE;
    a3f8:	2440      	movs	r4, #64	; 0x40
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    a3fa:	3008      	adds	r0, #8
    a3fc:	f7f8 f928 	bl	2650 <memcpy>
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    a400:	2007      	movs	r0, #7
	tx_packet->len = RAWIO_TX_SIZE;
    a402:	802c      	strh	r4, [r5, #0]
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    a404:	4629      	mov	r1, r5
    a406:	f7fe fffd 	bl	9404 <usb_tx>
	return RAWIO_TX_SIZE;
    a40a:	4620      	mov	r0, r4
    a40c:	e7ea      	b.n	a3e4 <usb_rawio_tx+0x38>
		if ( Time_duration_ms( start ) > timeout || !timeout )
    a40e:	2e00      	cmp	r6, #0
    a410:	d0e4      	beq.n	a3dc <usb_rawio_tx+0x30>
		yield();
    a412:	f7f8 f94b 	bl	26ac <yield>
		if ( !usb_configuration )
    a416:	e7d3      	b.n	a3c0 <usb_rawio_tx+0x14>
			return -1;
    a418:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a41c:	e7e2      	b.n	a3e4 <usb_rawio_tx+0x38>
    a41e:	bf00      	nop
    a420:	00010e4b 	.word	0x00010e4b
    a424:	1fff9546 	.word	0x1fff9546

0000a428 <usb_serial_getchar>:

// ----- Functions -----

// get the next character, or -1 if nothing received
int usb_serial_getchar()
{
    a428:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if ( !rx_packet )
    a42a:	4c10      	ldr	r4, [pc, #64]	; (a46c <usb_serial_getchar+0x44>)
    a42c:	6823      	ldr	r3, [r4, #0]
    a42e:	b163      	cbz	r3, a44a <usb_serial_getchar+0x22>
			return -1;
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
		if ( !rx_packet )
			return -1;
	}
	i = rx_packet->index;
    a430:	6820      	ldr	r0, [r4, #0]
    a432:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    a434:	18c2      	adds	r2, r0, r3
    a436:	3301      	adds	r3, #1
    a438:	7a15      	ldrb	r5, [r2, #8]
	if ( i >= rx_packet->len )
    a43a:	8802      	ldrh	r2, [r0, #0]
    a43c:	429a      	cmp	r2, r3
    a43e:	d812      	bhi.n	a466 <usb_serial_getchar+0x3e>
	{
		usb_free( rx_packet );
    a440:	f7ff fef4 	bl	a22c <usb_free>
		rx_packet = NULL;
    a444:	2300      	movs	r3, #0
    a446:	6023      	str	r3, [r4, #0]
    a448:	e004      	b.n	a454 <usb_serial_getchar+0x2c>
		if ( !usb_configuration )
    a44a:	4b09      	ldr	r3, [pc, #36]	; (a470 <usb_serial_getchar+0x48>)
    a44c:	781b      	ldrb	r3, [r3, #0]
    a44e:	b91b      	cbnz	r3, a458 <usb_serial_getchar+0x30>
			return -1;
    a450:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	else
	{
		rx_packet->index = i;
	}
	return c;
}
    a454:	4628      	mov	r0, r5
    a456:	bd38      	pop	{r3, r4, r5, pc}
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
    a458:	2005      	movs	r0, #5
    a45a:	f7fe ff47 	bl	92ec <usb_rx>
    a45e:	6020      	str	r0, [r4, #0]
		if ( !rx_packet )
    a460:	2800      	cmp	r0, #0
    a462:	d1e5      	bne.n	a430 <usb_serial_getchar+0x8>
    a464:	e7f4      	b.n	a450 <usb_serial_getchar+0x28>
		rx_packet->index = i;
    a466:	8043      	strh	r3, [r0, #2]
    a468:	e7f4      	b.n	a454 <usb_serial_getchar+0x2c>
    a46a:	bf00      	nop
    a46c:	1fff954c 	.word	0x1fff954c
    a470:	1fff9546 	.word	0x1fff9546

0000a474 <usb_serial_available>:
    a474:	4b04      	ldr	r3, [pc, #16]	; (a488 <usb_serial_available+0x14>)
}

// number of bytes available in the receive buffer
int usb_serial_available()
{
	int count = usb_rx_byte_count( CDC_RX_ENDPOINT );
    a476:	8918      	ldrh	r0, [r3, #8]
	if ( rx_packet )
    a478:	4b04      	ldr	r3, [pc, #16]	; (a48c <usb_serial_available+0x18>)
    a47a:	681a      	ldr	r2, [r3, #0]
    a47c:	b11a      	cbz	r2, a486 <usb_serial_available+0x12>
		count += rx_packet->len - rx_packet->index;
    a47e:	8813      	ldrh	r3, [r2, #0]
    a480:	8852      	ldrh	r2, [r2, #2]
    a482:	1a9b      	subs	r3, r3, r2
    a484:	4418      	add	r0, r3
	return count;
}
    a486:	4770      	bx	lr
    a488:	1fffae18 	.word	0x1fffae18
    a48c:	1fff954c 	.word	0x1fff954c

0000a490 <usb_serial_write>:
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    a490:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t len;
	Time start;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    a494:	4d30      	ldr	r5, [pc, #192]	; (a558 <usb_serial_write+0xc8>)
	while ( size > 0 )
	{
		if ( !tx_packet )
    a496:	4f31      	ldr	r7, [pc, #196]	; (a55c <usb_serial_write+0xcc>)
		{
			start = Time_now();
			while ( 1 )
			{
				if ( !usb_configuration )
    a498:	f8df 80cc 	ldr.w	r8, [pc, #204]	; a568 <usb_serial_write+0xd8>
	tx_noautoflush = 1;
    a49c:	2301      	movs	r3, #1
{
    a49e:	4606      	mov	r6, r0
    a4a0:	460c      	mov	r4, r1
	tx_noautoflush = 1;
    a4a2:	702b      	strb	r3, [r5, #0]
	while ( size > 0 )
    a4a4:	b914      	cbnz	r4, a4ac <usb_serial_write+0x1c>
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    a4a6:	702c      	strb	r4, [r5, #0]
	return 0;
    a4a8:	4620      	mov	r0, r4
    a4aa:	e00f      	b.n	a4cc <usb_serial_write+0x3c>
		if ( !tx_packet )
    a4ac:	683b      	ldr	r3, [r7, #0]
    a4ae:	bb63      	cbnz	r3, a50a <usb_serial_write+0x7a>
			start = Time_now();
    a4b0:	46e9      	mov	r9, sp
    a4b2:	4648      	mov	r0, r9
    a4b4:	f7f8 fa54 	bl	2960 <Time_now>
    a4b8:	f8df a0a4 	ldr.w	sl, [pc, #164]	; a560 <usb_serial_write+0xd0>
				if ( !usb_configuration )
    a4bc:	f898 3000 	ldrb.w	r3, [r8]
    a4c0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    a4c4:	b92b      	cbnz	r3, a4d2 <usb_serial_write+0x42>
					tx_noautoflush = 0;
    a4c6:	702a      	strb	r2, [r5, #0]
					return -1;
    a4c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    a4cc:	b002      	add	sp, #8
    a4ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if ( usb_tx_packet_count( CDC_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    a4d2:	2006      	movs	r0, #6
    a4d4:	f7fe ff26 	bl	9324 <usb_tx_packet_count>
    a4d8:	2807      	cmp	r0, #7
    a4da:	d806      	bhi.n	a4ea <usb_serial_write+0x5a>
					tx_noautoflush = 1;
    a4dc:	2301      	movs	r3, #1
    a4de:	702b      	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    a4e0:	f7ff fe86 	bl	a1f0 <usb_malloc>
    a4e4:	6038      	str	r0, [r7, #0]
					if ( tx_packet )
    a4e6:	b980      	cbnz	r0, a50a <usb_serial_write+0x7a>
					tx_noautoflush = 0;
    a4e8:	7028      	strb	r0, [r5, #0]
				if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    a4ea:	e899 0003 	ldmia.w	r9, {r0, r1}
    a4ee:	f7f8 faa1 	bl	2a34 <Time_duration_ms>
    a4f2:	2846      	cmp	r0, #70	; 0x46
    a4f4:	d802      	bhi.n	a4fc <usb_serial_write+0x6c>
    a4f6:	f89a 3000 	ldrb.w	r3, [sl]
    a4fa:	b11b      	cbz	r3, a504 <usb_serial_write+0x74>
					transmit_previous_timeout = 1;
    a4fc:	2301      	movs	r3, #1
    a4fe:	f88a 3000 	strb.w	r3, [sl]
    a502:	e7e1      	b.n	a4c8 <usb_serial_write+0x38>
				yield();
    a504:	f7f8 f8d2 	bl	26ac <yield>
				if ( !usb_configuration )
    a508:	e7d8      	b.n	a4bc <usb_serial_write+0x2c>
		len = CDC_TX_SIZE - tx_packet->index;
    a50a:	6839      	ldr	r1, [r7, #0]
		transmit_previous_timeout = 0;
    a50c:	4b14      	ldr	r3, [pc, #80]	; (a560 <usb_serial_write+0xd0>)
    a50e:	2200      	movs	r2, #0
    a510:	701a      	strb	r2, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    a512:	884b      	ldrh	r3, [r1, #2]
    a514:	f1c3 0240 	rsb	r2, r3, #64	; 0x40
    a518:	42a2      	cmp	r2, r4
    a51a:	bf28      	it	cs
    a51c:	4622      	movcs	r2, r4
		tx_packet->index += len;
    a51e:	1898      	adds	r0, r3, r2
    a520:	440b      	add	r3, r1
    a522:	8048      	strh	r0, [r1, #2]
		size -= len;
    a524:	1aa4      	subs	r4, r4, r2
    a526:	3307      	adds	r3, #7
    a528:	eb06 0902 	add.w	r9, r6, r2
		while ( len-- > 0 )
    a52c:	454e      	cmp	r6, r9
    a52e:	d10e      	bne.n	a54e <usb_serial_write+0xbe>
		if ( tx_packet->index >= CDC_TX_SIZE )
    a530:	884b      	ldrh	r3, [r1, #2]
    a532:	2b3f      	cmp	r3, #63	; 0x3f
    a534:	d906      	bls.n	a544 <usb_serial_write+0xb4>
			tx_packet->len = CDC_TX_SIZE;
    a536:	2340      	movs	r3, #64	; 0x40
    a538:	800b      	strh	r3, [r1, #0]
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
    a53a:	2006      	movs	r0, #6
    a53c:	f7fe ff62 	bl	9404 <usb_tx>
			tx_packet = NULL;
    a540:	2300      	movs	r3, #0
    a542:	603b      	str	r3, [r7, #0]
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    a544:	4b07      	ldr	r3, [pc, #28]	; (a564 <usb_serial_write+0xd4>)
    a546:	2205      	movs	r2, #5
    a548:	701a      	strb	r2, [r3, #0]
    a54a:	464e      	mov	r6, r9
    a54c:	e7aa      	b.n	a4a4 <usb_serial_write+0x14>
			*dest++ = *src++;
    a54e:	f816 2b01 	ldrb.w	r2, [r6], #1
    a552:	f803 2f01 	strb.w	r2, [r3, #1]!
    a556:	e7e9      	b.n	a52c <usb_serial_write+0x9c>
    a558:	1fff9551 	.word	0x1fff9551
    a55c:	1fff9554 	.word	0x1fff9554
    a560:	1fff9550 	.word	0x1fff9550
    a564:	1fff9559 	.word	0x1fff9559
    a568:	1fff9546 	.word	0x1fff9546

0000a56c <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback()
{
    a56c:	b538      	push	{r3, r4, r5, lr}
	if ( tx_noautoflush )
    a56e:	4b0e      	ldr	r3, [pc, #56]	; (a5a8 <usb_serial_flush_callback+0x3c>)
    a570:	781b      	ldrb	r3, [r3, #0]
    a572:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    a576:	b943      	cbnz	r3, a58a <usb_serial_flush_callback+0x1e>
		return;
	if ( tx_packet )
    a578:	4c0c      	ldr	r4, [pc, #48]	; (a5ac <usb_serial_flush_callback+0x40>)
    a57a:	6821      	ldr	r1, [r4, #0]
    a57c:	b131      	cbz	r1, a58c <usb_serial_flush_callback+0x20>
	{
		tx_packet->len = tx_packet->index;
    a57e:	884b      	ldrh	r3, [r1, #2]
    a580:	800b      	strh	r3, [r1, #0]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    a582:	2006      	movs	r0, #6
    a584:	f7fe ff3e 	bl	9404 <usb_tx>
		tx_packet = NULL;
    a588:	6025      	str	r5, [r4, #0]
		else
		{
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    a58a:	bd38      	pop	{r3, r4, r5, pc}
		usb_packet_t *tx = usb_malloc();
    a58c:	f7ff fe30 	bl	a1f0 <usb_malloc>
		if ( tx )
    a590:	4601      	mov	r1, r0
    a592:	b120      	cbz	r0, a59e <usb_serial_flush_callback+0x32>
			usb_tx( CDC_TX_ENDPOINT, tx );
    a594:	2006      	movs	r0, #6
}
    a596:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			usb_tx( CDC_TX_ENDPOINT, tx );
    a59a:	f7fe bf33 	b.w	9404 <usb_tx>
			usb_cdc_transmit_flush_timer = 1;
    a59e:	4b04      	ldr	r3, [pc, #16]	; (a5b0 <usb_serial_flush_callback+0x44>)
    a5a0:	2201      	movs	r2, #1
    a5a2:	701a      	strb	r2, [r3, #0]
    a5a4:	e7f1      	b.n	a58a <usb_serial_flush_callback+0x1e>
    a5a6:	bf00      	nop
    a5a8:	1fff9551 	.word	0x1fff9551
    a5ac:	1fff9554 	.word	0x1fff9554
    a5b0:	1fff9559 	.word	0x1fff9559

0000a5b4 <cliFunc_clear>:

// ----- CLI Command Functions -----

void cliFunc_clear( char* args)
{
	print("\033[2J\033[H\r"); // Erases the whole screen
    a5b4:	4801      	ldr	r0, [pc, #4]	; (a5bc <cliFunc_clear+0x8>)
    a5b6:	f000 bf23 	b.w	b400 <_print>
    a5ba:	bf00      	nop
    a5bc:	00011191 	.word	0x00011191

0000a5c0 <cliFunc_colorTest>:
		CLIHexDebugMode = 1;
	}
}

void cliFunc_colorTest( char* args )
{
    a5c0:	b508      	push	{r3, lr}
	print( NL );
    a5c2:	4804      	ldr	r0, [pc, #16]	; (a5d4 <cliFunc_colorTest+0x14>)
    a5c4:	f000 ff1c 	bl	b400 <_print>
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    a5c8:	4803      	ldr	r0, [pc, #12]	; (a5d8 <cliFunc_colorTest+0x18>)
}
    a5ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    a5ce:	f000 bf17 	b.w	b400 <_print>
    a5d2:	bf00      	nop
    a5d4:	00010d99 	.word	0x00010d99
    a5d8:	000111f7 	.word	0x000111f7

0000a5dc <cliFunc_reload>:
	info_msg("Rand: ");
	printHex32( rand_value32() );
}

void cliFunc_reload( char* args )
{
    a5dc:	b508      	push	{r3, lr}
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
    a5de:	4805      	ldr	r0, [pc, #20]	; (a5f4 <cliFunc_reload+0x18>)
    a5e0:	f000 ff0e 	bl	b400 <_print>
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
    a5e4:	4804      	ldr	r0, [pc, #16]	; (a5f8 <cliFunc_reload+0x1c>)
    a5e6:	f000 ff0b 	bl	b400 <_print>
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    a5ea:	4804      	ldr	r0, [pc, #16]	; (a5fc <cliFunc_reload+0x20>)
		return;
	}

	// Request to output module to be set into firmware reload mode
	Output_firmwareReload();
}
    a5ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    a5f0:	f000 bf06 	b.w	b400 <_print>
    a5f4:	00010d99 	.word	0x00010d99
    a5f8:	0000d917 	.word	0x0000d917
    a5fc:	0000d966 	.word	0x0000d966

0000a600 <cliFunc_reset>:

void cliFunc_reset( char* args )
{
	print("\033c"); // Resets the terminal
    a600:	4801      	ldr	r0, [pc, #4]	; (a608 <cliFunc_reset+0x8>)
    a602:	f000 befd 	b.w	b400 <_print>
    a606:	bf00      	nop
    a608:	000112d4 	.word	0x000112d4

0000a60c <cliFunc_help>:
{
    a60c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    a610:	f8df a0ac 	ldr.w	sl, [pc, #172]	; a6c0 <cliFunc_help+0xb4>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    a614:	f8df 80ac 	ldr.w	r8, [pc, #172]	; a6c4 <cliFunc_help+0xb8>
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    a618:	2700      	movs	r7, #0
    a61a:	f89a 3000 	ldrb.w	r3, [sl]
    a61e:	b2fd      	uxtb	r5, r7
    a620:	42ab      	cmp	r3, r5
    a622:	d802      	bhi.n	a62a <cliFunc_help+0x1e>
}
    a624:	b003      	add	sp, #12
    a626:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		print( NL "\033[1;32m" );
    a62a:	481e      	ldr	r0, [pc, #120]	; (a6a4 <cliFunc_help+0x98>)
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    a62c:	f8df b098 	ldr.w	fp, [pc, #152]	; a6c8 <cliFunc_help+0xbc>
		print( NL "\033[1;32m" );
    a630:	f000 fee6 	bl	b400 <_print>
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
    a634:	4b1c      	ldr	r3, [pc, #112]	; (a6a8 <cliFunc_help+0x9c>)
    a636:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    a63a:	f000 fee1 	bl	b400 <_print>
		print( "\033[0m" NL );
    a63e:	481b      	ldr	r0, [pc, #108]	; (a6ac <cliFunc_help+0xa0>)
    a640:	f000 fede 	bl	b400 <_print>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    a644:	f04f 0900 	mov.w	r9, #0
    a648:	fa5f f389 	uxtb.w	r3, r9
    a64c:	260c      	movs	r6, #12
    a64e:	435e      	muls	r6, r3
    a650:	f858 3025 	ldr.w	r3, [r8, r5, lsl #2]
    a654:	5999      	ldr	r1, [r3, r6]
    a656:	b909      	cbnz	r1, a65c <cliFunc_help+0x50>
    a658:	3701      	adds	r7, #1
    a65a:	e7de      	b.n	a61a <cliFunc_help+0xe>
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    a65c:	465b      	mov	r3, fp
    a65e:	4a14      	ldr	r2, [pc, #80]	; (a6b0 <cliFunc_help+0xa4>)
    a660:	4814      	ldr	r0, [pc, #80]	; (a6b4 <cliFunc_help+0xa8>)
    a662:	f000 feb5 	bl	b3d0 <printstrs>
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    a666:	f858 3025 	ldr.w	r3, [r8, r5, lsl #2]
    a66a:	5998      	ldr	r0, [r3, r6]
    a66c:	f000 feca 	bl	b404 <lenStr>
				print(" ");
    a670:	4b11      	ldr	r3, [pc, #68]	; (a6b8 <cliFunc_help+0xac>)
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    a672:	f1c0 000d 	rsb	r0, r0, #13
    a676:	b2c4      	uxtb	r4, r0
			while ( padLength-- > 0 )
    a678:	3c01      	subs	r4, #1
    a67a:	b2e4      	uxtb	r4, r4
    a67c:	2cff      	cmp	r4, #255	; 0xff
    a67e:	d10b      	bne.n	a698 <cliFunc_help+0x8c>
			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    a680:	f858 3025 	ldr.w	r3, [r8, r5, lsl #2]
    a684:	441e      	add	r6, r3
    a686:	f109 0901 	add.w	r9, r9, #1
    a68a:	6870      	ldr	r0, [r6, #4]
    a68c:	f000 feb8 	bl	b400 <_print>
			print( NL );
    a690:	480a      	ldr	r0, [pc, #40]	; (a6bc <cliFunc_help+0xb0>)
    a692:	f000 feb5 	bl	b400 <_print>
    a696:	e7d7      	b.n	a648 <cliFunc_help+0x3c>
				print(" ");
    a698:	4618      	mov	r0, r3
    a69a:	9301      	str	r3, [sp, #4]
    a69c:	f000 feb0 	bl	b400 <_print>
    a6a0:	9b01      	ldr	r3, [sp, #4]
    a6a2:	e7e9      	b.n	a678 <cliFunc_help+0x6c>
    a6a4:	00011216 	.word	0x00011216
    a6a8:	1fff9b00 	.word	0x1fff9b00
    a6ac:	00011220 	.word	0x00011220
    a6b0:	0000de76 	.word	0x0000de76
    a6b4:	00011227 	.word	0x00011227
    a6b8:	00011f77 	.word	0x00011f77
    a6bc:	00010d99 	.word	0x00010d99
    a6c0:	1fff9683 	.word	0x1fff9683
    a6c4:	1fff9ad4 	.word	0x1fff9ad4
    a6c8:	00010e85 	.word	0x00010e85

0000a6cc <cliFunc_led>:
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
    a6cc:	4b03      	ldr	r3, [pc, #12]	; (a6dc <cliFunc_led+0x10>)
    a6ce:	7818      	ldrb	r0, [r3, #0]
    a6d0:	f080 0002 	eor.w	r0, r0, #2
    a6d4:	7018      	strb	r0, [r3, #0]
	errorLED( CLILEDState ); // Enable/Disable error LED
    a6d6:	f000 be6d 	b.w	b3b4 <errorLED>
    a6da:	bf00      	nop
    a6dc:	1fff9682 	.word	0x1fff9682

0000a6e0 <cliFunc_restart>:
}

void cliFunc_restart( char* args )
{
	// Trigger an overall software reset
	Output_softReset();
    a6e0:	f7fe ba4f 	b.w	8b82 <Output_softReset>

0000a6e4 <cliFunc_tick>:
}

void cliFunc_tick( char* args )
{
    a6e4:	b513      	push	{r0, r1, r4, lr}
	print( NL );
    a6e6:	4c11      	ldr	r4, [pc, #68]	; (a72c <cliFunc_tick+0x48>)
    a6e8:	4620      	mov	r0, r4
    a6ea:	f000 fe89 	bl	b400 <_print>

	// Get current time
	Time now = Time_now();
    a6ee:	4668      	mov	r0, sp
    a6f0:	f7f8 f936 	bl	2960 <Time_now>

	// Display <systick>:<cycleticks since systick>
	info_msg("ns per cycletick: ");
    a6f4:	480e      	ldr	r0, [pc, #56]	; (a730 <cliFunc_tick+0x4c>)
    a6f6:	f000 fe83 	bl	b400 <_print>
	print( Time_ticksPer_ns_str );
    a6fa:	4b0e      	ldr	r3, [pc, #56]	; (a734 <cliFunc_tick+0x50>)
    a6fc:	6818      	ldr	r0, [r3, #0]
    a6fe:	f000 fe7f 	bl	b400 <_print>
	print( NL );
    a702:	4620      	mov	r0, r4
    a704:	f000 fe7c 	bl	b400 <_print>
	info_print("<systick ms>:<cycleticks since systick>");
    a708:	480b      	ldr	r0, [pc, #44]	; (a738 <cliFunc_tick+0x54>)
    a70a:	f000 fe79 	bl	b400 <_print>
	printInt32( now.ms );
    a70e:	9800      	ldr	r0, [sp, #0]
    a710:	f000 fee5 	bl	b4de <printInt32>
	print(":");
    a714:	4809      	ldr	r0, [pc, #36]	; (a73c <cliFunc_tick+0x58>)
    a716:	f000 fe73 	bl	b400 <_print>
	printInt32( now.ticks );
    a71a:	9801      	ldr	r0, [sp, #4]
    a71c:	f000 fedf 	bl	b4de <printInt32>
	print( NL );
    a720:	4620      	mov	r0, r4
}
    a722:	b002      	add	sp, #8
    a724:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    a728:	f000 be6a 	b.w	b400 <_print>
    a72c:	00010d99 	.word	0x00010d99
    a730:	000112d7 	.word	0x000112d7
    a734:	1fff89d0 	.word	0x1fff89d0
    a738:	000112fc 	.word	0x000112fc
    a73c:	0000f857 	.word	0x0000f857

0000a740 <cliFunc_cliDebug>:
{
    a740:	b510      	push	{r4, lr}
	if ( CLIHexDebugMode )
    a742:	4c09      	ldr	r4, [pc, #36]	; (a768 <cliFunc_cliDebug+0x28>)
		print( NL );
    a744:	4809      	ldr	r0, [pc, #36]	; (a76c <cliFunc_cliDebug+0x2c>)
	if ( CLIHexDebugMode )
    a746:	7823      	ldrb	r3, [r4, #0]
    a748:	b13b      	cbz	r3, a75a <cliFunc_cliDebug+0x1a>
		print( NL );
    a74a:	f000 fe59 	bl	b400 <_print>
		info_print("Hex debug mode disabled...");
    a74e:	4808      	ldr	r0, [pc, #32]	; (a770 <cliFunc_cliDebug+0x30>)
    a750:	f000 fe56 	bl	b400 <_print>
		CLIHexDebugMode = 0;
    a754:	2300      	movs	r3, #0
		CLIHexDebugMode = 1;
    a756:	7023      	strb	r3, [r4, #0]
}
    a758:	bd10      	pop	{r4, pc}
		print( NL );
    a75a:	f000 fe51 	bl	b400 <_print>
		info_print("Hex debug mode enabled...");
    a75e:	4805      	ldr	r0, [pc, #20]	; (a774 <cliFunc_cliDebug+0x34>)
    a760:	f000 fe4e 	bl	b400 <_print>
		CLIHexDebugMode = 1;
    a764:	2301      	movs	r3, #1
    a766:	e7f6      	b.n	a756 <cliFunc_cliDebug+0x16>
    a768:	1fff9680 	.word	0x1fff9680
    a76c:	00010d99 	.word	0x00010d99
    a770:	0001119a 	.word	0x0001119a
    a774:	000111c9 	.word	0x000111c9

0000a778 <cliFunc_rand>:
{
    a778:	b508      	push	{r3, lr}
	print( NL );
    a77a:	480a      	ldr	r0, [pc, #40]	; (a7a4 <cliFunc_rand+0x2c>)
    a77c:	f000 fe40 	bl	b400 <_print>
	if ( !rand_available() )
    a780:	f7f8 f814 	bl	27ac <rand_available>
    a784:	b920      	cbnz	r0, a790 <cliFunc_rand+0x18>
		warn_print("No entropy available!");
    a786:	4808      	ldr	r0, [pc, #32]	; (a7a8 <cliFunc_rand+0x30>)
}
    a788:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		warn_print("No entropy available!");
    a78c:	f000 be38 	b.w	b400 <_print>
	info_msg("Rand: ");
    a790:	4806      	ldr	r0, [pc, #24]	; (a7ac <cliFunc_rand+0x34>)
    a792:	f000 fe35 	bl	b400 <_print>
	printHex32( rand_value32() );
    a796:	f7f7 ffd7 	bl	2748 <rand_value32>
    a79a:	2101      	movs	r1, #1
}
    a79c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	printHex32( rand_value32() );
    a7a0:	f000 bf0e 	b.w	b5c0 <printHex32_op>
    a7a4:	00010d99 	.word	0x00010d99
    a7a8:	0001128e 	.word	0x0001128e
    a7ac:	000112bb 	.word	0x000112bb

0000a7b0 <ChipVersion_cpuid_partno>:

// ----- Functions -----

const char *ChipVersion_cpuid_partno()
{
	switch ( SCB_CPUID_PARTNO )
    a7b0:	4b06      	ldr	r3, [pc, #24]	; (a7cc <ChipVersion_cpuid_partno+0x1c>)
	case 0xC24:
		return "Cortex-M4";
	default:
		return "--";
	}
}
    a7b2:	4907      	ldr	r1, [pc, #28]	; (a7d0 <ChipVersion_cpuid_partno+0x20>)
	switch ( SCB_CPUID_PARTNO )
    a7b4:	681b      	ldr	r3, [r3, #0]
}
    a7b6:	4a07      	ldr	r2, [pc, #28]	; (a7d4 <ChipVersion_cpuid_partno+0x24>)
	switch ( SCB_CPUID_PARTNO )
    a7b8:	f3c3 130b 	ubfx	r3, r3, #4, #12
}
    a7bc:	f640 4024 	movw	r0, #3108	; 0xc24
    a7c0:	4283      	cmp	r3, r0
    a7c2:	bf0c      	ite	eq
    a7c4:	4608      	moveq	r0, r1
    a7c6:	4610      	movne	r0, r2
    a7c8:	4770      	bx	lr
    a7ca:	bf00      	nop
    a7cc:	e000ed00 	.word	0xe000ed00
    a7d0:	00010f7c 	.word	0x00010f7c
    a7d4:	00010f86 	.word	0x00010f86

0000a7d8 <ChipVersion_cpuid_implementor>:

const char *ChipVersion_cpuid_implementor()
{
	switch ( SCB_CPUID_IMPLEMENTOR )
    a7d8:	4b04      	ldr	r3, [pc, #16]	; (a7ec <ChipVersion_cpuid_implementor+0x14>)
	case 0x41:
		return "ARM";
	default:
		return "--";
	}
}
    a7da:	4a05      	ldr	r2, [pc, #20]	; (a7f0 <ChipVersion_cpuid_implementor+0x18>)
	switch ( SCB_CPUID_IMPLEMENTOR )
    a7dc:	78d8      	ldrb	r0, [r3, #3]
}
    a7de:	4b05      	ldr	r3, [pc, #20]	; (a7f4 <ChipVersion_cpuid_implementor+0x1c>)
    a7e0:	2841      	cmp	r0, #65	; 0x41
    a7e2:	bf0c      	ite	eq
    a7e4:	4610      	moveq	r0, r2
    a7e6:	4618      	movne	r0, r3
    a7e8:	4770      	bx	lr
    a7ea:	bf00      	nop
    a7ec:	e000ed00 	.word	0xe000ed00
    a7f0:	00010f78 	.word	0x00010f78
    a7f4:	00010f86 	.word	0x00010f86

0000a7f8 <ChipVersion_lookup>:
	// The first m stands for production, the other option is p (unqualified sample)

	//uint8_t family = SIM_SDID_FAMID; // e.g. k20
	// TODO e.g. d (Cortex-M4)
	//uint8_t flex = SIM_FCFG1_NVMSIZE ? 1 : 0; // e.g. x (Flex memory)
	uint16_t pflash = ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ]; // e.g. 256 (256 kB)
    a7f8:	4b1b      	ldr	r3, [pc, #108]	; (a868 <ChipVersion_lookup+0x70>)
    a7fa:	4a1c      	ldr	r2, [pc, #112]	; (a86c <ChipVersion_lookup+0x74>)
    a7fc:	78db      	ldrb	r3, [r3, #3]
    a7fe:	f003 030f 	and.w	r3, r3, #15
    a802:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
	//uint8_t pincount = SIM_SDID_PINID; // e.g. LH (64 LQFP)
	// TODO e.g. 7 (70 MHz)

	// Using openocd method of using the SDID mask
	// Not perfect, but generally ok, also using the pincount
	if ( SIM_SDID & 0x00000095 )
    a806:	4a1a      	ldr	r2, [pc, #104]	; (a870 <ChipVersion_lookup+0x78>)
    a808:	6810      	ldr	r0, [r2, #0]
    a80a:	f010 0f95 	tst.w	r0, #149	; 0x95
    a80e:	d01a      	beq.n	a846 <ChipVersion_lookup+0x4e>
	{
		switch ( pflash )
    a810:	2b80      	cmp	r3, #128	; 0x80
    a812:	d004      	beq.n	a81e <ChipVersion_lookup+0x26>
    a814:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    a818:	d00b      	beq.n	a832 <ChipVersion_lookup+0x3a>
				return "mk20dx256vmc7";
			default:
				return "mk20dx256XXXX";
			}
		default:
			return "mk20dxXXXvlh7";
    a81a:	4816      	ldr	r0, [pc, #88]	; (a874 <ChipVersion_lookup+0x7c>)
    a81c:	4770      	bx	lr
			switch ( SIM_SDID_PINID )
    a81e:	f000 030f 	and.w	r3, r0, #15
    a822:	2b04      	cmp	r3, #4
    a824:	d01a      	beq.n	a85c <ChipVersion_lookup+0x64>
				return "mk20dx128XXXX";
    a826:	4a14      	ldr	r2, [pc, #80]	; (a878 <ChipVersion_lookup+0x80>)
    a828:	4814      	ldr	r0, [pc, #80]	; (a87c <ChipVersion_lookup+0x84>)
    a82a:	2b05      	cmp	r3, #5
    a82c:	bf18      	it	ne
    a82e:	4610      	movne	r0, r2
    a830:	4770      	bx	lr
			switch ( SIM_SDID_PINID )
    a832:	f000 030f 	and.w	r3, r0, #15
    a836:	2b05      	cmp	r3, #5
    a838:	d012      	beq.n	a860 <ChipVersion_lookup+0x68>
				return "mk20dx256XXXX";
    a83a:	4a11      	ldr	r2, [pc, #68]	; (a880 <ChipVersion_lookup+0x88>)
    a83c:	4811      	ldr	r0, [pc, #68]	; (a884 <ChipVersion_lookup+0x8c>)
    a83e:	2b09      	cmp	r3, #9
    a840:	bf18      	it	ne
    a842:	4610      	movne	r0, r2
    a844:	4770      	bx	lr
		}
	}
	else if ( SIM_SDID & 0x00000315 )
    a846:	f240 3215 	movw	r2, #789	; 0x315
    a84a:	4210      	tst	r0, r2
    a84c:	d00a      	beq.n	a864 <ChipVersion_lookup+0x6c>
		switch ( pflash )
		{
		case 512:
			return "mk22fx512avlh12";
		default:
			return "mk22fxXXXavlh12";
    a84e:	4a0e      	ldr	r2, [pc, #56]	; (a888 <ChipVersion_lookup+0x90>)
    a850:	480e      	ldr	r0, [pc, #56]	; (a88c <ChipVersion_lookup+0x94>)
    a852:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a856:	bf18      	it	ne
    a858:	4610      	movne	r0, r2
    a85a:	4770      	bx	lr
				return "mk20dx128vlf5";
    a85c:	480c      	ldr	r0, [pc, #48]	; (a890 <ChipVersion_lookup+0x98>)
    a85e:	4770      	bx	lr
				return "mk20dx256vlh7";
    a860:	480c      	ldr	r0, [pc, #48]	; (a894 <ChipVersion_lookup+0x9c>)
    a862:	4770      	bx	lr
		}
	}

	return "--";
    a864:	480c      	ldr	r0, [pc, #48]	; (a898 <ChipVersion_lookup+0xa0>)
}
    a866:	4770      	bx	lr
    a868:	4004804c 	.word	0x4004804c
    a86c:	0001104a 	.word	0x0001104a
    a870:	40048024 	.word	0x40048024
    a874:	00010ffe 	.word	0x00010ffe
    a878:	00010fc6 	.word	0x00010fc6
    a87c:	00010fb8 	.word	0x00010fb8
    a880:	00010ff0 	.word	0x00010ff0
    a884:	00010fe2 	.word	0x00010fe2
    a888:	0001101c 	.word	0x0001101c
    a88c:	0001100c 	.word	0x0001100c
    a890:	00010faa 	.word	0x00010faa
    a894:	00010fd4 	.word	0x00010fd4
    a898:	00010f86 	.word	0x00010f86

0000a89c <cliFunc_version>:

void cliFunc_version( char* args )
{
    a89c:	b570      	push	{r4, r5, r6, lr}
	print( NL );
    a89e:	4c98      	ldr	r4, [pc, #608]	; (ab00 <cliFunc_version+0x264>)

	print( " \033[1mCPU Id:\033[0m        " );
	printHex32( SCB_CPUID );
	print( NL "  (Implementor:");
	print( ChipVersion_cpuid_implementor() );
	print( ":" );
    a8a0:	4d98      	ldr	r5, [pc, #608]	; (ab04 <cliFunc_version+0x268>)
	print( ChipVersion_cpuid_partno() );
	print( ":" );
	printHex32( SCB_CPUID_PARTNO );
	print( ")(Revision:" );
	printHex32( SCB_CPUID_REVISION );
	print( ")" NL );
    a8a2:	4e99      	ldr	r6, [pc, #612]	; (ab08 <cliFunc_version+0x26c>)
	print( NL );
    a8a4:	4620      	mov	r0, r4
    a8a6:	f000 fdab 	bl	b400 <_print>
	print( " \033[1mRevision:\033[0m      " CLI_Revision          NL );
    a8aa:	4898      	ldr	r0, [pc, #608]	; (ab0c <cliFunc_version+0x270>)
    a8ac:	f000 fda8 	bl	b400 <_print>
	print( " \033[1mRevision #:\033[0m    " CLI_RevisionNumberStr NL );
    a8b0:	4897      	ldr	r0, [pc, #604]	; (ab10 <cliFunc_version+0x274>)
    a8b2:	f000 fda5 	bl	b400 <_print>
	print( " \033[1mVersion:\033[0m       " CLI_Version " (+" );
    a8b6:	4897      	ldr	r0, [pc, #604]	; (ab14 <cliFunc_version+0x278>)
    a8b8:	f000 fda2 	bl	b400 <_print>
	printInt16( CLI_RevisionNumber - CLI_VersionRevNumber );
    a8bc:	2000      	movs	r0, #0
    a8be:	f000 fdef 	bl	b4a0 <printInt16>
	print( ":" CLI_VersionRevNumberStr ")" NL );
    a8c2:	4895      	ldr	r0, [pc, #596]	; (ab18 <cliFunc_version+0x27c>)
    a8c4:	f000 fd9c 	bl	b400 <_print>
	print( " \033[1mBranch:\033[0m        " CLI_Branch            NL );
    a8c8:	4894      	ldr	r0, [pc, #592]	; (ab1c <cliFunc_version+0x280>)
    a8ca:	f000 fd99 	bl	b400 <_print>
	print( " \033[1mTree Status:\033[0m   " CLI_ModifiedStatus CLI_ModifiedFiles NL );
    a8ce:	4894      	ldr	r0, [pc, #592]	; (ab20 <cliFunc_version+0x284>)
    a8d0:	f000 fd96 	bl	b400 <_print>
	print( " \033[1mRepo Origin:\033[0m   " CLI_RepoOrigin        NL );
    a8d4:	4893      	ldr	r0, [pc, #588]	; (ab24 <cliFunc_version+0x288>)
    a8d6:	f000 fd93 	bl	b400 <_print>
	print( " \033[1mCommit Date:\033[0m   " CLI_CommitDate        NL );
    a8da:	4893      	ldr	r0, [pc, #588]	; (ab28 <cliFunc_version+0x28c>)
    a8dc:	f000 fd90 	bl	b400 <_print>
	print( " \033[1mCommit Author:\033[0m " CLI_CommitAuthor      NL );
    a8e0:	4892      	ldr	r0, [pc, #584]	; (ab2c <cliFunc_version+0x290>)
    a8e2:	f000 fd8d 	bl	b400 <_print>
	print( " \033[1mBuild Date:\033[0m    " CLI_BuildDate         NL );
    a8e6:	4892      	ldr	r0, [pc, #584]	; (ab30 <cliFunc_version+0x294>)
    a8e8:	f000 fd8a 	bl	b400 <_print>
	print( " \033[1mBuild OS:\033[0m      " CLI_BuildOS           NL );
    a8ec:	4891      	ldr	r0, [pc, #580]	; (ab34 <cliFunc_version+0x298>)
    a8ee:	f000 fd87 	bl	b400 <_print>
	print( " \033[1mCompiler:\033[0m      " CLI_BuildCompiler     NL );
    a8f2:	4891      	ldr	r0, [pc, #580]	; (ab38 <cliFunc_version+0x29c>)
    a8f4:	f000 fd84 	bl	b400 <_print>
	print( " \033[1mArchitecture:\033[0m  " CLI_Arch              NL );
    a8f8:	4890      	ldr	r0, [pc, #576]	; (ab3c <cliFunc_version+0x2a0>)
    a8fa:	f000 fd81 	bl	b400 <_print>
	print( " \033[1mChip Compiled:\033[0m " CLI_ChipShort " (" CLI_Chip ")" NL );
    a8fe:	4890      	ldr	r0, [pc, #576]	; (ab40 <cliFunc_version+0x2a4>)
    a900:	f000 fd7e 	bl	b400 <_print>
	print( " \033[1mCPU:\033[0m           " CLI_CPU               NL );
    a904:	488f      	ldr	r0, [pc, #572]	; (ab44 <cliFunc_version+0x2a8>)
    a906:	f000 fd7b 	bl	b400 <_print>
	print( " \033[1mDevice:\033[0m        " CLI_Device            NL );
    a90a:	488f      	ldr	r0, [pc, #572]	; (ab48 <cliFunc_version+0x2ac>)
    a90c:	f000 fd78 	bl	b400 <_print>
	print( " \033[1mModules:\033[0m       " CLI_Modules           NL );
    a910:	488e      	ldr	r0, [pc, #568]	; (ab4c <cliFunc_version+0x2b0>)
    a912:	f000 fd75 	bl	b400 <_print>
	print( NL );
    a916:	4620      	mov	r0, r4
    a918:	f000 fd72 	bl	b400 <_print>
	print( " \033[1mCPU Detected:\033[0m  " );
    a91c:	488c      	ldr	r0, [pc, #560]	; (ab50 <cliFunc_version+0x2b4>)
    a91e:	f000 fd6f 	bl	b400 <_print>
	print( ChipVersion_lookup() );
    a922:	f7ff ff69 	bl	a7f8 <ChipVersion_lookup>
    a926:	f000 fd6b 	bl	b400 <_print>
	print( NL);
    a92a:	4620      	mov	r0, r4
	printHex32( SCB_CPUID );
    a92c:	4c89      	ldr	r4, [pc, #548]	; (ab54 <cliFunc_version+0x2b8>)
	print( NL);
    a92e:	f000 fd67 	bl	b400 <_print>
	print( " \033[1mCPU Id:\033[0m        " );
    a932:	4889      	ldr	r0, [pc, #548]	; (ab58 <cliFunc_version+0x2bc>)
    a934:	f000 fd64 	bl	b400 <_print>
	printHex32( SCB_CPUID );
    a938:	2101      	movs	r1, #1
    a93a:	6820      	ldr	r0, [r4, #0]
    a93c:	f000 fe40 	bl	b5c0 <printHex32_op>
	print( NL "  (Implementor:");
    a940:	4886      	ldr	r0, [pc, #536]	; (ab5c <cliFunc_version+0x2c0>)
    a942:	f000 fd5d 	bl	b400 <_print>
	print( ChipVersion_cpuid_implementor() );
    a946:	f7ff ff47 	bl	a7d8 <ChipVersion_cpuid_implementor>
    a94a:	f000 fd59 	bl	b400 <_print>
	print( ":" );
    a94e:	4628      	mov	r0, r5
    a950:	f000 fd56 	bl	b400 <_print>
	printHex32( SCB_CPUID_IMPLEMENTOR );
    a954:	2101      	movs	r1, #1
    a956:	78e0      	ldrb	r0, [r4, #3]
    a958:	f000 fe32 	bl	b5c0 <printHex32_op>
	print( ")(Variant:" );
    a95c:	4880      	ldr	r0, [pc, #512]	; (ab60 <cliFunc_version+0x2c4>)
    a95e:	f000 fd4f 	bl	b400 <_print>
	printHex32( SCB_CPUID_VARIANT );
    a962:	6820      	ldr	r0, [r4, #0]
    a964:	2101      	movs	r1, #1
    a966:	f3c0 5003 	ubfx	r0, r0, #20, #4
    a96a:	f000 fe29 	bl	b5c0 <printHex32_op>
	print( ")(Arch:" );
    a96e:	487d      	ldr	r0, [pc, #500]	; (ab64 <cliFunc_version+0x2c8>)
    a970:	f000 fd46 	bl	b400 <_print>
	printHex32( SCB_CPUID_ARCH );
    a974:	8860      	ldrh	r0, [r4, #2]
    a976:	2101      	movs	r1, #1
    a978:	f000 000f 	and.w	r0, r0, #15
    a97c:	f000 fe20 	bl	b5c0 <printHex32_op>
	print( ")(PartNo:" );
    a980:	4879      	ldr	r0, [pc, #484]	; (ab68 <cliFunc_version+0x2cc>)
    a982:	f000 fd3d 	bl	b400 <_print>
	print( ChipVersion_cpuid_partno() );
    a986:	f7ff ff13 	bl	a7b0 <ChipVersion_cpuid_partno>
    a98a:	f000 fd39 	bl	b400 <_print>
	print( ":" );
    a98e:	4628      	mov	r0, r5
    a990:	f000 fd36 	bl	b400 <_print>
	printHex32( SCB_CPUID_PARTNO );
    a994:	6820      	ldr	r0, [r4, #0]
    a996:	2101      	movs	r1, #1
    a998:	f3c0 100b 	ubfx	r0, r0, #4, #12
    a99c:	f000 fe10 	bl	b5c0 <printHex32_op>
	print( ")(Revision:" );
    a9a0:	4872      	ldr	r0, [pc, #456]	; (ab6c <cliFunc_version+0x2d0>)
    a9a2:	f000 fd2d 	bl	b400 <_print>
	printHex32( SCB_CPUID_REVISION );
    a9a6:	6820      	ldr	r0, [r4, #0]

	print( " \033[1mDevice Id:\033[0m     " );
	printHex32( SIM_SDID );
    a9a8:	4c71      	ldr	r4, [pc, #452]	; (ab70 <cliFunc_version+0x2d4>)
	printHex32( SCB_CPUID_REVISION );
    a9aa:	2101      	movs	r1, #1
    a9ac:	f000 000f 	and.w	r0, r0, #15
    a9b0:	f000 fe06 	bl	b5c0 <printHex32_op>
	print( ")" NL );
    a9b4:	4630      	mov	r0, r6
    a9b6:	f000 fd23 	bl	b400 <_print>
	print( " \033[1mDevice Id:\033[0m     " );
    a9ba:	486e      	ldr	r0, [pc, #440]	; (ab74 <cliFunc_version+0x2d8>)
    a9bc:	f000 fd20 	bl	b400 <_print>
	printHex32( SIM_SDID );
    a9c0:	2101      	movs	r1, #1
    a9c2:	6820      	ldr	r0, [r4, #0]
    a9c4:	f000 fdfc 	bl	b5c0 <printHex32_op>
	print( NL "  (Pincount:");
    a9c8:	486b      	ldr	r0, [pc, #428]	; (ab78 <cliFunc_version+0x2dc>)
    a9ca:	f000 fd19 	bl	b400 <_print>
	print( ChipVersion_pincount[ SIM_SDID_PINID ] );
    a9ce:	6823      	ldr	r3, [r4, #0]
    a9d0:	4a6a      	ldr	r2, [pc, #424]	; (ab7c <cliFunc_version+0x2e0>)
    a9d2:	f003 030f 	and.w	r3, r3, #15
    a9d6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    a9da:	f000 fd11 	bl	b400 <_print>
	print( ":" );
    a9de:	4628      	mov	r0, r5
    a9e0:	f000 fd0e 	bl	b400 <_print>
	printHex32( SIM_SDID_PINID );
    a9e4:	6820      	ldr	r0, [r4, #0]
    a9e6:	2101      	movs	r1, #1
    a9e8:	f000 000f 	and.w	r0, r0, #15
    a9ec:	f000 fde8 	bl	b5c0 <printHex32_op>
	print( ")(Family:" );
    a9f0:	4863      	ldr	r0, [pc, #396]	; (ab80 <cliFunc_version+0x2e4>)
    a9f2:	f000 fd05 	bl	b400 <_print>
	print( ChipVersion_familyid[ SIM_SDID_FAMID ] );
    a9f6:	6823      	ldr	r3, [r4, #0]
    a9f8:	4a62      	ldr	r2, [pc, #392]	; (ab84 <cliFunc_version+0x2e8>)
    a9fa:	f3c3 1302 	ubfx	r3, r3, #4, #3
    a9fe:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    aa02:	f000 fcfd 	bl	b400 <_print>
	print( ":" );
    aa06:	4628      	mov	r0, r5
    aa08:	f000 fcfa 	bl	b400 <_print>
	printHex32( SIM_SDID_FAMID );
    aa0c:	6820      	ldr	r0, [r4, #0]
    aa0e:	2101      	movs	r1, #1
    aa10:	f3c0 1002 	ubfx	r0, r0, #4, #3
    aa14:	f000 fdd4 	bl	b5c0 <printHex32_op>
	print( ")(Die:" );
    aa18:	485b      	ldr	r0, [pc, #364]	; (ab88 <cliFunc_version+0x2ec>)
    aa1a:	f000 fcf1 	bl	b400 <_print>
	printHex32( SIM_SDID_DIEID );
    aa1e:	6820      	ldr	r0, [r4, #0]
    aa20:	2101      	movs	r1, #1
    aa22:	f3c0 10c4 	ubfx	r0, r0, #7, #5
    aa26:	f000 fdcb 	bl	b5c0 <printHex32_op>
	print( ")(Rev:" );
    aa2a:	4858      	ldr	r0, [pc, #352]	; (ab8c <cliFunc_version+0x2f0>)
    aa2c:	f000 fce8 	bl	b400 <_print>
	printHex32( SIM_SDID_REVID );
    aa30:	6820      	ldr	r0, [r4, #0]
    aa32:	2101      	movs	r1, #1
    aa34:	f3c0 3003 	ubfx	r0, r0, #12, #4
    aa38:	f000 fdc2 	bl	b5c0 <printHex32_op>
	print( ")" NL );
    aa3c:	4630      	mov	r0, r6
    aa3e:	f000 fcdf 	bl	b400 <_print>

	print( " \033[1mFlash Cfg:\033[0m     " );
    aa42:	4853      	ldr	r0, [pc, #332]	; (ab90 <cliFunc_version+0x2f4>)
    aa44:	f000 fcdc 	bl	b400 <_print>
	printHex32( SIM_FCFG1 & 0xFFFFFFF0 );
    aa48:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    aa4a:	2101      	movs	r1, #1
    aa4c:	f020 000f 	bic.w	r0, r0, #15
    aa50:	f000 fdb6 	bl	b5c0 <printHex32_op>
	print( NL "  (FlexNVM:" );
    aa54:	484f      	ldr	r0, [pc, #316]	; (ab94 <cliFunc_version+0x2f8>)
    aa56:	f000 fcd3 	bl	b400 <_print>
	printInt16( ChipVersion_nvmsize[ SIM_FCFG1_NVMSIZE ] );
    aa5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    aa5c:	4a4e      	ldr	r2, [pc, #312]	; (ab98 <cliFunc_version+0x2fc>)
    aa5e:	0f1b      	lsrs	r3, r3, #28
    aa60:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    aa64:	f000 fd1c 	bl	b4a0 <printInt16>
	print( "kB)(PFlash:" );
    aa68:	484c      	ldr	r0, [pc, #304]	; (ab9c <cliFunc_version+0x300>)
    aa6a:	f000 fcc9 	bl	b400 <_print>
	printInt16( ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ] );
    aa6e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
    aa72:	4a4b      	ldr	r2, [pc, #300]	; (aba0 <cliFunc_version+0x304>)
    aa74:	f003 030f 	and.w	r3, r3, #15
    aa78:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    aa7c:	f000 fd10 	bl	b4a0 <printInt16>
	print( "kB)(EEPROM:" );
    aa80:	4848      	ldr	r0, [pc, #288]	; (aba4 <cliFunc_version+0x308>)
    aa82:	f000 fcbd 	bl	b400 <_print>
	printInt16( ChipVersion_eepromsize[ SIM_FCFG1_EESIZE ] );
    aa86:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    aa88:	4a47      	ldr	r2, [pc, #284]	; (aba8 <cliFunc_version+0x30c>)
    aa8a:	f003 030f 	and.w	r3, r3, #15
    aa8e:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    aa92:	f000 fd05 	bl	b4a0 <printInt16>
	print( ")(DEPART:" );
    aa96:	4845      	ldr	r0, [pc, #276]	; (abac <cliFunc_version+0x310>)
    aa98:	f000 fcb2 	bl	b400 <_print>
	printHex32( SIM_FCFG1_DEPART );
    aa9c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    aa9e:	2101      	movs	r1, #1
    aaa0:	f3c0 2003 	ubfx	r0, r0, #8, #4
    aaa4:	f000 fd8c 	bl	b5c0 <printHex32_op>
	print( ")" NL );
    aaa8:	4630      	mov	r0, r6
    aaaa:	f000 fca9 	bl	b400 <_print>

	print( " \033[1mRAM:\033[0m           ");
    aaae:	4840      	ldr	r0, [pc, #256]	; (abb0 <cliFunc_version+0x314>)
    aab0:	f000 fca6 	bl	b400 <_print>
	printInt16( ChipVersion_ramsize[ SIM_SOPT1_RAMSIZE ] );
    aab4:	4b3f      	ldr	r3, [pc, #252]	; (abb4 <cliFunc_version+0x318>)
    aab6:	4a40      	ldr	r2, [pc, #256]	; (abb8 <cliFunc_version+0x31c>)
    aab8:	681b      	ldr	r3, [r3, #0]
    aaba:	f3c3 3303 	ubfx	r3, r3, #12, #4
    aabe:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    aac2:	f000 fced 	bl	b4a0 <printInt16>
	print( " kB" NL );
    aac6:	483d      	ldr	r0, [pc, #244]	; (abbc <cliFunc_version+0x320>)
    aac8:	f000 fc9a 	bl	b400 <_print>

	print( " \033[1mUnique Id:\033[0m     " );
    aacc:	483c      	ldr	r0, [pc, #240]	; (abc0 <cliFunc_version+0x324>)
    aace:	f000 fc97 	bl	b400 <_print>
	printHex32_op( SIM_UIDH, 8 );
    aad2:	4b3c      	ldr	r3, [pc, #240]	; (abc4 <cliFunc_version+0x328>)
    aad4:	2108      	movs	r1, #8
    aad6:	6818      	ldr	r0, [r3, #0]
    aad8:	f000 fd72 	bl	b5c0 <printHex32_op>
	printHex32_op( SIM_UIDMH, 8 );
    aadc:	4b3a      	ldr	r3, [pc, #232]	; (abc8 <cliFunc_version+0x32c>)
    aade:	2108      	movs	r1, #8
    aae0:	6818      	ldr	r0, [r3, #0]
    aae2:	f000 fd6d 	bl	b5c0 <printHex32_op>
	printHex32_op( SIM_UIDML, 8 );
    aae6:	4b39      	ldr	r3, [pc, #228]	; (abcc <cliFunc_version+0x330>)
    aae8:	2108      	movs	r1, #8
    aaea:	6818      	ldr	r0, [r3, #0]
    aaec:	f000 fd68 	bl	b5c0 <printHex32_op>
	printHex32_op( SIM_UIDL, 8 );
    aaf0:	4b37      	ldr	r3, [pc, #220]	; (abd0 <cliFunc_version+0x334>)
    aaf2:	2108      	movs	r1, #8
    aaf4:	6818      	ldr	r0, [r3, #0]
#elif defined(_avr_at_)
#elif defined(_host_)
#else
#warning "No unique id defined."
#endif
}
    aaf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	printHex32_op( SIM_UIDL, 8 );
    aafa:	f000 bd61 	b.w	b5c0 <printHex32_op>
    aafe:	bf00      	nop
    ab00:	00010d99 	.word	0x00010d99
    ab04:	0000f857 	.word	0x0000f857
    ab08:	000113bd 	.word	0x000113bd
    ab0c:	00011338 	.word	0x00011338
    ab10:	0001137b 	.word	0x0001137b
    ab14:	00011398 	.word	0x00011398
    ab18:	000113ba 	.word	0x000113ba
    ab1c:	000113c1 	.word	0x000113c1
    ab20:	000113e2 	.word	0x000113e2
    ab24:	00011c2f 	.word	0x00011c2f
    ab28:	00011c6b 	.word	0x00011c6b
    ab2c:	00011c9f 	.word	0x00011c9f
    ab30:	00011cde 	.word	0x00011cde
    ab34:	00011d12 	.word	0x00011d12
    ab38:	00011d3d 	.word	0x00011d3d
    ab3c:	00011d78 	.word	0x00011d78
    ab40:	00011d96 	.word	0x00011d96
    ab44:	00011dca 	.word	0x00011dca
    ab48:	00011dee 	.word	0x00011dee
    ab4c:	00011e11 	.word	0x00011e11
    ab50:	00011e6a 	.word	0x00011e6a
    ab54:	e000ed00 	.word	0xe000ed00
    ab58:	00011e83 	.word	0x00011e83
    ab5c:	00011e9c 	.word	0x00011e9c
    ab60:	00011eae 	.word	0x00011eae
    ab64:	00011eb9 	.word	0x00011eb9
    ab68:	00011ec1 	.word	0x00011ec1
    ab6c:	00011ecb 	.word	0x00011ecb
    ab70:	40048024 	.word	0x40048024
    ab74:	00011ed7 	.word	0x00011ed7
    ab78:	00011ef0 	.word	0x00011ef0
    ab7c:	1fff9114 	.word	0x1fff9114
    ab80:	00011eff 	.word	0x00011eff
    ab84:	1fff90f4 	.word	0x1fff90f4
    ab88:	00011f09 	.word	0x00011f09
    ab8c:	00011f10 	.word	0x00011f10
    ab90:	00011f17 	.word	0x00011f17
    ab94:	00011f30 	.word	0x00011f30
    ab98:	0001102c 	.word	0x0001102c
    ab9c:	00011f3e 	.word	0x00011f3e
    aba0:	0001104a 	.word	0x0001104a
    aba4:	00011f4a 	.word	0x00011f4a
    aba8:	00010f8a 	.word	0x00010f8a
    abac:	00011f56 	.word	0x00011f56
    abb0:	00011f60 	.word	0x00011f60
    abb4:	40047000 	.word	0x40047000
    abb8:	0001106a 	.word	0x0001106a
    abbc:	00011f79 	.word	0x00011f79
    abc0:	00011f7f 	.word	0x00011f7f
    abc4:	40048054 	.word	0x40048054
    abc8:	40048058 	.word	0x40048058
    abcc:	4004805c 	.word	0x4004805c
    abd0:	40048060 	.word	0x40048060

0000abd4 <prompt>:
{
    abd4:	b508      	push	{r3, lr}
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    abd6:	4804      	ldr	r0, [pc, #16]	; (abe8 <prompt+0x14>)
    abd8:	f000 fc12 	bl	b400 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    abdc:	4803      	ldr	r0, [pc, #12]	; (abec <prompt+0x18>)
}
    abde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    abe2:	f000 bc0d 	b.w	b400 <_print>
    abe6:	bf00      	nop
    abe8:	0001212e 	.word	0x0001212e
    abec:	00012134 	.word	0x00012134

0000abf0 <CLI_argumentIsolation>:
{
    abf0:	b530      	push	{r4, r5, lr}
	char* cmdPtr = string - 1;
    abf2:	3801      	subs	r0, #1
	while ( *++cmdPtr == ' ' ); // Skips leading spaces, and points to first character of cmd
    abf4:	7843      	ldrb	r3, [r0, #1]
    abf6:	2b20      	cmp	r3, #32
    abf8:	f100 0501 	add.w	r5, r0, #1
    abfc:	d00a      	beq.n	ac14 <CLI_argumentIsolation+0x24>
	char* argPtr = cmdPtr + 1;
    abfe:	3002      	adds	r0, #2
	while ( *argPtr != ' ' && *argPtr != '\0' )
    ac00:	7803      	ldrb	r3, [r0, #0]
    ac02:	f013 03df 	ands.w	r3, r3, #223	; 0xdf
    ac06:	f100 0401 	add.w	r4, r0, #1
    ac0a:	d105      	bne.n	ac18 <CLI_argumentIsolation+0x28>
	(++argPtr)[-1] = '\0';
    ac0c:	7003      	strb	r3, [r0, #0]
	*first = cmdPtr;
    ac0e:	600d      	str	r5, [r1, #0]
	*second = argPtr;
    ac10:	6014      	str	r4, [r2, #0]
}
    ac12:	bd30      	pop	{r4, r5, pc}
    ac14:	4628      	mov	r0, r5
    ac16:	e7ed      	b.n	abf4 <CLI_argumentIsolation+0x4>
    ac18:	4620      	mov	r0, r4
    ac1a:	e7f1      	b.n	ac00 <CLI_argumentIsolation+0x10>

0000ac1c <cliFunc_periodic>:
{
    ac1c:	b507      	push	{r0, r1, r2, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    ac1e:	aa01      	add	r2, sp, #4
    ac20:	4669      	mov	r1, sp
    ac22:	f7ff ffe5 	bl	abf0 <CLI_argumentIsolation>
	print( NL );
    ac26:	480a      	ldr	r0, [pc, #40]	; (ac50 <cliFunc_periodic+0x34>)
    ac28:	f000 fbea 	bl	b400 <_print>
	if ( arg1Ptr[0] != '\0' )
    ac2c:	9800      	ldr	r0, [sp, #0]
    ac2e:	7803      	ldrb	r3, [r0, #0]
    ac30:	b11b      	cbz	r3, ac3a <cliFunc_periodic+0x1e>
		uint32_t cycles = (uint32_t)numToInt( arg1Ptr );
    ac32:	f000 fcf8 	bl	b626 <numToInt>
		Periodic_init( cycles );
    ac36:	f7f7 fe4f 	bl	28d8 <Periodic_init>
	info_msg("Period Clock Cycles: ");
    ac3a:	4806      	ldr	r0, [pc, #24]	; (ac54 <cliFunc_periodic+0x38>)
    ac3c:	f000 fbe0 	bl	b400 <_print>
	printInt32( Periodic_cycles() );
    ac40:	f7f7 fe7c 	bl	293c <Periodic_cycles>
    ac44:	f000 fc4b 	bl	b4de <printInt32>
}
    ac48:	b003      	add	sp, #12
    ac4a:	f85d fb04 	ldr.w	pc, [sp], #4
    ac4e:	bf00      	nop
    ac50:	00010d99 	.word	0x00010d99
    ac54:	00011266 	.word	0x00011266

0000ac58 <CLI_commandLookup>:
{
    ac58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if ( CLILineBufferCurrent == 0 )
    ac5c:	4b24      	ldr	r3, [pc, #144]	; (acf0 <CLI_commandLookup+0x98>)
    ac5e:	781b      	ldrb	r3, [r3, #0]
{
    ac60:	b089      	sub	sp, #36	; 0x24
	if ( CLILineBufferCurrent == 0 )
    ac62:	2b00      	cmp	r3, #0
    ac64:	d035      	beq.n	acd2 <CLI_commandLookup+0x7a>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ac66:	4d23      	ldr	r5, [pc, #140]	; (acf4 <CLI_commandLookup+0x9c>)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ac68:	f8df a0b0 	ldr.w	sl, [pc, #176]	; ad1c <CLI_commandLookup+0xc4>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ac6c:	f8df 80b0 	ldr.w	r8, [pc, #176]	; ad20 <CLI_commandLookup+0xc8>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ac70:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ac72:	aa07      	add	r2, sp, #28
    ac74:	a906      	add	r1, sp, #24
    ac76:	4628      	mov	r0, r5
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ac78:	54ec      	strb	r4, [r5, r3]
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ac7a:	f7ff ffb9 	bl	abf0 <CLI_argumentIsolation>
    ac7e:	46a9      	mov	r9, r5
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ac80:	f04f 0b0c 	mov.w	fp, #12
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ac84:	f89a 3000 	ldrb.w	r3, [sl]
    ac88:	b2e6      	uxtb	r6, r4
    ac8a:	42b3      	cmp	r3, r6
    ac8c:	d824      	bhi.n	acd8 <CLI_commandLookup+0x80>
	print( NL );
    ac8e:	4c1a      	ldr	r4, [pc, #104]	; (acf8 <CLI_commandLookup+0xa0>)
    ac90:	4620      	mov	r0, r4
    ac92:	f000 fbb5 	bl	b400 <_print>
	erro_dPrint("\"", CLILineBuffer, "\" is not a valid command...type \033[35mhelp\033[0m");
    ac96:	4b19      	ldr	r3, [pc, #100]	; (acfc <CLI_commandLookup+0xa4>)
    ac98:	4a19      	ldr	r2, [pc, #100]	; (ad00 <CLI_commandLookup+0xa8>)
    ac9a:	491a      	ldr	r1, [pc, #104]	; (ad04 <CLI_commandLookup+0xac>)
    ac9c:	481a      	ldr	r0, [pc, #104]	; (ad08 <CLI_commandLookup+0xb0>)
    ac9e:	e9cd 4304 	strd	r4, r3, [sp, #16]
    aca2:	4b1a      	ldr	r3, [pc, #104]	; (ad0c <CLI_commandLookup+0xb4>)
    aca4:	e9cd 9302 	strd	r9, r3, [sp, #8]
    aca8:	4b19      	ldr	r3, [pc, #100]	; (ad10 <CLI_commandLookup+0xb8>)
    acaa:	9301      	str	r3, [sp, #4]
    acac:	4b19      	ldr	r3, [pc, #100]	; (ad14 <CLI_commandLookup+0xbc>)
    acae:	9300      	str	r3, [sp, #0]
    acb0:	4b19      	ldr	r3, [pc, #100]	; (ad18 <CLI_commandLookup+0xc0>)
    acb2:	f000 fb8d 	bl	b3d0 <printstrs>
    acb6:	e00c      	b.n	acd2 <CLI_commandLookup+0x7a>
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == -1 )
    acb8:	9806      	ldr	r0, [sp, #24]
    acba:	f000 fca0 	bl	b5fe <eqStr>
    acbe:	3001      	adds	r0, #1
    acc0:	f107 0701 	add.w	r7, r7, #1
    acc4:	d109      	bne.n	acda <CLI_commandLookup+0x82>
				(*(void (*)(char*))CLIDict[dict][cmd].function)( argPtr );
    acc6:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
    acca:	9807      	ldr	r0, [sp, #28]
    accc:	441d      	add	r5, r3
    acce:	68ab      	ldr	r3, [r5, #8]
    acd0:	4798      	blx	r3
}
    acd2:	b009      	add	sp, #36	; 0x24
    acd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    acd8:	2700      	movs	r7, #0
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    acda:	b2fd      	uxtb	r5, r7
    acdc:	fb0b f505 	mul.w	r5, fp, r5
    ace0:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
    ace4:	5959      	ldr	r1, [r3, r5]
    ace6:	2900      	cmp	r1, #0
    ace8:	d1e6      	bne.n	acb8 <CLI_commandLookup+0x60>
    acea:	3401      	adds	r4, #1
    acec:	e7ca      	b.n	ac84 <CLI_commandLookup+0x2c>
    acee:	bf00      	nop
    acf0:	1fff9b28 	.word	0x1fff9b28
    acf4:	1fff9a6c 	.word	0x1fff9a6c
    acf8:	00010d99 	.word	0x00010d99
    acfc:	00010e85 	.word	0x00010e85
    ad00:	0000de79 	.word	0x0000de79
    ad04:	00010e8f 	.word	0x00010e8f
    ad08:	00010e96 	.word	0x00010e96
    ad0c:	00010e99 	.word	0x00010e99
    ad10:	00010ec7 	.word	0x00010ec7
    ad14:	0000caec 	.word	0x0000caec
    ad18:	00010e89 	.word	0x00010e89
    ad1c:	1fff9683 	.word	0x1fff9683
    ad20:	1fff9ad4 	.word	0x1fff9ad4

0000ad24 <CLI_registerDictionary>:
{
    ad24:	b410      	push	{r4}
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    ad26:	4a09      	ldr	r2, [pc, #36]	; (ad4c <CLI_registerDictionary+0x28>)
    ad28:	7813      	ldrb	r3, [r2, #0]
    ad2a:	2b09      	cmp	r3, #9
    ad2c:	d903      	bls.n	ad36 <CLI_registerDictionary+0x12>
		erro_print("Max number of dictionaries defined already...");
    ad2e:	4808      	ldr	r0, [pc, #32]	; (ad50 <CLI_registerDictionary+0x2c>)
}
    ad30:	bc10      	pop	{r4}
		erro_print("Max number of dictionaries defined already...");
    ad32:	f000 bb65 	b.w	b400 <_print>
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
    ad36:	4c07      	ldr	r4, [pc, #28]	; (ad54 <CLI_registerDictionary+0x30>)
    ad38:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    ad3c:	1c59      	adds	r1, r3, #1
    ad3e:	7011      	strb	r1, [r2, #0]
    ad40:	4a05      	ldr	r2, [pc, #20]	; (ad58 <CLI_registerDictionary+0x34>)
}
    ad42:	bc10      	pop	{r4}
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    ad44:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    ad48:	4770      	bx	lr
    ad4a:	bf00      	nop
    ad4c:	1fff9683 	.word	0x1fff9683
    ad50:	00010f33 	.word	0x00010f33
    ad54:	1fff9b00 	.word	0x1fff9b00
    ad58:	1fff9ad4 	.word	0x1fff9ad4

0000ad5c <CLI_init>:
	CLILineBufferCurrent = 0;
    ad5c:	4b0c      	ldr	r3, [pc, #48]	; (ad90 <CLI_init+0x34>)
{
    ad5e:	b510      	push	{r4, lr}
	CLILineBufferCurrent = 0;
    ad60:	2400      	movs	r4, #0
    ad62:	701c      	strb	r4, [r3, #0]
	CLIHistoryHead = 0;
    ad64:	4b0b      	ldr	r3, [pc, #44]	; (ad94 <CLI_init+0x38>)
    ad66:	701c      	strb	r4, [r3, #0]
	CLIHistoryCurrent = 0;
    ad68:	4b0b      	ldr	r3, [pc, #44]	; (ad98 <CLI_init+0x3c>)
    ad6a:	701c      	strb	r4, [r3, #0]
	CLIHistoryTail = 0;
    ad6c:	4b0b      	ldr	r3, [pc, #44]	; (ad9c <CLI_init+0x40>)
    ad6e:	701c      	strb	r4, [r3, #0]
	prompt();
    ad70:	f7ff ff30 	bl	abd4 <prompt>
	CLIDictionariesUsed = 0;
    ad74:	4b0a      	ldr	r3, [pc, #40]	; (ada0 <CLI_init+0x44>)
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    ad76:	490b      	ldr	r1, [pc, #44]	; (ada4 <CLI_init+0x48>)
    ad78:	480b      	ldr	r0, [pc, #44]	; (ada8 <CLI_init+0x4c>)
	CLIDictionariesUsed = 0;
    ad7a:	701c      	strb	r4, [r3, #0]
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    ad7c:	f7ff ffd2 	bl	ad24 <CLI_registerDictionary>
	init_errorLED();
    ad80:	f000 fb0a 	bl	b398 <init_errorLED>
	CLILEDState = 0;
    ad84:	4b09      	ldr	r3, [pc, #36]	; (adac <CLI_init+0x50>)
    ad86:	701c      	strb	r4, [r3, #0]
	CLIHexDebugMode = 0;
    ad88:	4b09      	ldr	r3, [pc, #36]	; (adb0 <CLI_init+0x54>)
    ad8a:	701c      	strb	r4, [r3, #0]
}
    ad8c:	bd10      	pop	{r4, pc}
    ad8e:	bf00      	nop
    ad90:	1fff9b28 	.word	0x1fff9b28
    ad94:	1fff9ad1 	.word	0x1fff9ad1
    ad98:	1fff9681 	.word	0x1fff9681
    ad9c:	1fff9afc 	.word	0x1fff9afc
    ada0:	1fff9683 	.word	0x1fff9683
    ada4:	00011134 	.word	0x00011134
    ada8:	0001108c 	.word	0x0001108c
    adac:	1fff9682 	.word	0x1fff9682
    adb0:	1fff9680 	.word	0x1fff9680

0000adb4 <CLI_tabCompletion>:
{
    adb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if ( CLILineBufferCurrent == 0 )
    adb8:	4e28      	ldr	r6, [pc, #160]	; (ae5c <CLI_tabCompletion+0xa8>)
    adba:	7833      	ldrb	r3, [r6, #0]
{
    adbc:	b087      	sub	sp, #28
	if ( CLILineBufferCurrent == 0 )
    adbe:	b31b      	cbz	r3, ae08 <CLI_tabCompletion+0x54>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    adc0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; ae64 <CLI_tabCompletion+0xb0>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    adc4:	f8df b0a0 	ldr.w	fp, [pc, #160]	; ae68 <CLI_tabCompletion+0xb4>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    adc8:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    adca:	aa05      	add	r2, sp, #20
    adcc:	a904      	add	r1, sp, #16
    adce:	4640      	mov	r0, r8
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    add0:	f808 4003 	strb.w	r4, [r8, r3]
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    add4:	f7ff ff0c 	bl	abf0 <CLI_argumentIsolation>
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    add8:	4b21      	ldr	r3, [pc, #132]	; (ae60 <CLI_tabCompletion+0xac>)
    adda:	f8cd 8004 	str.w	r8, [sp, #4]
	uint8_t matches = 0;
    adde:	4627      	mov	r7, r4
	char* tabMatch = 0;
    ade0:	4625      	mov	r5, r4
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ade2:	220c      	movs	r2, #12
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ade4:	7819      	ldrb	r1, [r3, #0]
    ade6:	fa5f f984 	uxtb.w	r9, r4
    adea:	4549      	cmp	r1, r9
    adec:	d82b      	bhi.n	ae46 <CLI_tabCompletion+0x92>
	if ( matches == 1 )
    adee:	2f01      	cmp	r7, #1
    adf0:	d10a      	bne.n	ae08 <CLI_tabCompletion+0x54>
		CLILineBufferCurrent = 0;
    adf2:	2300      	movs	r3, #0
    adf4:	7033      	strb	r3, [r6, #0]
		prompt();
    adf6:	f7ff feed 	bl	abd4 <prompt>
		dPrint( tabMatch );
    adfa:	4628      	mov	r0, r5
    adfc:	f7fd fec7 	bl	8b8e <Output_putstr>
    ae00:	3d01      	subs	r5, #1
		while ( *tabMatch != '\0' )
    ae02:	f815 3f01 	ldrb.w	r3, [r5, #1]!
    ae06:	bb0b      	cbnz	r3, ae4c <CLI_tabCompletion+0x98>
}
    ae08:	b007      	add	sp, #28
    ae0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
    ae0e:	9804      	ldr	r0, [sp, #16]
    ae10:	e9cd 3202 	strd	r3, r2, [sp, #8]
    ae14:	f000 fbf3 	bl	b5fe <eqStr>
    ae18:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    ae1c:	b928      	cbnz	r0, ae2a <CLI_tabCompletion+0x76>
				tabMatch = (char*)CLIDict[dict][cmd].name;
    ae1e:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
				matches++;
    ae22:	3701      	adds	r7, #1
				tabMatch = (char*)CLIDict[dict][cmd].name;
    ae24:	f851 5008 	ldr.w	r5, [r1, r8]
				matches++;
    ae28:	b2ff      	uxtb	r7, r7
    ae2a:	f10a 0a01 	add.w	sl, sl, #1
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ae2e:	fa5f f88a 	uxtb.w	r8, sl
    ae32:	fb02 f808 	mul.w	r8, r2, r8
    ae36:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
    ae3a:	f851 1008 	ldr.w	r1, [r1, r8]
    ae3e:	2900      	cmp	r1, #0
    ae40:	d1e5      	bne.n	ae0e <CLI_tabCompletion+0x5a>
    ae42:	3401      	adds	r4, #1
    ae44:	e7ce      	b.n	ade4 <CLI_tabCompletion+0x30>
    ae46:	f04f 0a00 	mov.w	sl, #0
    ae4a:	e7f0      	b.n	ae2e <CLI_tabCompletion+0x7a>
			CLILineBuffer[CLILineBufferCurrent++] = *tabMatch++;
    ae4c:	7833      	ldrb	r3, [r6, #0]
    ae4e:	9901      	ldr	r1, [sp, #4]
    ae50:	1c5a      	adds	r2, r3, #1
    ae52:	7032      	strb	r2, [r6, #0]
    ae54:	782a      	ldrb	r2, [r5, #0]
    ae56:	54ca      	strb	r2, [r1, r3]
    ae58:	e7d3      	b.n	ae02 <CLI_tabCompletion+0x4e>
    ae5a:	bf00      	nop
    ae5c:	1fff9b28 	.word	0x1fff9b28
    ae60:	1fff9683 	.word	0x1fff9683
    ae64:	1fff9a6c 	.word	0x1fff9a6c
    ae68:	1fff9ad4 	.word	0x1fff9ad4

0000ae6c <CLI_wrap>:
	if ( kX < kLowerBound )
    ae6c:	4281      	cmp	r1, r0
	int range_size = kUpperBound - kLowerBound + 1;
    ae6e:	eba2 0201 	sub.w	r2, r2, r1
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    ae72:	bfc8      	it	gt
    ae74:	1a0b      	subgt	r3, r1, r0
	int range_size = kUpperBound - kLowerBound + 1;
    ae76:	f102 0201 	add.w	r2, r2, #1
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    ae7a:	bfc2      	ittt	gt
    ae7c:	fb93 f3f2 	sdivgt	r3, r3, r2
    ae80:	fb03 2302 	mlagt	r3, r3, r2, r2
    ae84:	18c0      	addgt	r0, r0, r3
	return kLowerBound + (kX - kLowerBound) % range_size;
    ae86:	1a40      	subs	r0, r0, r1
    ae88:	fb90 f3f2 	sdiv	r3, r0, r2
    ae8c:	fb02 0013 	mls	r0, r2, r3, r0
}
    ae90:	4408      	add	r0, r1
    ae92:	4770      	bx	lr

0000ae94 <CLI_saveHistory>:
{
    ae94:	b510      	push	{r4, lr}
	if ( buff == NULL )
    ae96:	b1a8      	cbz	r0, aec4 <CLI_saveHistory+0x30>
    ae98:	3801      	subs	r0, #1
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
    ae9a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    ae9e:	2b20      	cmp	r3, #32
    aea0:	d0fb      	beq.n	ae9a <CLI_saveHistory+0x6>
        if (*cursor == '\0') { return ; }
    aea2:	b1ab      	cbz	r3, aed0 <CLI_saveHistory+0x3c>
	for (i = 0; i < CLILineBufferCurrent; i++)
    aea4:	4b0b      	ldr	r3, [pc, #44]	; (aed4 <CLI_saveHistory+0x40>)
    aea6:	7819      	ldrb	r1, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    aea8:	4b0b      	ldr	r3, [pc, #44]	; (aed8 <CLI_saveHistory+0x44>)
    aeaa:	7818      	ldrb	r0, [r3, #0]
    aeac:	4b0b      	ldr	r3, [pc, #44]	; (aedc <CLI_saveHistory+0x48>)
    aeae:	2264      	movs	r2, #100	; 0x64
    aeb0:	fb00 3202 	mla	r2, r0, r2, r3
    aeb4:	480a      	ldr	r0, [pc, #40]	; (aee0 <CLI_saveHistory+0x4c>)
	for (i = 0; i < CLILineBufferCurrent; i++)
    aeb6:	2300      	movs	r3, #0
    aeb8:	428b      	cmp	r3, r1
    aeba:	da09      	bge.n	aed0 <CLI_saveHistory+0x3c>
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    aebc:	5c1c      	ldrb	r4, [r3, r0]
    aebe:	54d4      	strb	r4, [r2, r3]
	for (i = 0; i < CLILineBufferCurrent; i++)
    aec0:	3301      	adds	r3, #1
    aec2:	e7f9      	b.n	aeb8 <CLI_saveHistory+0x24>
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    aec4:	4b04      	ldr	r3, [pc, #16]	; (aed8 <CLI_saveHistory+0x44>)
    aec6:	781a      	ldrb	r2, [r3, #0]
    aec8:	2364      	movs	r3, #100	; 0x64
    aeca:	4353      	muls	r3, r2
    aecc:	4a03      	ldr	r2, [pc, #12]	; (aedc <CLI_saveHistory+0x48>)
    aece:	54d0      	strb	r0, [r2, r3]
}
    aed0:	bd10      	pop	{r4, pc}
    aed2:	bf00      	nop
    aed4:	1fff9b28 	.word	0x1fff9b28
    aed8:	1fff9afc 	.word	0x1fff9afc
    aedc:	1fff9684 	.word	0x1fff9684
    aee0:	1fff9a6c 	.word	0x1fff9a6c

0000aee4 <CLI_retreiveHistory>:
	char *histMatch = CLIHistoryBuffer[ index ];
    aee4:	4b0d      	ldr	r3, [pc, #52]	; (af1c <CLI_retreiveHistory+0x38>)
{
    aee6:	b570      	push	{r4, r5, r6, lr}
	CLILineBufferCurrent = 0;
    aee8:	4d0d      	ldr	r5, [pc, #52]	; (af20 <CLI_retreiveHistory+0x3c>)
	char *histMatch = CLIHistoryBuffer[ index ];
    aeea:	2664      	movs	r6, #100	; 0x64
    aeec:	fb06 3600 	mla	r6, r6, r0, r3
	CLILineBufferCurrent = 0;
    aef0:	2400      	movs	r4, #0
    aef2:	702c      	strb	r4, [r5, #0]
	prompt();
    aef4:	f7ff fe6e 	bl	abd4 <prompt>
	dPrint( histMatch );
    aef8:	4630      	mov	r0, r6
    aefa:	f7fd fe48 	bl	8b8e <Output_putstr>
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    aefe:	4809      	ldr	r0, [pc, #36]	; (af24 <CLI_retreiveHistory+0x40>)
	CLILineBufferCurrent = 0;
    af00:	702c      	strb	r4, [r5, #0]
	while ( *histMatch != '\0' )
    af02:	4632      	mov	r2, r6
    af04:	1b93      	subs	r3, r2, r6
    af06:	f812 1b01 	ldrb.w	r1, [r2], #1
    af0a:	b2db      	uxtb	r3, r3
    af0c:	b911      	cbnz	r1, af14 <CLI_retreiveHistory+0x30>
    af0e:	b104      	cbz	r4, af12 <CLI_retreiveHistory+0x2e>
    af10:	702b      	strb	r3, [r5, #0]
}
    af12:	bd70      	pop	{r4, r5, r6, pc}
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    af14:	54c1      	strb	r1, [r0, r3]
    af16:	2401      	movs	r4, #1
    af18:	e7f4      	b.n	af04 <CLI_retreiveHistory+0x20>
    af1a:	bf00      	nop
    af1c:	1fff9684 	.word	0x1fff9684
    af20:	1fff9b28 	.word	0x1fff9b28
    af24:	1fff9a6c 	.word	0x1fff9a6c

0000af28 <CLI_process>:
{
    af28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    af2c:	4c72      	ldr	r4, [pc, #456]	; (b0f8 <CLI_process+0x1d0>)
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    af2e:	4e73      	ldr	r6, [pc, #460]	; (b0fc <CLI_process+0x1d4>)
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    af30:	7825      	ldrb	r5, [r4, #0]
		if ( Output_availablechar() == 0 )
    af32:	f7fd fe28 	bl	8b86 <Output_availablechar>
    af36:	b1b0      	cbz	r0, af66 <CLI_process+0x3e>
		char cur_char = (char)Output_getchar();
    af38:	f7fd fe27 	bl	8b8a <Output_getchar>
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    af3c:	7823      	ldrb	r3, [r4, #0]
    af3e:	2b63      	cmp	r3, #99	; 0x63
		char cur_char = (char)Output_getchar();
    af40:	b2c0      	uxtb	r0, r0
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    af42:	d90c      	bls.n	af5e <CLI_process+0x36>
			print( NL );
    af44:	486e      	ldr	r0, [pc, #440]	; (b100 <CLI_process+0x1d8>)
    af46:	f000 fa5b 	bl	b400 <_print>
			erro_print("Serial line buffer is full, dropping character and resetting...");
    af4a:	486e      	ldr	r0, [pc, #440]	; (b104 <CLI_process+0x1dc>)
    af4c:	f000 fa58 	bl	b400 <_print>
			CLILineBufferCurrent = 0;
    af50:	2300      	movs	r3, #0
    af52:	7023      	strb	r3, [r4, #0]
			prompt();
    af54:	f7ff fe3e 	bl	abd4 <prompt>
}
    af58:	2000      	movs	r0, #0
    af5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    af5e:	1c5a      	adds	r2, r3, #1
    af60:	7022      	strb	r2, [r4, #0]
    af62:	54f0      	strb	r0, [r6, r3]
	{
    af64:	e7e5      	b.n	af32 <CLI_process+0xa>
	if ( CLIHexDebugMode && CLILineBufferCurrent > prev_buf_pos )
    af66:	4b68      	ldr	r3, [pc, #416]	; (b108 <CLI_process+0x1e0>)
    af68:	781b      	ldrb	r3, [r3, #0]
    af6a:	b193      	cbz	r3, af92 <CLI_process+0x6a>
    af6c:	7823      	ldrb	r3, [r4, #0]
    af6e:	42ab      	cmp	r3, r5
    af70:	d9f2      	bls.n	af58 <CLI_process+0x30>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    af72:	4866      	ldr	r0, [pc, #408]	; (b10c <CLI_process+0x1e4>)
			printHex( CLILineBuffer[pos++] );
    af74:	4f61      	ldr	r7, [pc, #388]	; (b0fc <CLI_process+0x1d4>)
			print(" ");
    af76:	f8df 81b4 	ldr.w	r8, [pc, #436]	; b12c <CLI_process+0x204>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    af7a:	f000 fa41 	bl	b400 <_print>
		print("\033[2K");    // Erases the current line
    af7e:	4864      	ldr	r0, [pc, #400]	; (b110 <CLI_process+0x1e8>)
    af80:	f000 fa3e 	bl	b400 <_print>
		while ( CLILineBufferCurrent > pos )
    af84:	462b      	mov	r3, r5
    af86:	7822      	ldrb	r2, [r4, #0]
    af88:	429a      	cmp	r2, r3
    af8a:	d818      	bhi.n	afbe <CLI_process+0x96>
		print("\033[u"); // Restore cursor position
    af8c:	4861      	ldr	r0, [pc, #388]	; (b114 <CLI_process+0x1ec>)
    af8e:	f000 fa37 	bl	b400 <_print>
		switch ( CLILineBuffer[prev_buf_pos] )
    af92:	4e5a      	ldr	r6, [pc, #360]	; (b0fc <CLI_process+0x1d4>)
				print("\b \b");
    af94:	4f60      	ldr	r7, [pc, #384]	; (b118 <CLI_process+0x1f0>)
	while ( CLILineBufferCurrent > prev_buf_pos )
    af96:	7823      	ldrb	r3, [r4, #0]
    af98:	42ab      	cmp	r3, r5
    af9a:	d9dd      	bls.n	af58 <CLI_process+0x30>
		switch ( CLILineBuffer[prev_buf_pos] )
    af9c:	5d72      	ldrb	r2, [r6, r5]
    af9e:	2a0a      	cmp	r2, #10
    afa0:	d01f      	beq.n	afe2 <CLI_process+0xba>
    afa2:	d817      	bhi.n	afd4 <CLI_process+0xac>
    afa4:	2a08      	cmp	r2, #8
    afa6:	f000 809b 	beq.w	b0e0 <CLI_process+0x1b8>
    afaa:	2a09      	cmp	r2, #9
    afac:	d049      	beq.n	b042 <CLI_process+0x11a>
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    afae:	2200      	movs	r2, #0
			dPrint( &CLILineBuffer[prev_buf_pos] );
    afb0:	1970      	adds	r0, r6, r5
			prev_buf_pos++;
    afb2:	3501      	adds	r5, #1
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    afb4:	54f2      	strb	r2, [r6, r3]
			prev_buf_pos++;
    afb6:	b2ed      	uxtb	r5, r5
			dPrint( &CLILineBuffer[prev_buf_pos] );
    afb8:	f7fd fde9 	bl	8b8e <Output_putstr>
			break;
    afbc:	e7eb      	b.n	af96 <CLI_process+0x6e>
			printHex( CLILineBuffer[pos++] );
    afbe:	1c5e      	adds	r6, r3, #1
    afc0:	5cf8      	ldrb	r0, [r7, r3]
    afc2:	2101      	movs	r1, #1
    afc4:	f000 fac4 	bl	b550 <printHex_op>
    afc8:	b2f6      	uxtb	r6, r6
			print(" ");
    afca:	4640      	mov	r0, r8
    afcc:	f000 fa18 	bl	b400 <_print>
			printHex( CLILineBuffer[pos++] );
    afd0:	4633      	mov	r3, r6
    afd2:	e7d8      	b.n	af86 <CLI_process+0x5e>
		switch ( CLILineBuffer[prev_buf_pos] )
    afd4:	2a1b      	cmp	r2, #27
    afd6:	d03a      	beq.n	b04e <CLI_process+0x126>
    afd8:	2a7f      	cmp	r2, #127	; 0x7f
    afda:	f000 8081 	beq.w	b0e0 <CLI_process+0x1b8>
    afde:	2a0d      	cmp	r2, #13
    afe0:	d1e5      	bne.n	afae <CLI_process+0x86>
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    afe2:	441e      	add	r6, r3
    afe4:	2220      	movs	r2, #32
			if ( CLILineBufferCurrent == 1 )
    afe6:	2b01      	cmp	r3, #1
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    afe8:	f806 2c01 	strb.w	r2, [r6, #-1]
			if ( CLILineBufferCurrent == 1 )
    afec:	d023      	beq.n	b036 <CLI_process+0x10e>
				CLI_saveHistory( CLILineBuffer );
    afee:	4843      	ldr	r0, [pc, #268]	; (b0fc <CLI_process+0x1d4>)
    aff0:	f7ff ff50 	bl	ae94 <CLI_saveHistory>
				CLI_commandLookup();
    aff4:	f7ff fe30 	bl	ac58 <CLI_commandLookup>
				if ( CLIHistoryTail < CLIHistoryHead )
    aff8:	4a48      	ldr	r2, [pc, #288]	; (b11c <CLI_process+0x1f4>)
    affa:	4949      	ldr	r1, [pc, #292]	; (b120 <CLI_process+0x1f8>)
    affc:	7813      	ldrb	r3, [r2, #0]
    affe:	7808      	ldrb	r0, [r1, #0]
    b000:	4283      	cmp	r3, r0
    b002:	d206      	bcs.n	b012 <CLI_process+0xea>
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
    b004:	3001      	adds	r0, #1
    b006:	260a      	movs	r6, #10
    b008:	fb90 f5f6 	sdiv	r5, r0, r6
    b00c:	fb06 0015 	mls	r0, r6, r5, r0
    b010:	7008      	strb	r0, [r1, #0]
				CLIHistoryTail++;
    b012:	3301      	adds	r3, #1
    b014:	b2db      	uxtb	r3, r3
				if ( CLIHistoryTail == CLIMaxHistorySize )
    b016:	2b0a      	cmp	r3, #10
					CLIHistoryTail = 0;
    b018:	bf03      	ittte	eq
    b01a:	2300      	moveq	r3, #0
    b01c:	7013      	strbeq	r3, [r2, #0]
					CLIHistoryHead = 1;
    b01e:	2301      	moveq	r3, #1
				CLIHistoryTail++;
    b020:	7013      	strbne	r3, [r2, #0]
					CLIHistoryHead = 1;
    b022:	bf08      	it	eq
    b024:	700b      	strbeq	r3, [r1, #0]
				CLIHistoryCurrent = CLIHistoryTail; // 'Up' starts at the last item
    b026:	4b3f      	ldr	r3, [pc, #252]	; (b124 <CLI_process+0x1fc>)
    b028:	7812      	ldrb	r2, [r2, #0]
    b02a:	701a      	strb	r2, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    b02c:	2364      	movs	r3, #100	; 0x64
    b02e:	4353      	muls	r3, r2
    b030:	4a3d      	ldr	r2, [pc, #244]	; (b128 <CLI_process+0x200>)
    b032:	2100      	movs	r1, #0
    b034:	54d1      	strb	r1, [r2, r3]
			CLILineBufferCurrent = 0;
    b036:	2300      	movs	r3, #0
			print( NL );
    b038:	4831      	ldr	r0, [pc, #196]	; (b100 <CLI_process+0x1d8>)
			CLILineBufferCurrent = 0;
    b03a:	7023      	strb	r3, [r4, #0]
			print( NL );
    b03c:	f000 f9e0 	bl	b400 <_print>
    b040:	e788      	b.n	af54 <CLI_process+0x2c>
			CLI_tabCompletion();
    b042:	f7ff feb7 	bl	adb4 <CLI_tabCompletion>
			CLILineBufferCurrent--; // Remove the Tab
    b046:	7823      	ldrb	r3, [r4, #0]
    b048:	3b01      	subs	r3, #1
    b04a:	7023      	strb	r3, [r4, #0]
			return 0;
    b04c:	e784      	b.n	af58 <CLI_process+0x30>
			if ( CLILineBufferCurrent >= prev_buf_pos + 3
    b04e:	1caf      	adds	r7, r5, #2
    b050:	429f      	cmp	r7, r3
    b052:	da81      	bge.n	af58 <CLI_process+0x30>
				&& CLILineBuffer[ prev_buf_pos + 1] == 0x5B )
    b054:	1973      	adds	r3, r6, r5
    b056:	785b      	ldrb	r3, [r3, #1]
    b058:	2b5b      	cmp	r3, #91	; 0x5b
    b05a:	f47f af7d 	bne.w	af58 <CLI_process+0x30>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
    b05e:	5df3      	ldrb	r3, [r6, r7]
    b060:	2b41      	cmp	r3, #65	; 0x41
    b062:	d121      	bne.n	b0a8 <CLI_process+0x180>
					if ( CLIHistoryCurrent == CLIHistoryTail )
    b064:	4c2f      	ldr	r4, [pc, #188]	; (b124 <CLI_process+0x1fc>)
    b066:	4b2d      	ldr	r3, [pc, #180]	; (b11c <CLI_process+0x1f4>)
    b068:	f994 2000 	ldrsb.w	r2, [r4]
    b06c:	781b      	ldrb	r3, [r3, #0]
    b06e:	429a      	cmp	r2, r3
    b070:	d104      	bne.n	b07c <CLI_process+0x154>
						CLILineBuffer[ prev_buf_pos ] = '\0';
    b072:	2300      	movs	r3, #0
						CLI_saveHistory( CLILineBuffer );
    b074:	4821      	ldr	r0, [pc, #132]	; (b0fc <CLI_process+0x1d4>)
						CLILineBuffer[ prev_buf_pos ] = '\0';
    b076:	5573      	strb	r3, [r6, r5]
						CLI_saveHistory( CLILineBuffer );
    b078:	f7ff ff0c 	bl	ae94 <CLI_saveHistory>
					if ( RING_PREV( CLIHistoryCurrent ) != RING_PREV( CLIHistoryHead ) )
    b07c:	f994 0000 	ldrsb.w	r0, [r4]
    b080:	2209      	movs	r2, #9
    b082:	2100      	movs	r1, #0
    b084:	3801      	subs	r0, #1
    b086:	f7ff fef1 	bl	ae6c <CLI_wrap>
    b08a:	4b25      	ldr	r3, [pc, #148]	; (b120 <CLI_process+0x1f8>)
    b08c:	4605      	mov	r5, r0
    b08e:	7818      	ldrb	r0, [r3, #0]
    b090:	2209      	movs	r2, #9
    b092:	2100      	movs	r1, #0
    b094:	3801      	subs	r0, #1
    b096:	f7ff fee9 	bl	ae6c <CLI_wrap>
    b09a:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_PREV( CLIHistoryCurrent );
    b09c:	bf18      	it	ne
    b09e:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    b0a0:	f994 0000 	ldrsb.w	r0, [r4]
    b0a4:	f7ff ff1e 	bl	aee4 <CLI_retreiveHistory>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
    b0a8:	5df3      	ldrb	r3, [r6, r7]
    b0aa:	2b42      	cmp	r3, #66	; 0x42
    b0ac:	f47f af54 	bne.w	af58 <CLI_process+0x30>
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
    b0b0:	4c1c      	ldr	r4, [pc, #112]	; (b124 <CLI_process+0x1fc>)
    b0b2:	f994 0000 	ldrsb.w	r0, [r4]
    b0b6:	2209      	movs	r2, #9
    b0b8:	2100      	movs	r1, #0
    b0ba:	3001      	adds	r0, #1
    b0bc:	f7ff fed6 	bl	ae6c <CLI_wrap>
    b0c0:	4b16      	ldr	r3, [pc, #88]	; (b11c <CLI_process+0x1f4>)
    b0c2:	4605      	mov	r5, r0
    b0c4:	7818      	ldrb	r0, [r3, #0]
    b0c6:	2209      	movs	r2, #9
    b0c8:	2100      	movs	r1, #0
    b0ca:	3001      	adds	r0, #1
    b0cc:	f7ff fece 	bl	ae6c <CLI_wrap>
    b0d0:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
    b0d2:	bf18      	it	ne
    b0d4:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    b0d6:	f994 0000 	ldrsb.w	r0, [r4]
    b0da:	f7ff ff03 	bl	aee4 <CLI_retreiveHistory>
    b0de:	e73b      	b.n	af58 <CLI_process+0x30>
			if ( CLILineBufferCurrent > 0 )
    b0e0:	2b01      	cmp	r3, #1
    b0e2:	d102      	bne.n	b0ea <CLI_process+0x1c2>
			CLILineBufferCurrent--; // Remove the backspace
    b0e4:	2300      	movs	r3, #0
    b0e6:	7023      	strb	r3, [r4, #0]
    b0e8:	e755      	b.n	af96 <CLI_process+0x6e>
				CLILineBufferCurrent--;
    b0ea:	3b02      	subs	r3, #2
				print("\b \b");
    b0ec:	4638      	mov	r0, r7
				CLILineBufferCurrent--;
    b0ee:	7023      	strb	r3, [r4, #0]
				print("\b \b");
    b0f0:	f000 f986 	bl	b400 <_print>
    b0f4:	e74f      	b.n	af96 <CLI_process+0x6e>
    b0f6:	bf00      	nop
    b0f8:	1fff9b28 	.word	0x1fff9b28
    b0fc:	1fff9a6c 	.word	0x1fff9a6c
    b100:	00010d99 	.word	0x00010d99
    b104:	00010ec9 	.word	0x00010ec9
    b108:	1fff9680 	.word	0x1fff9680
    b10c:	00010f20 	.word	0x00010f20
    b110:	00010f26 	.word	0x00010f26
    b114:	00010f2b 	.word	0x00010f2b
    b118:	00010f2f 	.word	0x00010f2f
    b11c:	1fff9afc 	.word	0x1fff9afc
    b120:	1fff9ad1 	.word	0x1fff9ad1
    b124:	1fff9681 	.word	0x1fff9681
    b128:	1fff9684 	.word	0x1fff9684
    b12c:	00011f77 	.word	0x00011f77

0000b130 <printLatency>:
{
    b130:	b538      	push	{r3, r4, r5, lr}
    b132:	4604      	mov	r4, r0
	printInt8( resource );
    b134:	f000 f996 	bl	b464 <printInt8>
	print(":");
    b138:	481b      	ldr	r0, [pc, #108]	; (b1a8 <printLatency+0x78>)
	print("\t");
    b13a:	4d1c      	ldr	r5, [pc, #112]	; (b1ac <printLatency+0x7c>)
	print(":");
    b13c:	f000 f960 	bl	b400 <_print>
	print( Latency_query_name( resource ) );
    b140:	4620      	mov	r0, r4
    b142:	f000 f8c9 	bl	b2d8 <Latency_query_name>
    b146:	f000 f95b 	bl	b400 <_print>
	print("\t");
    b14a:	4628      	mov	r0, r5
    b14c:	f000 f958 	bl	b400 <_print>
	printInt32( Latency_query( LatencyQuery_Count, resource ) );
    b150:	4621      	mov	r1, r4
    b152:	2004      	movs	r0, #4
    b154:	f000 f896 	bl	b284 <Latency_query>
    b158:	f000 f9c1 	bl	b4de <printInt32>
	print("\t");
    b15c:	4628      	mov	r0, r5
    b15e:	f000 f94f 	bl	b400 <_print>
	printInt32( Latency_query( LatencyQuery_Min, resource ) );
    b162:	4621      	mov	r1, r4
    b164:	2000      	movs	r0, #0
    b166:	f000 f88d 	bl	b284 <Latency_query>
    b16a:	f000 f9b8 	bl	b4de <printInt32>
	print("\t");
    b16e:	4628      	mov	r0, r5
    b170:	f000 f946 	bl	b400 <_print>
	printInt32( Latency_query( LatencyQuery_Average, resource ) );
    b174:	4621      	mov	r1, r4
    b176:	2002      	movs	r0, #2
    b178:	f000 f884 	bl	b284 <Latency_query>
    b17c:	f000 f9af 	bl	b4de <printInt32>
	print("\t");
    b180:	4628      	mov	r0, r5
    b182:	f000 f93d 	bl	b400 <_print>
	printInt32( Latency_query( LatencyQuery_Last, resource ) );
    b186:	4621      	mov	r1, r4
    b188:	2003      	movs	r0, #3
    b18a:	f000 f87b 	bl	b284 <Latency_query>
    b18e:	f000 f9a6 	bl	b4de <printInt32>
	print("\t");
    b192:	4628      	mov	r0, r5
    b194:	f000 f934 	bl	b400 <_print>
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    b198:	4621      	mov	r1, r4
    b19a:	2001      	movs	r0, #1
    b19c:	f000 f872 	bl	b284 <Latency_query>
}
    b1a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    b1a4:	f000 b99b 	b.w	b4de <printInt32>
    b1a8:	0000f857 	.word	0x0000f857
    b1ac:	0000d901 	.word	0x0000d901

0000b1b0 <cliFunc_latency>:
{
    b1b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    b1b2:	aa01      	add	r2, sp, #4
    b1b4:	4669      	mov	r1, sp
    b1b6:	f7ff fd1b 	bl	abf0 <CLI_argumentIsolation>
	print( NL );
    b1ba:	4815      	ldr	r0, [pc, #84]	; (b210 <cliFunc_latency+0x60>)
    b1bc:	f000 f920 	bl	b400 <_print>
	print("Latency" NL );
    b1c0:	4814      	ldr	r0, [pc, #80]	; (b214 <cliFunc_latency+0x64>)
    b1c2:	f000 f91d 	bl	b400 <_print>
	print("<i>:<module>\t<count>\t<min>\t<avg>\t<last>\t<max>");
    b1c6:	4814      	ldr	r0, [pc, #80]	; (b218 <cliFunc_latency+0x68>)
    b1c8:	f000 f91a 	bl	b400 <_print>
	if ( arg1Ptr[0] == '\0' )
    b1cc:	9b00      	ldr	r3, [sp, #0]
    b1ce:	781c      	ldrb	r4, [r3, #0]
    b1d0:	b1e4      	cbz	r4, b20c <cliFunc_latency+0x5c>
		print( NL );
    b1d2:	480f      	ldr	r0, [pc, #60]	; (b210 <cliFunc_latency+0x60>)
    b1d4:	f000 f914 	bl	b400 <_print>
		if ( arg1Ptr[0] < Latency_resources() )
    b1d8:	9b00      	ldr	r3, [sp, #0]
    b1da:	781c      	ldrb	r4, [r3, #0]
    b1dc:	f000 f82e 	bl	b23c <Latency_resources>
    b1e0:	4284      	cmp	r4, r0
    b1e2:	d211      	bcs.n	b208 <cliFunc_latency+0x58>
			printLatency( arg1Ptr[0] );
    b1e4:	9b00      	ldr	r3, [sp, #0]
    b1e6:	7818      	ldrb	r0, [r3, #0]
    b1e8:	f7ff ffa2 	bl	b130 <printLatency>
}
    b1ec:	e00c      	b.n	b208 <cliFunc_latency+0x58>
			print( NL );
    b1ee:	4630      	mov	r0, r6
    b1f0:	f000 f906 	bl	b400 <_print>
			printLatency( c );
    b1f4:	4628      	mov	r0, r5
    b1f6:	f7ff ff9b 	bl	b130 <printLatency>
		for ( uint8_t c = 0; c < Latency_resources(); c++ )
    b1fa:	f000 f81f 	bl	b23c <Latency_resources>
    b1fe:	b2e5      	uxtb	r5, r4
    b200:	4285      	cmp	r5, r0
    b202:	f104 0401 	add.w	r4, r4, #1
    b206:	d3f2      	bcc.n	b1ee <cliFunc_latency+0x3e>
}
    b208:	b002      	add	sp, #8
    b20a:	bd70      	pop	{r4, r5, r6, pc}
			print( NL );
    b20c:	4e00      	ldr	r6, [pc, #0]	; (b210 <cliFunc_latency+0x60>)
    b20e:	e7f4      	b.n	b1fa <cliFunc_latency+0x4a>
    b210:	00010d99 	.word	0x00010d99
    b214:	0001122e 	.word	0x0001122e
    b218:	00011238 	.word	0x00011238

0000b21c <Latency_init>:
// ----- Functions -----

// Initialize latency module
// Call before adding resources
void Latency_init()
{
    b21c:	b508      	push	{r3, lr}
	// Zero out all measurements
	memset( &latency_measurements, 0, sizeof(LatencyMeasurement) * LatencyMeasurementCount_define );
    b21e:	f44f 7290 	mov.w	r2, #288	; 0x120
    b222:	2100      	movs	r1, #0
    b224:	4803      	ldr	r0, [pc, #12]	; (b234 <Latency_init+0x18>)
    b226:	f7f7 fa0b 	bl	2640 <memset>

	// Set used resources to 0
	latency_resources = 0;
    b22a:	4b03      	ldr	r3, [pc, #12]	; (b238 <Latency_init+0x1c>)
    b22c:	2200      	movs	r2, #0
    b22e:	701a      	strb	r2, [r3, #0]
}
    b230:	bd08      	pop	{r3, pc}
    b232:	bf00      	nop
    b234:	1fff955c 	.word	0x1fff955c
    b238:	1fff967c 	.word	0x1fff967c

0000b23c <Latency_resources>:

// Number of latency resources used
uint8_t Latency_resources()
{
	return latency_resources;
}
    b23c:	4b01      	ldr	r3, [pc, #4]	; (b244 <Latency_resources+0x8>)
    b23e:	7818      	ldrb	r0, [r3, #0]
    b240:	4770      	bx	lr
    b242:	bf00      	nop
    b244:	1fff967c 	.word	0x1fff967c

0000b248 <Latency_add_resource>:

// Add latency tracking resource
//
// return: resource index
uint8_t Latency_add_resource( const char* name, LatencyOption option )
{
    b248:	b538      	push	{r3, r4, r5, lr}
	// Add identifier name
	uint8_t index = latency_resources++;
    b24a:	4a0b      	ldr	r2, [pc, #44]	; (b278 <Latency_add_resource+0x30>)
    b24c:	7813      	ldrb	r3, [r2, #0]
    b24e:	1c5c      	adds	r4, r3, #1

	// Make sure there are resources left to allocate
	if ( index >= LatencyMeasurementCount_define )
    b250:	2b07      	cmp	r3, #7
	uint8_t index = latency_resources++;
    b252:	7014      	strb	r4, [r2, #0]
	if ( index >= LatencyMeasurementCount_define )
    b254:	d905      	bls.n	b262 <Latency_add_resource+0x1a>
	{
		erro_print("No more latency resources available...");
    b256:	4809      	ldr	r0, [pc, #36]	; (b27c <Latency_add_resource+0x34>)
    b258:	f000 f8d2 	bl	b400 <_print>
		return 0;
    b25c:	2300      	movs	r3, #0

	// Max out min latency
	latency_measurements[index].min_latency = 0xFFFFFFFF;

	return index;
}
    b25e:	4618      	mov	r0, r3
    b260:	bd38      	pop	{r3, r4, r5, pc}
	latency_measurements[index].name = name;
    b262:	4d07      	ldr	r5, [pc, #28]	; (b280 <Latency_add_resource+0x38>)
    b264:	2224      	movs	r2, #36	; 0x24
    b266:	435a      	muls	r2, r3
    b268:	18ac      	adds	r4, r5, r2
    b26a:	50a8      	str	r0, [r5, r2]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    b26c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	latency_measurements[index].option = option;
    b270:	7321      	strb	r1, [r4, #12]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    b272:	6122      	str	r2, [r4, #16]
	return index;
    b274:	e7f3      	b.n	b25e <Latency_add_resource+0x16>
    b276:	bf00      	nop
    b278:	1fff967c 	.word	0x1fff967c
    b27c:	00012352 	.word	0x00012352
    b280:	1fff955c 	.word	0x1fff955c

0000b284 <Latency_query>:
// resource: index of resource
//
// return: latency query result
uint32_t Latency_query( LatencyQuery type, uint8_t resource )
{
	switch ( type )
    b284:	2804      	cmp	r0, #4
    b286:	d822      	bhi.n	b2ce <Latency_query+0x4a>
    b288:	e8df f000 	tbb	[pc, r0]
    b28c:	150f0903 	.word	0x150f0903
    b290:	1b          	.byte	0x1b
    b291:	00          	.byte	0x00
	{
	case LatencyQuery_Min:
		return latency_measurements[resource].min_latency;
    b292:	4b10      	ldr	r3, [pc, #64]	; (b2d4 <Latency_query+0x50>)
    b294:	2224      	movs	r2, #36	; 0x24
    b296:	fb02 3101 	mla	r1, r2, r1, r3
    b29a:	6908      	ldr	r0, [r1, #16]
    b29c:	4770      	bx	lr

	case LatencyQuery_Max:
		return latency_measurements[resource].max_latency;
    b29e:	4b0d      	ldr	r3, [pc, #52]	; (b2d4 <Latency_query+0x50>)
    b2a0:	2224      	movs	r2, #36	; 0x24
    b2a2:	fb02 3101 	mla	r1, r2, r1, r3
    b2a6:	6948      	ldr	r0, [r1, #20]
    b2a8:	4770      	bx	lr

	case LatencyQuery_Average:
		return latency_measurements[resource].average_latency;
    b2aa:	4b0a      	ldr	r3, [pc, #40]	; (b2d4 <Latency_query+0x50>)
    b2ac:	2224      	movs	r2, #36	; 0x24
    b2ae:	fb02 3101 	mla	r1, r2, r1, r3
    b2b2:	6988      	ldr	r0, [r1, #24]
    b2b4:	4770      	bx	lr

	case LatencyQuery_Last:
		return latency_measurements[resource].last_latency;
    b2b6:	4b07      	ldr	r3, [pc, #28]	; (b2d4 <Latency_query+0x50>)
    b2b8:	2224      	movs	r2, #36	; 0x24
    b2ba:	fb02 3101 	mla	r1, r2, r1, r3
    b2be:	69c8      	ldr	r0, [r1, #28]
    b2c0:	4770      	bx	lr

	case LatencyQuery_Count:
		return latency_measurements[resource].count;
    b2c2:	4b04      	ldr	r3, [pc, #16]	; (b2d4 <Latency_query+0x50>)
    b2c4:	2224      	movs	r2, #36	; 0x24
    b2c6:	fb02 3101 	mla	r1, r2, r1, r3
    b2ca:	6a08      	ldr	r0, [r1, #32]
    b2cc:	4770      	bx	lr

	default:
		return 0;
    b2ce:	2000      	movs	r0, #0
	}
}
    b2d0:	4770      	bx	lr
    b2d2:	bf00      	nop
    b2d4:	1fff955c 	.word	0x1fff955c

0000b2d8 <Latency_query_name>:
// resource: index of resource
//
// return: Name of resource
const char* Latency_query_name( uint8_t resource )
{
	return latency_measurements[resource].name;
    b2d8:	2324      	movs	r3, #36	; 0x24
    b2da:	4358      	muls	r0, r3
}
    b2dc:	4b01      	ldr	r3, [pc, #4]	; (b2e4 <Latency_query_name+0xc>)
    b2de:	5818      	ldr	r0, [r3, r0]
    b2e0:	4770      	bx	lr
    b2e2:	bf00      	nop
    b2e4:	1fff955c 	.word	0x1fff955c

0000b2e8 <Latency_start_time>:

// Resource start time
//
// resource: index of resource
void Latency_start_time( uint8_t resource )
{
    b2e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	latency_measurements[resource].start_time = Time_now();
    b2ea:	4c07      	ldr	r4, [pc, #28]	; (b308 <Latency_start_time+0x20>)
    b2ec:	2324      	movs	r3, #36	; 0x24
    b2ee:	466d      	mov	r5, sp
    b2f0:	fb03 4400 	mla	r4, r3, r0, r4
    b2f4:	4628      	mov	r0, r5
    b2f6:	f7f7 fb33 	bl	2960 <Time_now>
    b2fa:	e895 0003 	ldmia.w	r5, {r0, r1}
    b2fe:	1d23      	adds	r3, r4, #4
    b300:	e883 0003 	stmia.w	r3, {r0, r1}
}
    b304:	b003      	add	sp, #12
    b306:	bd30      	pop	{r4, r5, pc}
    b308:	1fff955c 	.word	0x1fff955c

0000b30c <Latency_end_time>:

// Measure latency, and store
//
// resource: index of resource
void Latency_end_time( uint8_t resource )
{
    b30c:	b538      	push	{r3, r4, r5, lr}
	uint32_t measured;
	switch ( latency_measurements[resource].option )
    b30e:	4d21      	ldr	r5, [pc, #132]	; (b394 <Latency_end_time+0x88>)
    b310:	2324      	movs	r3, #36	; 0x24
    b312:	fb03 5300 	mla	r3, r3, r0, r5
{
    b316:	4604      	mov	r4, r0
	switch ( latency_measurements[resource].option )
    b318:	7b1a      	ldrb	r2, [r3, #12]
    b31a:	2a02      	cmp	r2, #2
    b31c:	f103 0304 	add.w	r3, r3, #4
    b320:	d02e      	beq.n	b380 <Latency_end_time+0x74>
    b322:	2a03      	cmp	r2, #3
    b324:	d006      	beq.n	b334 <Latency_end_time+0x28>
    b326:	2a01      	cmp	r2, #1
    b328:	d12f      	bne.n	b38a <Latency_end_time+0x7e>
	case LatencyOption_us:
		measured = Time_duration_us( latency_measurements[resource].start_time );
		break;

	case LatencyOption_ns:
		measured = Time_duration_ns( latency_measurements[resource].start_time );
    b32a:	e893 0003 	ldmia.w	r3, {r0, r1}
    b32e:	f7f7 fb9f 	bl	2a70 <Time_duration_ns>
		break;
    b332:	e003      	b.n	b33c <Latency_end_time+0x30>
		measured = Time_duration_ms( latency_measurements[resource].start_time );
    b334:	e893 0003 	ldmia.w	r3, {r0, r1}
    b338:	f7f7 fb7c 	bl	2a34 <Time_duration_ms>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
		break;
	}

	// Check if min or max latencies need to change
	if ( measured < latency_measurements[resource].min_latency )
    b33c:	2224      	movs	r2, #36	; 0x24
    b33e:	fb02 5304 	mla	r3, r2, r4, r5
	{
		latency_measurements[resource].min_latency = measured;
	}
	if ( measured > latency_measurements[resource].max_latency )
    b342:	fb02 5204 	mla	r2, r2, r4, r5
	if ( measured < latency_measurements[resource].min_latency )
    b346:	6919      	ldr	r1, [r3, #16]
    b348:	4281      	cmp	r1, r0
		latency_measurements[resource].min_latency = measured;
    b34a:	bf88      	it	hi
    b34c:	6118      	strhi	r0, [r3, #16]
	if ( measured > latency_measurements[resource].max_latency )
    b34e:	6953      	ldr	r3, [r2, #20]
    b350:	4283      	cmp	r3, r0
	{
		latency_measurements[resource].max_latency = measured;
	}

	// Calculate average, places emphasis on recent values
	uint32_t old_avg = latency_measurements[resource].average_latency;
    b352:	f04f 0324 	mov.w	r3, #36	; 0x24
    b356:	fb03 5304 	mla	r3, r3, r4, r5
		latency_measurements[resource].max_latency = measured;
    b35a:	bf38      	it	cc
    b35c:	6150      	strcc	r0, [r2, #20]
	uint32_t old_avg = latency_measurements[resource].average_latency;
    b35e:	6999      	ldr	r1, [r3, #24]
	if ( old_avg == 0 )
	{
		// Use measured value if this is the first calculation
		old_avg = measured;
	}
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    b360:	f000 0201 	and.w	r2, r0, #1
	if ( old_avg == 0 )
    b364:	2900      	cmp	r1, #0
    b366:	bf08      	it	eq
    b368:	4601      	moveq	r1, r0
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    b36a:	400a      	ands	r2, r1
    b36c:	eb02 0251 	add.w	r2, r2, r1, lsr #1
    b370:	eb02 0250 	add.w	r2, r2, r0, lsr #1

	// Set last average
	latency_measurements[resource].last_latency = measured;
    b374:	e9c3 2006 	strd	r2, r0, [r3, #24]

	// Latency check count
	latency_measurements[resource].count++;
    b378:	6a1a      	ldr	r2, [r3, #32]
    b37a:	3201      	adds	r2, #1
    b37c:	621a      	str	r2, [r3, #32]
}
    b37e:	bd38      	pop	{r3, r4, r5, pc}
		measured = Time_duration_us( latency_measurements[resource].start_time );
    b380:	e893 0003 	ldmia.w	r3, {r0, r1}
    b384:	f7f7 fb63 	bl	2a4e <Time_duration_us>
		break;
    b388:	e7d8      	b.n	b33c <Latency_end_time+0x30>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
    b38a:	e893 0003 	ldmia.w	r3, {r0, r1}
    b38e:	f7f7 fb81 	bl	2a94 <Time_duration_ticks>
		break;
    b392:	e7d3      	b.n	b33c <Latency_end_time+0x30>
    b394:	1fff955c 	.word	0x1fff955c

0000b398 <init_errorLED>:

// Kiibohd-dfu
#elif defined(_kii_v2_)
	// Kiibohd-dfu
	// Enable pin
	GPIOA_PDDR |= (1<<5);
    b398:	4a04      	ldr	r2, [pc, #16]	; (b3ac <init_errorLED+0x14>)
    b39a:	6813      	ldr	r3, [r2, #0]
    b39c:	f043 0320 	orr.w	r3, r3, #32
    b3a0:	6013      	str	r3, [r2, #0]

	// Setup pin - A5 - See Lib/pin_map.mchck for more details on pins
	PORTA_PCR5 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    b3a2:	4b03      	ldr	r3, [pc, #12]	; (b3b0 <init_errorLED+0x18>)
    b3a4:	f44f 72a2 	mov.w	r2, #324	; 0x144
    b3a8:	601a      	str	r2, [r3, #0]
#endif
}
    b3aa:	4770      	bx	lr
    b3ac:	400ff014 	.word	0x400ff014
    b3b0:	40049014 	.word	0x40049014

0000b3b4 <errorLED>:

// Kiibohd-dfu
#elif defined(_kii_v2_)
	// Kiibohd-dfu
	// Error LED On (A5)
	if ( on ) {
    b3b4:	b128      	cbz	r0, b3c2 <errorLED+0xe>
		GPIOA_PSOR |= (1<<5);
    b3b6:	4a04      	ldr	r2, [pc, #16]	; (b3c8 <errorLED+0x14>)
	}
	// Error LED Off
	else {
		GPIOA_PCOR |= (1<<5);
    b3b8:	6813      	ldr	r3, [r2, #0]
    b3ba:	f043 0320 	orr.w	r3, r3, #32
    b3be:	6013      	str	r3, [r2, #0]
	}

#endif
}
    b3c0:	4770      	bx	lr
		GPIOA_PCOR |= (1<<5);
    b3c2:	4a02      	ldr	r2, [pc, #8]	; (b3cc <errorLED+0x18>)
    b3c4:	e7f8      	b.n	b3b8 <errorLED+0x4>
    b3c6:	bf00      	nop
    b3c8:	400ff004 	.word	0x400ff004
    b3cc:	400ff008 	.word	0x400ff008

0000b3d0 <printstrs>:

// ----- Functions -----

// Multiple string Output
void printstrs( char* first, ... )
{
    b3d0:	b40f      	push	{r0, r1, r2, r3}
    b3d2:	b507      	push	{r0, r1, r2, lr}
    b3d4:	ab04      	add	r3, sp, #16
    b3d6:	f853 0b04 	ldr.w	r0, [r3], #4
	// Initialize the variadic function parameter list
	va_list ap;

	// Get the first parameter
	va_start( ap, first );
    b3da:	9301      	str	r3, [sp, #4]
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    b3dc:	7803      	ldrb	r3, [r0, #0]
    b3de:	b943      	cbnz	r3, b3f2 <printstrs+0x22>
    b3e0:	7843      	ldrb	r3, [r0, #1]
    b3e2:	b933      	cbnz	r3, b3f2 <printstrs+0x22>
    b3e4:	7883      	ldrb	r3, [r0, #2]
    b3e6:	b923      	cbnz	r3, b3f2 <printstrs+0x22>
		// Get the next argument ready
		cur = va_arg( ap, char* );
	}

	va_end( ap ); // Not required, but good practice
}
    b3e8:	b003      	add	sp, #12
    b3ea:	f85d eb04 	ldr.w	lr, [sp], #4
    b3ee:	b004      	add	sp, #16
    b3f0:	4770      	bx	lr
		Output_putstr( cur );
    b3f2:	f7fd fbcc 	bl	8b8e <Output_putstr>
		cur = va_arg( ap, char* );
    b3f6:	9b01      	ldr	r3, [sp, #4]
    b3f8:	1d1a      	adds	r2, r3, #4
    b3fa:	9201      	str	r2, [sp, #4]
    b3fc:	6818      	ldr	r0, [r3, #0]
    b3fe:	e7ed      	b.n	b3dc <printstrs+0xc>

0000b400 <_print>:
	while ( ( c = pgm_read_byte( s++ ) ) != '\0' )
	{
		Output_putchar( c );
	}
#elif defined(_kinetis_) // ARM
	Output_putstr( (char*)s );
    b400:	f7fd bbc5 	b.w	8b8e <Output_putstr>

0000b404 <lenStr>:
	}
}


uint16_t lenStr( char* in )
{
    b404:	4603      	mov	r3, r0
	// Iterator
	char *pos;

	// Loop until null is found
	for ( pos = in; *pos; pos++ );
    b406:	781a      	ldrb	r2, [r3, #0]
    b408:	1c59      	adds	r1, r3, #1
    b40a:	b912      	cbnz	r2, b412 <lenStr+0xe>

	// Return the difference between the pointers of in and pos (which is the string length)
	return (pos - in);
    b40c:	1a18      	subs	r0, r3, r0
}
    b40e:	b280      	uxth	r0, r0
    b410:	4770      	bx	lr
    b412:	460b      	mov	r3, r1
    b414:	e7f7      	b.n	b406 <lenStr+0x2>

0000b416 <revsStr>:
{
    b416:	b510      	push	{r4, lr}
    b418:	4604      	mov	r4, r0
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    b41a:	f7ff fff3 	bl	b404 <lenStr>
    b41e:	3801      	subs	r0, #1
    b420:	4420      	add	r0, r4
    b422:	4623      	mov	r3, r4
    b424:	1b1a      	subs	r2, r3, r4
    b426:	1b01      	subs	r1, r0, r4
    b428:	428a      	cmp	r2, r1
    b42a:	db00      	blt.n	b42e <revsStr+0x18>
}
    b42c:	bd10      	pop	{r4, pc}
		c = in[i];
    b42e:	781a      	ldrb	r2, [r3, #0]
		in[i] = in[j];
    b430:	7801      	ldrb	r1, [r0, #0]
    b432:	f803 1b01 	strb.w	r1, [r3], #1
		in[j] = c;
    b436:	f800 2901 	strb.w	r2, [r0], #-1
    b43a:	e7f3      	b.n	b424 <revsStr+0xe>

0000b43c <int8ToStr>:
{
    b43c:	b430      	push	{r4, r5}
    b43e:	4603      	mov	r3, r0
	pos = 0;
    b440:	2200      	movs	r2, #0
		out[pos++] = in % 10 + '0';
    b442:	240a      	movs	r4, #10
    b444:	fbb3 f0f4 	udiv	r0, r3, r4
    b448:	fb04 3310 	mls	r3, r4, r0, r3
    b44c:	3330      	adds	r3, #48	; 0x30
    b44e:	548b      	strb	r3, [r1, r2]
    b450:	1c55      	adds	r5, r2, #1
	while ( (in /= 10) > 0 );
    b452:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
		out[pos++] = in % 10 + '0';
    b456:	b2ea      	uxtb	r2, r5
	while ( (in /= 10) > 0 );
    b458:	d1f4      	bne.n	b444 <int8ToStr+0x8>
	out[pos] = '\0';
    b45a:	548b      	strb	r3, [r1, r2]
	revsStr(out);
    b45c:	4608      	mov	r0, r1
}
    b45e:	bc30      	pop	{r4, r5}
	revsStr(out);
    b460:	f7ff bfd9 	b.w	b416 <revsStr>

0000b464 <printInt8>:
{
    b464:	b507      	push	{r0, r1, r2, lr}
	int8ToStr( in, tmpStr );
    b466:	a901      	add	r1, sp, #4
    b468:	f7ff ffe8 	bl	b43c <int8ToStr>
	dPrintStr( tmpStr );
    b46c:	a801      	add	r0, sp, #4
    b46e:	f7fd fb8e 	bl	8b8e <Output_putstr>
}
    b472:	b003      	add	sp, #12
    b474:	f85d fb04 	ldr.w	pc, [sp], #4

0000b478 <int16ToStr>:
{
    b478:	b430      	push	{r4, r5}
    b47a:	4603      	mov	r3, r0
	pos = 0;
    b47c:	2200      	movs	r2, #0
		out[pos++] = in % 10 + '0';
    b47e:	240a      	movs	r4, #10
    b480:	fbb3 f0f4 	udiv	r0, r3, r4
    b484:	fb04 3310 	mls	r3, r4, r0, r3
    b488:	3330      	adds	r3, #48	; 0x30
    b48a:	548b      	strb	r3, [r1, r2]
    b48c:	1c55      	adds	r5, r2, #1
	while ( (in /= 10) > 0 );
    b48e:	b283      	uxth	r3, r0
		out[pos++] = in % 10 + '0';
    b490:	b2aa      	uxth	r2, r5
	while ( (in /= 10) > 0 );
    b492:	2b00      	cmp	r3, #0
    b494:	d1f4      	bne.n	b480 <int16ToStr+0x8>
	out[pos] = '\0';
    b496:	548b      	strb	r3, [r1, r2]
	revsStr(out);
    b498:	4608      	mov	r0, r1
}
    b49a:	bc30      	pop	{r4, r5}
	revsStr(out);
    b49c:	f7ff bfbb 	b.w	b416 <revsStr>

0000b4a0 <printInt16>:
{
    b4a0:	b507      	push	{r0, r1, r2, lr}
	int16ToStr( in, tmpStr );
    b4a2:	4669      	mov	r1, sp
    b4a4:	f7ff ffe8 	bl	b478 <int16ToStr>
	dPrintStr( tmpStr );
    b4a8:	4668      	mov	r0, sp
    b4aa:	f7fd fb70 	bl	8b8e <Output_putstr>
}
    b4ae:	b003      	add	sp, #12
    b4b0:	f85d fb04 	ldr.w	pc, [sp], #4

0000b4b4 <int32ToStr>:
{
    b4b4:	b430      	push	{r4, r5}
    b4b6:	4603      	mov	r3, r0
    b4b8:	1e4c      	subs	r4, r1, #1
	pos = 0;
    b4ba:	2200      	movs	r2, #0
		out[pos++] = in % 10 + '0';
    b4bc:	250a      	movs	r5, #10
    b4be:	fbb3 f0f5 	udiv	r0, r3, r5
    b4c2:	fb05 3310 	mls	r3, r5, r0, r3
    b4c6:	3330      	adds	r3, #48	; 0x30
    b4c8:	f804 3f01 	strb.w	r3, [r4, #1]!
    b4cc:	3201      	adds	r2, #1
	while ( (in /= 10) > 0 );
    b4ce:	4603      	mov	r3, r0
    b4d0:	2800      	cmp	r0, #0
    b4d2:	d1f4      	bne.n	b4be <int32ToStr+0xa>
	out[pos] = '\0';
    b4d4:	5488      	strb	r0, [r1, r2]
}
    b4d6:	bc30      	pop	{r4, r5}
	revsStr(out);
    b4d8:	4608      	mov	r0, r1
    b4da:	f7ff bf9c 	b.w	b416 <revsStr>

0000b4de <printInt32>:
{
    b4de:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	int32ToStr( in, tmpStr );
    b4e0:	a901      	add	r1, sp, #4
    b4e2:	f7ff ffe7 	bl	b4b4 <int32ToStr>
	dPrintStr( tmpStr );
    b4e6:	a801      	add	r0, sp, #4
    b4e8:	f7fd fb51 	bl	8b8e <Output_putstr>
}
    b4ec:	b005      	add	sp, #20
    b4ee:	f85d fb04 	ldr.w	pc, [sp], #4

0000b4f2 <hexToStr_op>:
{
    b4f2:	b470      	push	{r4, r5, r6}
	uint16_t pos = 0;
    b4f4:	2400      	movs	r4, #0
		uint16_t cur = in % 16;
    b4f6:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b4fa:	2d09      	cmp	r5, #9
    b4fc:	bf8c      	ite	hi
    b4fe:	2637      	movhi	r6, #55	; 0x37
    b500:	2630      	movls	r6, #48	; 0x30
    b502:	1c63      	adds	r3, r4, #1
    b504:	4435      	add	r5, r6
	while ( (in /= 16) > 0 );
    b506:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b508:	b29b      	uxth	r3, r3
    b50a:	550d      	strb	r5, [r1, r4]
	while ( (in /= 16) > 0 );
    b50c:	d113      	bne.n	b536 <hexToStr_op+0x44>
	switch ( op )
    b50e:	2a02      	cmp	r2, #2
    b510:	d013      	beq.n	b53a <hexToStr_op+0x48>
    b512:	2a04      	cmp	r2, #4
    b514:	d011      	beq.n	b53a <hexToStr_op+0x48>
    b516:	2a01      	cmp	r2, #1
    b518:	d107      	bne.n	b52a <hexToStr_op+0x38>
		out[pos++] = 'x';
    b51a:	2278      	movs	r2, #120	; 0x78
    b51c:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    b51e:	1ce3      	adds	r3, r4, #3
		out[pos++] = 'x';
    b520:	3402      	adds	r4, #2
		out[pos++] = '0';
    b522:	b2a4      	uxth	r4, r4
    b524:	2230      	movs	r2, #48	; 0x30
    b526:	550a      	strb	r2, [r1, r4]
    b528:	b29b      	uxth	r3, r3
	out[pos] = '\0';
    b52a:	2200      	movs	r2, #0
    b52c:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    b52e:	4608      	mov	r0, r1
}
    b530:	bc70      	pop	{r4, r5, r6}
	revsStr(out);
    b532:	f7ff bf70 	b.w	b416 <revsStr>
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b536:	461c      	mov	r4, r3
    b538:	e7dd      	b.n	b4f6 <hexToStr_op+0x4>
    b53a:	1e58      	subs	r0, r3, #1
    b53c:	4408      	add	r0, r1
		while ( pos < op )
    b53e:	b292      	uxth	r2, r2
			out[pos++] = '0';
    b540:	2430      	movs	r4, #48	; 0x30
		while ( pos < op )
    b542:	429a      	cmp	r2, r3
    b544:	d9f1      	bls.n	b52a <hexToStr_op+0x38>
			out[pos++] = '0';
    b546:	3301      	adds	r3, #1
    b548:	b29b      	uxth	r3, r3
    b54a:	f800 4f01 	strb.w	r4, [r0, #1]!
    b54e:	e7f8      	b.n	b542 <hexToStr_op+0x50>

0000b550 <printHex_op>:
{
    b550:	b507      	push	{r0, r1, r2, lr}
	hexToStr_op( in, tmpStr, op );
    b552:	460a      	mov	r2, r1
    b554:	4669      	mov	r1, sp
    b556:	f7ff ffcc 	bl	b4f2 <hexToStr_op>
	dPrintStr( tmpStr );
    b55a:	4668      	mov	r0, sp
    b55c:	f7fd fb17 	bl	8b8e <Output_putstr>
}
    b560:	b003      	add	sp, #12
    b562:	f85d fb04 	ldr.w	pc, [sp], #4

0000b566 <hex32ToStr_op>:
{
    b566:	b4f0      	push	{r4, r5, r6, r7}
    b568:	1e4e      	subs	r6, r1, #1
	uint32_t pos = 0;
    b56a:	2400      	movs	r4, #0
		uint32_t cur = in % 16;
    b56c:	f000 070f 	and.w	r7, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b570:	2f09      	cmp	r7, #9
    b572:	bf8c      	ite	hi
    b574:	2537      	movhi	r5, #55	; 0x37
    b576:	2530      	movls	r5, #48	; 0x30
    b578:	443d      	add	r5, r7
	while ( (in /= 16) > 0 );
    b57a:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b57c:	f104 0301 	add.w	r3, r4, #1
    b580:	f806 5f01 	strb.w	r5, [r6, #1]!
	while ( (in /= 16) > 0 );
    b584:	d108      	bne.n	b598 <hex32ToStr_op+0x32>
	switch ( op )
    b586:	1e50      	subs	r0, r2, #1
    b588:	2807      	cmp	r0, #7
    b58a:	d813      	bhi.n	b5b4 <hex32ToStr_op+0x4e>
    b58c:	e8df f000 	tbb	[pc, r0]
    b590:	0612060c 	.word	0x0612060c
    b594:	06121212 	.word	0x06121212
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    b598:	461c      	mov	r4, r3
    b59a:	e7e7      	b.n	b56c <hex32ToStr_op+0x6>
			out[pos++] = '0';
    b59c:	2030      	movs	r0, #48	; 0x30
		while ( pos < op )
    b59e:	4293      	cmp	r3, r2
    b5a0:	d208      	bcs.n	b5b4 <hex32ToStr_op+0x4e>
			out[pos++] = '0';
    b5a2:	54c8      	strb	r0, [r1, r3]
    b5a4:	3301      	adds	r3, #1
    b5a6:	e7fa      	b.n	b59e <hex32ToStr_op+0x38>
		out[pos++] = 'x';
    b5a8:	2278      	movs	r2, #120	; 0x78
    b5aa:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    b5ac:	1ce3      	adds	r3, r4, #3
    b5ae:	440c      	add	r4, r1
    b5b0:	2230      	movs	r2, #48	; 0x30
    b5b2:	70a2      	strb	r2, [r4, #2]
	out[pos] = '\0';
    b5b4:	2200      	movs	r2, #0
    b5b6:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    b5b8:	4608      	mov	r0, r1
}
    b5ba:	bcf0      	pop	{r4, r5, r6, r7}
	revsStr(out);
    b5bc:	f7ff bf2b 	b.w	b416 <revsStr>

0000b5c0 <printHex32_op>:
{
    b5c0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	hex32ToStr_op( in, tmpStr, op );
    b5c2:	460a      	mov	r2, r1
    b5c4:	a901      	add	r1, sp, #4
    b5c6:	f7ff ffce 	bl	b566 <hex32ToStr_op>
	dPrintStr( tmpStr );
    b5ca:	a801      	add	r0, sp, #4
    b5cc:	f7fd fadf 	bl	8b8e <Output_putstr>
}
    b5d0:	b005      	add	sp, #20
    b5d2:	f85d fb04 	ldr.w	pc, [sp], #4

0000b5d6 <hex32ToStr16>:
{
    b5d6:	b530      	push	{r4, r5, lr}
    b5d8:	b085      	sub	sp, #20
	hex32ToStr_op( in, tmpStr, op );
    b5da:	ad01      	add	r5, sp, #4
{
    b5dc:	460c      	mov	r4, r1
	hex32ToStr_op( in, tmpStr, op );
    b5de:	4629      	mov	r1, r5
    b5e0:	f7ff ffc1 	bl	b566 <hex32ToStr_op>
    b5e4:	2300      	movs	r3, #0
		if ( tmpStr[byte] == '\0' && out[byte] != 0x0000 )
    b5e6:	5cea      	ldrb	r2, [r5, r3]
    b5e8:	b912      	cbnz	r2, b5f0 <hex32ToStr16+0x1a>
    b5ea:	f834 1013 	ldrh.w	r1, [r4, r3, lsl #1]
    b5ee:	b921      	cbnz	r1, b5fa <hex32ToStr16+0x24>
		out[byte] = tmpStr[byte] | 0x0000;
    b5f0:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
    b5f4:	3301      	adds	r3, #1
	for ( uint8_t byte = 0; byte < sizeof( tmpStr ); byte++ )
    b5f6:	2b0b      	cmp	r3, #11
    b5f8:	d1f5      	bne.n	b5e6 <hex32ToStr16+0x10>
}
    b5fa:	b005      	add	sp, #20
    b5fc:	bd30      	pop	{r4, r5, pc}

0000b5fe <eqStr>:


int16_t eqStr( char* str1, char* str2 )
{
    b5fe:	b510      	push	{r4, lr}
    b600:	4603      	mov	r3, r0
	// Scan each string for NULLs and whether they are the same
	while( *str1 != '\0' && *str1++ == *str2++ );
    b602:	f810 2b01 	ldrb.w	r2, [r0], #1
    b606:	b122      	cbz	r2, b612 <eqStr+0x14>
    b608:	f811 4b01 	ldrb.w	r4, [r1], #1
    b60c:	4294      	cmp	r4, r2
    b60e:	4603      	mov	r3, r0
    b610:	d0f6      	beq.n	b600 <eqStr+0x2>

	// If the strings are still identical (i.e. both NULL), then return -1, otherwise current *str1
	// If *str1 is 0, then str1 ended (and str1 is "like" str2), otherwise strings are different
	return *--str1 == *--str2 ? -1 : *++str1;
    b612:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    b616:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    b61a:	4290      	cmp	r0, r2
    b61c:	bf14      	ite	ne
    b61e:	7818      	ldrbne	r0, [r3, #0]
    b620:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
}
    b624:	bd10      	pop	{r4, pc}

0000b626 <numToInt>:

int numToInt( char* in )
{
    b626:	b570      	push	{r4, r5, r6, lr}
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16
    b628:	220a      	movs	r2, #10
    b62a:	4604      	mov	r4, r0
	int sign = 1; // Default to positive
    b62c:	2501      	movs	r5, #1
    b62e:	4621      	mov	r1, r4

	// Scan the string once to determine the length
	while ( *lsd != '\0' )
    b630:	f814 3b01 	ldrb.w	r3, [r4], #1
    b634:	b933      	cbnz	r3, b644 <numToInt+0x1e>
			break;
		}
	}

	// Process string depending on which base
	switch ( base )
    b636:	2a0a      	cmp	r2, #10
    b638:	d01f      	beq.n	b67a <numToInt+0x54>
    b63a:	2a10      	cmp	r2, #16
    b63c:	d032      	beq.n	b6a4 <numToInt+0x7e>
		break;
	}

	// Propagate sign and return
	return total * sign;
}
    b63e:	fb05 f003 	mul.w	r0, r5, r3
    b642:	bd70      	pop	{r4, r5, r6, pc}
		switch ( *lsd++ )
    b644:	2b2b      	cmp	r3, #43	; 0x2b
    b646:	4621      	mov	r1, r4
    b648:	d00c      	beq.n	b664 <numToInt+0x3e>
    b64a:	d803      	bhi.n	b654 <numToInt+0x2e>
    b64c:	2b20      	cmp	r3, #32
    b64e:	d009      	beq.n	b664 <numToInt+0x3e>
    b650:	4601      	mov	r1, r0
    b652:	e007      	b.n	b664 <numToInt+0x3e>
    b654:	2b2d      	cmp	r3, #45	; 0x2d
    b656:	d003      	beq.n	b660 <numToInt+0x3a>
    b658:	2b78      	cmp	r3, #120	; 0x78
    b65a:	d1f9      	bne.n	b650 <numToInt+0x2a>
			base = 0x10;
    b65c:	2210      	movs	r2, #16
			break;
    b65e:	e001      	b.n	b664 <numToInt+0x3e>
		case '-': sign = -1;
    b660:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    b664:	4608      	mov	r0, r1
    b666:	e7e2      	b.n	b62e <numToInt+0x8>
			total += ( (*--lsd) - '0' ) * digit;
    b668:	f811 6d01 	ldrb.w	r6, [r1, #-1]!
    b66c:	3e30      	subs	r6, #48	; 0x30
    b66e:	fb04 3306 	mla	r3, r4, r6, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    b672:	4354      	muls	r4, r2
    b674:	4281      	cmp	r1, r0
    b676:	d8f7      	bhi.n	b668 <numToInt+0x42>
    b678:	e7e1      	b.n	b63e <numToInt+0x18>
    b67a:	2401      	movs	r4, #1
    b67c:	e7fa      	b.n	b674 <numToInt+0x4e>
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
    b67e:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
    b682:	2a39      	cmp	r2, #57	; 0x39
    b684:	d806      	bhi.n	b694 <numToInt+0x6e>
    b686:	3a30      	subs	r2, #48	; 0x30
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    b688:	fb04 3302 	mla	r3, r4, r2, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    b68c:	0124      	lsls	r4, r4, #4
    b68e:	4281      	cmp	r1, r0
    b690:	d8f5      	bhi.n	b67e <numToInt+0x58>
    b692:	e7d4      	b.n	b63e <numToInt+0x18>
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
    b694:	2a46      	cmp	r2, #70	; 0x46
    b696:	d801      	bhi.n	b69c <numToInt+0x76>
    b698:	3a37      	subs	r2, #55	; 0x37
    b69a:	e7f5      	b.n	b688 <numToInt+0x62>
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    b69c:	2a66      	cmp	r2, #102	; 0x66
    b69e:	d8f5      	bhi.n	b68c <numToInt+0x66>
    b6a0:	3a57      	subs	r2, #87	; 0x57
    b6a2:	e7f1      	b.n	b688 <numToInt+0x62>
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    b6a4:	2401      	movs	r4, #1
    b6a6:	e7f2      	b.n	b68e <numToInt+0x68>
    b6a8:	20737542 	.word	0x20737542
    b6ac:	6c756146 	.word	0x6c756146
    b6b0:	53202174 	.word	0x53202174
    b6b4:	435f4243 	.word	0x435f4243
    b6b8:	3a525346 	.word	0x3a525346
    b6bc:	53200020 	.word	0x53200020
    b6c0:	425f4243 	.word	0x425f4243
    b6c4:	3a524146 	.word	0x3a524146
    b6c8:	0020      	.short	0x0020
    b6ca:	6148      	.short	0x6148
    b6cc:	46206472 	.word	0x46206472
    b6d0:	746c7561 	.word	0x746c7561
    b6d4:	43532021 	.word	0x43532021
    b6d8:	46485f42 	.word	0x46485f42
    b6dc:	203a5253 	.word	0x203a5253
    b6e0:	00          	.byte	0x00
    b6e1:	4d          	.byte	0x4d
    b6e2:	6d65      	.short	0x6d65
    b6e4:	2079726f 	.word	0x2079726f
    b6e8:	616e614d 	.word	0x616e614d
    b6ec:	20726567 	.word	0x20726567
    b6f0:	6c756146 	.word	0x6c756146
    b6f4:	53202174 	.word	0x53202174
    b6f8:	435f4243 	.word	0x435f4243
    b6fc:	3a525346 	.word	0x3a525346
    b700:	53200020 	.word	0x53200020
    b704:	4d5f4243 	.word	0x4d5f4243
    b708:	3a52414d 	.word	0x3a52414d
    b70c:	0020      	.short	0x0020
    b70e:	4d4e      	.short	0x4d4e
    b710:	0a0d2149 	.word	0x0a0d2149
    b714:	00          	.byte	0x00

0000b715 <sys_reset_to_loader_magic>:
    b715:	ff 00 7f 52 45 53 45 54 20 54 4f 20 4c 4f 41 44     ...RESET TO LOAD
    b725:	45 52 7f 00 ff 00 55 73 61 67 65 20 46 61 75 6c     ER....Usage Faul
    b735:	74 21 20 53 43 42 5f 43 46 53 52 3a 20 00 57 61     t! SCB_CFSR: .Wa
    b745:	74 63 68 64 6f 67 20 74 69 6d 65 6f 75 74 21 20     tchdog timeout! 
    b755:	00 57 61 74 63 68 64 6f 67 20 52 65 73 65 74 20     .Watchdog Reset 
    b765:	43 6f 75 6e 74 3a 20 00 31 33 2e 38 38 39 20 6e     Count: .13.889 n
    b775:	73 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47     s..[1;33mWARNING
    b785:	1b 5b 30 6d 20 2d 20 41 72 62 69 74 72 61 74 69     .[0m - Arbitrati
    b795:	6f 6e 20 65 72 72 6f 72 2e 20 42 75 73 3a 20 00     on error. Bus: .
    b7a5:	1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b     .[1;33mWARNING.[
    b7b5:	30 6d 20 2d 20 4e 41 43 4b 20 52 65 63 65 69 76     0m - NACK Receiv
    b7c5:	65 64 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     ed....[1;33mWARN
    b7d5:	49 4e 47 1b 5b 30 6d 20 2d 20 41 72 62 69 74 72     ING.[0m - Arbitr
    b7e5:	61 74 69 6f 6e 20 6c 6f 73 74 0d 0a 00 4c 45 44     ation lost...LED
    b7f5:	5f 63 6f 6e 74 72 6f 6c 5f 63 61 70 61 62 69 6c     _control_capabil
    b805:	69 74 79 28 6d 6f 64 65 2c 61 6d 6f 75 6e 74 29     ity(mode,amount)
    b815:	00                                                  .

0000b816 <LED_ledEnableMask>:
    b816:	e8 00 00 00 ff 00 00 00 ff 00 00 00 ff 00 00 00     ................
    b826:	ff 00 00 00 3f 00 00 00 00 00 00 00 00 00 00 00     ....?...........
    b836:	00 00 00 00 00 00 00 00 1b 5b 31 3b 33 35 6d 44     .........[1;35mD
    b846:	45 42 55 47 1b 5b 30 6d 20 2d 20 31 66 72 61 6d     EBUG.[0m - 1fram
    b856:	65 2f 00 6d 73 20 2b 20 00 20 74 69 63 6b 73 00     e/.ms + . ticks.
    b866:	20 2d 20 43 6f 75 6c 64 20 6e 6f 74 20 6d 65 65      - Could not mee
    b876:	74 20 66 72 61 6d 65 72 61 74 65 3a 20 00 49 53     t framerate: .IS
    b886:	53 49 4c 65 64 00 1b 5b 31 3b 33 32 6d 49 4e 46     SILed..[1;32mINF
    b896:	4f 1b 5b 30 6d 20 2d 20 46 50 53 20 54 6f 67 67     O.[0m - FPS Togg
    b8a6:	6c 65 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     le..[1;32mINFO.[
    b8b6:	30 6d 20 2d 20 53 65 74 74 69 6e 67 20 66 72 61     0m - Setting fra
    b8c6:	6d 65 72 61 74 65 20 74 6f 3a 20 00 6d 73 00 1b     merate to: .ms..
    b8d6:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    b8e6:	20 4c 45 44 20 42 72 69 67 68 74 6e 65 73 73 20      LED Brightness 
    b8f6:	53 65 74 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     Set..[1;32mINFO.
    b906:	5b 30 6d 20 2d 20 4c 45 44 73 20 54 6f 67 67 6c     [0m - LEDs Toggl
    b916:	65 00                                               e.

0000b918 <ledCLIDict>:
    b918:	2d ba 00 00 79 b9 00 00 01 2e 00 00 36 ba 00 00     -...y.......6...
    b928:	af b9 00 00 a9 2e 00 00 3d ba 00 00 df b9 00 00     ........=.......
    b938:	e5 30 00 00 46 ba 00 00 f1 b9 00 00 0d 2e 00 00     .0..F...........
    b948:	4d ba 00 00 0e ba 00 00 d9 2d 00 00 00 00 00 00     M........-......
    b958:	00 00 00 00 00 00 00 00                             ........

0000b960 <ledCLIDictName>:
    b960:	49 53 53 49 20 4c 45 44 20 4d 6f 64 75 6c 65 20     ISSI LED Module 
    b970:	43 6f 6d 6d 61 6e 64 73 00                          Commands.

0000b979 <ledCheckCLIDict_DescEntry>:
    b979:	52 75 6e 20 4c 45 44 20 64 69 61 67 6e 6f 73 74     Run LED diagnost
    b989:	69 63 73 2e 20 4e 6f 74 20 61 6c 6c 20 49 53 53     ics. Not all ISS
    b999:	49 20 63 68 69 70 73 20 73 75 70 70 6f 72 74 20     I chips support 
    b9a9:	74 68 69 73 2e 00                                   this..

0000b9af <ledFPSCLIDict_DescEntry>:
    b9af:	53 68 6f 77 2f 73 65 74 20 46 50 53 20 6f 66 20     Show/set FPS of 
    b9bf:	4c 45 44 20 64 72 69 76 65 72 2c 20 72 20 2d 20     LED driver, r - 
    b9cf:	52 65 73 65 74 20 66 72 61 6d 65 72 61 74 65 00     Reset framerate.

0000b9df <ledResetCLIDict_DescEntry>:
    b9df:	52 65 73 65 74 20 49 53 53 49 20 63 68 69 70 73     Reset ISSI chips
    b9ef:	2e 00                                               ..

0000b9f1 <ledSetCLIDict_DescEntry>:
    b9f1:	53 65 74 20 49 53 53 49 20 6f 76 65 72 61 6c 6c     Set ISSI overall
    ba01:	20 62 72 69 67 68 74 6e 65 73 73 2e 00               brightness..

0000ba0e <ledToggleCLIDict_DescEntry>:
    ba0e:	54 6f 67 67 6c 65 20 49 53 53 49 20 68 61 72 64     Toggle ISSI hard
    ba1e:	77 61 72 65 20 73 68 75 74 64 6f 77 6e 2e 00 6c     ware shutdown..l
    ba2e:	65 64 43 68 65 63 6b 00 6c 65 64 46 50 53 00 6c     edCheck.ledFPS.l
    ba3e:	65 64 52 65 73 65 74 00 6c 65 64 53 65 74 00 6c     edReset.ledSet.l
    ba4e:	65 64 54 6f 67 67 6c 65 00 1b 5b 31 6d 4f 1b 5b     edToggle..[1mO.[
    ba5e:	30 6d 00 1b 5b 31 3b 33 33 6d 50 1b 5b 30 6d 00     0m..[1;33mP.[0m.
    ba6e:	1b 5b 31 3b 33 32 6d 48 1b 5b 30 6d 00 1b 5b 31     .[1;32mH.[0m..[1
    ba7e:	3b 33 35 6d 52 1b 5b 30 6d 00 1b 5b 31 3b 33 31     ;35mR.[0m..[1;31
    ba8e:	6d 49 1b 5b 30 6d 00 4d 61 74 72 69 78 41 52 4d     mI.[0m.MatrixARM
    ba9e:	50 65 72 69 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     Peri..[1;5;31mER
    baae:	52 4f 52 1b 5b 30 6d 20 2d 20 4d 61 74 72 69 78     ROR.[0m - Matrix
    babe:	20 73 63 61 6e 20 62 75 67 21 21 20 52 65 70 6f      scan bug!! Repo
    bace:	72 74 20 6d 65 21 20 2d 20 00 20 43 6f 6c 3a 20     rt me! - . Col: 
    bade:	00 20 52 6f 77 3a 20 00 20 4b 65 79 3a 20 00 1b     . Row: . Key: ..
    baee:	5b 31 6d 00 20 30 78 00 3c 6b 65 79 3e 3a 3c 70     [1m. 0x.<key>:<p
    bafe:	72 65 76 69 6f 75 73 20 73 74 61 74 65 3e 3c 63     revious state><c
    bb0e:	75 72 72 65 6e 74 20 73 74 61 74 65 3e 20 3c 61     urrent state> <a
    bb1e:	63 74 69 76 65 20 63 6f 75 6e 74 3e 20 3c 69 6e     ctive count> <in
    bb2e:	61 63 74 69 76 65 20 63 6f 75 6e 74 3e 00 1b 5b     active count>..[
    bb3e:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
    bb4e:	44 65 62 6f 75 6e 63 65 20 54 69 6d 65 72 3a 20     Debounce Timer: 
    bb5e:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    bb6e:	20 2d 20 4d 61 74 72 69 78 20 44 65 62 75 67 20      - Matrix Debug 
    bb7e:	4d 6f 64 65 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e     Mode: ..[1;32mIN
    bb8e:	46 4f 1b 5b 30 6d 20 2d 20 43 6f 6c 75 6d 6e 73     FO.[0m - Columns
    bb9e:	3a 20 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     :  ..[1;32mINFO.
    bbae:	5b 30 6d 20 2d 20 52 6f 77 73 3a 20 20 20 20 20     [0m - Rows:     
    bbbe:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    bbce:	20 2d 20 4d 61 78 20 4b 65 79 73 3a 20 00 1b 5b      - Max Keys: ..[
    bbde:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
    bbee:	53 74 72 6f 62 65 20 44 65 6c 61 79 3a 20 00        Strobe Delay: .

0000bbfd <debounceCLIDict_DescEntry>:
    bbfd:	53 65 74 20 74 68 65 20 64 65 62 6f 75 6e 63 65     Set the debounce
    bc0d:	20 74 69 6d 65 72 20 28 6d 73 29 2e 20 55 73 65      timer (ms). Use
    bc1d:	66 75 6c 20 66 6f 72 20 62 6f 75 6e 63 79 20 73     ful for bouncy s
    bc2d:	77 69 74 63 68 65 73 2e 00 00 00                    witches....

0000bc38 <matrixCLIDict>:
    bc38:	df bd 00 00 fd bb 00 00 69 34 00 00 e8 bd 00 00     ........i4......
    bc48:	97 bc 00 00 01 35 00 00 f4 bd 00 00 1d bd 00 00     .....5..........
    bc58:	b1 34 00 00 ff bd 00 00 45 bd 00 00 41 34 00 00     .4......E...A4..
    bc68:	0b be 00 00 17 be 00 00 7d 35 00 00 00 00 00 00     ........}5......
    bc78:	00 00 00 00 00 00 00 00                             ........

0000bc80 <matrixCLIDictName>:
    bc80:	4d 61 74 72 69 78 20 4d 6f 64 75 6c 65 20 43 6f     Matrix Module Co
    bc90:	6d 6d 61 6e 64 73 00                                mmands.

0000bc97 <matrixDebugCLIDict_DescEntry>:
    bc97:	45 6e 61 62 6c 65 73 20 6d 61 74 72 69 78 20 64     Enables matrix d
    bca7:	65 62 75 67 20 6d 6f 64 65 2c 20 70 72 69 6e 74     ebug mode, print
    bcb7:	73 20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20     s out each scan 
    bcc7:	63 6f 64 65 2e 0d 0a 09 09 49 66 20 61 72 67 75     code.....If argu
    bcd7:	6d 65 6e 74 20 1b 5b 33 35 6d 54 1b 5b 30 6d 20     ment .[35mT.[0m 
    bce7:	69 73 20 67 69 76 65 6e 2c 20 70 72 69 6e 74 73     is given, prints
    bcf7:	20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20 63      out each scan c
    bd07:	6f 64 65 20 73 74 61 74 65 20 74 72 61 6e 73 69     ode state transi
    bd17:	74 69 6f 6e 2e 00                                   tion..

0000bd1d <matrixInfoCLIDict_DescEntry>:
    bd1d:	50 72 69 6e 74 20 69 6e 66 6f 20 61 62 6f 75 74     Print info about
    bd2d:	20 74 68 65 20 63 6f 6e 66 69 67 75 72 65 64 20      the configured 
    bd3d:	6d 61 74 72 69 78 2e 00                             matrix..

0000bd45 <matrixStateCLIDict_DescEntry>:
    bd45:	50 72 69 6e 74 73 20 6f 75 74 20 74 68 65 20 63     Prints out the c
    bd55:	75 72 72 65 6e 74 20 73 63 61 6e 20 74 61 62 6c     urrent scan tabl
    bd65:	65 20 4e 20 74 69 6d 65 73 2e 0d 0a 09 09 20 1b     e N times..... .
    bd75:	5b 31 6d 4f 1b 5b 30 6d 20 2d 20 4f 66 66 2c 20     [1mO.[0m - Off, 
    bd85:	1b 5b 31 3b 33 33 6d 50 1b 5b 30 6d 20 2d 20 50     .[1;33mP.[0m - P
    bd95:	72 65 73 73 2c 20 1b 5b 31 3b 33 32 6d 48 1b 5b     ress, .[1;32mH.[
    bda5:	30 6d 20 2d 20 48 6f 6c 64 2c 20 1b 5b 31 3b 33     0m - Hold, .[1;3
    bdb5:	35 6d 52 1b 5b 30 6d 20 2d 20 52 65 6c 65 61 73     5mR.[0m - Releas
    bdc5:	65 2c 20 1b 5b 31 3b 33 31 6d 49 1b 5b 30 6d 20     e, .[1;31mI.[0m 
    bdd5:	2d 20 49 6e 76 61 6c 69 64 00 64 65 62 6f 75 6e     - Invalid.deboun
    bde5:	63 65 00 6d 61 74 72 69 78 44 65 62 75 67 00 6d     ce.matrixDebug.m
    bdf5:	61 74 72 69 78 49 6e 66 6f 00 6d 61 74 72 69 78     atrixInfo.matrix
    be05:	53 74 61 74 65 00 73 74 72 6f 62 65 44 65 6c 61     State.strobeDela
    be15:	79 00                                               y.

0000be17 <strobeDelayCLIDict_DescEntry>:
    be17:	53 65 74 20 74 68 65 20 73 74 72 6f 62 65 20 64     Set the strobe d
    be27:	65 6c 61 79 20 28 75 73 29 2e 20 55 73 65 66 75     elay (us). Usefu
    be37:	6c 20 66 6f 72 20 62 61 64 20 70 75 6c 6c 75 70     l for bad pullup
    be47:	20 72 65 73 69 73 74 6f 72 73 2e 00 00 00 00 00      resistors......
    be57:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
    be67:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    be77:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
    be87:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    be97:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
    bea7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    beb7:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
    bec7:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
    bed7:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
    bee7:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    bef7:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
    bf07:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    bf17:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
    bf27:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    bf37:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
    bf47:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    bf57:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
    bf67:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 00 00 00 00 00 00     ??????????......
    bf77:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    bf87:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 00 00 00 00 00 00     ................
    bf97:	07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07     ................
    bfa7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    bfb7:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
    bfc7:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
    bfd7:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
    bfe7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    bff7:	00 00 00 00 00 00 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c007:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c017:	00 00 00 00 00 00 07 07 07 07 07 07 07 07 07 07     ................
    c027:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c037:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
    c047:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c057:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c067:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c077:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c087:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c097:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
    c0a7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c0b7:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
    c0c7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c0d7:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
    c0e7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    c0f7:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c107:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c117:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
    c127:	07 07 07 07 07 07 07 07 07 07 00 00 00 00 00 00     ................
    c137:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
    c147:	fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00     ................
    c157:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
    c167:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    c177:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c187:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c197:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
    c1a7:	07 07 07 07 07 07 07 07 07 07 00 00 00 00 00 00     ................
    c1b7:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
    c1c7:	fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00     ................
    c1d7:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c1e7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c1f7:	00 00 00 00 00 00 00 00 00 00 00 00 00 e0 e0 e0     ................
    c207:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c217:	00 00 00 00 00 00 00 00 00 00 00 00 00 07 07 07     ................
    c227:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c237:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
    c247:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c257:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
    c267:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    c277:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c287:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c297:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
    c2a7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c2b7:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
    c2c7:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c2d7:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
    c2e7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
    c2f7:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    c307:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c317:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
    c327:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
    c337:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
    c347:	fc fc fc fc ff ff ff ff ff ff 00 00 00 39 b9 ea     .............9..
    c357:	aa 8d 8d a8 a8 27 27 a0 1f 4b 4b 8d 8d b5 34 00     .....''..KK...4.
    c367:	00 42 82 f3 b3 f6 f6 a5 a5 49 49 b7 b7 5d 5d 45     .B.......II..]]E
    c377:	85 fc bc f6 b6 2d 2d c1 00 7e 7e 3c 3c 03 83 94     .....--..~~<<...
    c387:	13 f9 b9 ca 09 d3 12 84 84 4c 43 44 5f 6c 61 79     .........LCD_lay
    c397:	65 72 53 74 61 63 6b 45 78 61 63 74 5f 63 61 70     erStackExact_cap
    c3a7:	61 62 69 6c 69 74 79 28 6e 75 6d 2c 6c 61 79 65     ability(num,laye
    c3b7:	72 31 2c 6c 61 79 65 72 32 2c 6c 61 79 65 72 33     r1,layer2,layer3
    c3c7:	2c 6c 61 79 65 72 34 29 00 4c 43 44 5f 6c 61 79     ,layer4).LCD_lay
    c3d7:	65 72 53 74 61 63 6b 5f 63 61 70 61 62 69 6c 69     erStack_capabili
    c3e7:	74 79 28 29 00 53 54 4c 63 64 00                    ty().STLcd.

0000c3f2 <STLcdDefaultImage>:
    c3f2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c402:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c412:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c422:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    c432:	ff ff ff ff ff 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
    c442:	1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
    c452:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c462:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c472:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c482:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c492:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c4a2:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    c4b2:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c4c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c4d2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c4e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c4f2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c502:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c512:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c522:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    c532:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c542:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c552:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c562:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c572:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c582:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c592:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    c5a2:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    c5b2:	ff ff ff ff ff f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
    c5c2:	f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
    c5d2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c5e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    c5f2:	4e 6f 20 61 72 67 73 20 70 72 6f 76 69 64 65 64     No args provided
    c602:	2e 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     ...[1;32mINFO.[0
    c612:	6d 20 2d 20 53 65 6e 64 69 6e 67 2d 20 00 1b 5b     m - Sending- ..[
    c622:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
    c632:	53 65 6e 64 69 6e 67 20 57 49 54 48 20 41 30 20     Sending WITH A0 
    c642:	46 4c 41 47 20 53 45 54 2d 20 00 00 00 00           FLAG SET- ....

0000c650 <lcdCLIDict>:
    c650:	bf c7 00 00 af c6 00 00 d9 3c 00 00 c6 c7 00 00     .........<......
    c660:	f3 c6 00 00 0d 3b 00 00 cf c7 00 00 38 c7 00 00     .....;......8...
    c670:	21 3c 00 00 d7 c7 00 00 86 c7 00 00 83 3e 00 00     !<...........>..
    c680:	df c7 00 00 a5 c7 00 00 8d 3d 00 00 00 00 00 00     .........=......
    c690:	00 00 00 00 00 00 00 00                             ........

0000c698 <lcdCLIDictName>:
    c698:	53 54 20 4c 43 44 20 4d 6f 64 75 6c 65 20 43 6f     ST LCD Module Co
    c6a8:	6d 6d 61 6e 64 73 00                                mmands.

0000c6af <lcdCmdCLIDict_DescEntry>:
    c6af:	53 65 6e 64 20 62 79 74 65 20 76 69 61 20 53 50     Send byte via SP
    c6bf:	49 2c 20 73 65 63 6f 6e 64 20 61 72 67 75 6d 65     I, second argume
    c6cf:	6e 74 20 65 6e 61 62 6c 65 73 20 61 30 2e 20 44     nt enables a0. D
    c6df:	65 66 61 75 6c 74 73 20 74 6f 20 63 6f 6e 74 72     efaults to contr
    c6ef:	6f 6c 2e 00                                         ol..

0000c6f3 <lcdColorCLIDict_DescEntry>:
    c6f3:	53 65 74 20 62 61 63 6b 6c 69 67 68 74 20 63 6f     Set backlight co
    c703:	6c 6f 72 2e 20 33 20 31 36 2d 62 69 74 20 6e 75     lor. 3 16-bit nu
    c713:	6d 62 65 72 73 3a 20 52 20 47 20 42 2e 20 69 2e     mbers: R G B. i.
    c723:	65 2e 20 30 78 46 46 46 20 30 78 31 34 34 34 20     e. 0xFFF 0x1444 
    c733:	30 78 33 32 00                                      0x32.

0000c738 <lcdDispCLIDict_DescEntry>:
    c738:	57 72 69 74 65 20 62 79 74 65 28 73 29 20 74 6f     Write byte(s) to
    c748:	20 67 69 76 65 6e 20 70 61 67 65 20 73 74 61 72      given page star
    c758:	74 69 6e 67 20 61 74 20 67 69 76 65 6e 20 61 64     ting at given ad
    c768:	64 72 65 73 73 2e 20 69 2e 65 2e 20 30 78 31 20     dress. i.e. 0x1 
    c778:	30 78 35 20 30 78 46 46 20 30 78 30 30 00           0x5 0xFF 0x00.

0000c786 <lcdInitCLIDict_DescEntry>:
    c786:	52 65 2d 69 6e 69 74 69 61 6c 69 7a 65 20 74 68     Re-initialize th
    c796:	65 20 4c 43 44 20 64 69 73 70 6c 61 79 2e 00        e LCD display..

0000c7a5 <lcdTestCLIDict_DescEntry>:
    c7a5:	54 65 73 74 20 6f 75 74 20 74 68 65 20 4c 43 44     Test out the LCD
    c7b5:	20 64 69 73 70 6c 61 79 2e 00 6c 63 64 43 6d 64      display..lcdCmd
    c7c5:	00 6c 63 64 43 6f 6c 6f 72 00 6c 63 64 44 69 73     .lcdColor.lcdDis
    c7d5:	70 00 6c 63 64 49 6e 69 74 00 6c 63 64 54 65 73     p.lcdInit.lcdTes
    c7e5:	74 00 00 bc ce 00 00 c7 ce 00 00 d1 ce 00 00 df     t...............
    c7f5:	ce 00 00 e8 ce 00 00 f1 ce 00 00 fb ce 00 00 0c     ................
    c805:	cf 00 00 19 cf 00 00 16 01 16 01 01 00 01 05 00     ................
    c815:	03 16 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47     ...[1;33mWARNING
    c825:	1b 5b 30 6d 20 2d 20 54 6f 6f 20 6d 75 63 68 20     .[0m - Too much 
    c835:	64 61 74 61 20 74 6f 20 73 65 6e 64 20 6f 6e 20     data to send on 
    c845:	55 41 52 54 00 2c 20 77 61 69 74 69 6e 67 2e 2e     UART., waiting..
    c855:	2e 0d 0a 00 20 2b 00 1b 5b 31 3b 35 3b 33 31 6d     .... +..[1;5;31m
    c865:	45 52 52 4f 52 1b 5b 30 6d 20 2d 20 54 6f 6f 20     ERROR.[0m - Too 
    c875:	62 69 67 20 6f 66 20 61 20 63 6f 6d 6d 61 6e 64     big of a command
    c885:	20 74 6f 20 66 69 74 20 69 6e 74 6f 20 74 68 65      to fit into the
    c895:	20 62 75 66 66 65 72 2e 2e 2e 00 1b 5b 31 3b 35      buffer.....[1;5
    c8a5:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
    c8b5:	49 6e 76 61 6c 69 64 20 55 41 52 54 20 74 6f 20     Invalid UART to 
    c8c5:	73 65 6e 64 20 66 72 6f 6d 2e 2e 2e 0d 0a 00 1b     send from.......
    c8d5:	5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20     [1;35mDEBUG.[0m 
    c8e5:	2d 20 41 6e 69 6d 61 74 69 6f 6e 0d 0a 00 1b 5b     - Animation....[
    c8f5:	31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d     1;35mDEBUG.[0m -
    c905:	20 50 45 4e 44 49 4e 47 20 53 45 54 20 2d 3e 20      PENDING SET -> 
    c915:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
    c925:	5b 30 6d 20 2d 20 43 61 62 6c 65 20 46 61 75 6c     [0m - Cable Faul
    c935:	74 21 0d 0a 00 20 53 6c 61 76 65 20 00 20 4d 61     t!... Slave . Ma
    c945:	73 74 65 72 20 00 1b 5b 31 3b 33 35 6d 44 45 42     ster ..[1;35mDEB
    c955:	55 47 1b 5b 30 6d 20 2d 20 43 41 42 4c 45 43 48     UG.[0m - CABLECH
    c965:	45 43 4b 20 52 45 43 45 49 56 45 20 2d 20 00 1b     ECK RECEIVE - ..
    c975:	5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20     [1;35mDEBUG.[0m 
    c985:	2d 20 49 64 45 6e 75 6d 65 72 61 74 69 6f 6e 0d     - IdEnumeration.
    c995:	0a 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52     ...[1;5;31mERROR
    c9a5:	1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 49     .[0m - Invalid I
    c9b5:	64 45 6e 75 6d 65 72 61 74 69 6f 6e 20 64 69 72     dEnumeration dir
    c9c5:	65 63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b 31 3b     ection.......[1;
    c9d5:	33 35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 49     35mDEBUG.[0m - I
    c9e5:	64 52 65 70 6f 72 74 0d 0a 00 1b 5b 31 3b 33 32     dReport....[1;32
    c9f5:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 49 64 20 52     mINFO.[0m - Id R
    ca05:	65 70 6f 72 74 65 64 3a 20 00 1b 5b 31 3b 33 35     eported: ..[1;35
    ca15:	6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 49 64 52     mDEBUG.[0m - IdR
    ca25:	65 71 75 65 73 74 0d 0a 00 1b 5b 31 3b 35 3b 33     equest....[1;5;3
    ca35:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e     1mERROR.[0m - In
    ca45:	76 61 6c 69 64 20 49 64 52 65 71 75 65 73 74 20     valid IdRequest 
    ca55:	64 69 72 65 63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b     direction.......
    ca65:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
    ca75:	6d 20 2d 20 49 6e 76 61 6c 69 64 20 53 63 61 6e     m - Invalid Scan
    ca85:	43 6f 64 65 20 64 69 72 65 63 74 69 6f 6e 2e 2e     Code direction..
    ca95:	2e 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     .....[1;33mWARNI
    caa5:	4e 47 1b 5b 30 6d 20 2d 20 4e 6f 74 20 65 6e 6f     NG.[0m - Not eno
    cab5:	75 67 68 20 69 6e 74 65 72 63 6f 6e 6e 65 63 74     ugh interconnect
    cac5:	20 6c 61 79 6f 75 74 20 6e 6f 64 65 73 20 63 6f      layout nodes co
    cad5:	6e 66 69 67 75 72 65 64 3a 20 00 1b 5b 31 3b 33     nfigured: ..[1;3
    cae5:	35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 00 20     5mDEBUG.[0m - . 
    caf5:	57 61 69 74 20 00 20 53 59 4e 20 00 20 53 4f 48     Wait . SYN . SOH
    cb05:	20 00 20 23 23 23 20 00 20 43 4d 44 20 00 1b 5b      . ### . CMD ..[
    cb15:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
    cb25:	20 2d 20 49 6e 76 61 6c 69 64 20 55 41 52 54 53      - Invalid UARTS
    cb35:	74 61 74 75 73 2e 2e 2e 00 54 78 46 49 46 4f 20     tatus....TxFIFO 
    cb45:	30 20 2d 20 00 54 78 46 49 46 4f 20 31 20 2d 20     0 - .TxFIFO 1 - 
    cb55:	00 55 41 52 54 43 6f 6e 6e 65 63 74 00 1b 5b 31     .UARTConnect..[1
    cb65:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 43     ;32mINFO.[0m - C
    cb75:	6f 6e 6e 65 63 74 20 44 65 62 75 67 20 4d 6f 64     onnect Debug Mod
    cb85:	65 20 54 6f 67 67 6c 65 00 1b 5b 31 3b 33 32 6d     e Toggle..[1;32m
    cb95:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 6e 64 69     INFO.[0m - Sendi
    cba5:	6e 67 20 53 79 6e 63 20 49 64 6c 65 73 2e 2e 2e     ng Sync Idles...
    cbb5:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    cbc5:	20 2d 20 4c 69 73 74 20 6f 66 20 55 41 52 54 43      - List of UARTC
    cbd5:	6f 6e 6e 65 63 74 20 63 6f 6d 6d 61 6e 64 73 00     onnect commands.
    cbe5:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    cbf5:	2d 20 53 65 74 74 69 6e 67 20 64 65 76 69 63 65     - Setting device
    cc05:	20 61 73 20 73 6c 61 76 65 2e 00 1b 5b 31 3b 33      as slave...[1;3
    cc15:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 74     2mINFO.[0m - Set
    cc25:	74 69 6e 67 20 64 65 76 69 63 65 20 61 73 20 6d     ting device as m
    cc35:	61 73 74 65 72 2e 00 1b 5b 31 3b 33 32 6d 49 4e     aster...[1;32mIN
    cc45:	46 4f 1b 5b 30 6d 20 2d 20 52 65 73 65 74 74 69     FO.[0m - Resetti
    cc55:	6e 67 20 55 41 52 54 43 6f 6e 6e 65 63 74 20 73     ng UARTConnect s
    cc65:	74 61 74 65 2e 2e 2e 00 4d 61 73 74 65 72 00 53     tate....Master.S
    cc75:	6c 61 76 65 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     lave..[1;32mINFO
    cc85:	1b 5b 30 6d 20 2d 20 55 41 52 54 43 6f 6e 6e 65     .[0m - UARTConne
    cc95:	63 74 20 53 74 61 74 75 73 00 0d 0a 44 65 76 69     ct Status...Devi
    cca5:	63 65 20 54 79 70 65 3a 09 00 0d 0a 44 65 76 69     ce Type:....Devi
    ccb5:	63 65 20 49 64 3a 09 00 0d 0a 4d 61 78 20 49 64     ce Id:....Max Id
    ccc5:	3a 09 00 0d 0a 4d 61 73 74 65 72 20 3c 3d 0d 0a     :....Master <=..
    ccd5:	09 53 74 61 74 75 73 3a 09 00 0d 0a 09 46 61 75     .Status:.....Fau
    cce5:	6c 74 73 3a 09 00 0d 0a 09 52 78 3a 09 00 0d 0a     lts:.....Rx:....
    ccf5:	09 54 78 3a 09 00 0d 0a 53 6c 61 76 65 20 3c 3d     .Tx:....Slave <=
    cd05:	0d 0a 09 53 74 61 74 75 73 3a 09 00                 ...Status:..

0000cd11 <connectCmdCLIDict_DescEntry>:
    cd11:	53 65 6e 64 73 20 61 20 63 6f 6d 6d 61 6e 64 20     Sends a command 
    cd21:	76 69 61 20 55 41 52 54 20 43 6f 6e 6e 65 63 74     via UART Connect
    cd31:	2c 20 66 69 72 73 74 20 61 72 67 20 69 73 20 77     , first arg is w
    cd41:	68 69 63 68 20 75 61 72 74 2c 20 6e 65 78 74 20     hich uart, next 
    cd51:	61 72 67 20 69 73 20 74 68 65 20 63 6f 6d 6d 61     arg is the comma
    cd61:	6e 64 2c 20 72 65 73 74 20 61 72 65 20 74 68 65     nd, rest are the
    cd71:	20 61 72 67 75 6d 65 6e 74 73 2e 00                  arguments..

0000cd7d <connectDbgCLIDict_DescEntry>:
    cd7d:	54 6f 67 67 6c 65 20 55 41 52 54 43 6f 6e 6e 65     Toggle UARTConne
    cd8d:	63 74 20 64 65 62 75 67 20 6d 6f 64 65 2e 00        ct debug mode..

0000cd9c <connectIdlCLIDict_DescEntry>:
    cd9c:	53 65 6e 64 73 20 4e 20 6e 75 6d 62 65 72 20 6f     Sends N number o
    cdac:	66 20 49 64 6c 65 20 63 6f 6d 6d 61 6e 64 73 2c     f Idle commands,
    cdbc:	20 32 20 69 73 20 74 68 65 20 64 65 66 61 75 6c      2 is the defaul
    cdcc:	74 20 76 61 6c 75 65 2c 20 61 6e 64 20 73 68 6f     t value, and sho
    cddc:	75 6c 64 20 62 65 20 73 75 66 66 69 63 69 65 6e     uld be sufficien
    cdec:	74 20 69 6e 20 6d 6f 73 74 20 63 61 73 65 73 2e     t in most cases.
    cdfc:	00                                                  .

0000cdfd <connectLstCLIDict_DescEntry>:
    cdfd:	4c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 20     Lists available 
    ce0d:	55 41 52 54 43 6f 6e 6e 65 63 74 20 63 6f 6d 6d     UARTConnect comm
    ce1d:	61 6e 64 73 20 61 6e 64 20 69 6e 64 65 78 20 69     ands and index i
    ce2d:	64 00                                               d.

0000ce2f <connectMstCLIDict_DescEntry>:
    ce2f:	53 65 74 73 20 74 68 65 20 64 65 76 69 63 65 20     Sets the device 
    ce3f:	61 73 20 6d 61 73 74 65 72 2e 20 55 73 65 20 61     as master. Use a
    ce4f:	72 67 75 6d 65 6e 74 20 6f 66 20 73 20 74 6f 20     rgument of s to 
    ce5f:	73 65 74 20 61 73 20 73 6c 61 76 65 2e 00           set as slave..

0000ce6d <connectRstCLIDict_DescEntry>:
    ce6d:	52 65 73 65 74 73 20 62 6f 74 68 20 52 78 20 61     Resets both Rx a
    ce7d:	6e 64 20 54 78 20 63 6f 6e 6e 65 63 74 20 62 75     nd Tx connect bu
    ce8d:	66 66 65 72 73 20 61 6e 64 20 73 74 61 74 65 20     ffers and state 
    ce9d:	76 61 72 69 61 62 6c 65 73 2e 00                    variables..

0000cea8 <connectStsCLIDict_DescEntry>:
    cea8:	55 41 52 54 43 6f 6e 6e 65 63 74 20 73 74 61 74     UARTConnect stat
    ceb8:	75 73 2e 00 43 61 62 6c 65 43 68 65 63 6b 00 49     us..CableCheck.I
    cec8:	64 52 65 71 75 65 73 74 00 49 64 45 6e 75 6d 65     dRequest.IdEnume
    ced8:	72 61 74 69 6f 6e 00 49 64 52 65 70 6f 72 74 00     ration.IdReport.
    cee8:	53 63 61 6e 43 6f 64 65 00 41 6e 69 6d 61 74 69     ScanCode.Animati
    cef8:	6f 6e 00 52 65 6d 6f 74 65 43 61 70 61 62 69 6c     on.RemoteCapabil
    cf08:	69 74 79 00 52 65 6d 6f 74 65 4f 75 74 70 75 74     ity.RemoteOutput
    cf18:	00 52 65 6d 6f 74 65 49 6e 70 75 74 00 63 6f 6e     .RemoteInput.con
    cf28:	6e 65 63 74 43 6d 64 00 63 6f 6e 6e 65 63 74 44     nectCmd.connectD
    cf38:	62 67 00 63 6f 6e 6e 65 63 74 49 64 6c 00 63 6f     bg.connectIdl.co
    cf48:	6e 6e 65 63 74 4c 73 74 00 63 6f 6e 6e 65 63 74     nnectLst.connect
    cf58:	4d 73 74 00 63 6f 6e 6e 65 63 74 52 73 74 00 63     Mst.connectRst.c
    cf68:	6f 6e 6e 65 63 74 53 74 73 00 00 00                 onnectSts...

0000cf74 <uartConnectCLIDict>:
    cf74:	25 cf 00 00 11 cd 00 00 91 4b 00 00 30 cf 00 00     %........K..0...
    cf84:	7d cd 00 00 2d 42 00 00 3b cf 00 00 9c cd 00 00     }...-B..;.......
    cf94:	15 4d 00 00 46 cf 00 00 fd cd 00 00 89 43 00 00     .M..F........C..
    cfa4:	51 cf 00 00 2f ce 00 00 2d 45 00 00 5c cf 00 00     Q.../...-E..\...
    cfb4:	6d ce 00 00 95 4d 00 00 67 cf 00 00 a8 ce 00 00     m....M..g.......
    cfc4:	e5 43 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .C..............

0000cfd4 <uartConnectCLIDictName>:
    cfd4:	55 41 52 54 43 6f 6e 6e 65 63 74 20 4d 6f 64 75     UARTConnect Modu
    cfe4:	6c 65 20 43 6f 6d 6d 61 6e 64 73 00                 le Commands.

0000cff0 <CapabilitiesList>:
    cff0:	21 40 00 00 09 00 00 00 65 41 00 00 00 00 00 00     !@......eA......
    d000:	e9 33 00 00 02 00 00 00 09 5a 00 00 02 01 00 00     .3.......Z......
    d010:	31 5a 00 00 02 01 00 00 95 5a 00 00 01 01 00 00     1Z.......Z......
    d020:	59 5a 00 00 02 01 00 00 e1 59 00 00 03 01 00 00     YZ.......Y......
    d030:	c9 8c 00 00 02 01 00 00 71 8a 00 00 00 01 00 00     ........q.......
    d040:	1d 8e 00 00 00 00 00 00 5d 8e 00 00 00 00 00 00     ........].......
    d050:	0d 8d 00 00 00 01 00 00 21 8d 00 00 01 01 00 00     ........!.......
    d060:	9d 8e 00 00 00 00 00 00 e1 8e 00 00 01 01 00 00     ................
    d070:	65 8d 00 00 06 01 00 00 a1 6c 00 00 01 00 00 00     e........l......
    d080:	55 6c 00 00 02 00 00 00 3d 6e 00 00 07 00 00 00     Ul......=n......
    d090:	8d 6c 00 00 00 00 00 00                             .l......

0000d098 <InterconnectOffsetList>:
    d098:	00 2d 5a 00                                         .-Z.

0000d09c <LayerIndex>:
    d09c:	1c 8a ff 1f ef d9 00 00 00 5a 00 00 88 8b ff 1f     .........Z......
    d0ac:	a7 de 00 00 03 58 00 00 1b 5b 31 3b 33 33 6d 57     .....X...[1;33mW
    d0bc:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 53 63 61     ARNING.[0m - Sca
    d0cc:	6e 43 6f 64 65 20 69 73 20 6f 75 74 20 6f 66 20     nCode is out of 
    d0dc:	72 61 6e 67 65 2f 6e 6f 74 20 64 65 66 69 6e 65     range/not define
    d0ec:	64 3a 20 00 4d 61 63 72 6f 5f 6c 61 79 65 72 4c     d: .Macro_layerL
    d0fc:	61 74 63 68 28 6c 61 79 65 72 49 6e 64 65 78 29     atch(layerIndex)
    d10c:	00 4d 61 63 72 6f 5f 6c 61 79 65 72 4c 6f 63 6b     .Macro_layerLock
    d11c:	28 6c 61 79 65 72 49 6e 64 65 78 29 00 1b 5b 31     (layerIndex)..[1
    d12c:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
    d13c:	2d 20 49 6e 64 65 78 20 68 61 73 20 6e 6f 20 64     - Index has no d
    d14c:	65 66 69 6e 65 64 20 54 72 69 67 67 65 72 20 4d     efined Trigger M
    d15c:	61 63 72 6f 3a 20 00 4d 61 63 72 6f 5f 6c 61 79     acro: .Macro_lay
    d16c:	65 72 52 6f 74 61 74 65 28 70 72 65 76 69 6f 75     erRotate(previou
    d17c:	73 29 00 4d 61 63 72 6f 5f 6c 61 79 65 72 53 68     s).Macro_layerSh
    d18c:	69 66 74 28 6c 61 79 65 72 49 6e 64 65 78 29 00     ift(layerIndex).
    d19c:	1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d     .[1;35mDEBUG.[0m
    d1ac:	20 2d 20 4c 61 79 65 72 20 00 20 30 00 4d 61 63      - Layer . 0.Mac
    d1bc:	72 6f 5f 6c 61 79 65 72 53 74 61 74 65 28 6c 61     ro_layerState(la
    d1cc:	79 65 72 49 6e 64 65 78 2c 6c 61 79 65 72 53 74     yerIndex,layerSt
    d1dc:	61 74 65 29 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     ate)..[1;5;31mER
    d1ec:	52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 74 65 72 63     ROR.[0m - Interc
    d1fc:	6f 6e 6e 65 63 74 20 54 72 69 67 67 65 72 20 45     onnect Trigger E
    d20c:	76 65 6e 74 20 54 79 70 65 20 2d 20 4e 6f 74 20     vent Type - Not 
    d21c:	49 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00 1b 5b     Implemented....[
    d22c:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
    d23c:	20 2d 20 4d 61 63 72 6f 20 54 72 69 67 67 65 72      - Macro Trigger
    d24c:	20 45 76 65 6e 74 20 4f 76 65 72 66 6c 6f 77 21      Event Overflow!
    d25c:	20 53 65 72 69 6f 75 73 20 42 75 67 21 20 00 1b      Serious Bug! ..
    d26c:	5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20     [1;35mDEBUG.[0m 
    d27c:	2d 20 4d 61 63 72 6f 20 53 74 65 70 0d 0a 00 1b     - Macro Step....
    d28c:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
    d29c:	6d 20 2d 20 49 6e 76 61 6c 69 64 20 6b 65 79 20     m - Invalid key 
    d2ac:	73 74 61 74 65 20 2d 20 00 1b 5b 31 3b 35 3b 33     state - ..[1;5;3
    d2bc:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e     1mERROR.[0m - In
    d2cc:	76 61 6c 69 64 20 74 79 70 65 20 2d 20 00 1b 5b     valid type - ..[
    d2dc:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
    d2ec:	20 2d 20 53 63 61 6e 43 6f 64 65 20 69 73 20 6f      - ScanCode is o
    d2fc:	75 74 20 6f 66 20 72 61 6e 67 65 2f 6e 6f 74 20     ut of range/not 
    d30c:	64 65 66 69 6e 65 64 20 2d 20 00 50 61 72 74 69     defined - .Parti
    d31c:	61 6c 4d 61 70 00 2c 00 55 50 00 55 52 00 44 6f     alMap.,.UP.UR.Do
    d32c:	6e 65 00 52 65 70 65 61 74 00 1b 5b 31 3b 33 31     ne.Repeat..[1;31
    d33c:	6d 49 4e 56 41 4c 49 44 1b 5b 30 6d 00 53 77 00     mINVALID.[0m.Sw.
    d34c:	4c 45 44 00 41 6e 00 4c 61 79 65 72 00 49 4e 56     LED.An.Layer.INV
    d35c:	41 4c 49 44 00 00 00 00                             ALID....

0000d364 <ResultMacroList>:
    d364:	53 ee 00 00 80 ee 00 00 ad ee 00 00 da ee 00 00     S...............
    d374:	07 ef 00 00 34 ef 00 00 61 ef 00 00 8d ef 00 00     ....4...a.......
    d384:	c1 ef 00 00 f3 ef 00 00 58 ee 00 00 5c ee 00 00     ........X...\...
    d394:	60 ee 00 00 64 ee 00 00 68 ee 00 00 6c ee 00 00     `...d...h...l...
    d3a4:	70 ee 00 00 74 ee 00 00 78 ee 00 00 7c ee 00 00     p...t...x...|...
    d3b4:	85 ee 00 00 89 ee 00 00 8d ee 00 00 91 ee 00 00     ................
    d3c4:	95 ee 00 00 99 ee 00 00 9d ee 00 00 a1 ee 00 00     ................
    d3d4:	a5 ee 00 00 a9 ee 00 00 b2 ee 00 00 b6 ee 00 00     ................
    d3e4:	ba ee 00 00 be ee 00 00 c2 ee 00 00 c6 ee 00 00     ................
    d3f4:	ca ee 00 00 ce ee 00 00 d2 ee 00 00 d6 ee 00 00     ................
    d404:	df ee 00 00 e3 ee 00 00 e7 ee 00 00 eb ee 00 00     ................
    d414:	ef ee 00 00 f3 ee 00 00 f7 ee 00 00 fb ee 00 00     ................
    d424:	ff ee 00 00 03 ef 00 00 0c ef 00 00 10 ef 00 00     ................
    d434:	14 ef 00 00 18 ef 00 00 1c ef 00 00 20 ef 00 00     ............ ...
    d444:	24 ef 00 00 28 ef 00 00 2c ef 00 00 30 ef 00 00     $...(...,...0...
    d454:	39 ef 00 00 3d ef 00 00 41 ef 00 00 45 ef 00 00     9...=...A...E...
    d464:	49 ef 00 00 4d ef 00 00 51 ef 00 00 55 ef 00 00     I...M...Q...U...
    d474:	59 ef 00 00 5d ef 00 00 65 ef 00 00 69 ef 00 00     Y...]...e...i...
    d484:	6d ef 00 00 71 ef 00 00 75 ef 00 00 79 ef 00 00     m...q...u...y...
    d494:	7d ef 00 00 81 ef 00 00 85 ef 00 00 89 ef 00 00     }...............
    d4a4:	91 ef 00 00 95 ef 00 00 99 ef 00 00 9f ef 00 00     ................
    d4b4:	a5 ef 00 00 ab ef 00 00 b1 ef 00 00 b5 ef 00 00     ................
    d4c4:	b9 ef 00 00 bd ef 00 00 c5 ef 00 00 c9 ef 00 00     ................
    d4d4:	cc ef 00 00 d2 ef 00 00 d8 ef 00 00 de ef 00 00     ................
    d4e4:	e4 ef 00 00 e9 ef 00 00 ee ef 00 00                 ............

0000d4f0 <TriggerMacroList>:
    d4f0:	8a f0 00 00 32 00 00 00 8a f0 00 00 45 00 00 00     ....2.......E...
    d500:	c1 f0 00 00 25 00 00 00 c1 f0 00 00 3f 00 00 00     ....%.......?...
    d510:	f8 f0 00 00 26 00 00 00 f8 f0 00 00 40 00 00 00     ....&.......@...
    d520:	2f f1 00 00 27 00 00 00 2f f1 00 00 41 00 00 00     /...'.../...A...
    d530:	66 f1 00 00 28 00 00 00 66 f1 00 00 42 00 00 00     f...(...f...B...
    d540:	9d f1 00 00 29 00 00 00 9d f1 00 00 43 00 00 00     ....).......C...
    d550:	d4 f1 00 00 2b 00 00 00 d4 f1 00 00 5b 00 00 00     ....+.......[...
    d560:	f7 f1 00 00 53 00 00 00 fc f1 00 00 1e 00 00 00     ....S...........
    d570:	01 f2 00 00 1a 00 00 00 8f f0 00 00 0e 00 00 00     ................
    d580:	94 f0 00 00 14 00 00 00 99 f0 00 00 15 00 00 00     ................
    d590:	9e f0 00 00 5a 00 00 00 a3 f0 00 00 0d 00 00 00     ....Z...........
    d5a0:	a3 f0 00 00 4c 00 00 00 a8 f0 00 00 0f 00 00 00     ....L...........
    d5b0:	a8 f0 00 00 4d 00 00 00 ad f0 00 00 10 00 00 00     ....M...........
    d5c0:	ad f0 00 00 4e 00 00 00 b2 f0 00 00 11 00 00 00     ....N...........
    d5d0:	b2 f0 00 00 4b 00 00 00 b7 f0 00 00 34 00 00 00     ....K.......4...
    d5e0:	bc f0 00 00 58 00 00 00 c6 f0 00 00 03 00 00 00     ....X...........
    d5f0:	c6 f0 00 00 62 00 00 00 cb f0 00 00 02 00 00 00     ....b...........
    d600:	d0 f0 00 00 55 00 00 00 d0 f0 00 00 5f 00 00 00     ....U......._...
    d610:	d5 f0 00 00 13 00 00 00 da f0 00 00 12 00 00 00     ................
    d620:	df f0 00 00 37 00 00 00 e4 f0 00 00 38 00 00 00     ....7.......8...
    d630:	e9 f0 00 00 39 00 00 00 ee f0 00 00 59 00 00 00     ....9.......Y...
    d640:	f3 f0 00 00 46 00 00 00 fd f0 00 00 49 00 00 00     ....F.......I...
    d650:	02 f1 00 00 2a 00 00 00 07 f1 00 00 2e 00 00 00     ....*...........
    d660:	0c f1 00 00 36 00 00 00 11 f1 00 00 35 00 00 00     ....6.......5...
    d670:	16 f1 00 00 33 00 00 00 1b f1 00 00 4f 00 00 00     ....3.......O...
    d680:	20 f1 00 00 5c 00 00 00 25 f1 00 00 31 00 00 00      ...\...%...1...
    d690:	25 f1 00 00 44 00 00 00 2a f1 00 00 24 00 00 00     %...D...*...$...
    d6a0:	2a f1 00 00 3e 00 00 00 34 f1 00 00 23 00 00 00     *...>...4...#...
    d6b0:	34 f1 00 00 3d 00 00 00 39 f1 00 00 22 00 00 00     4...=...9..."...
    d6c0:	39 f1 00 00 3c 00 00 00 3e f1 00 00 21 00 00 00     9...<...>...!...
    d6d0:	3e f1 00 00 3b 00 00 00 43 f1 00 00 20 00 00 00     >...;...C... ...
    d6e0:	43 f1 00 00 3a 00 00 00 48 f1 00 00 2b 00 00 00     C...:...H...+...
    d6f0:	48 f1 00 00 5b 00 00 00 4d f1 00 00 52 00 00 00     H...[...M...R...
    d700:	4d f1 00 00 5c 00 00 00 52 f1 00 00 19 00 00 00     M...\...R.......
    d710:	57 f1 00 00 17 00 00 00 5c f1 00 00 0a 00 00 00     W.......\.......
    d720:	61 f1 00 00 1c 00 00 00 6b f1 00 00 16 00 00 00     a.......k.......
    d730:	70 f1 00 00 57 00 00 00 75 f1 00 00 0c 00 00 00     p...W...u.......
    d740:	7a f1 00 00 0b 00 00 00 7f f1 00 00 09 00 00 00     z...............
    d750:	84 f1 00 00 18 00 00 00 89 f1 00 00 06 00 00 00     ................
    d760:	8e f1 00 00 50 00 00 00 93 f1 00 00 04 00 00 00     ....P...........
    d770:	93 f1 00 00 61 00 00 00 98 f1 00 00 05 00 00 00     ....a...........
    d780:	98 f1 00 00 60 00 00 00 a2 f1 00 00 54 00 00 00     ....`.......T...
    d790:	a2 f1 00 00 5d 00 00 00 a7 f1 00 00 07 00 00 00     ....]...........
    d7a0:	ac f1 00 00 1b 00 00 00 b1 f1 00 00 08 00 00 00     ................
    d7b0:	b6 f1 00 00 1d 00 00 00 bb f1 00 00 1f 00 00 00     ................
    d7c0:	c0 f1 00 00 51 00 00 00 c5 f1 00 00 47 00 00 00     ....Q.......G...
    d7d0:	ca f1 00 00 4a 00 00 00 cf f1 00 00 56 00 00 00     ....J.......V...
    d7e0:	d9 f1 00 00 2c 00 00 00 de f1 00 00 30 00 00 00     ....,.......0...
    d7f0:	de f1 00 00 00 00 00 00 e3 f1 00 00 2f 00 00 00     ............/...
    d800:	e3 f1 00 00 01 00 00 00 e8 f1 00 00 48 00 00 00     ............H...
    d810:	e8 f1 00 00 5e 00 00 00 ed f1 00 00 2d 00 00 00     ....^.......-...
    d820:	f2 f1 00 00 5c 00 00 00                             ....\...

0000d828 <capListCLIDict_DescEntry>:
    d828:	50 72 69 6e 74 73 20 61 6e 20 69 6e 64 65 78 65     Prints an indexe
    d838:	64 20 6c 69 73 74 20 6f 66 20 61 6c 6c 20 6e 6f     d list of all no
    d848:	6e 20 55 53 42 20 6b 65 79 63 6f 64 65 20 63 61     n USB keycode ca
    d858:	70 61 62 69 6c 69 74 69 65 73 2e 00                 pabilities..

0000d864 <capSelectCLIDict_DescEntry>:
    d864:	54 72 69 67 67 65 72 73 20 74 68 65 20 73 70 65     Triggers the spe
    d874:	63 69 66 69 65 64 20 63 61 70 61 62 69 6c 69 74     cified capabilit
    d884:	69 65 73 2e 20 46 69 72 73 74 20 74 77 6f 20 61     ies. First two a
    d894:	72 67 73 20 61 72 65 20 73 74 61 74 65 20 61 6e     rgs are state an
    d8a4:	64 20 73 74 61 74 65 54 79 70 65 2e 0d 0a 09 09     d stateType.....
    d8b4:	1b 5b 33 35 6d 4b 31 31 1b 5b 30 6d 20 4b 65 79     .[35mK11.[0m Key
    d8c4:	62 6f 61 72 64 20 43 61 70 61 62 69 6c 69 74 79     board Capability
    d8d4:	20 30 78 30 42 00 1b 5b 31 3b 33 32 6d 49 4e 46      0x0B..[1;32mINF
    d8e4:	4f 1b 5b 30 6d 20 2d 20 43 61 70 61 62 69 6c 69     O.[0m - Capabili
    d8f4:	74 69 65 73 20 4c 69 73 74 20 00 0d 0a 09 00 1b     ties List ......
    d904:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    d914:	20 4b 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e      K..[1;33mWARNIN
    d924:	47 1b 5b 30 6d 20 2d 20 66 6c 61 73 68 4d 6f 64     G.[0m - flashMod
    d934:	65 45 6e 61 62 6c 65 64 20 6e 6f 74 20 73 65 74     eEnabled not set
    d944:	2c 20 63 61 6e 63 65 6c 6c 69 6e 67 20 66 69 72     , cancelling fir
    d954:	6d 77 61 72 65 20 72 65 6c 6f 61 64 2e 2e 2e 0d     mware reload....
    d964:	0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     ...[1;32mINFO.[0
    d974:	6d 20 2d 20 53 65 74 20 66 6c 61 73 68 4d 6f 64     m - Set flashMod
    d984:	65 45 6e 61 62 6c 65 64 20 74 6f 20 31 20 69 6e     eEnabled to 1 in
    d994:	20 79 6f 75 72 20 6b 6c 6c 20 63 6f 6e 66 69 67      your kll config
    d9a4:	75 72 61 74 69 6f 6e 2e 00 1b 5b 31 3b 33 32 6d     uration...[1;32m
    d9b4:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 4c 61 79 65 72     INFO.[0m - Layer
    d9c4:	20 44 65 62 75 67 20 4d 6f 64 65 3a 20 00 1b 5b      Debug Mode: ..[
    d9d4:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
    d9e4:	4c 61 79 65 72 20 4c 69 73 74 00 44 3a 20 5f 68     Layer List.D: _h
    d9f4:	6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73     ome_oliver_repos
    da04:	5f 65 72 67 6f 64 6f 78 5f 53 63 61 6e 5f 44 65     _ergodox_Scan_De
    da14:	76 69 63 65 73 5f 49 53 53 49 4c 65 64 40 5b 27     vices_ISSILed@['
    da24:	63 61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70     capabilities']_p
    da34:	72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f     rocessed.kll + _
    da44:	68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f     home_oliver_repo
    da54:	73 5f 65 72 67 6f 64 6f 78 5f 53 63 61 6e 5f 44     s_ergodox_Scan_D
    da64:	65 76 69 63 65 73 5f 4d 61 74 72 69 78 41 52 4d     evices_MatrixARM
    da74:	50 65 72 69 6f 64 69 63 40 5b 27 63 61 70 61 62     Periodic@['capab
    da84:	69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73     ilities']_proces
    da94:	73 65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f     sed.kll + _home_
    daa4:	6f 6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72 67     oliver_repos_erg
    dab4:	6f 64 6f 78 5f 53 63 61 6e 5f 44 65 76 69 63 65     odox_Scan_Device
    dac4:	73 5f 53 54 4c 63 64 40 5b 27 63 61 70 61 62 69     s_STLcd@['capabi
    dad4:	6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73     lities']_process
    dae4:	65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f     ed.kll + _home_o
    daf4:	6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72 67 6f     liver_repos_ergo
    db04:	64 6f 78 5f 53 63 61 6e 5f 44 65 76 69 63 65 73     dox_Scan_Devices
    db14:	5f 55 41 52 54 43 6f 6e 6e 65 63 74 40 5b 27 63     _UARTConnect@['c
    db24:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
    db34:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f 68     ocessed.kll + _h
    db44:	6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73     ome_oliver_repos
    db54:	5f 65 72 67 6f 64 6f 78 5f 4d 61 63 72 6f 5f 50     _ergodox_Macro_P
    db64:	61 72 74 69 61 6c 4d 61 70 40 5b 27 63 61 70 61     artialMap@['capa
    db74:	62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65     bilities']_proce
    db84:	73 73 65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65     ssed.kll + _home
    db94:	5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72     _oliver_repos_er
    dba4:	67 6f 64 6f 78 5f 4d 61 63 72 6f 5f 50 69 78 65     godox_Macro_Pixe
    dbb4:	6c 4d 61 70 40 5b 27 63 61 70 61 62 69 6c 69 74     lMap@['capabilit
    dbc4:	69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     ies']_processed.
    dbd4:	6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76     kll + _home_oliv
    dbe4:	65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f 78     er_repos_ergodox
    dbf4:	5f 4f 75 74 70 75 74 5f 48 49 44 2d 49 4f 40 5b     _Output_HID-IO@[
    dc04:	27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f     'capabilities']_
    dc14:	70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20     processed.kll + 
    dc24:	5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70     _home_oliver_rep
    dc34:	6f 73 5f 65 72 67 6f 64 6f 78 5f 4f 75 74 70 75     os_ergodox_Outpu
    dc44:	74 5f 55 53 42 40 5b 27 63 61 70 61 62 69 6c 69     t_USB@['capabili
    dc54:	74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64     ties']_processed
    dc64:	2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69     .kll + _home_oli
    dc74:	76 65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f     ver_repos_ergodo
    dc84:	78 5f 44 65 62 75 67 5f 6c 61 74 65 6e 63 79 40     x_Debug_latency@
    dc94:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
    dca4:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
    dcb4:	20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65      _home_oliver_re
    dcc4:	70 6f 73 5f 65 72 67 6f 64 6f 78 5f 53 63 61 6e     pos_ergodox_Scan
    dcd4:	5f 49 6e 66 69 6e 69 74 79 5f 45 72 67 6f 64 6f     _Infinity_Ergodo
    dce4:	78 40 5b 27 73 63 61 6e 63 6f 64 65 5f 6d 61 70     x@['scancode_map
    dcf4:	27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c     ']_processed.kll
    dd04:	20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f      + _home_oliver_
    dd14:	72 65 70 6f 73 5f 65 72 67 6f 64 6f 78 5f 53 63     repos_ergodox_Sc
    dd24:	61 6e 5f 49 6e 66 69 6e 69 74 79 5f 45 72 67 6f     an_Infinity_Ergo
    dd34:	64 6f 78 40 5b 27 72 69 67 68 74 48 61 6e 64 27     dox@['rightHand'
    dd44:	5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20     ]_processed.kll 
    dd54:	2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72     + _home_oliver_r
    dd64:	65 70 6f 73 5f 65 72 67 6f 64 6f 78 5f 53 63 61     epos_ergodox_Sca
    dd74:	6e 5f 49 6e 66 69 6e 69 74 79 5f 45 72 67 6f 64     n_Infinity_Ergod
    dd84:	6f 78 40 5b 27 73 6c 61 76 65 31 27 5d 5f 70 72     ox@['slave1']_pr
    dd94:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f 68     ocessed.kll + _h
    dda4:	6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73     ome_oliver_repos
    ddb4:	5f 65 72 67 6f 64 6f 78 5f 53 63 61 6e 5f 49 6e     _ergodox_Scan_In
    ddc4:	66 69 6e 69 74 79 5f 45 72 67 6f 64 6f 78 40 5b     finity_Ergodox@[
    ddd4:	27 6c 65 66 74 48 61 6e 64 27 5d 5f 70 72 6f 63     'leftHand']_proc
    dde4:	65 73 73 65 64 2e 6b 6c 6c 20 2b 20 40 5b 27 6c     essed.kll + @['l
    ddf4:	61 79 65 72 2d 64 65 66 61 75 6c 74 27 5d 5f 70     ayer-default']_p
    de04:	72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f     rocessed.kll + _
    de14:	68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f     home_oliver_repo
    de24:	73 5f 65 72 67 6f 64 6f 78 5f 6b 6c 6c 5f 6c 61     s_ergodox_kll_la
    de34:	79 6f 75 74 73 5f 69 6e 66 69 6e 69 74 79 5f 65     youts_infinity_e
    de44:	72 67 6f 64 6f 78 40 5b 27 6c 63 64 46 75 6e 63     rgodox@['lcdFunc
    de54:	4d 61 70 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     Map']_processed.
    de64:	6b 6c 6c 00 20 1b 5b 31 6d 28 64 65 66 61 75 6c     kll. .[1m(defaul
    de74:	74 29 1b 5b 30 6d 00 0d 0a 09 09 20 4c 61 79 65     t).[0m..... Laye
    de84:	72 20 53 74 61 74 65 3a 20 00 20 46 69 72 73 74     r State: . First
    de94:	20 2d 3e 20 4c 61 73 74 20 49 6e 64 69 63 65 73      -> Last Indices
    dea4:	3a 20 00 31 3a 20 5f 68 6f 6d 65 5f 6f 6c 69 76     : .1: _home_oliv
    deb4:	65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f 78     er_repos_ergodox
    dec4:	5f 53 63 61 6e 5f 44 65 76 69 63 65 73 5f 49 53     _Scan_Devices_IS
    ded4:	53 49 4c 65 64 40 5b 27 63 61 70 61 62 69 6c 69     SILed@['capabili
    dee4:	74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64     ties']_processed
    def4:	2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69     .kll + _home_oli
    df04:	76 65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f     ver_repos_ergodo
    df14:	78 5f 53 63 61 6e 5f 44 65 76 69 63 65 73 5f 4d     x_Scan_Devices_M
    df24:	61 74 72 69 78 41 52 4d 50 65 72 69 6f 64 69 63     atrixARMPeriodic
    df34:	40 5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27     @['capabilities'
    df44:	5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20     ]_processed.kll 
    df54:	2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72     + _home_oliver_r
    df64:	65 70 6f 73 5f 65 72 67 6f 64 6f 78 5f 53 63 61     epos_ergodox_Sca
    df74:	6e 5f 44 65 76 69 63 65 73 5f 53 54 4c 63 64 40     n_Devices_STLcd@
    df84:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
    df94:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
    dfa4:	20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65      _home_oliver_re
    dfb4:	70 6f 73 5f 65 72 67 6f 64 6f 78 5f 53 63 61 6e     pos_ergodox_Scan
    dfc4:	5f 44 65 76 69 63 65 73 5f 55 41 52 54 43 6f 6e     _Devices_UARTCon
    dfd4:	6e 65 63 74 40 5b 27 63 61 70 61 62 69 6c 69 74     nect@['capabilit
    dfe4:	69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     ies']_processed.
    dff4:	6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76     kll + _home_oliv
    e004:	65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f 78     er_repos_ergodox
    e014:	5f 4d 61 63 72 6f 5f 50 61 72 74 69 61 6c 4d 61     _Macro_PartialMa
    e024:	70 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65 73     p@['capabilities
    e034:	27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c     ']_processed.kll
    e044:	20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f      + _home_oliver_
    e054:	72 65 70 6f 73 5f 65 72 67 6f 64 6f 78 5f 4d 61     repos_ergodox_Ma
    e064:	63 72 6f 5f 50 69 78 65 6c 4d 61 70 40 5b 27 63     cro_PixelMap@['c
    e074:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
    e084:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f 68     ocessed.kll + _h
    e094:	6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73     ome_oliver_repos
    e0a4:	5f 65 72 67 6f 64 6f 78 5f 4f 75 74 70 75 74 5f     _ergodox_Output_
    e0b4:	48 49 44 2d 49 4f 40 5b 27 63 61 70 61 62 69 6c     HID-IO@['capabil
    e0c4:	69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65     ities']_processe
    e0d4:	64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c     d.kll + _home_ol
    e0e4:	69 76 65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64     iver_repos_ergod
    e0f4:	6f 78 5f 4f 75 74 70 75 74 5f 55 53 42 40 5b 27     ox_Output_USB@['
    e104:	63 61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70     capabilities']_p
    e114:	72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 5f     rocessed.kll + _
    e124:	68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65 70 6f     home_oliver_repo
    e134:	73 5f 65 72 67 6f 64 6f 78 5f 44 65 62 75 67 5f     s_ergodox_Debug_
    e144:	6c 61 74 65 6e 63 79 40 5b 27 63 61 70 61 62 69     latency@['capabi
    e154:	6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73     lities']_process
    e164:	65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f     ed.kll + _home_o
    e174:	6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72 67 6f     liver_repos_ergo
    e184:	64 6f 78 5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74     dox_Scan_Infinit
    e194:	79 5f 45 72 67 6f 64 6f 78 40 5b 27 73 63 61 6e     y_Ergodox@['scan
    e1a4:	63 6f 64 65 5f 6d 61 70 27 5d 5f 70 72 6f 63 65     code_map']_proce
    e1b4:	73 73 65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65     ssed.kll + _home
    e1c4:	5f 6f 6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72     _oliver_repos_er
    e1d4:	67 6f 64 6f 78 5f 53 63 61 6e 5f 49 6e 66 69 6e     godox_Scan_Infin
    e1e4:	69 74 79 5f 45 72 67 6f 64 6f 78 40 5b 27 72 69     ity_Ergodox@['ri
    e1f4:	67 68 74 48 61 6e 64 27 5d 5f 70 72 6f 63 65 73     ghtHand']_proces
    e204:	73 65 64 2e 6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f     sed.kll + _home_
    e214:	6f 6c 69 76 65 72 5f 72 65 70 6f 73 5f 65 72 67     oliver_repos_erg
    e224:	6f 64 6f 78 5f 53 63 61 6e 5f 49 6e 66 69 6e 69     odox_Scan_Infini
    e234:	74 79 5f 45 72 67 6f 64 6f 78 40 5b 27 73 6c 61     ty_Ergodox@['sla
    e244:	76 65 31 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     ve1']_processed.
    e254:	6b 6c 6c 20 2b 20 5f 68 6f 6d 65 5f 6f 6c 69 76     kll + _home_oliv
    e264:	65 72 5f 72 65 70 6f 73 5f 65 72 67 6f 64 6f 78     er_repos_ergodox
    e274:	5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74 79 5f 45     _Scan_Infinity_E
    e284:	72 67 6f 64 6f 78 40 5b 27 6c 65 66 74 48 61 6e     rgodox@['leftHan
    e294:	64 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     d']_processed.kl
    e2a4:	6c 20 2b 20 40 5b 27 6c 61 79 65 72 2d 31 27 5d     l + @['layer-1']
    e2b4:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
    e2c4:	20 5f 68 6f 6d 65 5f 6f 6c 69 76 65 72 5f 72 65      _home_oliver_re
    e2d4:	70 6f 73 5f 65 72 67 6f 64 6f 78 5f 6b 6c 6c 5f     pos_ergodox_kll_
    e2e4:	6c 61 79 6f 75 74 73 5f 69 6e 66 69 6e 69 74 79     layouts_infinity
    e2f4:	5f 65 72 67 6f 64 6f 78 40 5b 27 6c 63 64 46 75     _ergodox@['lcdFu
    e304:	6e 63 4d 61 70 27 5d 5f 70 72 6f 63 65 73 73 65     ncMap']_processe
    e314:	64 2e 6b 6c 6c 00 1b 5b 31 3b 33 32 6d 49 4e 46     d.kll..[1;32mINF
    e324:	4f 1b 5b 30 6d 20 2d 20 53 65 74 74 69 6e 67 20     O.[0m - Setting 
    e334:	4c 61 79 65 72 20 4c 00 20 74 6f 20 2d 20 00 1b     Layer L. to - ..
    e344:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    e354:	20 4d 61 63 72 6f 20 44 65 62 75 67 20 4d 6f 64      Macro Debug Mod
    e364:	65 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     e: ..[1;32mINFO.
    e374:	5b 30 6d 20 2d 20 50 65 6e 64 69 6e 67 20 4b 65     [0m - Pending Ke
    e384:	79 20 45 76 65 6e 74 73 3a 20 00 20 3a 20 00 1b     y Events: . : ..
    e394:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    e3a4:	20 50 65 6e 64 69 6e 67 20 54 72 69 67 67 65 72      Pending Trigger
    e3b4:	20 4d 61 63 72 6f 73 3a 20 00 1b 5b 31 3b 33 32      Macros: ..[1;32
    e3c4:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 65 6e 64     mINFO.[0m - Pend
    e3d4:	69 6e 67 20 52 65 73 75 6c 74 20 4d 61 63 72 6f     ing Result Macro
    e3e4:	73 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     s: ..[1;32mINFO.
    e3f4:	5b 30 6d 20 2d 20 54 72 69 67 67 65 72 20 4d 61     [0m - Trigger Ma
    e404:	63 72 6f 73 20 52 61 6e 67 65 3a 20 54 30 20 2d     cros Range: T0 -
    e414:	3e 20 54 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     > T..[1;32mINFO.
    e424:	5b 30 6d 20 2d 20 52 65 73 75 6c 74 20 20 4d 61     [0m - Result  Ma
    e434:	63 72 6f 73 20 52 61 6e 67 65 3a 20 52 30 20 2d     cros Range: R0 -
    e444:	3e 20 52 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     > R..[1;32mINFO.
    e454:	5b 30 6d 20 2d 20 54 72 69 67 67 65 72 20 3a 20     [0m - Trigger : 
    e464:	52 65 73 75 6c 74 20 4d 61 63 72 6f 20 50 61 69     Result Macro Pai
    e474:	72 73 00 09 54 00 20 3a 20 52 00 1b 5b 31 3b 33     rs..T. : R..[1;3
    e484:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4d 61 63     2mINFO.[0m - Mac
    e494:	72 6f 20 50 72 6f 63 65 73 73 69 6e 67 20 4d 6f     ro Processing Mo
    e4a4:	64 65 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     de: ..[1;32mINFO
    e4b4:	1b 5b 30 6d 20 2d 20 56 6f 74 65 20 44 65 62 75     .[0m - Vote Debu
    e4c4:	67 20 4d 6f 64 65 3a 20 00 00 00 00                 g Mode: ....

0000e4d0 <default_tl_0x00>:
    e4d0:	00 00 00 00                                         ....

0000e4d4 <default_tl_0x01>:
    e4d4:	00 00 00 00                                         ....

0000e4d8 <default_tl_0x02>:
    e4d8:	00 00 00 00                                         ....

0000e4dc <default_tl_0x03>:
    e4dc:	01 00 00 00 00 00 00 00                             ........

0000e4e4 <default_tl_0x04>:
    e4e4:	01 00 00 00 02 00 00 00                             ........

0000e4ec <default_tl_0x05>:
    e4ec:	01 00 00 00 04 00 00 00                             ........

0000e4f4 <default_tl_0x06>:
    e4f4:	01 00 00 00 06 00 00 00                             ........

0000e4fc <default_tl_0x07>:
    e4fc:	01 00 00 00 08 00 00 00                             ........

0000e504 <default_tl_0x08>:
    e504:	01 00 00 00 0a 00 00 00                             ........

0000e50c <default_tl_0x09>:
    e50c:	01 00 00 00 0c 00 00 00                             ........

0000e514 <default_tl_0x0A>:
    e514:	00 00 00 00                                         ....

0000e518 <default_tl_0x0B>:
    e518:	00 00 00 00                                         ....

0000e51c <default_tl_0x0C>:
    e51c:	01 00 00 00 0e 00 00 00                             ........

0000e524 <default_tl_0x0D>:
    e524:	01 00 00 00 0f 00 00 00                             ........

0000e52c <default_tl_0x0E>:
    e52c:	01 00 00 00 10 00 00 00                             ........

0000e534 <default_tl_0x0F>:
    e534:	01 00 00 00 11 00 00 00                             ........

0000e53c <default_tl_0x10>:
    e53c:	01 00 00 00 12 00 00 00                             ........

0000e544 <default_tl_0x11>:
    e544:	01 00 00 00 13 00 00 00                             ........

0000e54c <default_tl_0x12>:
    e54c:	01 00 00 00 14 00 00 00                             ........

0000e554 <default_tl_0x13>:
    e554:	00 00 00 00                                         ....

0000e558 <default_tl_0x14>:
    e558:	00 00 00 00                                         ....

0000e55c <default_tl_0x15>:
    e55c:	00 00 00 00                                         ....

0000e560 <default_tl_0x16>:
    e560:	01 00 00 00 15 00 00 00                             ........

0000e568 <default_tl_0x17>:
    e568:	01 00 00 00 17 00 00 00                             ........

0000e570 <default_tl_0x18>:
    e570:	01 00 00 00 19 00 00 00                             ........

0000e578 <default_tl_0x19>:
    e578:	01 00 00 00 1b 00 00 00                             ........

0000e580 <default_tl_0x1A>:
    e580:	01 00 00 00 1d 00 00 00                             ........

0000e588 <default_tl_0x1B>:
    e588:	01 00 00 00 1e 00 00 00                             ........

0000e590 <default_tl_0x1C>:
    e590:	01 00 00 00 1f 00 00 00                             ........

0000e598 <default_tl_0x1D>:
    e598:	01 00 00 00 21 00 00 00                             ....!...

0000e5a0 <default_tl_0x1E>:
    e5a0:	01 00 00 00 22 00 00 00                             ...."...

0000e5a8 <default_tl_0x1F>:
    e5a8:	01 00 00 00 24 00 00 00                             ....$...

0000e5b0 <default_tl_0x20>:
    e5b0:	01 00 00 00 25 00 00 00                             ....%...

0000e5b8 <default_tl_0x21>:
    e5b8:	01 00 00 00 26 00 00 00                             ....&...

0000e5c0 <default_tl_0x22>:
    e5c0:	01 00 00 00 27 00 00 00                             ....'...

0000e5c8 <default_tl_0x23>:
    e5c8:	01 00 00 00 28 00 00 00                             ....(...

0000e5d0 <default_tl_0x24>:
    e5d0:	01 00 00 00 29 00 00 00                             ....)...

0000e5d8 <default_tl_0x25>:
    e5d8:	01 00 00 00 2a 00 00 00                             ....*...

0000e5e0 <default_tl_0x26>:
    e5e0:	01 00 00 00 2b 00 00 00                             ....+...

0000e5e8 <default_tl_0x27>:
    e5e8:	01 00 00 00 2c 00 00 00                             ....,...

0000e5f0 <default_tl_0x28>:
    e5f0:	01 00 00 00 2d 00 00 00                             ....-...

0000e5f8 <default_tl_0x29>:
    e5f8:	01 00 00 00 2e 00 00 00                             ........

0000e600 <default_tl_0x2A>:
    e600:	01 00 00 00 2f 00 00 00                             ..../...

0000e608 <default_tl_0x2B>:
    e608:	01 00 00 00 30 00 00 00                             ....0...

0000e610 <default_tl_0x2C>:
    e610:	01 00 00 00 31 00 00 00                             ....1...

0000e618 <default_tl_0x2D>:
    e618:	01 00 00 00 32 00 00 00                             ....2...

0000e620 <default_tl_0x2E>:
    e620:	00 00 00 00                                         ....

0000e624 <default_tl_0x2F>:
    e624:	00 00 00 00                                         ....

0000e628 <default_tl_0x30>:
    e628:	01 00 00 00 33 00 00 00                             ....3...

0000e630 <default_tl_0x31>:
    e630:	01 00 00 00 35 00 00 00                             ....5...

0000e638 <default_tl_0x32>:
    e638:	01 00 00 00 37 00 00 00                             ....7...

0000e640 <default_tl_0x33>:
    e640:	01 00 00 00 39 00 00 00                             ....9...

0000e648 <default_tl_0x34>:
    e648:	01 00 00 00 3b 00 00 00                             ....;...

0000e650 <default_tl_0x35>:
    e650:	01 00 00 00 3d 00 00 00                             ....=...

0000e658 <default_tl_0x36>:
    e658:	01 00 00 00 3f 00 00 00                             ....?...

0000e660 <default_tl_0x37>:
    e660:	00 00 00 00                                         ....

0000e664 <default_tl_0x38>:
    e664:	00 00 00 00                                         ....

0000e668 <default_tl_0x39>:
    e668:	01 00 00 00 41 00 00 00                             ....A...

0000e670 <default_tl_0x3A>:
    e670:	01 00 00 00 43 00 00 00                             ....C...

0000e678 <default_tl_0x3B>:
    e678:	01 00 00 00 44 00 00 00                             ....D...

0000e680 <default_tl_0x3C>:
    e680:	01 00 00 00 45 00 00 00                             ....E...

0000e688 <default_tl_0x3D>:
    e688:	01 00 00 00 46 00 00 00                             ....F...

0000e690 <default_tl_0x3E>:
    e690:	01 00 00 00 47 00 00 00                             ....G...

0000e698 <default_tl_0x3F>:
    e698:	01 00 00 00 48 00 00 00                             ....H...

0000e6a0 <default_tl_0x40>:
    e6a0:	00 00 00 00                                         ....

0000e6a4 <default_tl_0x41>:
    e6a4:	00 00 00 00                                         ....

0000e6a8 <default_tl_0x42>:
    e6a8:	00 00 00 00                                         ....

0000e6ac <default_tl_0x43>:
    e6ac:	01 00 00 00 49 00 00 00                             ....I...

0000e6b4 <default_tl_0x44>:
    e6b4:	01 00 00 00 4a 00 00 00                             ....J...

0000e6bc <default_tl_0x45>:
    e6bc:	01 00 00 00 4b 00 00 00                             ....K...

0000e6c4 <default_tl_0x46>:
    e6c4:	01 00 00 00 4c 00 00 00                             ....L...

0000e6cc <default_tl_0x47>:
    e6cc:	01 00 00 00 4d 00 00 00                             ....M...

0000e6d4 <default_tl_0x48>:
    e6d4:	01 00 00 00 4e 00 00 00                             ....N...

0000e6dc <default_tl_0x49>:
    e6dc:	01 00 00 00 4f 00 00 00                             ....O...

0000e6e4 <default_tl_0x4A>:
    e6e4:	01 00 00 00 51 00 00 00                             ....Q...

0000e6ec <default_tl_0x4B>:
    e6ec:	01 00 00 00 53 00 00 00                             ....S...

0000e6f4 <default_tl_0x4C>:
    e6f4:	01 00 00 00 55 00 00 00                             ....U...

0000e6fc <default_tl_0x4D>:
    e6fc:	01 00 00 00 56 00 00 00                             ....V...

0000e704 <default_tl_0x4E>:
    e704:	01 00 00 00 57 00 00 00                             ....W...

0000e70c <default_tl_0x4F>:
    e70c:	01 00 00 00 58 00 00 00                             ....X...

0000e714 <default_tl_0x50>:
    e714:	01 00 00 00 59 00 00 00                             ....Y...

0000e71c <default_tl_0x51>:
    e71c:	01 00 00 00 5a 00 00 00                             ....Z...

0000e724 <default_tl_0x52>:
    e724:	01 00 00 00 5b 00 00 00                             ....[...

0000e72c <default_tl_0x53>:
    e72c:	01 00 00 00 5c 00 00 00                             ....\...

0000e734 <default_tl_0x54>:
    e734:	01 00 00 00 5d 00 00 00                             ....]...

0000e73c <default_tl_0x55>:
    e73c:	01 00 00 00 5e 00 00 00                             ....^...

0000e744 <default_tl_0x56>:
    e744:	01 00 00 00 5f 00 00 00                             ...._...

0000e74c <default_tl_0x57>:
    e74c:	01 00 00 00 61 00 00 00                             ....a...

0000e754 <default_tl_0x58>:
    e754:	01 00 00 00 63 00 00 00                             ....c...

0000e75c <default_tl_0x59>:
    e75c:	01 00 00 00 65 00 00 00                             ....e...

0000e764 <default_tl_0x5A>:
    e764:	01 00 00 00 66 00 00 00                             ....f...

0000e76c <keyHoldCLIDict_DescEntry>:
    e76c:	53 65 6e 64 20 6b 65 79 2d 68 6f 6c 64 20 65 76     Send key-hold ev
    e77c:	65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63 72     ents to the macr
    e78c:	6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63     o module. Duplic
    e79c:	61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66 69     ates have undefi
    e7ac:	6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a     ned behaviour...
    e7bc:	09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53     ...[35mS10.[0m S
    e7cc:	63 61 6e 63 6f 64 65 20 30 78 30 41 00              cancode 0x0A.

0000e7d9 <keyPressCLIDict_DescEntry>:
    e7d9:	53 65 6e 64 20 6b 65 79 2d 70 72 65 73 73 20 65     Send key-press e
    e7e9:	76 65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63     vents to the mac
    e7f9:	72 6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69     ro module. Dupli
    e809:	63 61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66     cates have undef
    e819:	69 6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d     ined behaviour..
    e829:	0a 09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20     ....[35mS10.[0m 
    e839:	53 63 61 6e 63 6f 64 65 20 30 78 30 41 00           Scancode 0x0A.

0000e847 <keyReleaseCLIDict_DescEntry>:
    e847:	53 65 6e 64 20 6b 65 79 2d 72 65 6c 65 61 73 65     Send key-release
    e857:	20 65 76 65 6e 74 20 74 6f 20 6d 61 63 72 6f 20      event to macro 
    e867:	6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63 61 74     module. Duplicat
    e877:	65 73 20 68 61 76 65 20 75 6e 64 65 66 69 6e 65     es have undefine
    e887:	64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a 09 09     d behaviour.....
    e897:	1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53 63 61     .[35mS10.[0m Sca
    e8a7:	6e 63 6f 64 65 20 30 78 30 41 00 00 00              ncode 0x0A...

0000e8b4 <layer1_tl_0x00>:
    e8b4:	01 00 00 00 01 00 00 00                             ........

0000e8bc <layer1_tl_0x01>:
    e8bc:	01 00 00 00 03 00 00 00                             ........

0000e8c4 <layer1_tl_0x02>:
    e8c4:	01 00 00 00 05 00 00 00                             ........

0000e8cc <layer1_tl_0x03>:
    e8cc:	01 00 00 00 07 00 00 00                             ........

0000e8d4 <layer1_tl_0x04>:
    e8d4:	01 00 00 00 09 00 00 00                             ........

0000e8dc <layer1_tl_0x05>:
    e8dc:	01 00 00 00 0b 00 00 00                             ........

0000e8e4 <layer1_tl_0x06>:
    e8e4:	01 00 00 00 0d 00 00 00                             ........

0000e8ec <layer1_tl_0x07>:
    e8ec:	00 00 00 00                                         ....

0000e8f0 <layer1_tl_0x08>:
    e8f0:	00 00 00 00                                         ....

0000e8f4 <layer1_tl_0x09>:
    e8f4:	00 00 00 00                                         ....

0000e8f8 <layer1_tl_0x0A>:
    e8f8:	00 00 00 00                                         ....

0000e8fc <layer1_tl_0x0B>:
    e8fc:	00 00 00 00                                         ....

0000e900 <layer1_tl_0x0C>:
    e900:	00 00 00 00                                         ....

0000e904 <layer1_tl_0x0D>:
    e904:	00 00 00 00                                         ....

0000e908 <layer1_tl_0x0E>:
    e908:	00 00 00 00                                         ....

0000e90c <layer1_tl_0x0F>:
    e90c:	00 00 00 00                                         ....

0000e910 <layer1_tl_0x10>:
    e910:	00 00 00 00                                         ....

0000e914 <layer1_tl_0x11>:
    e914:	00 00 00 00                                         ....

0000e918 <layer1_tl_0x12>:
    e918:	00 00 00 00                                         ....

0000e91c <layer1_tl_0x13>:
    e91c:	01 00 00 00 16 00 00 00                             ........

0000e924 <layer1_tl_0x14>:
    e924:	01 00 00 00 18 00 00 00                             ........

0000e92c <layer1_tl_0x15>:
    e92c:	01 00 00 00 1a 00 00 00                             ........

0000e934 <layer1_tl_0x16>:
    e934:	01 00 00 00 1c 00 00 00                             ........

0000e93c <layer1_tl_0x17>:
    e93c:	00 00 00 00                                         ....

0000e940 <layer1_tl_0x18>:
    e940:	00 00 00 00                                         ....

0000e944 <layer1_tl_0x19>:
    e944:	01 00 00 00 20 00 00 00                             .... ...

0000e94c <layer1_tl_0x1A>:
    e94c:	00 00 00 00                                         ....

0000e950 <layer1_tl_0x1B>:
    e950:	01 00 00 00 23 00 00 00                             ....#...

0000e958 <layer1_tl_0x1C>:
    e958:	00 00 00 00                                         ....

0000e95c <layer1_tl_0x1D>:
    e95c:	00 00 00 00                                         ....

0000e960 <layer1_tl_0x1E>:
    e960:	00 00 00 00                                         ....

0000e964 <layer1_tl_0x1F>:
    e964:	00 00 00 00                                         ....

0000e968 <layer1_tl_0x20>:
    e968:	00 00 00 00                                         ....

0000e96c <layer1_tl_0x21>:
    e96c:	00 00 00 00                                         ....

0000e970 <layer1_tl_0x22>:
    e970:	00 00 00 00                                         ....

0000e974 <layer1_tl_0x23>:
    e974:	00 00 00 00                                         ....

0000e978 <layer1_tl_0x24>:
    e978:	00 00 00 00                                         ....

0000e97c <layer1_tl_0x25>:
    e97c:	00 00 00 00                                         ....

0000e980 <layer1_tl_0x26>:
    e980:	00 00 00 00                                         ....

0000e984 <layer1_tl_0x27>:
    e984:	00 00 00 00                                         ....

0000e988 <layer1_tl_0x28>:
    e988:	00 00 00 00                                         ....

0000e98c <layer1_tl_0x29>:
    e98c:	00 00 00 00                                         ....

0000e990 <layer1_tl_0x2A>:
    e990:	00 00 00 00                                         ....

0000e994 <layer1_tl_0x2B>:
    e994:	00 00 00 00                                         ....

0000e998 <layer1_tl_0x2C>:
    e998:	00 00 00 00                                         ....

0000e99c <layer1_tl_0x2D>:
    e99c:	01 00 00 00 34 00 00 00                             ....4...

0000e9a4 <layer1_tl_0x2E>:
    e9a4:	01 00 00 00 36 00 00 00                             ....6...

0000e9ac <layer1_tl_0x2F>:
    e9ac:	01 00 00 00 38 00 00 00                             ....8...

0000e9b4 <layer1_tl_0x30>:
    e9b4:	01 00 00 00 3a 00 00 00                             ....:...

0000e9bc <layer1_tl_0x31>:
    e9bc:	01 00 00 00 3c 00 00 00                             ....<...

0000e9c4 <layer1_tl_0x32>:
    e9c4:	01 00 00 00 3e 00 00 00                             ....>...

0000e9cc <layer1_tl_0x33>:
    e9cc:	01 00 00 00 40 00 00 00                             ....@...

0000e9d4 <layer1_tl_0x34>:
    e9d4:	00 00 00 00                                         ....

0000e9d8 <layer1_tl_0x35>:
    e9d8:	00 00 00 00                                         ....

0000e9dc <layer1_tl_0x36>:
    e9dc:	01 00 00 00 42 00 00 00                             ....B...

0000e9e4 <layer1_tl_0x37>:
    e9e4:	00 00 00 00                                         ....

0000e9e8 <layer1_tl_0x38>:
    e9e8:	00 00 00 00                                         ....

0000e9ec <layer1_tl_0x39>:
    e9ec:	00 00 00 00                                         ....

0000e9f0 <layer1_tl_0x3A>:
    e9f0:	00 00 00 00                                         ....

0000e9f4 <layer1_tl_0x3B>:
    e9f4:	00 00 00 00                                         ....

0000e9f8 <layer1_tl_0x3C>:
    e9f8:	00 00 00 00                                         ....

0000e9fc <layer1_tl_0x3D>:
    e9fc:	00 00 00 00                                         ....

0000ea00 <layer1_tl_0x3E>:
    ea00:	00 00 00 00                                         ....

0000ea04 <layer1_tl_0x3F>:
    ea04:	00 00 00 00                                         ....

0000ea08 <layer1_tl_0x40>:
    ea08:	00 00 00 00                                         ....

0000ea0c <layer1_tl_0x41>:
    ea0c:	00 00 00 00                                         ....

0000ea10 <layer1_tl_0x42>:
    ea10:	00 00 00 00                                         ....

0000ea14 <layer1_tl_0x43>:
    ea14:	00 00 00 00                                         ....

0000ea18 <layer1_tl_0x44>:
    ea18:	00 00 00 00                                         ....

0000ea1c <layer1_tl_0x45>:
    ea1c:	00 00 00 00                                         ....

0000ea20 <layer1_tl_0x46>:
    ea20:	01 00 00 00 50 00 00 00                             ....P...

0000ea28 <layer1_tl_0x47>:
    ea28:	01 00 00 00 52 00 00 00                             ....R...

0000ea30 <layer1_tl_0x48>:
    ea30:	01 00 00 00 54 00 00 00                             ....T...

0000ea38 <layer1_tl_0x49>:
    ea38:	00 00 00 00                                         ....

0000ea3c <layer1_tl_0x4A>:
    ea3c:	00 00 00 00                                         ....

0000ea40 <layer1_tl_0x4B>:
    ea40:	00 00 00 00                                         ....

0000ea44 <layer1_tl_0x4C>:
    ea44:	00 00 00 00                                         ....

0000ea48 <layer1_tl_0x4D>:
    ea48:	00 00 00 00                                         ....

0000ea4c <layer1_tl_0x4E>:
    ea4c:	00 00 00 00                                         ....

0000ea50 <layer1_tl_0x4F>:
    ea50:	00 00 00 00                                         ....

0000ea54 <layer1_tl_0x50>:
    ea54:	00 00 00 00                                         ....

0000ea58 <layer1_tl_0x51>:
    ea58:	00 00 00 00                                         ....

0000ea5c <layer1_tl_0x52>:
    ea5c:	00 00 00 00                                         ....

0000ea60 <layer1_tl_0x53>:
    ea60:	01 00 00 00 60 00 00 00                             ....`...

0000ea68 <layer1_tl_0x54>:
    ea68:	01 00 00 00 62 00 00 00                             ....b...

0000ea70 <layer1_tl_0x55>:
    ea70:	01 00 00 00 64 00 00 00                             ....d...

0000ea78 <layerDebugCLIDict_DescEntry>:
    ea78:	4c 61 79 65 72 20 64 65 62 75 67 20 6d 6f 64 65     Layer debug mode
    ea88:	2e 20 53 68 6f 77 73 20 6c 61 79 65 72 20 73 74     . Shows layer st
    ea98:	61 63 6b 20 61 6e 64 20 61 6e 79 20 63 68 61 6e     ack and any chan
    eaa8:	67 65 73 2e 00                                      ges..

0000eaad <layerListCLIDict_DescEntry>:
    eaad:	4c 69 73 74 20 61 76 61 69 6c 61 62 6c 65 20 6c     List available l
    eabd:	61 79 65 72 73 2e 00                                ayers..

0000eac4 <layerStateCLIDict_DescEntry>:
    eac4:	4d 6f 64 69 66 79 20 73 70 65 63 69 66 69 65 64     Modify specified
    ead4:	20 69 6e 64 65 78 65 64 20 6c 61 79 65 72 20 73      indexed layer s
    eae4:	74 61 74 65 20 3c 6c 61 79 65 72 3e 20 3c 73 74     tate <layer> <st
    eaf4:	61 74 65 20 62 79 74 65 3e 2e 0d 0a 09 09 1b 5b     ate byte>......[
    eb04:	33 35 6d 4c 32 1b 5b 30 6d 20 49 6e 64 65 78 65     35mL2.[0m Indexe
    eb14:	64 20 4c 61 79 65 72 20 30 78 30 32 0d 0a 09 09     d Layer 0x02....
    eb24:	30 20 4f 66 66 2c 20 31 20 53 68 69 66 74 2c 20     0 Off, 1 Shift, 
    eb34:	32 20 4c 61 74 63 68 2c 20 34 20 4c 6f 63 6b 20     2 Latch, 4 Lock 
    eb44:	53 74 61 74 65 73 00 00                             States..

0000eb4c <macroCLIDict>:
    eb4c:	f7 ef 00 00 28 d8 00 00 a5 53 00 00 ff ef 00 00     ....(....S......
    eb5c:	64 d8 00 00 49 56 00 00 09 f0 00 00 6c e7 00 00     d...IV......l...
    eb6c:	29 5e 00 00 11 f0 00 00 d9 e7 00 00 59 5e 00 00     )^..........Y^..
    eb7c:	1a f0 00 00 47 e8 00 00 89 5e 00 00 25 f0 00 00     ....G....^..%...
    eb8c:	78 ea 00 00 09 54 00 00 30 f0 00 00 ad ea 00 00     x....T..0.......
    eb9c:	e9 57 00 00 3a f0 00 00 c4 ea 00 00 59 57 00 00     .W..:.......YW..
    ebac:	45 f0 00 00 22 ec 00 00 d5 55 00 00 50 f0 00 00     E..."....U..P...
    ebbc:	2f ed 00 00 69 54 00 00 5a f0 00 00 5b ed 00 00     /...iT..Z...[...
    ebcc:	39 54 00 00 64 f0 00 00 7a ed 00 00 a9 63 00 00     9T..d...z....c..
    ebdc:	6e f0 00 00 fe ed 00 00 c1 57 00 00 78 f0 00 00     n........W..x...
    ebec:	2a ee 00 00 99 53 00 00 80 f0 00 00 06 f2 00 00     *....S..........
    ebfc:	c9 58 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .X..............

0000ec0c <macroCLIDictName>:
    ec0c:	4d 61 63 72 6f 20 4d 6f 64 75 6c 65 20 43 6f 6d     Macro Module Com
    ec1c:	6d 61 6e 64 73 00                                   mands.

0000ec22 <macroDebugCLIDict_DescEntry>:
    ec22:	44 69 73 61 62 6c 65 73 2f 45 6e 61 62 6c 65 73     Disables/Enables
    ec32:	20 73 65 6e 64 69 6e 67 20 55 53 42 20 6b 65 79      sending USB key
    ec42:	63 6f 64 65 73 20 74 6f 20 74 68 65 20 4f 75 74     codes to the Out
    ec52:	70 75 74 20 4d 6f 64 75 6c 65 20 61 6e 64 20 70     put Module and p
    ec62:	72 69 6e 74 73 20 55 2f 4b 20 63 6f 64 65 73 2e     rints U/K codes.
    ec72:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    ec82:	20 2d 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 20      - Result Macro 
    ec92:	49 6e 64 65 78 3a 20 00 0d 0a 46 69 6e 61 6c 20     Index: ...Final 
    eca2:	54 72 69 67 67 65 72 20 53 74 61 74 65 20 28 53     Trigger State (S
    ecb2:	74 61 74 65 2f 54 79 70 65 29 3a 20 00 1b 5b 31     tate/Type): ..[1
    ecc2:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 54     ;32mINFO.[0m - T
    ecd2:	72 69 67 67 65 72 20 4d 61 63 72 6f 20 49 6e 64     rigger Macro Ind
    ece2:	65 78 3a 20 00 7c 00 3b 00 0d 0a 50 6f 73 69 74     ex: .|.;...Posit
    ecf2:	69 6f 6e 3a 20 00 0d 0a 52 65 73 75 6c 74 20 4d     ion: ...Result M
    ed02:	61 63 72 6f 20 49 6e 64 65 78 3a 20 00 0d 0a 54     acro Index: ...T
    ed12:	72 69 67 67 65 72 20 4d 61 63 72 6f 20 53 74 61     rigger Macro Sta
    ed22:	74 65 3a 20 00 57 61 69 74 69 6e 67 00              te: .Waiting.

0000ed2f <macroListCLIDict_DescEntry>:
    ed2f:	4c 69 73 74 20 74 68 65 20 64 65 66 69 6e 65 64     List the defined
    ed3f:	20 74 72 69 67 67 65 72 20 61 6e 64 20 72 65 73      trigger and res
    ed4f:	75 6c 74 20 6d 61 63 72 6f 73 2e 00                 ult macros..

0000ed5b <macroProcCLIDict_DescEntry>:
    ed5b:	50 61 75 73 65 2f 52 65 73 75 6d 65 20 6d 61 63     Pause/Resume mac
    ed6b:	72 6f 20 70 72 6f 63 65 73 73 69 6e 67 2e 00        ro processing..

0000ed7a <macroShowCLIDict_DescEntry>:
    ed7a:	53 68 6f 77 20 74 68 65 20 6d 61 63 72 6f 20 63     Show the macro c
    ed8a:	6f 72 72 65 73 70 6f 6e 64 69 6e 67 20 74 6f 20     orresponding to 
    ed9a:	74 68 65 20 67 69 76 65 6e 20 69 6e 64 65 78 2e     the given index.
    edaa:	0d 0a 09 09 1b 5b 33 35 6d 54 31 36 1b 5b 30 6d     .....[35mT16.[0m
    edba:	20 49 6e 64 65 78 65 64 20 54 72 69 67 67 65 72      Indexed Trigger
    edca:	20 4d 61 63 72 6f 20 30 78 31 30 2c 20 1b 5b 33      Macro 0x10, .[3
    edda:	35 6d 52 31 32 1b 5b 30 6d 20 49 6e 64 65 78 65     5mR12.[0m Indexe
    edea:	64 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 20 30     d Result Macro 0
    edfa:	78 30 43 00                                         x0C.

0000edfe <macroStepCLIDict_DescEntry>:
    edfe:	44 6f 20 4e 20 6d 61 63 72 6f 20 70 72 6f 63 65     Do N macro proce
    ee0e:	73 73 69 6e 67 20 73 74 65 70 73 2e 20 44 65 66     ssing steps. Def
    ee1e:	61 75 6c 74 73 20 74 6f 20 31 2e 00                 aults to 1..

0000ee2a <posListCLIDict_DescEntry>:
    ee2a:	4c 69 73 74 20 70 68 79 73 69 63 61 6c 20 6b 65     List physical ke
    ee3a:	79 20 70 6f 73 69 74 69 6f 6e 73 20 62 79 20 53     y positions by S
    ee4a:	63 61 6e 43 6f 64 65 2e 00                          canCode..

0000ee53 <rm0_guide>:
    ee53:	01 08 b5 00 00                                      .....

0000ee58 <rm10_guide>:
    ee58:	01 0f 08 00                                         ....

0000ee5c <rm11_guide>:
    ee5c:	01 0f 09 00                                         ....

0000ee60 <rm12_guide>:
    ee60:	01 0f 0a 00                                         ....

0000ee64 <rm13_guide>:
    ee64:	01 0f 0b 00                                         ....

0000ee68 <rm14_guide>:
    ee68:	01 0f 0c 00                                         ....

0000ee6c <rm15_guide>:
    ee6c:	01 0f 0d 00                                         ....

0000ee70 <rm16_guide>:
    ee70:	01 0f 0e 00                                         ....

0000ee74 <rm17_guide>:
    ee74:	01 0f 0f 00                                         ....

0000ee78 <rm18_guide>:
    ee78:	01 0f 10 00                                         ....

0000ee7c <rm19_guide>:
    ee7c:	01 0f 11 00                                         ....

0000ee80 <rm1_guide>:
    ee80:	01 08 b6 00 00                                      .....

0000ee85 <rm20_guide>:
    ee85:	01 0f 12 00                                         ....

0000ee89 <rm21_guide>:
    ee89:	01 0f 13 00                                         ....

0000ee8d <rm22_guide>:
    ee8d:	01 0f 14 00                                         ....

0000ee91 <rm23_guide>:
    ee91:	01 0f 15 00                                         ....

0000ee95 <rm24_guide>:
    ee95:	01 0f 16 00                                         ....

0000ee99 <rm25_guide>:
    ee99:	01 0f 17 00                                         ....

0000ee9d <rm26_guide>:
    ee9d:	01 0f 18 00                                         ....

0000eea1 <rm27_guide>:
    eea1:	01 0f 19 00                                         ....

0000eea5 <rm28_guide>:
    eea5:	01 0f 1a 00                                         ....

0000eea9 <rm29_guide>:
    eea9:	01 0f 1b 00                                         ....

0000eead <rm2_guide>:
    eead:	01 08 cd 00 00                                      .....

0000eeb2 <rm30_guide>:
    eeb2:	01 0f 1c 00                                         ....

0000eeb6 <rm31_guide>:
    eeb6:	01 0f 1d 00                                         ....

0000eeba <rm32_guide>:
    eeba:	01 0f 1e 00                                         ....

0000eebe <rm33_guide>:
    eebe:	01 0f 1f 00                                         ....

0000eec2 <rm34_guide>:
    eec2:	01 0f 20 00                                         .. .

0000eec6 <rm35_guide>:
    eec6:	01 0f 21 00                                         ..!.

0000eeca <rm36_guide>:
    eeca:	01 0f 22 00                                         ..".

0000eece <rm37_guide>:
    eece:	01 0f 23 00                                         ..#.

0000eed2 <rm38_guide>:
    eed2:	01 0f 24 00                                         ..$.

0000eed6 <rm39_guide>:
    eed6:	01 0f 25 00                                         ..%.

0000eeda <rm3_guide>:
    eeda:	01 08 e2 00 00                                      .....

0000eedf <rm40_guide>:
    eedf:	01 0f 26 00                                         ..&.

0000eee3 <rm41_guide>:
    eee3:	01 0f 27 00                                         ..'.

0000eee7 <rm42_guide>:
    eee7:	01 0f 28 00                                         ..(.

0000eeeb <rm43_guide>:
    eeeb:	01 0f 29 00                                         ..).

0000eeef <rm44_guide>:
    eeef:	01 0f 2a 00                                         ..*.

0000eef3 <rm45_guide>:
    eef3:	01 0f 2b 00                                         ..+.

0000eef7 <rm46_guide>:
    eef7:	01 0f 2c 00                                         ..,.

0000eefb <rm47_guide>:
    eefb:	01 0f 2d 00                                         ..-.

0000eeff <rm48_guide>:
    eeff:	01 0f 2e 00                                         ....

0000ef03 <rm49_guide>:
    ef03:	01 0f 2f 00                                         ../.

0000ef07 <rm4_guide>:
    ef07:	01 08 e9 00 00                                      .....

0000ef0c <rm50_guide>:
    ef0c:	01 0f 30 00                                         ..0.

0000ef10 <rm51_guide>:
    ef10:	01 0f 31 00                                         ..1.

0000ef14 <rm52_guide>:
    ef14:	01 0f 33 00                                         ..3.

0000ef18 <rm53_guide>:
    ef18:	01 0f 34 00                                         ..4.

0000ef1c <rm54_guide>:
    ef1c:	01 0f 35 00                                         ..5.

0000ef20 <rm55_guide>:
    ef20:	01 0f 36 00                                         ..6.

0000ef24 <rm56_guide>:
    ef24:	01 0f 37 00                                         ..7.

0000ef28 <rm57_guide>:
    ef28:	01 0f 38 00                                         ..8.

0000ef2c <rm58_guide>:
    ef2c:	01 0f 3a 00                                         ..:.

0000ef30 <rm59_guide>:
    ef30:	01 0f 3b 00                                         ..;.

0000ef34 <rm5_guide>:
    ef34:	01 08 ea 00 00                                      .....

0000ef39 <rm60_guide>:
    ef39:	01 0f 3c 00                                         ..<.

0000ef3d <rm61_guide>:
    ef3d:	01 0f 3d 00                                         ..=.

0000ef41 <rm62_guide>:
    ef41:	01 0f 3e 00                                         ..>.

0000ef45 <rm63_guide>:
    ef45:	01 0f 3f 00                                         ..?.

0000ef49 <rm64_guide>:
    ef49:	01 0f 40 00                                         ..@.

0000ef4d <rm65_guide>:
    ef4d:	01 0f 41 00                                         ..A.

0000ef51 <rm66_guide>:
    ef51:	01 0f 42 00                                         ..B.

0000ef55 <rm67_guide>:
    ef55:	01 0f 43 00                                         ..C.

0000ef59 <rm68_guide>:
    ef59:	01 0f 44 00                                         ..D.

0000ef5d <rm69_guide>:
    ef5d:	01 0f 45 00                                         ..E.

0000ef61 <rm6_guide>:
    ef61:	01 0f 04 00                                         ....

0000ef65 <rm70_guide>:
    ef65:	01 0f 4a 00                                         ..J.

0000ef69 <rm71_guide>:
    ef69:	01 0f 4b 00                                         ..K.

0000ef6d <rm72_guide>:
    ef6d:	01 0f 4c 00                                         ..L.

0000ef71 <rm73_guide>:
    ef71:	01 0f 4d 00                                         ..M.

0000ef75 <rm74_guide>:
    ef75:	01 0f 4e 00                                         ..N.

0000ef79 <rm75_guide>:
    ef79:	01 0f 4f 00                                         ..O.

0000ef7d <rm76_guide>:
    ef7d:	01 0f 50 00                                         ..P.

0000ef81 <rm77_guide>:
    ef81:	01 0f 51 00                                         ..Q.

0000ef85 <rm78_guide>:
    ef85:	01 0f 52 00                                         ..R.

0000ef89 <rm79_guide>:
    ef89:	01 0f 64 00                                         ..d.

0000ef8d <rm7_guide>:
    ef8d:	01 0f 05 00                                         ....

0000ef91 <rm80_guide>:
    ef91:	01 0f e0 00                                         ....

0000ef95 <rm81_guide>:
    ef95:	01 0f e1 00                                         ....

0000ef99 <rm82_guide>:
    ef99:	02 0f e1 0f 26 00                                   ....&.

0000ef9f <rm83_guide>:
    ef9f:	02 0f e1 0f 27 00                                   ....'.

0000efa5 <rm84_guide>:
    efa5:	02 0f e1 0f 2f 00                                   ..../.

0000efab <rm85_guide>:
    efab:	02 0f e1 0f 30 00                                   ....0.

0000efb1 <rm86_guide>:
    efb1:	01 0f e2 00                                         ....

0000efb5 <rm87_guide>:
    efb5:	01 0f e3 00                                         ....

0000efb9 <rm88_guide>:
    efb9:	01 0f e4 00                                         ....

0000efbd <rm89_guide>:
    efbd:	01 0f e5 00                                         ....

0000efc1 <rm8_guide>:
    efc1:	01 0f 06 00                                         ....

0000efc5 <rm90_guide>:
    efc5:	01 0f e7 00                                         ....

0000efc9 <rm91_guide>:
    efc9:	01 09 00                                            ...

0000efcc <rm92_guide>:
    efcc:	02 06 01 00 01 00                                   ......

0000efd2 <rm93_guide>:
    efd2:	02 06 02 00 01 00                                   ......

0000efd8 <rm94_guide>:
    efd8:	02 06 03 00 01 00                                   ......

0000efde <rm95_guide>:
    efde:	02 06 07 00 01 00                                   ......

0000efe4 <rm96_guide>:
    efe4:	01 02 03 0f 00                                      .....

0000efe9 <rm97_guide>:
    efe9:	01 02 04 0f 00                                      .....

0000efee <rm98_guide>:
    efee:	01 02 05 00 00                                      .....

0000eff3 <rm9_guide>:
    eff3:	01 0f 07 00 63 61 70 4c 69 73 74 00 63 61 70 53     ....capList.capS
    f003:	65 6c 65 63 74 00 6b 65 79 48 6f 6c 64 00 6b 65     elect.keyHold.ke
    f013:	79 50 72 65 73 73 00 6b 65 79 52 65 6c 65 61 73     yPress.keyReleas
    f023:	65 00 6c 61 79 65 72 44 65 62 75 67 00 6c 61 79     e.layerDebug.lay
    f033:	65 72 4c 69 73 74 00 6c 61 79 65 72 53 74 61 74     erList.layerStat
    f043:	65 00 6d 61 63 72 6f 44 65 62 75 67 00 6d 61 63     e.macroDebug.mac
    f053:	72 6f 4c 69 73 74 00 6d 61 63 72 6f 50 72 6f 63     roList.macroProc
    f063:	00 6d 61 63 72 6f 53 68 6f 77 00 6d 61 63 72 6f     .macroShow.macro
    f073:	53 74 65 70 00 70 6f 73 4c 69 73 74 00 76 6f 74     Step.posList.vot
    f083:	65 44 65 62 75 67 00                                eDebug.

0000f08a <tm0_guide>:
    f08a:	01 00 01 03 00                                      .....

0000f08f <tm10_guide>:
    f08f:	01 00 01 0f 00                                      .....

0000f094 <tm11_guide>:
    f094:	01 00 01 10 00                                      .....

0000f099 <tm12_guide>:
    f099:	01 00 01 11 00                                      .....

0000f09e <tm13_guide>:
    f09e:	01 00 01 12 00                                      .....

0000f0a3 <tm14_guide>:
    f0a3:	01 00 01 16 00                                      .....

0000f0a8 <tm15_guide>:
    f0a8:	01 00 01 17 00                                      .....

0000f0ad <tm16_guide>:
    f0ad:	01 00 01 18 00                                      .....

0000f0b2 <tm17_guide>:
    f0b2:	01 00 01 19 00                                      .....

0000f0b7 <tm18_guide>:
    f0b7:	01 00 01 1a 00                                      .....

0000f0bc <tm19_guide>:
    f0bc:	01 00 01 1b 00                                      .....

0000f0c1 <tm1_guide>:
    f0c1:	01 00 01 04 00                                      .....

0000f0c6 <tm20_guide>:
    f0c6:	01 00 01 1c 00                                      .....

0000f0cb <tm21_guide>:
    f0cb:	01 00 01 1d 00                                      .....

0000f0d0 <tm22_guide>:
    f0d0:	01 00 01 1e 00                                      .....

0000f0d5 <tm23_guide>:
    f0d5:	01 00 01 1f 00                                      .....

0000f0da <tm24_guide>:
    f0da:	01 00 01 20 00                                      ... .

0000f0df <tm25_guide>:
    f0df:	01 00 01 21 00                                      ...!.

0000f0e4 <tm26_guide>:
    f0e4:	01 00 01 22 00                                      ...".

0000f0e9 <tm27_guide>:
    f0e9:	01 00 01 23 00                                      ...#.

0000f0ee <tm28_guide>:
    f0ee:	01 00 01 24 00                                      ...$.

0000f0f3 <tm29_guide>:
    f0f3:	01 00 01 25 00                                      ...%.

0000f0f8 <tm2_guide>:
    f0f8:	01 00 01 05 00                                      .....

0000f0fd <tm30_guide>:
    f0fd:	01 00 01 26 00                                      ...&.

0000f102 <tm31_guide>:
    f102:	01 00 01 27 00                                      ...'.

0000f107 <tm32_guide>:
    f107:	01 00 01 28 00                                      ...(.

0000f10c <tm33_guide>:
    f10c:	01 00 01 29 00                                      ...).

0000f111 <tm34_guide>:
    f111:	01 00 01 2a 00                                      ...*.

0000f116 <tm35_guide>:
    f116:	01 00 01 2b 00                                      ...+.

0000f11b <tm36_guide>:
    f11b:	01 00 01 2c 00                                      ...,.

0000f120 <tm37_guide>:
    f120:	01 00 01 2d 00                                      ...-.

0000f125 <tm38_guide>:
    f125:	01 00 01 30 00                                      ...0.

0000f12a <tm39_guide>:
    f12a:	01 00 01 31 00                                      ...1.

0000f12f <tm3_guide>:
    f12f:	01 00 01 06 00                                      .....

0000f134 <tm40_guide>:
    f134:	01 00 01 32 00                                      ...2.

0000f139 <tm41_guide>:
    f139:	01 00 01 33 00                                      ...3.

0000f13e <tm42_guide>:
    f13e:	01 00 01 34 00                                      ...4.

0000f143 <tm43_guide>:
    f143:	01 00 01 35 00                                      ...5.

0000f148 <tm44_guide>:
    f148:	01 00 01 36 00                                      ...6.

0000f14d <tm45_guide>:
    f14d:	01 00 01 39 00                                      ...9.

0000f152 <tm46_guide>:
    f152:	01 00 01 3a 00                                      ...:.

0000f157 <tm47_guide>:
    f157:	01 00 01 3b 00                                      ...;.

0000f15c <tm48_guide>:
    f15c:	01 00 01 3c 00                                      ...<.

0000f161 <tm49_guide>:
    f161:	01 00 01 3d 00                                      ...=.

0000f166 <tm4_guide>:
    f166:	01 00 01 07 00                                      .....

0000f16b <tm50_guide>:
    f16b:	01 00 01 3e 00                                      ...>.

0000f170 <tm51_guide>:
    f170:	01 00 01 3f 00                                      ...?.

0000f175 <tm52_guide>:
    f175:	01 00 01 43 00                                      ...C.

0000f17a <tm53_guide>:
    f17a:	01 00 01 44 00                                      ...D.

0000f17f <tm54_guide>:
    f17f:	01 00 01 45 00                                      ...E.

0000f184 <tm55_guide>:
    f184:	01 00 01 46 00                                      ...F.

0000f189 <tm56_guide>:
    f189:	01 00 01 47 00                                      ...G.

0000f18e <tm57_guide>:
    f18e:	01 00 01 48 00                                      ...H.

0000f193 <tm58_guide>:
    f193:	01 00 01 49 00                                      ...I.

0000f198 <tm59_guide>:
    f198:	01 00 01 4a 00                                      ...J.

0000f19d <tm5_guide>:
    f19d:	01 00 01 08 00                                      .....

0000f1a2 <tm60_guide>:
    f1a2:	01 00 01 4b 00                                      ...K.

0000f1a7 <tm61_guide>:
    f1a7:	01 00 01 4c 00                                      ...L.

0000f1ac <tm62_guide>:
    f1ac:	01 00 01 4d 00                                      ...M.

0000f1b1 <tm63_guide>:
    f1b1:	01 00 01 4e 00                                      ...N.

0000f1b6 <tm64_guide>:
    f1b6:	01 00 01 4f 00                                      ...O.

0000f1bb <tm65_guide>:
    f1bb:	01 00 01 50 00                                      ...P.

0000f1c0 <tm66_guide>:
    f1c0:	01 00 01 51 00                                      ...Q.

0000f1c5 <tm67_guide>:
    f1c5:	01 00 01 52 00                                      ...R.

0000f1ca <tm68_guide>:
    f1ca:	01 00 01 53 00                                      ...S.

0000f1cf <tm69_guide>:
    f1cf:	01 00 01 54 00                                      ...T.

0000f1d4 <tm6_guide>:
    f1d4:	01 00 01 09 00                                      .....

0000f1d9 <tm70_guide>:
    f1d9:	01 00 01 55 00                                      ...U.

0000f1de <tm71_guide>:
    f1de:	01 00 01 56 00                                      ...V.

0000f1e3 <tm72_guide>:
    f1e3:	01 00 01 57 00                                      ...W.

0000f1e8 <tm73_guide>:
    f1e8:	01 00 01 58 00                                      ...X.

0000f1ed <tm74_guide>:
    f1ed:	01 00 01 59 00                                      ...Y.

0000f1f2 <tm75_guide>:
    f1f2:	01 00 01 5a 00                                      ...Z.

0000f1f7 <tm7_guide>:
    f1f7:	01 00 01 0c 00                                      .....

0000f1fc <tm8_guide>:
    f1fc:	01 00 01 0d 00                                      .....

0000f201 <tm9_guide>:
    f201:	01 00 01 0e 00                                      .....

0000f206 <voteDebugCLIDict_DescEntry>:
    f206:	53 68 6f 77 20 72 65 73 75 6c 74 73 20 6f 66 20     Show results of 
    f216:	54 72 69 67 67 65 72 45 76 65 6e 74 20 76 6f 74     TriggerEvent vot
    f226:	69 6e 67 2e 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     ing...[1;33mWARN
    f236:	49 4e 47 1b 5b 30 6d 20 2d 20 44 65 6c 61 79 65     ING.[0m - Delaye
    f246:	64 20 63 61 70 61 62 69 6c 69 74 79 20 73 74 61     d capability sta
    f256:	63 6b 20 66 75 6c 6c 21 0d 0a 00 1b 5b 31 3b 35     ck full!....[1;5
    f266:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
    f276:	4c 45 44 20 53 74 61 74 65 20 54 79 70 65 20 2d     LED State Type -
    f286:	20 4e 6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65 64      Not implemented
    f296:	2e 2e 2e 0d 0a 00 1b 5b 31 3b 35 3b 33 31 6d 45     .......[1;5;31mE
    f2a6:	52 52 4f 52 1b 5b 30 6d 20 2d 20 41 6e 61 6c 6f     RROR.[0m - Analo
    f2b6:	67 20 53 74 61 74 65 20 54 79 70 65 20 2d 20 4e     g State Type - N
    f2c6:	6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65 64 2e 2e     ot implemented..
    f2d6:	2e 0d 0a 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52     .....[1;5;31mERR
    f2e6:	4f 52 1b 5b 30 6d 20 2d 20 4c 61 79 65 72 20 53     OR.[0m - Layer S
    f2f6:	74 61 74 65 20 54 79 70 65 20 2d 20 4e 6f 74 20     tate Type - Not 
    f306:	69 6d 70 6c 65 6d 65 6e 74 65 64 2e 2e 2e 0d 0a     implemented.....
    f316:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    f326:	5b 30 6d 20 2d 20 41 6e 69 6d 61 74 69 6f 6e 20     [0m - Animation 
    f336:	53 74 61 74 65 20 54 79 70 65 20 2d 20 4e 6f 74     State Type - Not
    f346:	20 69 6d 70 6c 65 6d 65 6e 74 2e 2e 2e 0d 0a 00      implement......
    f356:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
    f366:	30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 53 74 61     0m - Invalid Sta
    f376:	74 65 20 54 79 70 65 2e 20 54 68 69 73 20 69 73     te Type. This is
    f386:	20 61 20 62 75 67 2e 0d 0a 00 56 3a 49 00 56 3a      a bug....V:I.V:
    f396:	52 00 56 3a 50 00 56 3a 50 52 00 56 3a 00 46 00     R.V:P.V:PR.V:.F.
    f3a6:	4e 52 00 4e 00 50 69 78 65 6c 5f 41 6e 69 6d 61     NR.N.Pixel_Anima
    f3b6:	74 69 6f 6e 43 6f 6e 74 72 6f 6c 5f 63 61 70 61     tionControl_capa
    f3c6:	62 69 6c 69 74 79 28 66 75 6e 63 29 00 50 69 78     bility(func).Pix
    f3d6:	65 6c 5f 41 6e 69 6d 61 74 69 6f 6e 49 6e 64 65     el_AnimationInde
    f3e6:	78 5f 63 61 70 61 62 69 6c 69 74 79 28 73 65 74     x_capability(set
    f3f6:	74 69 6e 67 69 6e 64 65 78 29 00 1b 5b 31 3b 33     tingindex)..[1;3
    f406:	33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20     3mWARNING.[0m - 
    f416:	49 6e 76 61 6c 69 64 20 41 6e 69 6d 61 74 69 6f     Invalid Animatio
    f426:	6e 53 65 74 74 69 6e 67 20 69 6e 64 65 78 3a 20     nSetting index: 
    f436:	00 50 69 78 65 6c 5f 41 6e 69 6d 61 74 69 6f 6e     .Pixel_Animation
    f446:	5f 63 61 70 61 62 69 6c 69 74 79 28 69 6e 64 65     _capability(inde
    f456:	78 2c 6c 6f 6f 70 73 2c 70 66 75 6e 63 2c 66 72     x,loops,pfunc,fr
    f466:	61 6d 65 64 65 6c 61 79 2c 66 72 61 6d 65 6f 70     amedelay,frameop
    f476:	74 69 6f 6e 2c 72 65 70 6c 61 63 65 29 00 50 69     tion,replace).Pi
    f486:	78 65 6c 5f 50 69 78 65 6c 5f 63 61 70 61 62 69     xel_Pixel_capabi
    f496:	6c 69 74 79 28 70 69 78 65 6c 2c 63 68 61 6e 2c     lity(pixel,chan,
    f4a6:	76 61 6c 75 65 29 00 1b 5b 31 3b 33 33 6d 57 41     value)..[1;33mWA
    f4b6:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 41 6e 69 6d     RNING.[0m - Anim
    f4c6:	61 74 69 6f 6e 20 73 74 61 63 6b 20 69 73 20 66     ation stack is f
    f4d6:	75 6c 6c 2e 2e 2e 0d 0a 00 1b 5b 31 3b 35 3b 33     ull.......[1;5;3
    f4e6:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 41 6e     1mERROR.[0m - An
    f4f6:	69 6d 61 74 69 6f 6e 20 53 74 61 63 6b 20 6d 65     imation Stack me
    f506:	6d 6f 72 79 20 6c 65 61 6b 2e 2e 2e 74 68 69 73     mory leak...this
    f516:	20 69 73 20 61 20 62 75 67 21 0d 0a 00 1b 5b 31      is a bug!....[1
    f526:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
    f536:	2d 20 49 6e 76 61 6c 69 64 20 63 68 61 6e 6e 65     - Invalid channe
    f546:	6c 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     l: ..[1;33mWARNI
    f556:	4e 47 1b 5b 30 6d 20 2d 20 43 68 61 6e 53 65 74     NG.[0m - ChanSet
    f566:	20 55 6e 6b 6e 6f 77 6e 20 77 69 64 74 68 3a 20      Unknown width: 
    f576:	00 20 43 68 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     . Ch: ..[1;33mWA
    f586:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 43 68 61 6e     RNING.[0m - Chan
    f596:	54 6f 67 67 6c 65 20 55 6e 6b 6e 6f 77 6e 20 77     Toggle Unknown w
    f5a6:	69 64 74 68 3a 20 00 1b 5b 34 38 3b 32 00 1b 5b     idth: ..[48;2..[
    f5b6:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
    f5c6:	20 2d 20 49 6e 76 61 6c 69 64 20 72 6f 77 2c 63      - Invalid row,c
    f5d6:	6f 6c 75 6d 6e 20 69 6e 64 65 78 3a 20 00 1b 5b     olumn index: ..[
    f5e6:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
    f5f6:	20 2d 20 49 6e 76 61 6c 69 64 20 53 63 61 6e 43      - Invalid ScanC
    f606:	6f 64 65 3a 20 00 1b 5b 31 3b 35 3b 33 31 6d 45     ode: ..[1;5;31mE
    f616:	52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c     RROR.[0m - Inval
    f626:	69 64 20 70 6f 73 69 74 69 6f 6e 20 69 6e 64 65     id position inde
    f636:	78 20 28 72 65 6c 63 6f 6c 29 3a 20 00 1b 5b 31     x (relcol): ..[1
    f646:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
    f656:	2d 20 49 6e 76 61 6c 69 64 20 70 6f 73 69 74 69     - Invalid positi
    f666:	6f 6e 20 69 6e 64 65 78 20 28 72 65 6c 72 6f 77     on index (relrow
    f676:	29 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     ): ..[1;33mWARNI
    f686:	4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64     NG.[0m - Invalid
    f696:	20 50 69 78 65 6c 45 6c 65 6d 65 6e 74 20 77 69      PixelElement wi
    f6a6:	64 74 68 20 6d 61 70 70 69 6e 67 0d 0a 00 1b 5b     dth mapping....[
    f6b6:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
    f6c6:	20 2d 20 49 6e 76 61 6c 69 64 20 77 69 64 74 68      - Invalid width
    f6d6:	20 6d 61 70 70 69 6e 67 20 66 6f 72 20 3d 0d 0a      mapping for =..
    f6e6:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
    f6f6:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 77 69     [0m - Invalid wi
    f706:	64 74 68 20 6d 61 70 70 69 6e 67 20 66 6f 72 20     dth mapping for 
    f716:	2b 3d 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     +=....[1;33mWARN
    f726:	49 4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69     ING.[0m - Invali
    f736:	64 20 77 69 64 74 68 20 6d 61 70 70 69 6e 67 20     d width mapping 
    f746:	66 6f 72 20 2d 3d 0d 0a 00 1b 5b 31 3b 33 33 6d     for -=....[1;33m
    f756:	57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 6e     WARNING.[0m - In
    f766:	76 61 6c 69 64 20 77 69 64 74 68 20 6d 61 70 70     valid width mapp
    f776:	69 6e 67 20 66 6f 72 20 3c 3c 3d 0d 0a 00 1b 5b     ing for <<=....[
    f786:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
    f796:	20 2d 20 49 6e 76 61 6c 69 64 20 77 69 64 74 68      - Invalid width
    f7a6:	20 6d 61 70 70 69 6e 67 20 66 6f 72 20 3e 3e 3d      mapping for >>=
    f7b6:	0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e     ....[1;33mWARNIN
    f7c6:	47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20     G.[0m - Invalid 
    f7d6:	77 69 64 74 68 20 6d 61 70 70 69 6e 67 20 6f 6e     width mapping on
    f7e6:	20 73 65 74 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41      set....[1;33mWA
    f7f6:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 55 6e 69 6d     RNING.[0m - Unim
    f806:	70 6c 65 6d 65 6e 74 65 64 20 70 69 78 65 6c 20     plemented pixel 
    f816:	6d 6f 64 69 66 69 65 72 0d 0a 00 1b 5b 31 3b 35     modifier....[1;5
    f826:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
    f836:	50 69 78 65 6c 20 54 77 65 65 6e 20 42 75 67 21     Pixel Tween Bug!
    f846:	0d 0a 00 50 69 78 65 6c 4d 61 70 00 57 3a 00 20     ...PixelMap.W:. 
    f856:	43 3a 00 20 49 3a 00                                C:. I:.

0000f85d <aniAddCLIDict_DescEntry>:
    f85d:	41 64 64 20 74 68 65 20 67 69 76 65 6e 20 61 6e     Add the given an
    f86d:	69 6d 61 74 69 6f 6e 20 69 64 20 74 6f 20 74 68     imation id to th
    f87d:	65 20 73 74 61 63 6b 00                             e stack.

0000f885 <aniDelCLIDict_DescEntry>:
    f885:	52 65 6d 6f 76 65 20 74 68 65 20 67 69 76 65 6e     Remove the given
    f895:	20 73 74 61 63 6b 20 69 6e 64 65 78 20 61 6e 69      stack index ani
    f8a5:	6d 61 74 69 6f 6e 00                                mation.

0000f8ac <aniStackCLIDict_DescEntry>:
    f8ac:	44 69 73 70 6c 61 79 73 20 74 68 65 20 61 6e 69     Displays the ani
    f8bc:	6d 61 74 69 6f 6e 20 73 74 61 63 6b 20 63 6f 6e     mation stack con
    f8cc:	74 65 6e 74 73 00                                   tents.

0000f8d2 <chanTestCLIDict_DescEntry>:
    f8d2:	43 68 61 6e 6e 65 6c 20 74 65 73 74 2e 20 4e 6f     Channel test. No
    f8e2:	20 61 72 67 20 2d 20 6e 65 78 74 20 70 69 78 65      arg - next pixe
    f8f2:	6c 2e 20 23 20 2d 20 70 69 78 65 6c 2c 20 72 20     l. # - pixel, r 
    f902:	2d 20 72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e 20     - roll-through. 
    f912:	61 20 2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74 6f     a - all, s - sto
    f922:	70 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     p..[1;32mINFO.[0
    f932:	6d 20 2d 20 53 74 61 63 6b 20 53 69 7a 65 3a 20     m - Stack Size: 
    f942:	00 20 69 6e 64 65 78 28 00 29 20 70 6f 73 28 00     . index(.) pos(.
    f952:	29 20 6c 6f 6f 70 73 28 00 29 20 66 72 61 6d 65     ) loops(.) frame
    f962:	64 65 6c 61 79 28 00 29 20 66 72 61 6d 65 6f 70     delay(.) frameop
    f972:	74 69 6f 6e 28 00 29 20 66 66 75 6e 63 28 00 29     tion(.) ffunc(.)
    f982:	20 70 66 75 6e 63 28 00 1b 5b 31 3b 33 32 6d 49      pfunc(..[1;32mI
    f992:	4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c 20 63 68     NFO.[0m - All ch
    f9a2:	61 6e 6e 65 6c 20 74 65 73 74 00 1b 5b 31 3b 33     annel test..[1;3
    f9b2:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 43 68 61     2mINFO.[0m - Cha
    f9c2:	6e 6e 65 6c 20 72 6f 6c 6c 20 74 65 73 74 00 1b     nnel roll test..
    f9d2:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    f9e2:	20 53 74 6f 70 70 69 6e 67 20 63 68 61 6e 6e 65      Stopping channe
    f9f2:	6c 20 74 65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e     l test..[1;32mIN
    fa02:	46 4f 1b 5b 30 6d 20 2d 20 45 6e 61 62 6c 65 20     FO.[0m - Enable 
    fa12:	61 6c 6c 20 70 69 78 65 6c 73 00 1b 5b 31 3b 33     all pixels..[1;3
    fa22:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 44 69 73     2mINFO.[0m - Dis
    fa32:	61 62 6c 65 20 61 6c 6c 20 70 69 78 65 6c 73 00     able all pixels.
    fa42:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    fa52:	2d 20 43 68 61 6e 6e 65 6c 3a 20 00 1b 5b 31 3b     - Channel: ..[1;
    fa62:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 42 75     32mINFO.[0m - Bu
    fa72:	66 66 65 72 20 4c 69 73 74 00 3a 77 69 64 74 68     ffer List.:width
    fa82:	28 00 29 3a 73 69 7a 65 28 00 1b 5b 31 3b 33 32     (.):size(..[1;32
    fa92:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 69 78 65     mINFO.[0m - Pixe
    faa2:	6c 20 4c 69 73 74 20 2d 20 3c 6e 75 6d 3e 5b 3c     l List - <num>[<
    fab2:	63 68 31 3e 2c 2e 2e 2e 5d 3c 77 69 64 74 68 3e     ch1>,...]<width>
    fac2:	3a 2e 2e 2e 00 5d 00 1b 5b 31 3b 33 32 6d 49 4e     :....]..[1;32mIN
    fad2:	46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c 20 73 63 61     FO.[0m - All sca
    fae2:	6e 63 6f 64 65 20 70 69 78 65 6c 20 74 65 73 74     ncode pixel test
    faf2:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    fb02:	20 2d 20 53 63 61 6e 63 6f 64 65 20 70 69 78 65      - Scancode pixe
    fb12:	6c 20 72 6f 6c 6c 20 74 65 73 74 00 1b 5b 31 3b     l roll test..[1;
    fb22:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 74     32mINFO.[0m - St
    fb32:	6f 70 70 69 6e 67 20 73 63 61 6e 63 6f 64 65 20     opping scancode 
    fb42:	70 69 78 65 6c 20 74 65 73 74 00 1b 5b 31 3b 33     pixel test..[1;3
    fb52:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 63 61     2mINFO.[0m - Sca
    fb62:	6e 43 6f 64 65 3a 20 00 1b 5b 31 3b 33 32 6d 49     nCode: ..[1;32mI
    fb72:	4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c 20 70 69     NFO.[0m - All pi
    fb82:	78 65 6c 20 74 65 73 74 00 1b 5b 31 3b 33 32 6d     xel test..[1;32m
    fb92:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 69 78 65 6c     INFO.[0m - Pixel
    fba2:	20 72 6f 6c 6c 20 74 65 73 74 00 1b 5b 31 3b 33      roll test..[1;3
    fbb2:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 74 6f     2mINFO.[0m - Sto
    fbc2:	70 70 69 6e 67 20 70 69 78 65 6c 20 74 65 73 74     pping pixel test
    fbd2:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    fbe2:	20 2d 20 50 69 78 65 6c 3a 20 00 1b 5b 31 3b 33      - Pixel: ..[1;3
    fbf2:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c     2mINFO.[0m - All
    fc02:	20 78 2c 79 20 70 69 78 65 6c 20 74 65 73 74 00      x,y pixel test.
    fc12:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    fc22:	2d 20 78 2c 79 20 70 69 78 65 6c 20 72 6f 6c 6c     - x,y pixel roll
    fc32:	20 74 65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e 46      test..[1;32mINF
    fc42:	4f 1b 5b 30 6d 20 2d 20 53 74 6f 70 70 69 6e 67     O.[0m - Stopping
    fc52:	20 78 2c 79 20 70 69 78 65 6c 20 74 65 73 74 00      x,y pixel test.
    fc62:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    fc72:	2d 20 48 6f 72 69 7a 6f 6e 74 61 6c 3a 20 00 1b     - Horizontal: ..
    fc82:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    fc92:	20 56 65 72 74 69 63 61 6c 3a 20 00 1b 5b 31 3b      Vertical: ..[1;
    fca2:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 6f     32mINFO.[0m - Po
    fcb2:	73 69 74 69 6f 6e 20 28 78 2c 79 29 3a 20 00 00     sition (x,y): ..
    fcc2:	00 00                                               ..

0000fcc4 <pixelCLIDict>:
    fcc4:	ac fe 00 00 5d f8 00 00 25 6a 00 00 b3 fe 00 00     ....]...%j......
    fcd4:	85 f8 00 00 31 6a 00 00 ba fe 00 00 ac f8 00 00     ....1j..........
    fce4:	4d 6a 00 00 c3 fe 00 00 d2 f8 00 00 09 73 00 00     Mj...........s..
    fcf4:	cc fe 00 00 52 fd 00 00 15 6b 00 00 d6 fe 00 00     ....R....k......
    fd04:	75 fd 00 00 85 75 00 00 e2 fe 00 00 ce fd 00 00     u....u..........
    fd14:	65 74 00 00 ec fe 00 00 28 fe 00 00 81 76 00 00     et......(....v..
    fd24:	f8 fe 00 00 7b fe 00 00 41 81 00 00 00 00 00 00     ....{...A.......
    fd34:	00 00 00 00 00 00 00 00                             ........

0000fd3c <pixelCLIDictName>:
    fd3c:	50 69 78 65 6c 20 4d 6f 64 75 6c 65 20 43 6f 6d     Pixel Module Com
    fd4c:	6d 61 6e 64 73 00                                   mands.

0000fd52 <pixelListCLIDict_DescEntry>:
    fd52:	50 72 69 6e 74 73 20 6f 75 74 20 70 69 78 65 6c     Prints out pixel
    fd62:	3a 63 68 61 6e 6e 65 6c 20 6d 61 70 70 69 6e 67     :channel mapping
    fd72:	73 2e 00                                            s..

0000fd75 <pixelSCTestCLIDict_DescEntry>:
    fd75:	53 63 61 6e 63 6f 64 65 20 70 69 78 65 6c 20 74     Scancode pixel t
    fd85:	65 73 74 2e 20 4e 6f 20 61 72 67 20 2d 20 6e 65     est. No arg - ne
    fd95:	78 74 20 70 69 78 65 6c 2e 20 23 20 2d 20 70 69     xt pixel. # - pi
    fda5:	78 65 6c 2c 20 72 20 2d 20 72 6f 6c 6c 2d 74 68     xel, r - roll-th
    fdb5:	72 6f 75 67 68 2e 20 61 20 2d 20 61 6c 6c 2c 20     rough. a - all, 
    fdc5:	73 20 2d 20 73 74 6f 70 00                          s - stop.

0000fdce <pixelTestCLIDict_DescEntry>:
    fdce:	50 69 78 65 6c 20 74 65 73 74 2e 20 4e 6f 20 61     Pixel test. No a
    fdde:	72 67 20 2d 20 6e 65 78 74 20 70 69 78 65 6c 2e     rg - next pixel.
    fdee:	20 23 20 2d 20 70 69 78 65 6c 2c 20 72 20 2d 20      # - pixel, r - 
    fdfe:	72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e 20 61 20     roll-through. a 
    fe0e:	2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74 6f 70 2c     - all, s - stop,
    fe1e:	20 66 20 2d 20 66 75 6c 6c 00                        f - full.

0000fe28 <pixelXYTestCLIDict_DescEntry>:
    fe28:	58 59 20 70 69 78 65 6c 20 74 65 73 74 2e 20 4e     XY pixel test. N
    fe38:	6f 20 61 72 67 20 2d 20 6e 65 78 74 20 70 69 78     o arg - next pix
    fe48:	65 6c 2e 20 23 20 2d 20 70 69 78 65 6c 2c 20 72     el. # - pixel, r
    fe58:	20 2d 20 72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e      - roll-through.
    fe68:	20 61 20 2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74      a - all, s - st
    fe78:	6f 70 00                                            op.

0000fe7b <rectDispCLIDict_DescEntry>:
    fe7b:	53 68 6f 77 20 74 68 65 20 63 75 72 72 65 6e 74     Show the current
    fe8b:	20 6f 75 74 70 75 74 20 6f 66 20 74 68 65 20 4d      output of the M
    fe9b:	43 55 20 70 69 78 65 6c 20 62 75 66 66 65 72 2e     CU pixel buffer.
    feab:	00 61 6e 69 41 64 64 00 61 6e 69 44 65 6c 00 61     .aniAdd.aniDel.a
    febb:	6e 69 53 74 61 63 6b 00 63 68 61 6e 54 65 73 74     niStack.chanTest
    fecb:	00 70 69 78 65 6c 4c 69 73 74 00 70 69 78 65 6c     .pixelList.pixel
    fedb:	53 43 54 65 73 74 00 70 69 78 65 6c 54 65 73 74     SCTest.pixelTest
    feeb:	00 70 69 78 65 6c 58 59 54 65 73 74 00 72 65 63     .pixelXYTest.rec
    fefb:	74 44 69 73 70 00 00                                tDisp..

0000ff02 <Pixel_DisplayMapping>:
    ff02:	07 00 00 00 06 00 00 00 05 00 00 00 04 00 00 00     ................
    ff12:	03 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00     ................
    ff22:	00 00 0e 00 00 00 0d 00 00 00 0c 00 00 00 0b 00     ................
    ff32:	00 00 0a 00 00 00 09 00 00 00 08 00 00 00 00 00     ................
    ff42:	00 00 00 00 14 00 00 00 13 00 00 00 12 00 00 00     ................
    ff52:	11 00 00 00 10 00 00 00 0f 00 00 00 00 00 00 00     ................
    ff62:	00 00 00 00 00 00 1d 00 00 00 1c 00 00 00 1b 00     ................
    ff72:	00 00 1a 00 00 00 19 00 00 00 18 00 00 00 17 00     ................
    ff82:	00 00 00 00 00 00 00 00 00 00 26 00 25 00 00 00     ..........&.%...
    ff92:	24 00 00 00 23 00 00 00 22 00 00 00 00 00 00 00     $...#...".......
    ffa2:	00 00 00 00 16 00 00 00 15 00 00 00 00 00 00 00     ................
    ffb2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    ffc2:	21 00 00 00 20 00 00 00 1e 00 00 00 00 00 00 00     !... ...........
    ffd2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    ffe2:	00 00 00 00 00 00 00 00 1f 00 00 00 00 00           ..............

0000fff0 <Pixel_Mapping>:
    fff0:	08 01 00 00 00 00 00 00 08 01 10 00 00 00 00 00     ................
   10000:	08 01 20 00 00 00 00 00 08 01 30 00 00 00 00 00     .. .......0.....
   10010:	08 01 40 00 00 00 00 00 08 01 01 00 00 00 00 00     ..@.............
   10020:	08 01 11 00 00 00 00 00 08 01 21 00 00 00 00 00     ..........!.....
   10030:	08 01 31 00 00 00 00 00 08 01 41 00 00 00 00 00     ..1.......A.....
   10040:	08 01 02 00 00 00 00 00 08 01 12 00 00 00 00 00     ................
   10050:	08 01 22 00 00 00 00 00 08 01 32 00 00 00 00 00     ..".......2.....
   10060:	08 01 42 00 00 00 00 00 08 01 03 00 00 00 00 00     ..B.............
   10070:	08 01 13 00 00 00 00 00 08 01 23 00 00 00 00 00     ..........#.....
   10080:	08 01 33 00 00 00 00 00 08 01 43 00 00 00 00 00     ..3.......C.....
   10090:	08 01 04 00 00 00 00 00 08 01 14 00 00 00 00 00     ................
   100a0:	08 01 24 00 00 00 00 00 08 01 34 00 00 00 00 00     ..$.......4.....
   100b0:	08 01 44 00 00 00 00 00 08 01 05 00 00 00 00 00     ..D.............
   100c0:	08 01 15 00 00 00 00 00 08 01 25 00 00 00 00 00     ..........%.....
   100d0:	08 01 35 00 00 00 00 00 08 01 45 00 00 00 00 00     ..5.......E.....
   100e0:	08 01 06 00 00 00 00 00 08 01 16 00 00 00 00 00     ................
   100f0:	08 01 26 00 00 00 00 00 08 01 36 00 00 00 00 00     ..&.......6.....
   10100:	08 01 07 00 00 00 00 00 08 01 17 00 00 00 00 00     ................
   10110:	08 01 27 00 00 00 00 00 08 01 37 00 00 00 00 00     ..'.......7.....

00010120 <Pixel_ScanCodeToDisplay>:
   10120:	00 00 00 00 0c 00 0a 00 08 00 06 00 04 00 02 00     ................
   10130:	00 00 00 00 00 00 1d 00 1b 00 19 00 17 00 15 00     ................
   10140:	13 00 11 00 00 00 00 00 00 00 2c 00 2a 00 28 00     ..........,.*.(.
   10150:	26 00 24 00 22 00 54 00 52 00 3f 00 3d 00 3b 00     &.$.".T.R.?.=.;.
   10160:	39 00 37 00 35 00 33 00 64 00 74 00 62 00 60 00     9.7.5.3.d.t.b.`.
   10170:	4c 00 4a 00 48 00 46 00 45 00                       L.J.H.F.E.

0001017a <Pixel_ScanCodeToPixel>:
   1017a:	00 00 00 00 01 00 02 00 03 00 04 00 05 00 06 00     ................
   1018a:	07 00 00 00 00 00 08 00 09 00 0a 00 0b 00 0c 00     ................
   1019a:	0d 00 0e 00 00 00 00 00 00 00 0f 00 10 00 11 00     ................
   101aa:	12 00 13 00 14 00 15 00 16 00 17 00 18 00 19 00     ................
   101ba:	1a 00 1b 00 1c 00 1d 00 1e 00 1f 00 20 00 21 00     ............ .!.
   101ca:	22 00 23 00 24 00 25 00 26 00 1b 5b 31 3b 35 3b     ".#.$.%.&..[1;5;
   101da:	33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 4e     31mERROR.[0m - N
   101ea:	6f 74 20 65 6e 6f 75 67 68 20 62 79 74 65 73 20     ot enough bytes 
   101fa:	69 6e 20 48 49 44 49 4f 20 62 75 66 66 65 72 3a     in HIDIO buffer:
   1020a:	20 00 20 62 79 74 65 73 20 6c 65 66 74 2c 20 00      . bytes left, .
   1021a:	20 62 79 74 65 73 20 74 6f 74 61 6c 20 00 20 62      bytes total . b
   1022a:	79 74 65 73 20 72 65 71 75 65 73 74 65 64 00 1b     ytes requested..
   1023a:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   1024a:	6d 20 2d 20 52 65 71 75 65 73 74 65 64 20 48 49     m - Requested HI
   1025a:	44 49 4f 20 62 75 66 66 65 72 20 70 6f 70 20 6c     DIO buffer pop l
   1026a:	61 72 67 65 72 20 74 68 61 6e 20 65 6e 74 69 72     arger than entir
   1027a:	65 20 62 75 66 66 65 72 3a 20 00 46 41 49 4c 0d     e buffer: .FAIL.
   1028a:	0a 00 53 59 4e 43 00 1b 5b 31 3b 33 33 6d 57 41     ..SYNC..[1;33mWA
   1029a:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 44 72 6f 70     RNING.[0m - Drop
   102aa:	70 69 6e 67 20 69 6e 63 6f 6d 69 6e 67 20 43 6f     ping incoming Co
   102ba:	6e 74 69 6e 75 65 64 20 44 61 74 61 20 70 61 63     ntinued Data pac
   102ca:	6b 65 74 2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 33 6d     ket.......[1;33m
   102da:	57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 44 72     WARNING.[0m - Dr
   102ea:	6f 70 70 69 6e 67 20 69 6e 63 6f 6d 69 6e 67 20     opping incoming 
   102fa:	44 61 74 61 20 70 61 63 6b 65 74 2c 20 6e 6f 74     Data packet, not
   1030a:	20 65 6e 6f 75 67 68 20 62 75 66 66 65 72 20 73      enough buffer s
   1031a:	70 61 63 65 2e 2e 2e 0d 0a 00 68 65 61 64 3a 20     pace......head: 
   1032a:	00 20 74 61 69 6c 3a 20 00 20 62 79 74 65 73 5f     . tail: . bytes_
   1033a:	6c 65 66 74 3a 20 00 20 72 65 71 75 65 73 74 3a     left: . request:
   1034a:	20 00 54 4f 44 4f 21 0d 0a 00 1b 5b 31 3b 35 3b      .TODO!....[1;5;
   1035a:	33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 48     31mERROR.[0m - H
   1036a:	49 44 49 4f 5f 49 64 5f 4c 69 73 74 20 69 73 20     IDIO_Id_List is 
   1037a:	66 75 6c 6c 2c 20 63 61 6e 6e 6f 74 20 72 65 67     full, cannot reg
   1038a:	69 73 74 65 72 20 49 64 3a 20 00 48 49 44 2d 49     ister Id: .HID-I
   1039a:	4f 00                                               O.

0001039c <hidioCLIDict>:
   1039c:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

000103a8 <hidioCLIDictName>:
   103a8:	48 49 44 2d 49 4f 20 4d 6f 64 75 6c 65 20 43 6f     HID-IO Module Co
   103b8:	6d 6d 61 6e 64 73 00 4f 75 74 70 75 74 5f 66 6c     mmands.Output_fl
   103c8:	61 73 68 4d 6f 64 65 28 29 00 1b 5b 31 3b 33 32     ashMode()..[1;32
   103d8:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 45 78 74 65     mINFO.[0m - Exte
   103e8:	72 6e 61 6c 20 41 76 61 69 6c 61 62 6c 65 20 43     rnal Available C
   103f8:	75 72 72 65 6e 74 20 43 68 61 6e 67 65 64 2e 20     urrent Changed. 
   10408:	54 6f 74 61 6c 20 41 76 61 69 6c 61 62 6c 65 3a     Total Available:
   10418:	20 00 20 6d 41 0d 0a 00 1b 5b 31 3b 33 32 6d 49      . mA....[1;32mI
   10428:	4e 46 4f 1b 5b 30 6d 20 2d 20 43 75 72 72 65 6e     NFO.[0m - Curren
   10438:	74 20 61 76 61 69 6c 61 62 6c 65 3a 20 00 20 6d     t available: . m
   10448:	41 00                                               A.

0001044a <currentCLIDict_DescEntry>:
   1044a:	53 68 6f 77 73 20 74 68 65 20 63 75 72 72 65 6e     Shows the curren
   1045a:	74 20 6e 65 67 6f 74 69 61 74 65 64 20 63 75 72     t negotiated cur
   1046a:	72 65 6e 74 2e 00                                   rent..

00010470 <outputCLIDict>:
   10470:	c5 04 01 00 4a 04 01 00 39 8b 00 00 cd 04 01 00     ....J...9.......
   10480:	ab 04 01 00 45 8a 00 00 00 00 00 00 00 00 00 00     ....E...........
   10490:	00 00 00 00                                         ....

00010494 <outputCLIDictName>:
   10494:	4f 75 74 70 75 74 20 4d 6f 64 75 6c 65 20 43 6f     Output Module Co
   104a4:	6d 6d 61 6e 64 73 00                                mmands.

000104ab <outputDebugCLIDict_DescEntry>:
   104ab:	54 6f 67 67 6c 65 20 4f 75 74 70 75 74 20 44 65     Toggle Output De
   104bb:	62 75 67 20 6d 6f 64 65 2e 00 63 75 72 72 65 6e     bug mode..curren
   104cb:	74 00 6f 75 74 70 75 74 44 65 62 75 67 00           t.outputDebug.

000104d9 <CSWTCH.63>:
   104d9:	00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02     ................
   104e9:	02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 04     ................
   104f9:	04 04 04 04 04 04 04 05 05 05 05 05 05 05 05        ...............

00010508 <CSWTCH.64>:
   10508:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   10518:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   10528:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07        ...............

00010537 <CSWTCH.65>:
   10537:	06 06 06 06 06 06 06 06 07 07 07 07 07 07 07 07     ................
   10547:	08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09     ................
   10557:	0a 0a 0a 0a 0a 0a 0a 0a 0b 0b 0b 0b 0b 0b 0b 0b     ................
   10567:	0c 0c 0c 0c 0c 0c 0c 0c 0d 0d 0d 0d 0d 0d 0d 0d     ................
   10577:	0e 0e 0e 0e 0e 0e 0e 0e 0f 0f 0f 0f 0f 0f 0f 0f     ................
   10587:	10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11     ................
   10597:	12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13     ................

000105a7 <CSWTCH.66>:
   105a7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   105b7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   105c7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   105d7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   105e7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   105f7:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   10607:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................

00010617 <CSWTCH.67>:
   10617:	00 01 02 03 04 05 06 07                             ........

0001061f <CSWTCH.68>:
   1061f:	15 15 15 15 15 15 15 15 16 16 16 16 16 16 16 16     ................
   1062f:	17 17 17 17 17 17 17 17 18 18 18 18 18 18 18 18     ................
   1063f:	19 19 19 19 19 19 19 19 1a 1a 1a 1a 1a 1a 1a 1a     ................

0001064f <CSWTCH.69>:
   1064f:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   1065f:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   1066f:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
   1067f:	4f 75 74 70 75 74 5f 63 6f 6e 73 43 74 72 6c 53     Output_consCtrlS
   1068f:	65 6e 64 28 63 6f 6e 73 43 6f 64 65 29 00 4f 75     end(consCode).Ou
   1069f:	74 70 75 74 5f 6b 62 64 50 72 6f 74 6f 63 6f 6c     tput_kbdProtocol
   106af:	42 6f 6f 74 28 29 00 4f 75 74 70 75 74 5f 6b 62     Boot().Output_kb
   106bf:	64 50 72 6f 74 6f 63 6f 6c 4e 4b 52 4f 28 29 00     dProtocolNKRO().
   106cf:	4f 75 74 70 75 74 5f 6e 6f 6e 65 53 65 6e 64 28     Output_noneSend(
   106df:	29 00 4f 75 74 70 75 74 5f 73 79 73 43 74 72 6c     ).Output_sysCtrl
   106ef:	53 65 6e 64 28 73 79 73 43 6f 64 65 29 00 4f 75     Send(sysCode).Ou
   106ff:	74 70 75 74 5f 74 6f 67 67 6c 65 4b 62 64 50 72     tput_toggleKbdPr
   1070f:	6f 74 6f 63 6f 6c 28 29 00 4f 75 74 70 75 74 5f     otocol().Output_
   1071f:	75 73 62 43 6f 64 65 53 65 6e 64 28 75 73 62 43     usbCodeSend(usbC
   1072f:	6f 64 65 29 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     ode)..[1;33mWARN
   1073f:	49 4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20 4b 65     ING.[0m - USB Ke
   1074f:	79 20 6c 69 6d 69 74 20 72 65 61 63 68 65 64 0d     y limit reached.
   1075f:	0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47     ...[1;33mWARNING
   1076f:	1b 5b 30 6d 20 2d 20 55 53 42 20 43 6f 64 65 20     .[0m - USB Code 
   1077f:	6e 6f 74 20 77 69 74 68 69 6e 20 34 2d 34 39 20     not within 4-49 
   1078f:	28 30 78 34 2d 30 78 33 31 29 2c 20 35 31 2d 31     (0x4-0x31), 51-1
   1079f:	35 35 20 28 30 78 33 33 2d 30 78 39 42 29 2c 20     55 (0x33-0x9B), 
   107af:	31 35 37 2d 31 36 34 20 28 30 78 39 44 2d 30 78     157-164 (0x9D-0x
   107bf:	41 34 29 2c 20 31 37 36 2d 32 32 31 20 28 30 78     A4), 176-221 (0x
   107cf:	42 30 2d 30 78 44 44 29 20 6f 72 20 32 32 34 2d     B0-0xDD) or 224-
   107df:	32 33 31 20 28 30 78 45 30 2d 30 78 45 37 29 20     231 (0xE0-0xE7) 
   107ef:	4e 4b 52 4f 20 4d 6f 64 65 3a 20 00 4f 75 74 70     NKRO Mode: .Outp
   107ff:	75 74 5f 75 73 62 4d 6f 75 73 65 28 6d 6f 75 73     ut_usbMouse(mous
   1080f:	65 42 75 74 74 6f 6e 2c 72 65 6c 58 2c 72 65 6c     eButton,relX,rel
   1081f:	59 29 00 55 53 42 4f 75 74 70 75 74 50 65 72 69     Y).USBOutputPeri
   1082f:	00 55 53 42 4f 75 74 70 75 74 50 6f 6c 6c 00 1b     .USBOutputPoll..
   1083f:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   1084f:	20 55 53 42 20 49 64 6c 65 20 43 6f 6e 66 69 67      USB Idle Config
   1085f:	3a 20 00 20 6d 73 20 2d 20 00 1b 5b 31 3b 33 32     : . ms - ..[1;32
   1086f:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 74 74     mINFO.[0m - Sett
   1087f:	69 6e 67 20 4b 65 79 62 6f 61 72 64 20 50 72 6f     ing Keyboard Pro
   1088f:	74 6f 63 6f 6c 20 74 6f 3a 20 00 1b 5b 31 3b 33     tocol to: ..[1;3
   1089f:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4b 65 79     2mINFO.[0m - Key
   108af:	62 6f 61 72 64 20 50 72 6f 74 6f 63 6f 6c 3a 20     board Protocol: 
   108bf:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
   108cf:	20 2d 20 4c 45 44 20 53 74 61 74 65 3a 20 00 1b      - LED State: ..
   108df:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   108ef:	20 55 53 42 20 49 6e 69 74 20 54 69 6d 65 3a 20      USB Init Time: 
   108ff:	00                                                  .

00010900 <idleCLIDict_DescEntry>:
   10900:	53 68 6f 77 2f 73 65 74 20 74 68 65 20 48 49 44     Show/set the HID
   10910:	20 49 64 6c 65 20 74 69 6d 65 20 28 6d 75 6c 74      Idle time (mult
   10920:	69 70 6c 65 73 20 6f 66 20 34 20 6d 73 29 2e 00     iples of 4 ms)..

00010930 <kbdProtocolCLIDict_DescEntry>:
   10930:	4b 65 79 62 6f 61 72 64 20 50 72 6f 74 6f 63 6f     Keyboard Protoco
   10940:	6c 20 4d 6f 64 65 3a 20 30 20 2d 20 42 6f 6f 74     l Mode: 0 - Boot
   10950:	2c 20 31 20 2d 20 4f 53 2f 4e 4b 52 4f 20 4d 6f     , 1 - OS/NKRO Mo
   10960:	64 65 2e 00                                         de..

00010964 <readLEDsCLIDict_DescEntry>:
   10964:	52 65 61 64 20 4c 45 44 20 62 79 74 65 3a 0d 0a     Read LED byte:..
   10974:	09 09 31 20 4e 75 6d 4c 63 6b 2c 20 32 20 43 61     ..1 NumLck, 2 Ca
   10984:	70 73 4c 63 6b 2c 20 34 20 53 63 72 6c 4c 63 6b     psLck, 4 ScrlLck
   10994:	2c 20 31 36 20 4b 61 6e 61 2c 20 65 74 63 2e 00     , 16 Kana, etc..
   109a4:	69 64 6c 65 00 6b 62 64 50 72 6f 74 6f 63 6f 6c     idle.kbdProtocol
   109b4:	00 72 65 61 64 4c 45 44 73 00 75 73 62 49 6e 69     .readLEDs.usbIni
   109c4:	74 54 69 6d 65 00 00 00                             tTime...

000109cc <usbCLIDict>:
   109cc:	a4 09 01 00 00 09 01 00 a1 8b 00 00 a9 09 01 00     ................
   109dc:	30 09 01 00 6d 8c 00 00 b5 09 01 00 64 09 01 00     0...m.......d...
   109ec:	f5 8b 00 00 be 09 01 00 1c 0a 01 00 1d 8c 00 00     ................
   109fc:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

00010a08 <usbCLIDictName>:
   10a08:	55 53 42 20 4d 6f 64 75 6c 65 20 43 6f 6d 6d 61     USB Module Comma
   10a18:	6e 64 73 00                                         nds.

00010a1c <usbInitTimeCLIDict_DescEntry>:
   10a1c:	44 69 73 70 6c 61 79 73 20 74 68 65 20 74 69 6d     Displays the tim
   10a2c:	65 20 69 6e 20 6d 73 20 66 72 6f 6d 20 75 73 62     e in ms from usb
   10a3c:	5f 69 6e 69 74 28 29 20 74 69 6c 6c 20 74 68 65     _init() till the
   10a4c:	20 6c 61 73 74 20 73 65 74 75 70 20 63 61 6c 6c      last setup call
   10a5c:	2e 00 00 00                                         ....

00010a60 <usb_descriptor_list>:
   10a60:	00 01 00 00 b9 8d ff 1f 12 00 00 00 00 02 00 00     ................
   10a70:	ea 8c ff 1f cf 00 00 00 00 06 00 00 f8 93 ff 1f     ................
   10a80:	01 00 00 00 00 0a 00 00 f9 93 ff 1f 01 00 00 00     ................
   10a90:	00 03 00 00 d6 8e ff 1f 00 00 00 00 01 03 09 04     ................
   10aa0:	b2 8f ff 1f 00 00 00 00 02 03 09 04 f6 8f ff 1f     ................
   10ab0:	00 00 00 00 03 03 09 04 74 90 ff 1f 00 00 00 00     ........t.......
   10ac0:	04 03 09 04 88 8f ff 1f 00 00 00 00 00 22 00 00     ............."..
   10ad0:	cb 8d ff 1f 3f 00 00 00 00 21 00 00 fc 8c ff 1f     ....?....!......
   10ae0:	09 00 00 00 00 22 01 00 3d 8e ff 1f 7d 00 00 00     ....."..=...}...
   10af0:	00 21 01 00 15 8d ff 1f 09 00 00 00 00 22 02 00     .!..........."..
   10b00:	da 8e ff 1f 35 00 00 00 00 21 02 00 2e 8d ff 1f     ....5....!......
   10b10:	09 00 00 00 05 03 09 04 94 8f ff 1f 00 00 00 00     ................
   10b20:	06 03 09 04 d8 8f ff 1f 00 00 00 00 07 03 09 04     ................
   10b30:	d0 90 ff 1f 00 00 00 00 08 03 09 04 4c 8f ff 1f     ............L...
   10b40:	00 00 00 00 09 03 09 04 14 8f ff 1f 00 00 00 00     ................
   10b50:	00 22 05 00 ba 8e ff 1f 1b 00 00 00 00 21 05 00     ."...........!..
   10b60:	89 8d ff 1f 09 00 00 00 0a 03 09 04 4a 90 ff 1f     ............J...
   10b70:	00 00 00 00 00 22 06 00 0a 8e ff 1f 33 00 00 00     ....."......3...
   10b80:	00 21 06 00 89 8d ff 1f 09 00 00 00 0b 03 09 04     .!..............
   10b90:	ca 8f ff 1f 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10ba0:	00 00 00 00                                         ....

00010ba4 <usb_endpoint_config_table>:
   10ba4:	15 15 15 15 19 15 15 19 15 15 1b 5b 31 3b 33 33     ...........[1;33
   10bb4:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 55     mWARNING.[0m - U
   10bc4:	53 42 20 4c 6f 77 20 50 6f 77 65 72 20 4e 65 67     SB Low Power Neg
   10bd4:	6f 74 61 74 69 6f 6e 20 44 69 73 61 62 6c 65 64     otation Disabled
   10be4:	2c 20 63 6f 6e 64 69 74 69 6f 6e 20 64 65 74 65     , condition dete
   10bf4:	63 74 65 64 2e 00 1b 5b 31 3b 33 33 6d 57 41 52     cted...[1;33mWAR
   10c04:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 53 45 54 5f 46     NING.[0m - SET_F
   10c14:	45 41 54 55 52 45 20 2d 20 44 65 76 69 63 65 20     EATURE - Device 
   10c24:	77 56 61 6c 75 65 28 00 1b 5b 31 3b 33 33 6d 57     wValue(..[1;33mW
   10c34:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 43 4c 45     ARNING.[0m - CLE
   10c44:	41 52 5f 46 45 41 54 55 52 45 20 2d 20 49 6e 74     AR_FEATURE - Int
   10c54:	65 72 66 61 63 65 20 77 56 61 6c 75 65 28 00 29     erface wValue(.)
   10c64:	20 77 49 6e 64 65 78 28 00 1b 5b 31 3b 33 33 6d      wIndex(..[1;33m
   10c74:	57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 53 45     WARNING.[0m - SE
   10c84:	54 5f 46 45 41 54 55 52 45 20 2d 20 49 6e 74 65     T_FEATURE - Inte
   10c94:	72 66 61 63 65 20 77 56 61 6c 75 65 28 00 1b 5b     rface wValue(..[
   10ca4:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
   10cb4:	20 2d 20 28 53 45 54 5f 52 45 50 4f 52 54 2c 20      - (SET_REPORT, 
   10cc4:	53 45 54 55 50 29 20 55 6e 6b 6e 6f 77 6e 20 69     SETUP) Unknown i
   10cd4:	6e 74 65 72 66 61 63 65 20 2d 20 00 1b 5b 31 3b     nterface - ..[1;
   10ce4:	33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d     33mWARNING.[0m -
   10cf4:	20 28 53 45 54 5f 52 45 50 4f 52 54 2c 20 42 55      (SET_REPORT, BU
   10d04:	4c 4b 29 20 55 6e 6b 6e 6f 77 6e 20 69 6e 74 65     LK) Unknown inte
   10d14:	72 66 61 63 65 20 2d 20 00 1b 5b 31 3b 35 3b 33     rface - ..[1;5;3
   10d24:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 55 53     1mERROR.[0m - US
   10d34:	42 20 6e 6f 74 20 63 6f 6e 66 69 67 75 72 65 64     B not configured
   10d44:	2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52     .......[1;33mWAR
   10d54:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20 54     NING.[0m - USB T
   10d64:	72 61 6e 73 6d 69 74 20 54 69 6d 65 6f 75 74 2e     ransmit Timeout.
   10d74:	2e 2e 61 75 74 6f 2d 72 65 73 74 61 72 74 20 64     ..auto-restart d
   10d84:	69 73 61 62 6c 65 64 0d 0a 00 53 79 73 43 74 72     isabled...SysCtr
   10d94:	6c 5b 00 5d 20 0d 0a 00 43 6f 6e 73 43 74 72 6c     l[.] ...ConsCtrl
   10da4:	5b 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b     [..[1;35mDEBUG.[
   10db4:	30 6d 20 2d 20 42 6f 6f 74 20 55 53 42 3a 20 00     0m - Boot USB: .
   10dc4:	1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d     .[1;35mDEBUG.[0m
   10dd4:	20 2d 20 4e 4b 52 4f 20 55 53 42 3a 20 00 1b 5b      - NKRO USB: ..[
   10de4:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
   10df4:	20 2d 20 55 53 42 20 54 72 61 6e 73 6d 69 74 20      - USB Transmit 
   10e04:	54 69 6d 65 6f 75 74 2e 2e 2e 0d 0a 00 1b 5b 31     Timeout.......[1
   10e14:	3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20     ;33mWARNING.[0m 
   10e24:	2d 20 52 41 57 49 4f 20 52 78 20 2d 20 54 69 6d     - RAWIO Rx - Tim
   10e34:	65 6f 75 74 2c 20 64 72 6f 70 70 69 6e 67 20 70     eout, dropping p
   10e44:	61 63 6b 65 74 2e 00 1b 5b 31 3b 33 33 6d 57 41     acket...[1;33mWA
   10e54:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 52 41 57 49     RNING.[0m - RAWI
   10e64:	4f 20 54 78 20 2d 20 54 69 6d 65 6f 75 74 2c 20     O Tx - Timeout, 
   10e74:	64 72 6f 70 70 69 6e 67 20 70 61 63 6b 65 74 2e     dropping packet.
   10e84:	00 00 00 00 00 45 52 52 4f 52 00 31 3b 35 3b 33     .....ERROR.1;5;3
   10e94:	31 00 1b 5b 00 22 20 69 73 20 6e 6f 74 20 61 20     1..[." is not a 
   10ea4:	76 61 6c 69 64 20 63 6f 6d 6d 61 6e 64 2e 2e 2e     valid command...
   10eb4:	74 79 70 65 20 1b 5b 33 35 6d 68 65 6c 70 1b 5b     type .[35mhelp.[
   10ec4:	30 6d 00 22 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     0m."..[1;5;31mER
   10ed4:	52 4f 52 1b 5b 30 6d 20 2d 20 53 65 72 69 61 6c     ROR.[0m - Serial
   10ee4:	20 6c 69 6e 65 20 62 75 66 66 65 72 20 69 73 20      line buffer is 
   10ef4:	66 75 6c 6c 2c 20 64 72 6f 70 70 69 6e 67 20 63     full, dropping c
   10f04:	68 61 72 61 63 74 65 72 20 61 6e 64 20 72 65 73     haracter and res
   10f14:	65 74 74 69 6e 67 2e 2e 2e 0d 0a 00 1b 5b 73 0d     etting.......[s.
   10f24:	0a 00 1b 5b 32 4b 00 1b 5b 75 00 08 20 08 00 1b     ...[2K..[u.. ...
   10f34:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   10f44:	6d 20 2d 20 4d 61 78 20 6e 75 6d 62 65 72 20 6f     m - Max number o
   10f54:	66 20 64 69 63 74 69 6f 6e 61 72 69 65 73 20 64     f dictionaries d
   10f64:	65 66 69 6e 65 64 20 61 6c 72 65 61 64 79 2e 2e     efined already..
   10f74:	2e 0d 0a 00 41 52 4d 00 43 6f 72 74 65 78 2d 4d     ....ARM.Cortex-M
   10f84:	34 00 2d 2d 00 00                                   4.--..

00010f8a <ChipVersion_eepromsize>:
   10f8a:	00 40 00 20 00 10 00 08 00 04 00 02 00 01 80 00     .@. ............
   10f9a:	40 00 20 00 ff ff ff ff ff ff ff ff ff ff 00 00     @. .............
   10faa:	6d 6b 32 30 64 78 31 32 38 76 6c 66 35 00 6d 6b     mk20dx128vlf5.mk
   10fba:	32 30 64 78 31 32 38 76 6c 68 37 00 6d 6b 32 30     20dx128vlh7.mk20
   10fca:	64 78 31 32 38 58 58 58 58 00 6d 6b 32 30 64 78     dx128XXXX.mk20dx
   10fda:	32 35 36 76 6c 68 37 00 6d 6b 32 30 64 78 32 35     256vlh7.mk20dx25
   10fea:	36 76 6d 63 37 00 6d 6b 32 30 64 78 32 35 36 58     6vmc7.mk20dx256X
   10ffa:	58 58 58 00 6d 6b 32 30 64 78 58 58 58 76 6c 68     XXX.mk20dxXXXvlh
   1100a:	37 00 6d 6b 32 32 66 78 35 31 32 61 76 6c 68 31     7.mk22fx512avlh1
   1101a:	32 00 6d 6b 32 32 66 78 58 58 58 61 76 6c 68 31     2.mk22fxXXXavlh1
   1102a:	32 00                                               2.

0001102c <ChipVersion_nvmsize>:
   1102c:	00 00 ff ff ff ff 20 00 40 00 80 00 ff ff 00 01     ...... .@.......
   1103c:	ff ff 00 02 ff ff ff ff ff ff ff ff 00 02           ..............

0001104a <ChipVersion_pflashsize>:
   1104a:	ff ff ff ff ff ff 20 00 ff ff 40 00 ff ff 80 00     ...... ...@.....
   1105a:	ff ff 00 01 ff ff 00 02 ff ff 00 04 ff ff 00 04     ................

0001106a <ChipVersion_ramsize>:
   1106a:	ff ff 08 00 ff ff 10 00 18 00 20 00 30 00 40 00     .......... .0.@.
   1107a:	60 00 80 00 ff ff 00 01 ff ff ff ff ff ff ff ff     `...............
   1108a:	00 00                                               ..

0001108c <basicCLIDict>:
   1108c:	16 22 01 00 45 11 01 00 b5 a5 00 00 1c 22 01 00     ."..E........"..
   1109c:	57 11 01 00 41 a7 00 00 25 22 01 00 98 1f 01 00     W...A...%"......
   110ac:	c1 a5 00 00 2f 22 01 00 f9 1f 01 00 0d a6 00 00     ..../"..........
   110bc:	34 22 01 00 11 20 01 00 b1 b1 00 00 3c 22 01 00     4"... ......<"..
   110cc:	61 20 01 00 cd a6 00 00 40 22 01 00 f7 20 01 00     a ......@"... ..
   110dc:	1d ac 00 00 49 22 01 00 42 21 01 00 79 a7 00 00     ....I"..B!..y...
   110ec:	4e 22 01 00 76 21 01 00 dd a5 00 00 55 22 01 00     N"..v!......U"..
   110fc:	a1 21 01 00 01 a6 00 00 5b 22 01 00 cf 21 01 00     .!......["...!..
   1110c:	e1 a6 00 00 63 22 01 00 df 22 01 00 e5 a6 00 00     ....c"..."......
   1111c:	68 22 01 00 29 23 01 00 9d a8 00 00 00 00 00 00     h"..)#..........
   1112c:	00 00 00 00 00 00 00 00                             ........

00011134 <basicCLIDictName>:
   11134:	47 65 6e 65 72 61 6c 20 43 6f 6d 6d 61 6e 64 73     General Commands
   11144:	00                                                  .

00011145 <clearCLIDict_DescEntry>:
   11145:	43 6c 65 61 72 20 74 68 65 20 73 63 72 65 65 6e     Clear the screen
   11155:	2e 00                                               ..

00011157 <cliDebugCLIDict_DescEntry>:
   11157:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
   11167:	20 68 65 78 20 6f 75 74 70 75 74 20 6f 66 20 74      hex output of t
   11177:	68 65 20 6d 6f 73 74 20 72 65 63 65 6e 74 20 63     he most recent c
   11187:	6c 69 20 69 6e 70 75 74 2e 00 1b 5b 32 4a 1b 5b     li input...[2J.[
   11197:	48 0d 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     H...[1;32mINFO.[
   111a7:	30 6d 20 2d 20 48 65 78 20 64 65 62 75 67 20 6d     0m - Hex debug m
   111b7:	6f 64 65 20 64 69 73 61 62 6c 65 64 2e 2e 2e 0d     ode disabled....
   111c7:	0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     ...[1;32mINFO.[0
   111d7:	6d 20 2d 20 48 65 78 20 64 65 62 75 67 20 6d 6f     m - Hex debug mo
   111e7:	64 65 20 65 6e 61 62 6c 65 64 2e 2e 2e 0d 0a 00     de enabled......
   111f7:	1b 5b 33 38 3b 32 3b 32 35 35 3b 31 30 30 3b 30     .[38;2;255;100;0
   11207:	6d 54 52 55 45 43 4f 4c 4f 52 1b 5b 30 6d 00 0d     mTRUECOLOR.[0m..
   11217:	0a 1b 5b 31 3b 33 32 6d 00 1b 5b 30 6d 0d 0a 00     ..[1;32m..[0m...
   11227:	20 1b 5b 33 35 6d 00 4c 61 74 65 6e 63 79 0d 0a      .[35m.Latency..
   11237:	00 3c 69 3e 3a 3c 6d 6f 64 75 6c 65 3e 09 3c 63     .<i>:<module>.<c
   11247:	6f 75 6e 74 3e 09 3c 6d 69 6e 3e 09 3c 61 76 67     ount>.<min>.<avg
   11257:	3e 09 3c 6c 61 73 74 3e 09 3c 6d 61 78 3e 00 1b     >.<last>.<max>..
   11267:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   11277:	20 50 65 72 69 6f 64 20 43 6c 6f 63 6b 20 43 79      Period Clock Cy
   11287:	63 6c 65 73 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     cles: ..[1;33mWA
   11297:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 4e 6f 20 65     RNING.[0m - No e
   112a7:	6e 74 72 6f 70 79 20 61 76 61 69 6c 61 62 6c 65     ntropy available
   112b7:	21 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     !....[1;32mINFO.
   112c7:	5b 30 6d 20 2d 20 52 61 6e 64 3a 20 00 1b 63 00     [0m - Rand: ..c.
   112d7:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
   112e7:	2d 20 6e 73 20 70 65 72 20 63 79 63 6c 65 74 69     - ns per cycleti
   112f7:	63 6b 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     ck: ..[1;32mINFO
   11307:	1b 5b 30 6d 20 2d 20 3c 73 79 73 74 69 63 6b 20     .[0m - <systick 
   11317:	6d 73 3e 3a 3c 63 79 63 6c 65 74 69 63 6b 73 20     ms>:<cycleticks 
   11327:	73 69 6e 63 65 20 73 79 73 74 69 63 6b 3e 0d 0a     since systick>..
   11337:	00 20 1b 5b 31 6d 52 65 76 69 73 69 6f 6e 3a 1b     . .[1mRevision:.
   11347:	5b 30 6d 20 20 20 20 20 20 39 34 30 32 31 32 63     [0m      940212c
   11357:	63 34 32 36 33 38 39 36 39 64 39 37 32 31 37 31     c42638969d972171
   11367:	66 61 66 66 37 36 33 34 37 33 61 36 34 39 32 62     faff763473a6492b
   11377:	39 0d 0a 00 20 1b 5b 31 6d 52 65 76 69 73 69 6f     9... .[1mRevisio
   11387:	6e 20 23 3a 1b 5b 30 6d 20 20 20 20 33 32 0d 0a     n #:.[0m    32..
   11397:	00 20 1b 5b 31 6d 56 65 72 73 69 6f 6e 3a 1b 5b     . .[1mVersion:.[
   113a7:	30 6d 20 20 20 20 20 20 20 6c 61 74 65 73 74 20     0m       latest 
   113b7:	28 2b 00 3a 33 32 29 0d 0a 00 20 1b 5b 31 6d 42     (+.:32)... .[1mB
   113c7:	72 61 6e 63 68 3a 1b 5b 30 6d 20 20 20 20 20 20     ranch:.[0m      
   113d7:	20 20 6d 61 73 74 65 72 0d 0a 00 20 1b 5b 31 6d       master... .[1m
   113e7:	54 72 65 65 20 53 74 61 74 75 73 3a 1b 5b 30 6d     Tree Status:.[0m
   113f7:	20 20 20 44 69 72 74 79 0d 0a 09 39 38 2d 6b 69        Dirty...98-ki
   11407:	69 62 6f 68 64 2e 72 75 6c 65 73 0d 0a 09 42 6f     ibohd.rules...Bo
   11417:	6f 74 6c 6f 61 64 65 72 2f 43 4d 61 6b 65 4c 69     otloader/CMakeLi
   11427:	73 74 73 2e 74 78 74 0d 0a 09 42 6f 6f 74 6c 6f     sts.txt...Bootlo
   11437:	61 64 65 72 2f 53 63 72 69 70 74 73 2f 73 77 64     ader/Scripts/swd
   11447:	4c 6f 61 64 2e 62 61 73 68 0d 0a 09 42 6f 6f 74     Load.bash...Boot
   11457:	6c 6f 61 64 65 72 2f 5f 62 75 69 6c 64 76 61 72     loader/_buildvar
   11467:	73 2e 68 0d 0a 09 42 6f 6f 74 6c 6f 61 64 65 72     s.h...Bootloader
   11477:	2f 64 65 62 75 67 2e 63 0d 0a 09 42 6f 6f 74 6c     /debug.c...Bootl
   11487:	6f 61 64 65 72 2f 64 65 62 75 67 2e 68 0d 0a 09     oader/debug.h...
   11497:	42 6f 6f 74 6c 6f 61 64 65 72 2f 64 66 75 2e 63     Bootloader/dfu.c
   114a7:	0d 0a 09 42 6f 6f 74 6c 6f 61 64 65 72 2f 64 66     ...Bootloader/df
   114b7:	75 2e 64 65 73 63 2e 63 0d 0a 09 42 6f 6f 74 6c     u.desc.c...Bootl
   114c7:	6f 61 64 65 72 2f 64 66 75 2e 64 65 73 63 2e 68     oader/dfu.desc.h
   114d7:	0d 0a 09 42 6f 6f 74 6c 6f 61 64 65 72 2f 64 66     ...Bootloader/df
   114e7:	75 2e 68 0d 0a 09 42 6f 6f 74 6c 6f 61 64 65 72     u.h...Bootloader
   114f7:	2f 66 6c 61 73 68 2e 63 0d 0a 09 42 6f 6f 74 6c     /flash.c...Bootl
   11507:	6f 61 64 65 72 2f 66 6c 61 73 68 2e 68 0d 0a 09     oader/flash.h...
   11517:	42 6f 6f 74 6c 6f 61 64 65 72 2f 6d 61 69 6e 2e     Bootloader/main.
   11527:	63 0d 0a 09 42 6f 6f 74 6c 6f 61 64 65 72 2f 6d     c...Bootloader/m
   11537:	63 68 63 6b 2e 68 0d 0a 09 42 6f 6f 74 6c 6f 61     chck.h...Bootloa
   11547:	64 65 72 2f 75 73 62 2e 63 0d 0a 09 42 6f 6f 74     der/usb.c...Boot
   11557:	6c 6f 61 64 65 72 2f 75 73 62 2e 68 0d 0a 09 43     loader/usb.h...C
   11567:	4d 61 6b 65 4c 69 73 74 73 2e 74 78 74 0d 0a 09     MakeLists.txt...
   11577:	44 65 62 75 67 2f 63 6c 69 2f 63 6c 69 2e 63 0d     Debug/cli/cli.c.
   11587:	0a 09 44 65 62 75 67 2f 63 6c 69 2f 63 6c 69 2e     ..Debug/cli/cli.
   11597:	68 0d 0a 09 44 65 62 75 67 2f 63 6c 69 2f 73 65     h...Debug/cli/se
   115a7:	74 75 70 2e 63 6d 61 6b 65 0d 0a 09 44 65 62 75     tup.cmake...Debu
   115b7:	67 2f 66 75 6c 6c 2f 73 65 74 75 70 2e 63 6d 61     g/full/setup.cma
   115c7:	6b 65 0d 0a 09 44 65 62 75 67 2f 6c 65 64 2f 6c     ke...Debug/led/l
   115d7:	65 64 2e 63 0d 0a 09 44 65 62 75 67 2f 6c 65 64     ed.c...Debug/led
   115e7:	2f 6c 65 64 2e 68 0d 0a 09 44 65 62 75 67 2f 6c     /led.h...Debug/l
   115f7:	65 64 2f 73 65 74 75 70 2e 63 6d 61 6b 65 0d 0a     ed/setup.cmake..
   11607:	09 44 65 62 75 67 2f 70 72 69 6e 74 2f 70 72 69     .Debug/print/pri
   11617:	6e 74 2e 63 0d 0a 09 44 65 62 75 67 2f 70 72 69     nt.c...Debug/pri
   11627:	6e 74 2f 70 72 69 6e 74 2e 68 0d 0a 09 44 65 62     nt/print.h...Deb
   11637:	75 67 2f 70 72 69 6e 74 2f 73 65 74 75 70 2e 63     ug/print/setup.c
   11647:	6d 61 6b 65 0d 0a 09 4b 65 79 62 6f 61 72 64 73     make...Keyboards
   11657:	2f 63 6d 61 6b 65 2e 62 61 73 68 0d 0a 09 4b 65     /cmake.bash...Ke
   11667:	79 62 6f 61 72 64 73 2f 65 72 67 6f 64 6f 78 2e     yboards/ergodox.
   11677:	62 61 73 68 0d 0a 09 4b 65 79 62 6f 61 72 64 73     bash...Keyboards
   11687:	2f 69 6e 66 69 6e 69 74 79 2e 62 61 73 68 0d 0a     /infinity.bash..
   11697:	09 4b 65 79 62 6f 61 72 64 73 2f 74 65 6d 70 6c     .Keyboards/templ
   116a7:	61 74 65 2e 62 61 73 68 0d 0a 09 4b 65 79 62 6f     ate.bash...Keybo
   116b7:	61 72 64 73 2f 77 68 69 74 65 66 6f 78 2e 62 61     ards/whitefox.ba
   116c7:	73 68 0d 0a 09 4c 69 62 2f 43 4d 61 6b 65 2f 46     sh...Lib/CMake/F
   116d7:	69 6e 64 43 74 61 67 73 2e 63 6d 61 6b 65 0d 0a     indCtags.cmake..
   116e7:	09 4c 69 62 2f 43 4d 61 6b 65 2f 61 72 6d 2e 63     .Lib/CMake/arm.c
   116f7:	6d 61 6b 65 0d 0a 09 4c 69 62 2f 43 4d 61 6b 65     make...Lib/CMake
   11707:	2f 61 76 72 2e 63 6d 61 6b 65 0d 0a 09 4c 69 62     /avr.cmake...Lib
   11717:	2f 43 4d 61 6b 65 2f 62 75 69 6c 64 2e 63 6d 61     /CMake/build.cma
   11727:	6b 65 0d 0a 09 4c 69 62 2f 43 4d 61 6b 65 2f 69     ke...Lib/CMake/i
   11737:	6e 69 74 69 61 6c 69 7a 65 2e 63 6d 61 6b 65 0d     nitialize.cmake.
   11747:	0a 09 4c 69 62 2f 43 4d 61 6b 65 2f 6b 6c 6c 2e     ..Lib/CMake/kll.
   11757:	63 6d 61 6b 65 0d 0a 09 4c 69 62 2f 43 4d 61 6b     cmake...Lib/CMak
   11767:	65 2f 6d 6f 64 75 6c 65 73 2e 63 6d 61 6b 65 0d     e/modules.cmake.
   11777:	0a 09 4c 69 62 2f 49 6e 74 65 72 72 75 70 74 73     ..Lib/Interrupts
   11787:	2e 68 0d 0a 09 4c 69 62 2f 4d 61 63 72 6f 4c 69     .h...Lib/MacroLi
   11797:	62 2e 68 0d 0a 09 4c 69 62 2f 4d 61 69 6e 4c 69     b.h...Lib/MainLi
   117a7:	62 2e 68 0d 0a 09 4c 69 62 2f 4f 75 74 70 75 74     b.h...Lib/Output
   117b7:	4c 69 62 2e 68 0d 0a 09 4c 69 62 2f 53 63 61 6e     Lib.h...Lib/Scan
   117c7:	4c 69 62 2e 68 0d 0a 09 4c 69 62 2f 5f 62 75 69     Lib.h...Lib/_bui
   117d7:	6c 64 76 61 72 73 2e 68 0d 0a 09 4c 69 62 2f 63     ldvars.h...Lib/c
   117e7:	6c 61 6e 67 2e 63 0d 0a 09 4c 69 62 2f 64 65 6c     lang.c...Lib/del
   117f7:	61 79 2e 63 0d 0a 09 4c 69 62 2f 64 65 6c 61 79     ay.c...Lib/delay
   11807:	2e 68 0d 0a 09 4c 6f 61 64 46 69 6c 65 2f 6c 6f     .h...LoadFile/lo
   11817:	61 64 2e 64 66 75 0d 0a 09 4c 6f 61 64 46 69 6c     ad.dfu...LoadFil
   11827:	65 2f 6c 6f 61 64 2e 74 65 65 6e 73 79 0d 0a 09     e/load.teensy...
   11837:	4d 61 63 72 6f 2f 50 61 72 74 69 61 6c 4d 61 70     Macro/PartialMap
   11847:	2f 63 61 70 61 62 69 6c 69 74 69 65 73 2e 6b 6c     /capabilities.kl
   11857:	6c 0d 0a 09 4d 61 63 72 6f 2f 50 61 72 74 69 61     l...Macro/Partia
   11867:	6c 4d 61 70 2f 6b 6c 6c 2e 68 0d 0a 09 4d 61 63     lMap/kll.h...Mac
   11877:	72 6f 2f 50 61 72 74 69 61 6c 4d 61 70 2f 6d 61     ro/PartialMap/ma
   11887:	63 72 6f 2e 63 0d 0a 09 4d 61 63 72 6f 2f 50 61     cro.c...Macro/Pa
   11897:	72 74 69 61 6c 4d 61 70 2f 6d 61 63 72 6f 2e 68     rtialMap/macro.h
   118a7:	0d 0a 09 4d 61 63 72 6f 2f 50 61 72 74 69 61 6c     ...Macro/Partial
   118b7:	4d 61 70 2f 72 65 73 75 6c 74 2e 63 0d 0a 09 4d     Map/result.c...M
   118c7:	61 63 72 6f 2f 50 61 72 74 69 61 6c 4d 61 70 2f     acro/PartialMap/
   118d7:	72 65 73 75 6c 74 2e 68 0d 0a 09 4d 61 63 72 6f     result.h...Macro
   118e7:	2f 50 61 72 74 69 61 6c 4d 61 70 2f 73 65 74 75     /PartialMap/setu
   118f7:	70 2e 63 6d 61 6b 65 0d 0a 09 4d 61 63 72 6f 2f     p.cmake...Macro/
   11907:	50 61 72 74 69 61 6c 4d 61 70 2f 74 72 69 67 67     PartialMap/trigg
   11917:	65 72 2e 63 0d 0a 09 4d 61 63 72 6f 2f 62 75 66     er.c...Macro/buf
   11927:	66 65 72 2f 6d 61 63 72 6f 2e 63 0d 0a 09 4d 61     fer/macro.c...Ma
   11937:	6b 65 66 69 6c 65 0d 0a 09 52 45 41 44 4d 45 2e     kefile...README.
   11947:	6d 64 0d 0a 09 53 63 61 6e 2f 43 4b 33 2f 73 65     md...Scan/CK3/se
   11957:	74 75 70 2e 63 6d 61 6b 65 0d 0a 09 53 63 61 6e     tup.cmake...Scan
   11967:	2f 4d 44 31 2e 31 2f 64 65 66 61 75 6c 74 4d 61     /MD1.1/defaultMa
   11977:	70 2e 6b 6c 6c 0d 0a 09 53 63 61 6e 2f 4d 44 31     p.kll...Scan/MD1
   11987:	2e 31 2f 6d 61 74 72 69 78 2e 68 0d 0a 09 53 63     .1/matrix.h...Sc
   11997:	61 6e 2f 4d 44 31 2e 31 2f 70 69 6e 6f 75 74 0d     an/MD1.1/pinout.
   119a7:	0a 09 53 63 61 6e 2f 4d 44 31 2e 31 2f 73 63 61     ..Scan/MD1.1/sca
   119b7:	6e 5f 6c 6f 6f 70 2e 63 0d 0a 09 53 63 61 6e 2f     n_loop.c...Scan/
   119c7:	4d 44 31 2e 31 2f 73 63 61 6e 5f 6c 6f 6f 70 2e     MD1.1/scan_loop.
   119d7:	68 0d 0a 09 53 63 61 6e 2f 4d 44 31 2e 31 2f 73     h...Scan/MD1.1/s
   119e7:	65 74 75 70 2e 63 6d 61 6b 65 0d 0a 09 53 63 61     etup.cmake...Sca
   119f7:	6e 2f 4d 44 31 2f 64 65 66 61 75 6c 74 4d 61 70     n/MD1/defaultMap
   11a07:	2e 6b 6c 6c 0d 0a 09 53 63 61 6e 2f 4d 44 31 2f     .kll...Scan/MD1/
   11a17:	6d 61 74 72 69 78 2e 68 0d 0a 09 53 63 61 6e 2f     matrix.h...Scan/
   11a27:	4d 44 31 2f 70 69 6e 6f 75 74 0d 0a 09 53 63 61     MD1/pinout...Sca
   11a37:	6e 2f 4d 44 31 2f 70 72 6f 74 6f 74 79 70 65 2e     n/MD1/prototype.
   11a47:	6b 6c 6c 0d 0a 09 53 63 61 6e 2f 4d 44 31 2f 73     kll...Scan/MD1/s
   11a57:	63 61 6e 5f 6c 6f 6f 70 2e 63 0d 0a 09 53 63 61     can_loop.c...Sca
   11a67:	6e 2f 4d 44 31 2f 73 63 61 6e 5f 6c 6f 6f 70 2e     n/MD1/scan_loop.
   11a77:	68 0d 0a 09 53 63 61 6e 2f 4d 44 31 2f 73 65 74     h...Scan/MD1/set
   11a87:	75 70 2e 63 6d 61 6b 65 0d 0a 09 53 63 61 6e 2f     up.cmake...Scan/
   11a97:	4d 44 45 72 67 6f 31 2f 64 65 66 61 75 6c 74 4d     MDErgo1/defaultM
   11aa7:	61 70 2e 6b 6c 6c 0d 0a 09 53 63 61 6e 2f 4d 44     ap.kll...Scan/MD
   11ab7:	45 72 67 6f 31 2f 6c 65 64 5f 63 6f 6e 66 2e 68     Ergo1/led_conf.h
   11ac7:	0d 0a 09 53 63 61 6e 2f 4d 44 45 72 67 6f 31 2f     ...Scan/MDErgo1/
   11ad7:	6c 65 66 74 48 61 6e 64 2e 6b 6c 6c 0d 0a 09 53     leftHand.kll...S
   11ae7:	63 61 6e 2f 4d 44 45 72 67 6f 31 2f 6c 65 66 74     can/MDErgo1/left
   11af7:	54 68 65 6e 52 69 67 68 74 2e 6b 6c 6c 0d 0a 09     ThenRight.kll...
   11b07:	53 63 61 6e 2f 4d 44 45 72 67 6f 31 2f 6d 61 74     Scan/MDErgo1/mat
   11b17:	72 69 78 2e 68 0d 0a 09 53 63 61 6e 2f 4d 44 45     rix.h...Scan/MDE
   11b27:	72 67 6f 31 2f 70 69 6e 6f 75 74 0d 0a 09 53 63     rgo1/pinout...Sc
   11b37:	61 6e 2f 4d 44 45 72 67 6f 31 2f 72 69 67 68 74     an/MDErgo1/right
   11b47:	48 61 6e 64 2e 6b 6c 6c 0d 0a 09 53 63 61 6e 2f     Hand.kll...Scan/
   11b57:	4d 44 45 72 67 6f 31 2f 73 63 61 6e 5f 6c 6f 6f     MDErgo1/scan_loo
   11b67:	70 2e 63 0d 0a 09 53 63 61 6e 2f 4d 44 45 72 67     p.c...Scan/MDErg
   11b77:	6f 31 2f 73 63 61 6e 5f 6c 6f 6f 70 2e 68 0d 0a     o1/scan_loop.h..
   11b87:	09 53 63 61 6e 2f 4d 44 45 72 67 6f 31 2f 73 65     .Scan/MDErgo1/se
   11b97:	74 75 70 2e 63 6d 61 6b 65 0d 0a 09 53 63 61 6e     tup.cmake...Scan
   11ba7:	2f 4d 44 45 72 67 6f 31 2f 73 6c 61 76 65 31 2e     /MDErgo1/slave1.
   11bb7:	6b 6c 6c 0d 0a 09 53 63 61 6e 2f 57 68 69 74 65     kll...Scan/White
   11bc7:	46 6f 78 2f 73 63 61 6e 5f 6c 6f 6f 70 2e 63 0d     Fox/scan_loop.c.
   11bd7:	0a 09 53 63 61 6e 2f 57 68 69 74 65 46 6f 78 2f     ..Scan/WhiteFox/
   11be7:	73 63 61 6e 5f 6c 6f 6f 70 2e 68 0d 0a 09 53 63     scan_loop.h...Sc
   11bf7:	61 6e 2f 57 68 69 74 65 46 6f 78 2f 73 65 74 75     an/WhiteFox/setu
   11c07:	70 2e 63 6d 61 6b 65 0d 0a 09 6c 61 79 65 72 73     p.cmake...layers
   11c17:	2f 6c 61 79 65 72 2d 31 2e 6b 6c 6c 0d 0a 09 6d     /layer-1.kll...m
   11c27:	61 69 6e 2e 63 0d 0a 00 20 1b 5b 31 6d 52 65 70     ain.c... .[1mRep
   11c37:	6f 20 4f 72 69 67 69 6e 3a 1b 5b 30 6d 20 20 20     o Origin:.[0m   
   11c47:	67 69 74 40 67 69 74 68 75 62 2e 63 6f 6d 3a 4f     git@github.com:O
   11c57:	6c 69 63 61 6c 2f 65 72 67 6f 64 6f 78 2e 67 69     lical/ergodox.gi
   11c67:	74 0d 0a 00 20 1b 5b 31 6d 43 6f 6d 6d 69 74 20     t... .[1mCommit 
   11c77:	44 61 74 65 3a 1b 5b 30 6d 20 20 20 32 30 31 36     Date:.[0m   2016
   11c87:	2d 31 30 2d 32 35 20 31 31 3a 31 31 3a 35 30 20     -10-25 11:11:50 
   11c97:	2b 30 31 30 30 0d 0a 00 20 1b 5b 31 6d 43 6f 6d     +0100... .[1mCom
   11ca7:	6d 69 74 20 41 75 74 68 6f 72 3a 1b 5b 30 6d 20     mit Author:.[0m 
   11cb7:	4f 6c 69 76 65 72 20 43 61 6c 64 77 65 6c 6c 20     Oliver Caldwell 
   11cc7:	3c 6f 6c 6c 69 65 63 38 37 40 67 6d 61 69 6c 2e     <olliec87@gmail.
   11cd7:	63 6f 6d 3e 0d 0a 00 20 1b 5b 31 6d 42 75 69 6c     com>... .[1mBuil
   11ce7:	64 20 44 61 74 65 3a 1b 5b 30 6d 20 20 20 20 32     d Date:.[0m    2
   11cf7:	30 31 38 2d 30 31 2d 30 34 20 32 31 3a 30 39 3a     018-01-04 21:09:
   11d07:	34 31 20 2b 30 30 30 30 0d 0a 00 20 1b 5b 31 6d     41 +0000... .[1m
   11d17:	42 75 69 6c 64 20 4f 53 3a 1b 5b 30 6d 20 20 20     Build OS:.[0m   
   11d27:	20 20 20 27 41 72 63 68 20 4c 69 6e 75 78 27 20        'Arch Linux' 
   11d37:	6e 2f 61 0d 0a 00 20 1b 5b 31 6d 43 6f 6d 70 69     n/a... .[1mCompi
   11d47:	6c 65 72 3a 1b 5b 30 6d 20 20 20 20 20 20 2f 75     ler:.[0m      /u
   11d57:	73 72 2f 62 69 6e 2f 61 72 6d 2d 6e 6f 6e 65 2d     sr/bin/arm-none-
   11d67:	65 61 62 69 2d 67 63 63 20 37 2e 32 2e 30 0d 0a     eabi-gcc 7.2.0..
   11d77:	00 20 1b 5b 31 6d 41 72 63 68 69 74 65 63 74 75     . .[1mArchitectu
   11d87:	72 65 3a 1b 5b 30 6d 20 20 61 72 6d 0d 0a 00 20     re:.[0m  arm... 
   11d97:	1b 5b 31 6d 43 68 69 70 20 43 6f 6d 70 69 6c 65     .[1mChip Compile
   11da7:	64 3a 1b 5b 30 6d 20 6d 6b 32 30 64 78 32 35 36     d:.[0m mk20dx256
   11db7:	20 28 6d 6b 32 30 64 78 32 35 36 76 6c 68 37 29      (mk20dx256vlh7)
   11dc7:	0d 0a 00 20 1b 5b 31 6d 43 50 55 3a 1b 5b 30 6d     ... .[1mCPU:.[0m
   11dd7:	20 20 20 20 20 20 20 20 20 20 20 63 6f 72 74 65                corte
   11de7:	78 2d 6d 34 0d 0a 00 20 1b 5b 31 6d 44 65 76 69     x-m4... .[1mDevi
   11df7:	63 65 3a 1b 5b 30 6d 20 20 20 20 20 20 20 20 4b     ce:.[0m        K
   11e07:	65 79 62 6f 61 72 64 0d 0a 00 20 1b 5b 31 6d 4d     eyboard... .[1mM
   11e17:	6f 64 75 6c 65 73 3a 1b 5b 30 6d 20 20 20 20 20     odules:.[0m     
   11e27:	20 20 53 63 61 6e 28 49 6e 66 69 6e 69 74 79 5f       Scan(Infinity_
   11e37:	45 72 67 6f 64 6f 78 29 20 4d 61 63 72 6f 28 50     Ergodox) Macro(P
   11e47:	69 78 65 6c 4d 61 70 29 20 4f 75 74 70 75 74 28     ixelMap) Output(
   11e57:	55 53 42 29 20 44 65 62 75 67 28 66 75 6c 6c 29     USB) Debug(full)
   11e67:	0d 0a 00 20 1b 5b 31 6d 43 50 55 20 44 65 74 65     ... .[1mCPU Dete
   11e77:	63 74 65 64 3a 1b 5b 30 6d 20 20 00 20 1b 5b 31     cted:.[0m  . .[1
   11e87:	6d 43 50 55 20 49 64 3a 1b 5b 30 6d 20 20 20 20     mCPU Id:.[0m    
   11e97:	20 20 20 20 00 0d 0a 20 20 28 49 6d 70 6c 65 6d         ...  (Implem
   11ea7:	65 6e 74 6f 72 3a 00 29 28 56 61 72 69 61 6e 74     entor:.)(Variant
   11eb7:	3a 00 29 28 41 72 63 68 3a 00 29 28 50 61 72 74     :.)(Arch:.)(Part
   11ec7:	4e 6f 3a 00 29 28 52 65 76 69 73 69 6f 6e 3a 00     No:.)(Revision:.
   11ed7:	20 1b 5b 31 6d 44 65 76 69 63 65 20 49 64 3a 1b      .[1mDevice Id:.
   11ee7:	5b 30 6d 20 20 20 20 20 00 0d 0a 20 20 28 50 69     [0m     ...  (Pi
   11ef7:	6e 63 6f 75 6e 74 3a 00 29 28 46 61 6d 69 6c 79     ncount:.)(Family
   11f07:	3a 00 29 28 44 69 65 3a 00 29 28 52 65 76 3a 00     :.)(Die:.)(Rev:.
   11f17:	20 1b 5b 31 6d 46 6c 61 73 68 20 43 66 67 3a 1b      .[1mFlash Cfg:.
   11f27:	5b 30 6d 20 20 20 20 20 00 0d 0a 20 20 28 46 6c     [0m     ...  (Fl
   11f37:	65 78 4e 56 4d 3a 00 6b 42 29 28 50 46 6c 61 73     exNVM:.kB)(PFlas
   11f47:	68 3a 00 6b 42 29 28 45 45 50 52 4f 4d 3a 00 29     h:.kB)(EEPROM:.)
   11f57:	28 44 45 50 41 52 54 3a 00 20 1b 5b 31 6d 52 41     (DEPART:. .[1mRA
   11f67:	4d 3a 1b 5b 30 6d 20 20 20 20 20 20 20 20 20 20     M:.[0m          
   11f77:	20 00 20 6b 42 0d 0a 00 20 1b 5b 31 6d 55 6e 69      . kB... .[1mUni
   11f87:	71 75 65 20 49 64 3a 1b 5b 30 6d 20 20 20 20 20     que Id:.[0m     
   11f97:	00                                                  .

00011f98 <colorTestCLIDict_DescEntry>:
   11f98:	44 69 73 70 6c 61 79 73 20 61 20 54 72 75 65 20     Displays a True 
   11fa8:	43 6f 6c 6f 72 20 41 4e 53 49 20 74 65 73 74 20     Color ANSI test 
   11fb8:	73 65 71 75 65 6e 63 65 20 74 6f 20 74 65 73 74     sequence to test
   11fc8:	20 74 65 72 6d 69 6e 61 6c 2e 20 49 66 20 69 74      terminal. If it
   11fd8:	20 64 69 73 70 6c 61 79 73 20 69 6e 20 63 6f 6c      displays in col
   11fe8:	6f 72 2c 20 79 6f 75 27 72 65 20 67 6f 6f 64 2e     or, you're good.
   11ff8:	00                                                  .

00011ff9 <helpCLIDict_DescEntry>:
   11ff9:	59 6f 75 27 72 65 20 6c 6f 6f 6b 69 6e 67 20 61     You're looking a
   12009:	74 20 69 74 20 3a 50 00                             t it :P.

00012011 <latencyCLIDict_DescEntry>:
   12011:	53 68 6f 77 20 6c 61 74 65 6e 63 79 20 6f 66 20     Show latency of 
   12021:	73 70 65 63 69 66 69 63 20 6d 6f 64 75 6c 65 73     specific modules
   12031:	20 61 6e 64 20 72 6f 75 74 69 69 6e 65 73 2e 20      and routiines. 
   12041:	53 70 65 63 69 66 79 20 69 6e 64 65 78 20 66 6f     Specify index fo
   12051:	72 20 61 20 73 69 6e 67 6c 65 20 69 74 65 6d 00     r a single item.

00012061 <ledCLIDict_DescEntry>:
   12061:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
   12071:	20 69 6e 64 69 63 61 74 6f 72 20 4c 45 44 2e 20      indicator LED. 
   12081:	54 72 79 20 61 20 63 6f 75 70 6c 65 20 74 69 6d     Try a couple tim
   12091:	65 73 20 6a 75 73 74 20 69 6e 20 63 61 73 65 20     es just in case 
   120a1:	74 68 65 20 4c 45 44 20 69 73 20 69 6e 20 61 6e     the LED is in an
   120b1:	20 6f 64 64 20 73 74 61 74 65 2e 0d 0a 09 09 1b      odd state......
   120c1:	5b 33 33 6d 57 61 72 6e 69 6e 67 1b 5b 30 6d 3a     [33mWarning.[0m:
   120d1:	20 4d 61 79 20 61 64 76 65 72 73 65 6c 79 20 61      May adversely a
   120e1:	66 66 65 63 74 20 73 6f 6d 65 20 6d 6f 64 75 6c     ffect some modul
   120f1:	65 73 2e 2e 2e 00                                   es....

000120f7 <periodicCLIDict_DescEntry>:
   120f7:	53 65 74 20 74 68 65 20 6e 75 6d 62 65 72 20 6f     Set the number o
   12107:	66 20 63 6c 6f 63 6b 20 63 79 63 6c 65 73 20 62     f clock cycles b
   12117:	65 74 77 65 65 6e 20 70 65 72 69 6f 64 69 63 20     etween periodic 
   12127:	73 63 61 6e 73 2e 00 1b 5b 32 4b 0d 00 1b 5b 31     scans...[2K...[1
   12137:	3b 33 34 6d 3a 1b 5b 30 6d 20 00                    ;34m:.[0m .

00012142 <randCLIDict_DescEntry>:
   12142:	49 66 20 65 6e 74 72 6f 70 79 20 61 76 61 69 6c     If entropy avail
   12152:	61 62 6c 65 2c 20 70 72 69 6e 74 20 61 20 72 61     able, print a ra
   12162:	6e 64 6f 6d 20 33 32 2d 62 69 74 20 6e 75 6d 62     ndom 32-bit numb
   12172:	65 72 2e 00                                         er..

00012176 <reloadCLIDict_DescEntry>:
   12176:	53 69 67 6e 61 6c 73 20 6d 69 63 72 6f 63 6f 6e     Signals microcon
   12186:	74 72 6f 6c 6c 65 72 20 74 6f 20 72 65 66 6c 61     troller to refla
   12196:	73 68 2f 72 65 6c 6f 61 64 2e 00                    sh/reload..

000121a1 <resetCLIDict_DescEntry>:
   121a1:	52 65 73 65 74 73 20 74 68 65 20 74 65 72 6d 69     Resets the termi
   121b1:	6e 61 6c 20 62 61 63 6b 20 74 6f 20 69 6e 69 74     nal back to init
   121c1:	69 61 6c 20 73 65 74 74 69 6e 67 73 2e 00           ial settings..

000121cf <restartCLIDict_DescEntry>:
   121cf:	53 65 6e 64 73 20 61 20 73 6f 66 74 77 61 72 65     Sends a software
   121df:	20 72 65 73 74 61 72 74 2c 20 73 68 6f 75 6c 64      restart, should
   121ef:	20 62 65 20 73 69 6d 69 6c 61 72 20 74 6f 20 70      be similar to p
   121ff:	6f 77 65 72 69 6e 67 20 6f 6e 20 74 68 65 20 64     owering on the d
   1220f:	65 76 69 63 65 2e 00 63 6c 65 61 72 00 63 6c 69     evice..clear.cli
   1221f:	44 65 62 75 67 00 63 6f 6c 6f 72 54 65 73 74 00     Debug.colorTest.
   1222f:	68 65 6c 70 00 6c 61 74 65 6e 63 79 00 6c 65 64     help.latency.led
   1223f:	00 70 65 72 69 6f 64 69 63 00 72 61 6e 64 00 72     .periodic.rand.r
   1224f:	65 6c 6f 61 64 00 72 65 73 65 74 00 72 65 73 74     eload.reset.rest
   1225f:	61 72 74 00 74 69 63 6b 00 76 65 72 73 69 6f 6e     art.tick.version
   1226f:	00 4b 31 30 2f 31 32 00 4b 32 30 2f 32 32 00 4b     .K10/12.K20/22.K
   1227f:	33 30 2f 31 31 2f 36 31 00 4b 34 30 2f 32 31 00     30/11/61.K40/21.
   1228f:	4b 36 30 2f 36 32 00 4b 37 30 00 33 32 2d 70 69     K60/62.K70.32-pi
   1229f:	6e 00 34 38 2d 70 69 6e 00 36 34 2d 70 69 6e 00     n.48-pin.64-pin.
   122af:	38 30 2d 70 69 6e 00 38 31 2f 31 32 31 2d 70 69     80-pin.81/121-pi
   122bf:	6e 00 31 30 30 2d 70 69 6e 00 31 34 34 2d 70 69     n.100-pin.144-pi
   122cf:	6e 00 57 4c 43 53 50 00 32 35 36 2d 70 69 6e 00     n.WLCSP.256-pin.

000122df <tickCLIDict_DescEntry>:
   122df:	44 69 73 70 6c 61 79 73 20 74 68 65 20 66 75 6e     Displays the fun
   122ef:	64 61 6d 65 6e 74 61 6c 20 74 69 63 6b 20 73 69     damental tick si
   122ff:	7a 65 2c 20 61 6e 64 20 63 75 72 72 65 6e 74 20     ze, and current 
   1230f:	74 69 63 6b 73 20 73 69 6e 63 65 20 6c 61 73 74     ticks since last
   1231f:	20 73 79 73 74 69 63 6b 2e 00                        systick..

00012329 <versionCLIDict_DescEntry>:
   12329:	56 65 72 73 69 6f 6e 20 69 6e 66 6f 72 6d 61 74     Version informat
   12339:	69 6f 6e 20 61 62 6f 75 74 20 74 68 69 73 20 66     ion about this f
   12349:	69 72 6d 77 61 72 65 2e 00 1b 5b 31 3b 35 3b 33     irmware...[1;5;3
   12359:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 4e 6f     1mERROR.[0m - No
   12369:	20 6d 6f 72 65 20 6c 61 74 65 6e 63 79 20 72 65      more latency re
   12379:	73 6f 75 72 63 65 73 20 61 76 61 69 6c 61 62 6c     sources availabl
   12389:	65 2e 2e 2e 0d 0a 00                                e......
